[
  {
    "function_name": "btrfs_bio_counter_inc_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "924-937",
    "snippet": "void btrfs_bio_counter_inc_blocked(struct btrfs_fs_info *fs_info)\n{\n\twhile (1) {\n\t\tpercpu_counter_inc(&fs_info->bio_counter);\n\t\tif (likely(!test_bit(BTRFS_FS_STATE_DEV_REPLACING,\n\t\t\t\t     &fs_info->fs_state)))\n\t\t\tbreak;\n\n\t\tbtrfs_bio_counter_dec(fs_info);\n\t\twait_event(fs_info->replace_wait,\n\t\t\t   !test_bit(BTRFS_FS_STATE_DEV_REPLACING,\n\t\t\t\t     &fs_info->fs_state));\n\t}\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "fs_info->replace_wait",
            "!test_bit(BTRFS_FS_STATE_DEV_REPLACING,\n\t\t\t\t     &fs_info->fs_state)"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_FS_STATE_DEV_REPLACING",
            "&fs_info->fs_state"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_bio_counter_dec",
          "args": [
            "fs_info"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_counter_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4159-4162",
          "snippet": "static inline void btrfs_bio_counter_dec(struct btrfs_fs_info *fs_info)\n{\n\tbtrfs_bio_counter_sub(fs_info, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_bio_counter_dec(struct btrfs_fs_info *fs_info)\n{\n\tbtrfs_bio_counter_sub(fs_info, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!test_bit(BTRFS_FS_STATE_DEV_REPLACING,\n\t\t\t\t     &fs_info->fs_state)"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_inc",
          "args": [
            "&fs_info->bio_counter"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_bio_counter_inc_blocked(struct btrfs_fs_info *fs_info)\n{\n\twhile (1) {\n\t\tpercpu_counter_inc(&fs_info->bio_counter);\n\t\tif (likely(!test_bit(BTRFS_FS_STATE_DEV_REPLACING,\n\t\t\t\t     &fs_info->fs_state)))\n\t\t\tbreak;\n\n\t\tbtrfs_bio_counter_dec(fs_info);\n\t\twait_event(fs_info->replace_wait,\n\t\t\t   !test_bit(BTRFS_FS_STATE_DEV_REPLACING,\n\t\t\t\t     &fs_info->fs_state));\n\t}\n}"
  },
  {
    "function_name": "btrfs_bio_counter_sub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "916-922",
    "snippet": "void btrfs_bio_counter_sub(struct btrfs_fs_info *fs_info, s64 amount)\n{\n\tpercpu_counter_sub(&fs_info->bio_counter, amount);\n\n\tif (waitqueue_active(&fs_info->replace_wait))\n\t\twake_up(&fs_info->replace_wait);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fs_info->replace_wait"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&fs_info->replace_wait"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sub",
          "args": [
            "&fs_info->bio_counter",
            "amount"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_bio_counter_sub(struct btrfs_fs_info *fs_info, s64 amount)\n{\n\tpercpu_counter_sub(&fs_info->bio_counter, amount);\n\n\tif (waitqueue_active(&fs_info->replace_wait))\n\t\twake_up(&fs_info->replace_wait);\n}"
  },
  {
    "function_name": "btrfs_bio_counter_inc_noblocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "911-914",
    "snippet": "void btrfs_bio_counter_inc_noblocked(struct btrfs_fs_info *fs_info)\n{\n\tpercpu_counter_inc(&fs_info->bio_counter);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_counter_inc",
          "args": [
            "&fs_info->bio_counter"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_bio_counter_inc_noblocked(struct btrfs_fs_info *fs_info)\n{\n\tpercpu_counter_inc(&fs_info->bio_counter);\n}"
  },
  {
    "function_name": "btrfs_dev_replace_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "895-909",
    "snippet": "void btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dev_replace->lock_management_lock"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dev_replace->lock"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dev_replace->lock_management_lock"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&dev_replace->nesting_level"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&dev_replace->nesting_level"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "dev_replace->lock_owner != current->pid"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&dev_replace->nesting_level) < 1"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&dev_replace->nesting_level"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dev_replace->lock_management_lock"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!mutex_is_locked(&dev_replace->lock)"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&dev_replace->lock"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}"
  },
  {
    "function_name": "btrfs_dev_replace_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "867-893",
    "snippet": "void btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dev_replace->lock_management_lock"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dev_replace->lock_management_lock"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dev_replace->nesting_level"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!mutex_is_locked(&dev_replace->lock)"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&dev_replace->lock"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&dev_replace->nesting_level"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dev_replace->lock_management_lock"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dev_replace->lock_management_lock"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dev_replace->nesting_level"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dev_replace->lock_management_lock"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dev_replace->lock"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&dev_replace->nesting_level"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}"
  },
  {
    "function_name": "btrfs_dev_replace_is_ongoing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "840-865",
    "snippet": "int btrfs_dev_replace_is_ongoing(struct btrfs_dev_replace *dev_replace)\n{\n\tif (!dev_replace->is_valid)\n\t\treturn 0;\n\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\t/*\n\t\t * return true even if tgtdev is missing (this is\n\t\t * something that can happen if the dev_replace\n\t\t * procedure is suspended by an umount and then\n\t\t * the tgtdev is missing (or \"btrfs dev scan\") was\n\t\t * not called and the the filesystem is remounted\n\t\t * in degraded state. This does not stop the\n\t\t * dev_replace procedure. It needs to be canceled\n\t\t * manually if the cancelation is wanted.\n\t\t */\n\t\tbreak;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\n\nint btrfs_dev_replace_is_ongoing(struct btrfs_dev_replace *dev_replace)\n{\n\tif (!dev_replace->is_valid)\n\t\treturn 0;\n\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\t/*\n\t\t * return true even if tgtdev is missing (this is\n\t\t * something that can happen if the dev_replace\n\t\t * procedure is suspended by an umount and then\n\t\t * the tgtdev is missing (or \"btrfs dev scan\") was\n\t\t * not called and the the filesystem is remounted\n\t\t * in degraded state. This does not stop the\n\t\t * dev_replace procedure. It needs to be canceled\n\t\t * manually if the cancelation is wanted.\n\t\t */\n\t\tbreak;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "btrfs_dev_replace_continue_on_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "826-838",
    "snippet": "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tint ret;\n\n\tret = btrfs_scrub_dev(fs_info, dev_replace->srcdev->devid,\n\t\t\t      dev_replace->committed_cursor_left,\n\t\t\t      btrfs_device_get_total_bytes(dev_replace->srcdev),\n\t\t\t      &dev_replace->scrub_progress, 0, 1);\n\tret = btrfs_dev_replace_finishing(fs_info, ret);\n\tWARN_ON(ret);\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_finishing",
          "args": [
            "fs_info",
            "ret"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_finishing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "458-598",
          "snippet": "static int btrfs_dev_replace_finishing(struct btrfs_fs_info *fs_info,\n\t\t\t\t       int scrub_ret)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_device *tgt_device;\n\tstruct btrfs_device *src_device;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tu8 uuid_tmp[BTRFS_UUID_SIZE];\n\tstruct btrfs_trans_handle *trans;\n\tint ret = 0;\n\n\t/* don't allow cancel or unmount to disturb the finishing procedure */\n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\t/* was the operation canceled, or is it finished? */\n\tif (dev_replace->replace_state !=\n\t    BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED) {\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn 0;\n\t}\n\n\ttgt_device = dev_replace->tgtdev;\n\tsrc_device = dev_replace->srcdev;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\t/*\n\t * flush all outstanding I/O and inode extent mappings before the\n\t * copy operation is declared as being finished\n\t */\n\tret = btrfs_start_delalloc_roots(root->fs_info, 0, -1);\n\tif (ret) {\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn ret;\n\t}\n\tbtrfs_wait_ordered_roots(root->fs_info, -1);\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn PTR_ERR(trans);\n\t}\n\tret = btrfs_commit_transaction(trans, root);\n\tWARN_ON(ret);\n\n\tmutex_lock(&uuid_mutex);\n\t/* keep away write_all_supers() during the finishing procedure */\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tmutex_lock(&root->fs_info->chunk_mutex);\n\tbtrfs_dev_replace_lock(dev_replace);\n\tdev_replace->replace_state =\n\t\tscrub_ret ? BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED\n\t\t\t  : BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED;\n\tdev_replace->tgtdev = NULL;\n\tdev_replace->srcdev = NULL;\n\tdev_replace->time_stopped = get_seconds();\n\tdev_replace->item_needs_writeback = 1;\n\n\t/* replace old device with new one in mapping tree */\n\tif (!scrub_ret) {\n\t\tbtrfs_dev_replace_update_device_in_mapping_tree(fs_info,\n\t\t\t\t\t\t\t\tsrc_device,\n\t\t\t\t\t\t\t\ttgt_device);\n\t} else {\n\t\tprintk_in_rcu(KERN_ERR\n\t\t\t      \"BTRFS: btrfs_scrub_dev(%s, %llu, %s) failed %d\\n\",\n\t\t\t      src_device->missing ? \"<missing disk>\" :\n\t\t\t        rcu_str_deref(src_device->name),\n\t\t\t      src_device->devid,\n\t\t\t      rcu_str_deref(tgt_device->name), scrub_ret);\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\tmutex_unlock(&root->fs_info->chunk_mutex);\n\t\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\t\tmutex_unlock(&uuid_mutex);\n\t\tif (tgt_device)\n\t\t\tbtrfs_destroy_dev_replace_tgtdev(fs_info, tgt_device);\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\n\t\treturn scrub_ret;\n\t}\n\n\tprintk_in_rcu(KERN_INFO\n\t\t      \"BTRFS: dev_replace from %s (devid %llu) to %s finished\\n\",\n\t\t      src_device->missing ? \"<missing disk>\" :\n\t\t        rcu_str_deref(src_device->name),\n\t\t      src_device->devid,\n\t\t      rcu_str_deref(tgt_device->name));\n\ttgt_device->is_tgtdev_for_dev_replace = 0;\n\ttgt_device->devid = src_device->devid;\n\tsrc_device->devid = BTRFS_DEV_REPLACE_DEVID;\n\tmemcpy(uuid_tmp, tgt_device->uuid, sizeof(uuid_tmp));\n\tmemcpy(tgt_device->uuid, src_device->uuid, sizeof(tgt_device->uuid));\n\tmemcpy(src_device->uuid, uuid_tmp, sizeof(src_device->uuid));\n\tbtrfs_device_set_total_bytes(tgt_device, src_device->total_bytes);\n\tbtrfs_device_set_disk_total_bytes(tgt_device,\n\t\t\t\t\t  src_device->disk_total_bytes);\n\tbtrfs_device_set_bytes_used(tgt_device, src_device->bytes_used);\n\tASSERT(list_empty(&src_device->resized_list));\n\ttgt_device->commit_total_bytes = src_device->commit_total_bytes;\n\ttgt_device->commit_bytes_used = src_device->bytes_used;\n\tif (fs_info->sb->s_bdev == src_device->bdev)\n\t\tfs_info->sb->s_bdev = tgt_device->bdev;\n\tif (fs_info->fs_devices->latest_bdev == src_device->bdev)\n\t\tfs_info->fs_devices->latest_bdev = tgt_device->bdev;\n\tlist_add(&tgt_device->dev_alloc_list, &fs_info->fs_devices->alloc_list);\n\tfs_info->fs_devices->rw_devices++;\n\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tbtrfs_rm_dev_replace_blocked(fs_info);\n\n\tbtrfs_rm_dev_replace_remove_srcdev(fs_info, src_device);\n\n\tbtrfs_rm_dev_replace_unblocked(fs_info);\n\n\t/*\n\t * this is again a consistent state where no dev_replace procedure\n\t * is running, the target device is part of the filesystem, the\n\t * source device is not part of the filesystem anymore and its 1st\n\t * superblock is scratched out so that it is no longer marked to\n\t * belong to this filesystem.\n\t */\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\tmutex_unlock(&uuid_mutex);\n\n\t/* replace the sysfs entry */\n\tbtrfs_kobj_rm_device(fs_info, src_device);\n\tbtrfs_kobj_add_device(fs_info, tgt_device);\n\tbtrfs_rm_dev_replace_free_srcdev(fs_info, src_device);\n\n\t/* write back the superblocks */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (!IS_ERR(trans))\n\t\tbtrfs_commit_transaction(trans, root);\n\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_dev_replace_finishing(struct btrfs_fs_info *fs_info,\n\t\t\t\t       int scrub_ret);",
            "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);",
            "static int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\n\t\t\t\t\t char *srcdev_name,\n\t\t\t\t\t struct btrfs_device **device);",
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_dev_replace_finishing(struct btrfs_fs_info *fs_info,\n\t\t\t\t       int scrub_ret);\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\nstatic int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\n\t\t\t\t\t char *srcdev_name,\n\t\t\t\t\t struct btrfs_device **device);\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nstatic int btrfs_dev_replace_finishing(struct btrfs_fs_info *fs_info,\n\t\t\t\t       int scrub_ret)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_device *tgt_device;\n\tstruct btrfs_device *src_device;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tu8 uuid_tmp[BTRFS_UUID_SIZE];\n\tstruct btrfs_trans_handle *trans;\n\tint ret = 0;\n\n\t/* don't allow cancel or unmount to disturb the finishing procedure */\n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\t/* was the operation canceled, or is it finished? */\n\tif (dev_replace->replace_state !=\n\t    BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED) {\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn 0;\n\t}\n\n\ttgt_device = dev_replace->tgtdev;\n\tsrc_device = dev_replace->srcdev;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\t/*\n\t * flush all outstanding I/O and inode extent mappings before the\n\t * copy operation is declared as being finished\n\t */\n\tret = btrfs_start_delalloc_roots(root->fs_info, 0, -1);\n\tif (ret) {\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn ret;\n\t}\n\tbtrfs_wait_ordered_roots(root->fs_info, -1);\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn PTR_ERR(trans);\n\t}\n\tret = btrfs_commit_transaction(trans, root);\n\tWARN_ON(ret);\n\n\tmutex_lock(&uuid_mutex);\n\t/* keep away write_all_supers() during the finishing procedure */\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tmutex_lock(&root->fs_info->chunk_mutex);\n\tbtrfs_dev_replace_lock(dev_replace);\n\tdev_replace->replace_state =\n\t\tscrub_ret ? BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED\n\t\t\t  : BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED;\n\tdev_replace->tgtdev = NULL;\n\tdev_replace->srcdev = NULL;\n\tdev_replace->time_stopped = get_seconds();\n\tdev_replace->item_needs_writeback = 1;\n\n\t/* replace old device with new one in mapping tree */\n\tif (!scrub_ret) {\n\t\tbtrfs_dev_replace_update_device_in_mapping_tree(fs_info,\n\t\t\t\t\t\t\t\tsrc_device,\n\t\t\t\t\t\t\t\ttgt_device);\n\t} else {\n\t\tprintk_in_rcu(KERN_ERR\n\t\t\t      \"BTRFS: btrfs_scrub_dev(%s, %llu, %s) failed %d\\n\",\n\t\t\t      src_device->missing ? \"<missing disk>\" :\n\t\t\t        rcu_str_deref(src_device->name),\n\t\t\t      src_device->devid,\n\t\t\t      rcu_str_deref(tgt_device->name), scrub_ret);\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\tmutex_unlock(&root->fs_info->chunk_mutex);\n\t\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\t\tmutex_unlock(&uuid_mutex);\n\t\tif (tgt_device)\n\t\t\tbtrfs_destroy_dev_replace_tgtdev(fs_info, tgt_device);\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\n\t\treturn scrub_ret;\n\t}\n\n\tprintk_in_rcu(KERN_INFO\n\t\t      \"BTRFS: dev_replace from %s (devid %llu) to %s finished\\n\",\n\t\t      src_device->missing ? \"<missing disk>\" :\n\t\t        rcu_str_deref(src_device->name),\n\t\t      src_device->devid,\n\t\t      rcu_str_deref(tgt_device->name));\n\ttgt_device->is_tgtdev_for_dev_replace = 0;\n\ttgt_device->devid = src_device->devid;\n\tsrc_device->devid = BTRFS_DEV_REPLACE_DEVID;\n\tmemcpy(uuid_tmp, tgt_device->uuid, sizeof(uuid_tmp));\n\tmemcpy(tgt_device->uuid, src_device->uuid, sizeof(tgt_device->uuid));\n\tmemcpy(src_device->uuid, uuid_tmp, sizeof(src_device->uuid));\n\tbtrfs_device_set_total_bytes(tgt_device, src_device->total_bytes);\n\tbtrfs_device_set_disk_total_bytes(tgt_device,\n\t\t\t\t\t  src_device->disk_total_bytes);\n\tbtrfs_device_set_bytes_used(tgt_device, src_device->bytes_used);\n\tASSERT(list_empty(&src_device->resized_list));\n\ttgt_device->commit_total_bytes = src_device->commit_total_bytes;\n\ttgt_device->commit_bytes_used = src_device->bytes_used;\n\tif (fs_info->sb->s_bdev == src_device->bdev)\n\t\tfs_info->sb->s_bdev = tgt_device->bdev;\n\tif (fs_info->fs_devices->latest_bdev == src_device->bdev)\n\t\tfs_info->fs_devices->latest_bdev = tgt_device->bdev;\n\tlist_add(&tgt_device->dev_alloc_list, &fs_info->fs_devices->alloc_list);\n\tfs_info->fs_devices->rw_devices++;\n\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tbtrfs_rm_dev_replace_blocked(fs_info);\n\n\tbtrfs_rm_dev_replace_remove_srcdev(fs_info, src_device);\n\n\tbtrfs_rm_dev_replace_unblocked(fs_info);\n\n\t/*\n\t * this is again a consistent state where no dev_replace procedure\n\t * is running, the target device is part of the filesystem, the\n\t * source device is not part of the filesystem anymore and its 1st\n\t * superblock is scratched out so that it is no longer marked to\n\t * belong to this filesystem.\n\t */\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\tmutex_unlock(&uuid_mutex);\n\n\t/* replace the sysfs entry */\n\tbtrfs_kobj_rm_device(fs_info, src_device);\n\tbtrfs_kobj_add_device(fs_info, tgt_device);\n\tbtrfs_rm_dev_replace_free_srcdev(fs_info, src_device);\n\n\t/* write back the superblocks */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (!IS_ERR(trans))\n\t\tbtrfs_commit_transaction(trans, root);\n\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_scrub_dev",
          "args": [
            "fs_info",
            "dev_replace->srcdev->devid",
            "dev_replace->committed_cursor_left",
            "btrfs_device_get_total_bytes(dev_replace->srcdev)",
            "&dev_replace->scrub_progress",
            "0",
            "1"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_scrub_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3611-3754",
          "snippet": "int btrfs_scrub_dev(struct btrfs_fs_info *fs_info, u64 devid, u64 start,\n\t\t    u64 end, struct btrfs_scrub_progress *progress,\n\t\t    int readonly, int is_dev_replace)\n{\n\tstruct scrub_ctx *sctx;\n\tint ret;\n\tstruct btrfs_device *dev;\n\tstruct rcu_string *name;\n\n\tif (btrfs_fs_closing(fs_info))\n\t\treturn -EINVAL;\n\n\tif (fs_info->chunk_root->nodesize > BTRFS_STRIPE_LEN) {\n\t\t/*\n\t\t * in this case scrub is unable to calculate the checksum\n\t\t * the way scrub is implemented. Do not handle this\n\t\t * situation at all because it won't ever happen.\n\t\t */\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"scrub: size assumption nodesize <= BTRFS_STRIPE_LEN (%d <= %d) fails\",\n\t\t       fs_info->chunk_root->nodesize, BTRFS_STRIPE_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fs_info->chunk_root->sectorsize != PAGE_SIZE) {\n\t\t/* not supported for data w/o checksums */\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"scrub: size assumption sectorsize != PAGE_SIZE \"\n\t\t\t   \"(%d != %lu) fails\",\n\t\t       fs_info->chunk_root->sectorsize, PAGE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fs_info->chunk_root->nodesize >\n\t    PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK ||\n\t    fs_info->chunk_root->sectorsize >\n\t    PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK) {\n\t\t/*\n\t\t * would exhaust the array bounds of pagev member in\n\t\t * struct scrub_block\n\t\t */\n\t\tbtrfs_err(fs_info, \"scrub: size assumption nodesize and sectorsize \"\n\t\t\t   \"<= SCRUB_MAX_PAGES_PER_BLOCK (%d <= %d && %d <= %d) fails\",\n\t\t       fs_info->chunk_root->nodesize,\n\t\t       SCRUB_MAX_PAGES_PER_BLOCK,\n\t\t       fs_info->chunk_root->sectorsize,\n\t\t       SCRUB_MAX_PAGES_PER_BLOCK);\n\t\treturn -EINVAL;\n\t}\n\n\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info, devid, NULL, NULL);\n\tif (!dev || (dev->missing && !is_dev_replace)) {\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!is_dev_replace && !readonly && !dev->writeable) {\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(dev->name);\n\t\tbtrfs_err(fs_info, \"scrub: device %s is not writable\",\n\t\t\t  name->str);\n\t\trcu_read_unlock();\n\t\treturn -EROFS;\n\t}\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!dev->in_fs_metadata || dev->is_tgtdev_for_dev_replace) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -EIO;\n\t}\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (dev->scrub_device ||\n\t    (!is_dev_replace &&\n\t     btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))) {\n\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -EINPROGRESS;\n\t}\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\tret = scrub_workers_get(fs_info, is_dev_replace);\n\tif (ret) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn ret;\n\t}\n\n\tsctx = scrub_setup_ctx(dev, is_dev_replace);\n\tif (IS_ERR(sctx)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\tscrub_workers_put(fs_info);\n\t\treturn PTR_ERR(sctx);\n\t}\n\tsctx->readonly = readonly;\n\tdev->scrub_device = sctx;\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\n\t/*\n\t * checking @scrub_pause_req here, we can avoid\n\t * race between committing transaction and scrubbing.\n\t */\n\t__scrub_blocked_if_needed(fs_info);\n\tatomic_inc(&fs_info->scrubs_running);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\tif (!is_dev_replace) {\n\t\t/*\n\t\t * by holding device list mutex, we can\n\t\t * kick off writing super in log tree sync.\n\t\t */\n\t\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\t\tret = scrub_supers(sctx, dev);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t}\n\n\tif (!ret)\n\t\tret = scrub_enumerate_chunks(sctx, dev, start, end,\n\t\t\t\t\t     is_dev_replace);\n\n\twait_event(sctx->list_wait, atomic_read(&sctx->bios_in_flight) == 0);\n\tatomic_dec(&fs_info->scrubs_running);\n\twake_up(&fs_info->scrub_pause_wait);\n\n\twait_event(sctx->list_wait, atomic_read(&sctx->workers_pending) == 0);\n\n\tif (progress)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tdev->scrub_device = NULL;\n\tscrub_workers_put(fs_info);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\tscrub_put_ctx(sctx);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [
            "#define SCRUB_MAX_PAGES_PER_BLOCK\t16\t/* 64k per node/leaf/sector */"
          ],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_MAX_PAGES_PER_BLOCK\t16\t/* 64k per node/leaf/sector */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_scrub_dev(struct btrfs_fs_info *fs_info, u64 devid, u64 start,\n\t\t    u64 end, struct btrfs_scrub_progress *progress,\n\t\t    int readonly, int is_dev_replace)\n{\n\tstruct scrub_ctx *sctx;\n\tint ret;\n\tstruct btrfs_device *dev;\n\tstruct rcu_string *name;\n\n\tif (btrfs_fs_closing(fs_info))\n\t\treturn -EINVAL;\n\n\tif (fs_info->chunk_root->nodesize > BTRFS_STRIPE_LEN) {\n\t\t/*\n\t\t * in this case scrub is unable to calculate the checksum\n\t\t * the way scrub is implemented. Do not handle this\n\t\t * situation at all because it won't ever happen.\n\t\t */\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"scrub: size assumption nodesize <= BTRFS_STRIPE_LEN (%d <= %d) fails\",\n\t\t       fs_info->chunk_root->nodesize, BTRFS_STRIPE_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fs_info->chunk_root->sectorsize != PAGE_SIZE) {\n\t\t/* not supported for data w/o checksums */\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"scrub: size assumption sectorsize != PAGE_SIZE \"\n\t\t\t   \"(%d != %lu) fails\",\n\t\t       fs_info->chunk_root->sectorsize, PAGE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fs_info->chunk_root->nodesize >\n\t    PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK ||\n\t    fs_info->chunk_root->sectorsize >\n\t    PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK) {\n\t\t/*\n\t\t * would exhaust the array bounds of pagev member in\n\t\t * struct scrub_block\n\t\t */\n\t\tbtrfs_err(fs_info, \"scrub: size assumption nodesize and sectorsize \"\n\t\t\t   \"<= SCRUB_MAX_PAGES_PER_BLOCK (%d <= %d && %d <= %d) fails\",\n\t\t       fs_info->chunk_root->nodesize,\n\t\t       SCRUB_MAX_PAGES_PER_BLOCK,\n\t\t       fs_info->chunk_root->sectorsize,\n\t\t       SCRUB_MAX_PAGES_PER_BLOCK);\n\t\treturn -EINVAL;\n\t}\n\n\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info, devid, NULL, NULL);\n\tif (!dev || (dev->missing && !is_dev_replace)) {\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!is_dev_replace && !readonly && !dev->writeable) {\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(dev->name);\n\t\tbtrfs_err(fs_info, \"scrub: device %s is not writable\",\n\t\t\t  name->str);\n\t\trcu_read_unlock();\n\t\treturn -EROFS;\n\t}\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!dev->in_fs_metadata || dev->is_tgtdev_for_dev_replace) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -EIO;\n\t}\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (dev->scrub_device ||\n\t    (!is_dev_replace &&\n\t     btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))) {\n\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -EINPROGRESS;\n\t}\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\tret = scrub_workers_get(fs_info, is_dev_replace);\n\tif (ret) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn ret;\n\t}\n\n\tsctx = scrub_setup_ctx(dev, is_dev_replace);\n\tif (IS_ERR(sctx)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\tscrub_workers_put(fs_info);\n\t\treturn PTR_ERR(sctx);\n\t}\n\tsctx->readonly = readonly;\n\tdev->scrub_device = sctx;\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\n\t/*\n\t * checking @scrub_pause_req here, we can avoid\n\t * race between committing transaction and scrubbing.\n\t */\n\t__scrub_blocked_if_needed(fs_info);\n\tatomic_inc(&fs_info->scrubs_running);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\tif (!is_dev_replace) {\n\t\t/*\n\t\t * by holding device list mutex, we can\n\t\t * kick off writing super in log tree sync.\n\t\t */\n\t\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\t\tret = scrub_supers(sctx, dev);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t}\n\n\tif (!ret)\n\t\tret = scrub_enumerate_chunks(sctx, dev, start, end,\n\t\t\t\t\t     is_dev_replace);\n\n\twait_event(sctx->list_wait, atomic_read(&sctx->bios_in_flight) == 0);\n\tatomic_dec(&fs_info->scrubs_running);\n\twake_up(&fs_info->scrub_pause_wait);\n\n\twait_event(sctx->list_wait, atomic_read(&sctx->workers_pending) == 0);\n\n\tif (progress)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tdev->scrub_device = NULL;\n\tscrub_workers_put(fs_info);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\tscrub_put_ctx(sctx);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_get_total_bytes",
          "args": [
            "dev_replace->srcdev"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tint ret;\n\n\tret = btrfs_scrub_dev(fs_info, dev_replace->srcdev->devid,\n\t\t\t      dev_replace->committed_cursor_left,\n\t\t\t      btrfs_device_get_total_bytes(dev_replace->srcdev),\n\t\t\t      &dev_replace->scrub_progress, 0, 1);\n\tret = btrfs_dev_replace_finishing(fs_info, ret);\n\tWARN_ON(ret);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_dev_replace_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "797-824",
    "snippet": "static int btrfs_dev_replace_kthread(void *data)\n{\n\tstruct btrfs_fs_info *fs_info = data;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_ioctl_dev_replace_args *status_args;\n\tu64 progress;\n\n\tstatus_args = kzalloc(sizeof(*status_args), GFP_NOFS);\n\tif (status_args) {\n\t\tbtrfs_dev_replace_status(fs_info, status_args);\n\t\tprogress = status_args->status.progress_1000;\n\t\tkfree(status_args);\n\t\tdo_div(progress, 10);\n\t\tprintk_in_rcu(KERN_INFO\n\t\t\t\"BTRFS: continuing dev_replace from %s (devid %llu) to %s @%u%%\\n\",\n\t\t\tdev_replace->srcdev->missing ? \"<missing disk>\" :\n\t\t\trcu_str_deref(dev_replace->srcdev->name),\n\t\t\tdev_replace->srcdev->devid,\n\t\t\tdev_replace->tgtdev ?\n\t\t\trcu_str_deref(dev_replace->tgtdev->name) :\n\t\t\t\"<missing target disk>\",\n\t\t\t(unsigned int)progress);\n\t}\n\tbtrfs_dev_replace_continue_on_mount(fs_info);\n\tatomic_set(&fs_info->mutually_exclusive_operation_running, 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);",
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_kthread(void *data);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fs_info->mutually_exclusive_operation_running",
            "0"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_continue_on_mount",
          "args": [
            "fs_info"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_continue_on_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "826-838",
          "snippet": "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tint ret;\n\n\tret = btrfs_scrub_dev(fs_info, dev_replace->srcdev->devid,\n\t\t\t      dev_replace->committed_cursor_left,\n\t\t\t      btrfs_device_get_total_bytes(dev_replace->srcdev),\n\t\t\t      &dev_replace->scrub_progress, 0, 1);\n\tret = btrfs_dev_replace_finishing(fs_info, ret);\n\tWARN_ON(ret);\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tint ret;\n\n\tret = btrfs_scrub_dev(fs_info, dev_replace->srcdev->devid,\n\t\t\t      dev_replace->committed_cursor_left,\n\t\t\t      btrfs_device_get_total_bytes(dev_replace->srcdev),\n\t\t\t      &dev_replace->scrub_progress, 0, 1);\n\tret = btrfs_dev_replace_finishing(fs_info, ret);\n\tWARN_ON(ret);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_in_rcu",
          "args": [
            "KERN_INFO\n\t\t\t\"BTRFS: continuing dev_replace from %s (devid %llu) to %s @%u%%\\n\"",
            "dev_replace->srcdev->missing ? \"<missing disk>\" :\n\t\t\trcu_str_deref(dev_replace->srcdev->name)",
            "dev_replace->srcdev->devid",
            "dev_replace->tgtdev ?\n\t\t\trcu_str_deref(dev_replace->tgtdev->name) :\n\t\t\t\"<missing target disk>\"",
            "(unsigned int)progress"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "dev_replace->tgtdev->name"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "dev_replace->srcdev->name"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "progress",
            "10"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "status_args"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_status",
          "args": [
            "fs_info",
            "status_args"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "645-678",
          "snippet": "void btrfs_dev_replace_status(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_ioctl_dev_replace_args *args)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_device *srcdev;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\t/* even if !dev_replace_is_valid, the values are good enough for\n\t * the replace_status ioctl */\n\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\n\targs->status.replace_state = dev_replace->replace_state;\n\targs->status.time_started = dev_replace->time_started;\n\targs->status.time_stopped = dev_replace->time_stopped;\n\targs->status.num_write_errors =\n\t\tatomic64_read(&dev_replace->num_write_errors);\n\targs->status.num_uncorrectable_read_errors =\n\t\tatomic64_read(&dev_replace->num_uncorrectable_read_errors);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\targs->status.progress_1000 = 0;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\t\targs->status.progress_1000 = 1000;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tsrcdev = dev_replace->srcdev;\n\t\targs->status.progress_1000 = div64_u64(dev_replace->cursor_left,\n\t\t\tdiv64_u64(btrfs_device_get_total_bytes(srcdev), 1000));\n\t\tbreak;\n\t}\n\tbtrfs_dev_replace_unlock(dev_replace);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_dev_replace_status(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_ioctl_dev_replace_args *args)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_device *srcdev;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\t/* even if !dev_replace_is_valid, the values are good enough for\n\t * the replace_status ioctl */\n\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\n\targs->status.replace_state = dev_replace->replace_state;\n\targs->status.time_started = dev_replace->time_started;\n\targs->status.time_stopped = dev_replace->time_stopped;\n\targs->status.num_write_errors =\n\t\tatomic64_read(&dev_replace->num_write_errors);\n\targs->status.num_uncorrectable_read_errors =\n\t\tatomic64_read(&dev_replace->num_uncorrectable_read_errors);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\targs->status.progress_1000 = 0;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\t\targs->status.progress_1000 = 1000;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tsrcdev = dev_replace->srcdev;\n\t\targs->status.progress_1000 = div64_u64(dev_replace->cursor_left,\n\t\t\tdiv64_u64(btrfs_device_get_total_bytes(srcdev), 1000));\n\t\tbreak;\n\t}\n\tbtrfs_dev_replace_unlock(dev_replace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*status_args)",
            "GFP_NOFS"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_kthread(void *data);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nstatic int btrfs_dev_replace_kthread(void *data)\n{\n\tstruct btrfs_fs_info *fs_info = data;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_ioctl_dev_replace_args *status_args;\n\tu64 progress;\n\n\tstatus_args = kzalloc(sizeof(*status_args), GFP_NOFS);\n\tif (status_args) {\n\t\tbtrfs_dev_replace_status(fs_info, status_args);\n\t\tprogress = status_args->status.progress_1000;\n\t\tkfree(status_args);\n\t\tdo_div(progress, 10);\n\t\tprintk_in_rcu(KERN_INFO\n\t\t\t\"BTRFS: continuing dev_replace from %s (devid %llu) to %s @%u%%\\n\",\n\t\t\tdev_replace->srcdev->missing ? \"<missing disk>\" :\n\t\t\trcu_str_deref(dev_replace->srcdev->name),\n\t\t\tdev_replace->srcdev->devid,\n\t\t\tdev_replace->tgtdev ?\n\t\t\trcu_str_deref(dev_replace->tgtdev->name) :\n\t\t\t\"<missing target disk>\",\n\t\t\t(unsigned int)progress);\n\t}\n\tbtrfs_dev_replace_continue_on_mount(fs_info);\n\tatomic_set(&fs_info->mutually_exclusive_operation_running, 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_resume_dev_replace_async",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "763-795",
    "snippet": "int btrfs_resume_dev_replace_async(struct btrfs_fs_info *fs_info)\n{\n\tstruct task_struct *task;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_STARTED;\n\t\tbreak;\n\t}\n\tif (!dev_replace->tgtdev || !dev_replace->tgtdev->bdev) {\n\t\tbtrfs_info(fs_info, \"cannot continue dev_replace, tgtdev is missing\");\n\t\tbtrfs_info(fs_info,\n\t\t\t\"you may cancel the operation after 'mount -o degraded'\");\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\treturn 0;\n\t}\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tWARN_ON(atomic_xchg(\n\t\t&fs_info->mutually_exclusive_operation_running, 1));\n\ttask = kthread_run(btrfs_dev_replace_kthread, fs_info, \"btrfs-devrepl\");\n\treturn PTR_ERR_OR_ZERO(task);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);",
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR_OR_ZERO",
          "args": [
            "task"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "btrfs_dev_replace_kthread",
            "fs_info",
            "\"btrfs-devrepl\""
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_xchg(\n\t\t&fs_info->mutually_exclusive_operation_running, 1)"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&fs_info->mutually_exclusive_operation_running",
            "1"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_unlock",
          "args": [
            "dev_replace"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "895-909",
          "snippet": "void btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "fs_info",
            "\"you may cancel the operation after 'mount -o degraded'\""
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "fs_info",
            "\"cannot continue dev_replace, tgtdev is missing\""
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_lock",
          "args": [
            "dev_replace"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "867-893",
          "snippet": "void btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nint btrfs_resume_dev_replace_async(struct btrfs_fs_info *fs_info)\n{\n\tstruct task_struct *task;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_STARTED;\n\t\tbreak;\n\t}\n\tif (!dev_replace->tgtdev || !dev_replace->tgtdev->bdev) {\n\t\tbtrfs_info(fs_info, \"cannot continue dev_replace, tgtdev is missing\");\n\t\tbtrfs_info(fs_info,\n\t\t\t\"you may cancel the operation after 'mount -o degraded'\");\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\treturn 0;\n\t}\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tWARN_ON(atomic_xchg(\n\t\t&fs_info->mutually_exclusive_operation_running, 1));\n\ttask = kthread_run(btrfs_dev_replace_kthread, fs_info, \"btrfs-devrepl\");\n\treturn PTR_ERR_OR_ZERO(task);\n}"
  },
  {
    "function_name": "btrfs_dev_replace_suspend_for_unmount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "737-760",
    "snippet": "void btrfs_dev_replace_suspend_for_unmount(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED;\n\t\tdev_replace->time_stopped = get_seconds();\n\t\tdev_replace->item_needs_writeback = 1;\n\t\tbtrfs_info(fs_info, \"suspending dev_replace for unmount\");\n\t\tbreak;\n\t}\n\n\tbtrfs_dev_replace_unlock(dev_replace);\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dev_replace->lock_finishing_cancel_unmount"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_unlock",
          "args": [
            "dev_replace"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "895-909",
          "snippet": "void btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "fs_info",
            "\"suspending dev_replace for unmount\""
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_lock",
          "args": [
            "dev_replace"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "867-893",
          "snippet": "void btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dev_replace->lock_finishing_cancel_unmount"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_dev_replace_suspend_for_unmount(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED;\n\t\tdev_replace->time_stopped = get_seconds();\n\t\tdev_replace->item_needs_writeback = 1;\n\t\tbtrfs_info(fs_info, \"suspending dev_replace for unmount\");\n\t\tbreak;\n\t}\n\n\tbtrfs_dev_replace_unlock(dev_replace);\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n}"
  },
  {
    "function_name": "__btrfs_dev_replace_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "687-735",
    "snippet": "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_device *tgt_device = NULL;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tu64 result;\n\tint ret;\n\n\tif (fs_info->sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tresult = BTRFS_IOCTL_DEV_REPLACE_RESULT_NOT_STARTED;\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\tgoto leave;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tresult = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\n\t\ttgt_device = dev_replace->tgtdev;\n\t\tdev_replace->tgtdev = NULL;\n\t\tdev_replace->srcdev = NULL;\n\t\tbreak;\n\t}\n\tdev_replace->replace_state = BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED;\n\tdev_replace->time_stopped = get_seconds();\n\tdev_replace->item_needs_writeback = 1;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\tbtrfs_scrub_cancel(fs_info);\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn PTR_ERR(trans);\n\t}\n\tret = btrfs_commit_transaction(trans, root);\n\tWARN_ON(ret);\n\tif (tgt_device)\n\t\tbtrfs_destroy_dev_replace_tgtdev(fs_info, tgt_device);\n\nleave:\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\treturn result;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);",
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dev_replace->lock_finishing_cancel_unmount"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_destroy_dev_replace_tgtdev",
          "args": [
            "fs_info",
            "tgt_device"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_dev_replace_tgtdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1863-1889",
          "snippet": "void btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,\n\t\t\t\t      struct btrfs_device *tgtdev)\n{\n\tstruct btrfs_device *next_device;\n\n\tmutex_lock(&uuid_mutex);\n\tWARN_ON(!tgtdev);\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tif (tgtdev->bdev) {\n\t\tbtrfs_scratch_superblock(tgtdev);\n\t\tfs_info->fs_devices->open_devices--;\n\t}\n\tfs_info->fs_devices->num_devices--;\n\n\tnext_device = list_entry(fs_info->fs_devices->devices.next,\n\t\t\t\t struct btrfs_device, dev_list);\n\tif (tgtdev->bdev == fs_info->sb->s_bdev)\n\t\tfs_info->sb->s_bdev = next_device->bdev;\n\tif (tgtdev->bdev == fs_info->fs_devices->latest_bdev)\n\t\tfs_info->fs_devices->latest_bdev = next_device->bdev;\n\tlist_del_rcu(&tgtdev->dev_list);\n\n\tcall_rcu(&tgtdev->rcu, free_device);\n\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\tmutex_unlock(&uuid_mutex);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,\n\t\t\t\t      struct btrfs_device *tgtdev)\n{\n\tstruct btrfs_device *next_device;\n\n\tmutex_lock(&uuid_mutex);\n\tWARN_ON(!tgtdev);\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tif (tgtdev->bdev) {\n\t\tbtrfs_scratch_superblock(tgtdev);\n\t\tfs_info->fs_devices->open_devices--;\n\t}\n\tfs_info->fs_devices->num_devices--;\n\n\tnext_device = list_entry(fs_info->fs_devices->devices.next,\n\t\t\t\t struct btrfs_device, dev_list);\n\tif (tgtdev->bdev == fs_info->sb->s_bdev)\n\t\tfs_info->sb->s_bdev = next_device->bdev;\n\tif (tgtdev->bdev == fs_info->fs_devices->latest_bdev)\n\t\tfs_info->fs_devices->latest_bdev = next_device->bdev;\n\tlist_del_rcu(&tgtdev->dev_list);\n\n\tcall_rcu(&tgtdev->rcu, free_device);\n\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\tmutex_unlock(&uuid_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dev_replace->lock_finishing_cancel_unmount"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_scrub_cancel",
          "args": [
            "fs_info"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_scrub_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3781-3800",
          "snippet": "int btrfs_scrub_cancel(struct btrfs_fs_info *fs_info)\n{\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\treturn -ENOTCONN;\n\t}\n\n\tatomic_inc(&fs_info->scrub_cancel_req);\n\twhile (atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   atomic_read(&fs_info->scrubs_running) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tatomic_dec(&fs_info->scrub_cancel_req);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_scrub_cancel(struct btrfs_fs_info *fs_info)\n{\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\treturn -ENOTCONN;\n\t}\n\n\tatomic_inc(&fs_info->scrub_cancel_req);\n\twhile (atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   atomic_read(&fs_info->scrubs_running) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tatomic_dec(&fs_info->scrub_cancel_req);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_unlock",
          "args": [
            "dev_replace"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "895-909",
          "snippet": "void btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_lock",
          "args": [
            "dev_replace"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "867-893",
          "snippet": "void btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dev_replace->lock_finishing_cancel_unmount"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_device *tgt_device = NULL;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tu64 result;\n\tint ret;\n\n\tif (fs_info->sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tresult = BTRFS_IOCTL_DEV_REPLACE_RESULT_NOT_STARTED;\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\tgoto leave;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tresult = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\n\t\ttgt_device = dev_replace->tgtdev;\n\t\tdev_replace->tgtdev = NULL;\n\t\tdev_replace->srcdev = NULL;\n\t\tbreak;\n\t}\n\tdev_replace->replace_state = BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED;\n\tdev_replace->time_stopped = get_seconds();\n\tdev_replace->item_needs_writeback = 1;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\tbtrfs_scrub_cancel(fs_info);\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn PTR_ERR(trans);\n\t}\n\tret = btrfs_commit_transaction(trans, root);\n\tWARN_ON(ret);\n\tif (tgt_device)\n\t\tbtrfs_destroy_dev_replace_tgtdev(fs_info, tgt_device);\n\nleave:\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\treturn result;\n}"
  },
  {
    "function_name": "btrfs_dev_replace_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "680-685",
    "snippet": "int btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info,\n\t\t\t     struct btrfs_ioctl_dev_replace_args *args)\n{\n\targs->result = __btrfs_dev_replace_cancel(fs_info);\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_dev_replace_cancel",
          "args": [
            "fs_info"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_dev_replace_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "687-735",
          "snippet": "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_device *tgt_device = NULL;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tu64 result;\n\tint ret;\n\n\tif (fs_info->sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tresult = BTRFS_IOCTL_DEV_REPLACE_RESULT_NOT_STARTED;\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\tgoto leave;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tresult = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\n\t\ttgt_device = dev_replace->tgtdev;\n\t\tdev_replace->tgtdev = NULL;\n\t\tdev_replace->srcdev = NULL;\n\t\tbreak;\n\t}\n\tdev_replace->replace_state = BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED;\n\tdev_replace->time_stopped = get_seconds();\n\tdev_replace->item_needs_writeback = 1;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\tbtrfs_scrub_cancel(fs_info);\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn PTR_ERR(trans);\n\t}\n\tret = btrfs_commit_transaction(trans, root);\n\tWARN_ON(ret);\n\tif (tgt_device)\n\t\tbtrfs_destroy_dev_replace_tgtdev(fs_info, tgt_device);\n\nleave:\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\treturn result;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);",
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_device *tgt_device = NULL;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tu64 result;\n\tint ret;\n\n\tif (fs_info->sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tresult = BTRFS_IOCTL_DEV_REPLACE_RESULT_NOT_STARTED;\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\tgoto leave;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tresult = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\n\t\ttgt_device = dev_replace->tgtdev;\n\t\tdev_replace->tgtdev = NULL;\n\t\tdev_replace->srcdev = NULL;\n\t\tbreak;\n\t}\n\tdev_replace->replace_state = BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED;\n\tdev_replace->time_stopped = get_seconds();\n\tdev_replace->item_needs_writeback = 1;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\tbtrfs_scrub_cancel(fs_info);\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn PTR_ERR(trans);\n\t}\n\tret = btrfs_commit_transaction(trans, root);\n\tWARN_ON(ret);\n\tif (tgt_device)\n\t\tbtrfs_destroy_dev_replace_tgtdev(fs_info, tgt_device);\n\nleave:\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nint btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info,\n\t\t\t     struct btrfs_ioctl_dev_replace_args *args)\n{\n\targs->result = __btrfs_dev_replace_cancel(fs_info);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_dev_replace_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "645-678",
    "snippet": "void btrfs_dev_replace_status(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_ioctl_dev_replace_args *args)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_device *srcdev;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\t/* even if !dev_replace_is_valid, the values are good enough for\n\t * the replace_status ioctl */\n\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\n\targs->status.replace_state = dev_replace->replace_state;\n\targs->status.time_started = dev_replace->time_started;\n\targs->status.time_stopped = dev_replace->time_stopped;\n\targs->status.num_write_errors =\n\t\tatomic64_read(&dev_replace->num_write_errors);\n\targs->status.num_uncorrectable_read_errors =\n\t\tatomic64_read(&dev_replace->num_uncorrectable_read_errors);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\targs->status.progress_1000 = 0;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\t\targs->status.progress_1000 = 1000;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tsrcdev = dev_replace->srcdev;\n\t\targs->status.progress_1000 = div64_u64(dev_replace->cursor_left,\n\t\t\tdiv64_u64(btrfs_device_get_total_bytes(srcdev), 1000));\n\t\tbreak;\n\t}\n\tbtrfs_dev_replace_unlock(dev_replace);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_dev_replace_unlock",
          "args": [
            "dev_replace"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "895-909",
          "snippet": "void btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "dev_replace->cursor_left",
            "div64_u64(btrfs_device_get_total_bytes(srcdev), 1000)"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "btrfs_device_get_total_bytes(srcdev)",
            "1000"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_get_total_bytes",
          "args": [
            "srcdev"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&dev_replace->num_uncorrectable_read_errors"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&dev_replace->num_write_errors"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_lock",
          "args": [
            "dev_replace"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "867-893",
          "snippet": "void btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_dev_replace_status(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_ioctl_dev_replace_args *args)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_device *srcdev;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\t/* even if !dev_replace_is_valid, the values are good enough for\n\t * the replace_status ioctl */\n\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\n\targs->status.replace_state = dev_replace->replace_state;\n\targs->status.time_started = dev_replace->time_started;\n\targs->status.time_stopped = dev_replace->time_stopped;\n\targs->status.num_write_errors =\n\t\tatomic64_read(&dev_replace->num_write_errors);\n\targs->status.num_uncorrectable_read_errors =\n\t\tatomic64_read(&dev_replace->num_uncorrectable_read_errors);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\targs->status.progress_1000 = 0;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\t\targs->status.progress_1000 = 1000;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tsrcdev = dev_replace->srcdev;\n\t\targs->status.progress_1000 = div64_u64(dev_replace->cursor_left,\n\t\t\tdiv64_u64(btrfs_device_get_total_bytes(srcdev), 1000));\n\t\tbreak;\n\t}\n\tbtrfs_dev_replace_unlock(dev_replace);\n}"
  },
  {
    "function_name": "btrfs_dev_replace_find_srcdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "626-643",
    "snippet": "static int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\n\t\t\t\t\t char *srcdev_name,\n\t\t\t\t\t struct btrfs_device **device)\n{\n\tint ret;\n\n\tif (srcdevid) {\n\t\tret = 0;\n\t\t*device = btrfs_find_device(root->fs_info, srcdevid, NULL,\n\t\t\t\t\t    NULL);\n\t\tif (!*device)\n\t\t\tret = -ENOENT;\n\t} else {\n\t\tret = btrfs_find_device_missing_or_by_path(root, srcdev_name,\n\t\t\t\t\t\t\t   device);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\n\t\t\t\t\t char *srcdev_name,\n\t\t\t\t\t struct btrfs_device **device);",
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_find_device_missing_or_by_path",
          "args": [
            "root",
            "srcdev_name",
            "device"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_device_missing_or_by_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1918-1948",
          "snippet": "int btrfs_find_device_missing_or_by_path(struct btrfs_root *root,\n\t\t\t\t\t char *device_path,\n\t\t\t\t\t struct btrfs_device **device)\n{\n\t*device = NULL;\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\tstruct list_head *devices;\n\t\tstruct btrfs_device *tmp;\n\n\t\tdevices = &root->fs_info->fs_devices->devices;\n\t\t/*\n\t\t * It is safe to read the devices since the volume_mutex\n\t\t * is held by the caller.\n\t\t */\n\t\tlist_for_each_entry(tmp, devices, dev_list) {\n\t\t\tif (tmp->in_fs_metadata && !tmp->bdev) {\n\t\t\t\t*device = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!*device) {\n\t\t\tbtrfs_err(root->fs_info, \"no missing device found\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\treturn 0;\n\t} else {\n\t\treturn btrfs_find_device_by_path(root, device_path, device);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_find_device_missing_or_by_path(struct btrfs_root *root,\n\t\t\t\t\t char *device_path,\n\t\t\t\t\t struct btrfs_device **device)\n{\n\t*device = NULL;\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\tstruct list_head *devices;\n\t\tstruct btrfs_device *tmp;\n\n\t\tdevices = &root->fs_info->fs_devices->devices;\n\t\t/*\n\t\t * It is safe to read the devices since the volume_mutex\n\t\t * is held by the caller.\n\t\t */\n\t\tlist_for_each_entry(tmp, devices, dev_list) {\n\t\t\tif (tmp->in_fs_metadata && !tmp->bdev) {\n\t\t\t\t*device = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!*device) {\n\t\t\tbtrfs_err(root->fs_info, \"no missing device found\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\treturn 0;\n\t} else {\n\t\treturn btrfs_find_device_by_path(root, device_path, device);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_device",
          "args": [
            "root->fs_info",
            "srcdevid",
            "NULL",
            "NULL"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5918-5936",
          "snippet": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\n\t\t\t\t\t char *srcdev_name,\n\t\t\t\t\t struct btrfs_device **device);\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nstatic int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\n\t\t\t\t\t char *srcdev_name,\n\t\t\t\t\t struct btrfs_device **device)\n{\n\tint ret;\n\n\tif (srcdevid) {\n\t\tret = 0;\n\t\t*device = btrfs_find_device(root->fs_info, srcdevid, NULL,\n\t\t\t\t\t    NULL);\n\t\tif (!*device)\n\t\t\tret = -ENOENT;\n\t} else {\n\t\tret = btrfs_find_device_missing_or_by_path(root, srcdev_name,\n\t\t\t\t\t\t\t   device);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_dev_replace_update_device_in_mapping_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "600-624",
    "snippet": "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev)\n{\n\tstruct extent_map_tree *em_tree = &fs_info->mapping_tree.map_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tu64 start = 0;\n\tint i;\n\n\twrite_lock(&em_tree->lock);\n\tdo {\n\t\tem = lookup_extent_mapping(em_tree, start, (u64)-1);\n\t\tif (!em)\n\t\t\tbreak;\n\t\tmap = (struct map_lookup *)em->bdev;\n\t\tfor (i = 0; i < map->num_stripes; i++)\n\t\t\tif (srcdev == map->stripes[i].dev)\n\t\t\t\tmap->stripes[i].dev = tgtdev;\n\t\tstart = em->start + em->len;\n\t\tfree_extent_map(em);\n\t} while (start);\n\twrite_unlock(&em_tree->lock);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);",
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "em_tree",
            "start",
            "(u64)-1"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "345-348",
          "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev)\n{\n\tstruct extent_map_tree *em_tree = &fs_info->mapping_tree.map_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tu64 start = 0;\n\tint i;\n\n\twrite_lock(&em_tree->lock);\n\tdo {\n\t\tem = lookup_extent_mapping(em_tree, start, (u64)-1);\n\t\tif (!em)\n\t\t\tbreak;\n\t\tmap = (struct map_lookup *)em->bdev;\n\t\tfor (i = 0; i < map->num_stripes; i++)\n\t\t\tif (srcdev == map->stripes[i].dev)\n\t\t\t\tmap->stripes[i].dev = tgtdev;\n\t\tstart = em->start + em->len;\n\t\tfree_extent_map(em);\n\t} while (start);\n\twrite_unlock(&em_tree->lock);\n}"
  },
  {
    "function_name": "btrfs_dev_replace_finishing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "458-598",
    "snippet": "static int btrfs_dev_replace_finishing(struct btrfs_fs_info *fs_info,\n\t\t\t\t       int scrub_ret)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_device *tgt_device;\n\tstruct btrfs_device *src_device;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tu8 uuid_tmp[BTRFS_UUID_SIZE];\n\tstruct btrfs_trans_handle *trans;\n\tint ret = 0;\n\n\t/* don't allow cancel or unmount to disturb the finishing procedure */\n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\t/* was the operation canceled, or is it finished? */\n\tif (dev_replace->replace_state !=\n\t    BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED) {\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn 0;\n\t}\n\n\ttgt_device = dev_replace->tgtdev;\n\tsrc_device = dev_replace->srcdev;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\t/*\n\t * flush all outstanding I/O and inode extent mappings before the\n\t * copy operation is declared as being finished\n\t */\n\tret = btrfs_start_delalloc_roots(root->fs_info, 0, -1);\n\tif (ret) {\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn ret;\n\t}\n\tbtrfs_wait_ordered_roots(root->fs_info, -1);\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn PTR_ERR(trans);\n\t}\n\tret = btrfs_commit_transaction(trans, root);\n\tWARN_ON(ret);\n\n\tmutex_lock(&uuid_mutex);\n\t/* keep away write_all_supers() during the finishing procedure */\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tmutex_lock(&root->fs_info->chunk_mutex);\n\tbtrfs_dev_replace_lock(dev_replace);\n\tdev_replace->replace_state =\n\t\tscrub_ret ? BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED\n\t\t\t  : BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED;\n\tdev_replace->tgtdev = NULL;\n\tdev_replace->srcdev = NULL;\n\tdev_replace->time_stopped = get_seconds();\n\tdev_replace->item_needs_writeback = 1;\n\n\t/* replace old device with new one in mapping tree */\n\tif (!scrub_ret) {\n\t\tbtrfs_dev_replace_update_device_in_mapping_tree(fs_info,\n\t\t\t\t\t\t\t\tsrc_device,\n\t\t\t\t\t\t\t\ttgt_device);\n\t} else {\n\t\tprintk_in_rcu(KERN_ERR\n\t\t\t      \"BTRFS: btrfs_scrub_dev(%s, %llu, %s) failed %d\\n\",\n\t\t\t      src_device->missing ? \"<missing disk>\" :\n\t\t\t        rcu_str_deref(src_device->name),\n\t\t\t      src_device->devid,\n\t\t\t      rcu_str_deref(tgt_device->name), scrub_ret);\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\tmutex_unlock(&root->fs_info->chunk_mutex);\n\t\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\t\tmutex_unlock(&uuid_mutex);\n\t\tif (tgt_device)\n\t\t\tbtrfs_destroy_dev_replace_tgtdev(fs_info, tgt_device);\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\n\t\treturn scrub_ret;\n\t}\n\n\tprintk_in_rcu(KERN_INFO\n\t\t      \"BTRFS: dev_replace from %s (devid %llu) to %s finished\\n\",\n\t\t      src_device->missing ? \"<missing disk>\" :\n\t\t        rcu_str_deref(src_device->name),\n\t\t      src_device->devid,\n\t\t      rcu_str_deref(tgt_device->name));\n\ttgt_device->is_tgtdev_for_dev_replace = 0;\n\ttgt_device->devid = src_device->devid;\n\tsrc_device->devid = BTRFS_DEV_REPLACE_DEVID;\n\tmemcpy(uuid_tmp, tgt_device->uuid, sizeof(uuid_tmp));\n\tmemcpy(tgt_device->uuid, src_device->uuid, sizeof(tgt_device->uuid));\n\tmemcpy(src_device->uuid, uuid_tmp, sizeof(src_device->uuid));\n\tbtrfs_device_set_total_bytes(tgt_device, src_device->total_bytes);\n\tbtrfs_device_set_disk_total_bytes(tgt_device,\n\t\t\t\t\t  src_device->disk_total_bytes);\n\tbtrfs_device_set_bytes_used(tgt_device, src_device->bytes_used);\n\tASSERT(list_empty(&src_device->resized_list));\n\ttgt_device->commit_total_bytes = src_device->commit_total_bytes;\n\ttgt_device->commit_bytes_used = src_device->bytes_used;\n\tif (fs_info->sb->s_bdev == src_device->bdev)\n\t\tfs_info->sb->s_bdev = tgt_device->bdev;\n\tif (fs_info->fs_devices->latest_bdev == src_device->bdev)\n\t\tfs_info->fs_devices->latest_bdev = tgt_device->bdev;\n\tlist_add(&tgt_device->dev_alloc_list, &fs_info->fs_devices->alloc_list);\n\tfs_info->fs_devices->rw_devices++;\n\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tbtrfs_rm_dev_replace_blocked(fs_info);\n\n\tbtrfs_rm_dev_replace_remove_srcdev(fs_info, src_device);\n\n\tbtrfs_rm_dev_replace_unblocked(fs_info);\n\n\t/*\n\t * this is again a consistent state where no dev_replace procedure\n\t * is running, the target device is part of the filesystem, the\n\t * source device is not part of the filesystem anymore and its 1st\n\t * superblock is scratched out so that it is no longer marked to\n\t * belong to this filesystem.\n\t */\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\tmutex_unlock(&uuid_mutex);\n\n\t/* replace the sysfs entry */\n\tbtrfs_kobj_rm_device(fs_info, src_device);\n\tbtrfs_kobj_add_device(fs_info, tgt_device);\n\tbtrfs_rm_dev_replace_free_srcdev(fs_info, src_device);\n\n\t/* write back the superblocks */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (!IS_ERR(trans))\n\t\tbtrfs_commit_transaction(trans, root);\n\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_dev_replace_finishing(struct btrfs_fs_info *fs_info,\n\t\t\t\t       int scrub_ret);",
      "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);",
      "static int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\n\t\t\t\t\t char *srcdev_name,\n\t\t\t\t\t struct btrfs_device **device);",
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dev_replace->lock_finishing_cancel_unmount"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_rm_dev_replace_free_srcdev",
          "args": [
            "fs_info",
            "src_device"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_rm_dev_replace_free_srcdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1832-1861",
          "snippet": "void btrfs_rm_dev_replace_free_srcdev(struct btrfs_fs_info *fs_info,\n\t\t\t\t      struct btrfs_device *srcdev)\n{\n\tstruct btrfs_fs_devices *fs_devices = srcdev->fs_devices;\n\n\tcall_rcu(&srcdev->rcu, free_device);\n\n\t/*\n\t * unless fs_devices is seed fs, num_devices shouldn't go\n\t * zero\n\t */\n\tBUG_ON(!fs_devices->num_devices && !fs_devices->seeding);\n\n\t/* if this is no devs we rather delete the fs_devices */\n\tif (!fs_devices->num_devices) {\n\t\tstruct btrfs_fs_devices *tmp_fs_devices;\n\n\t\ttmp_fs_devices = fs_info->fs_devices;\n\t\twhile (tmp_fs_devices) {\n\t\t\tif (tmp_fs_devices->seed == fs_devices) {\n\t\t\t\ttmp_fs_devices->seed = fs_devices->seed;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp_fs_devices = tmp_fs_devices->seed;\n\t\t}\n\t\tfs_devices->seed = NULL;\n\t\t__btrfs_close_devices(fs_devices);\n\t\tfree_fs_devices(fs_devices);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_rm_dev_replace_free_srcdev(struct btrfs_fs_info *fs_info,\n\t\t\t\t      struct btrfs_device *srcdev)\n{\n\tstruct btrfs_fs_devices *fs_devices = srcdev->fs_devices;\n\n\tcall_rcu(&srcdev->rcu, free_device);\n\n\t/*\n\t * unless fs_devices is seed fs, num_devices shouldn't go\n\t * zero\n\t */\n\tBUG_ON(!fs_devices->num_devices && !fs_devices->seeding);\n\n\t/* if this is no devs we rather delete the fs_devices */\n\tif (!fs_devices->num_devices) {\n\t\tstruct btrfs_fs_devices *tmp_fs_devices;\n\n\t\ttmp_fs_devices = fs_info->fs_devices;\n\t\twhile (tmp_fs_devices) {\n\t\t\tif (tmp_fs_devices->seed == fs_devices) {\n\t\t\t\ttmp_fs_devices->seed = fs_devices->seed;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp_fs_devices = tmp_fs_devices->seed;\n\t\t}\n\t\tfs_devices->seed = NULL;\n\t\t__btrfs_close_devices(fs_devices);\n\t\tfree_fs_devices(fs_devices);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_kobj_add_device",
          "args": [
            "fs_info",
            "tgt_device"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_kobj_add_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/sysfs.c",
          "lines": "625-659",
          "snippet": "int btrfs_kobj_add_device(struct btrfs_fs_info *fs_info,\n\t\tstruct btrfs_device *one_device)\n{\n\tint error = 0;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *dev;\n\n\tif (!fs_info->device_dir_kobj)\n\t\tfs_info->device_dir_kobj = kobject_create_and_add(\"devices\",\n\t\t\t\t\t\t&fs_info->super_kobj);\n\n\tif (!fs_info->device_dir_kobj)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tstruct hd_struct *disk;\n\t\tstruct kobject *disk_kobj;\n\n\t\tif (!dev->bdev)\n\t\t\tcontinue;\n\n\t\tif (one_device && one_device != dev)\n\t\t\tcontinue;\n\n\t\tdisk = dev->bdev->bd_part;\n\t\tdisk_kobj = &part_to_dev(disk)->kobj;\n\n\t\terror = sysfs_create_link(fs_info->device_dir_kobj,\n\t\t\t\t\t  disk_kobj, disk_kobj->name);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"sysfs.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bug.h>",
            "#include <linux/kobject.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline struct btrfs_fs_info *to_fs_info(struct kobject *kobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"sysfs.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/debugfs.h>\n#include <linux/genhd.h>\n#include <linux/bug.h>\n#include <linux/kobject.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic inline struct btrfs_fs_info *to_fs_info(struct kobject *kobj);\n\nint btrfs_kobj_add_device(struct btrfs_fs_info *fs_info,\n\t\tstruct btrfs_device *one_device)\n{\n\tint error = 0;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *dev;\n\n\tif (!fs_info->device_dir_kobj)\n\t\tfs_info->device_dir_kobj = kobject_create_and_add(\"devices\",\n\t\t\t\t\t\t&fs_info->super_kobj);\n\n\tif (!fs_info->device_dir_kobj)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tstruct hd_struct *disk;\n\t\tstruct kobject *disk_kobj;\n\n\t\tif (!dev->bdev)\n\t\t\tcontinue;\n\n\t\tif (one_device && one_device != dev)\n\t\t\tcontinue;\n\n\t\tdisk = dev->bdev->bd_part;\n\t\tdisk_kobj = &part_to_dev(disk)->kobj;\n\n\t\terror = sysfs_create_link(fs_info->device_dir_kobj,\n\t\t\t\t\t  disk_kobj, disk_kobj->name);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_kobj_rm_device",
          "args": [
            "fs_info",
            "src_device"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_kobj_rm_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/sysfs.c",
          "lines": "605-623",
          "snippet": "int btrfs_kobj_rm_device(struct btrfs_fs_info *fs_info,\n\t\tstruct btrfs_device *one_device)\n{\n\tstruct hd_struct *disk;\n\tstruct kobject *disk_kobj;\n\n\tif (!fs_info->device_dir_kobj)\n\t\treturn -EINVAL;\n\n\tif (one_device && one_device->bdev) {\n\t\tdisk = one_device->bdev->bd_part;\n\t\tdisk_kobj = &part_to_dev(disk)->kobj;\n\n\t\tsysfs_remove_link(fs_info->device_dir_kobj,\n\t\t\t\t\t\tdisk_kobj->name);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"sysfs.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bug.h>",
            "#include <linux/kobject.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline struct btrfs_fs_info *to_fs_info(struct kobject *kobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"sysfs.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/debugfs.h>\n#include <linux/genhd.h>\n#include <linux/bug.h>\n#include <linux/kobject.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic inline struct btrfs_fs_info *to_fs_info(struct kobject *kobj);\n\nint btrfs_kobj_rm_device(struct btrfs_fs_info *fs_info,\n\t\tstruct btrfs_device *one_device)\n{\n\tstruct hd_struct *disk;\n\tstruct kobject *disk_kobj;\n\n\tif (!fs_info->device_dir_kobj)\n\t\treturn -EINVAL;\n\n\tif (one_device && one_device->bdev) {\n\t\tdisk = one_device->bdev->bd_part;\n\t\tdisk_kobj = &part_to_dev(disk)->kobj;\n\n\t\tsysfs_remove_link(fs_info->device_dir_kobj,\n\t\t\t\t\t\tdisk_kobj->name);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->chunk_mutex"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_rm_dev_replace_unblocked",
          "args": [
            "fs_info"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_rm_dev_replace_unblocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "451-456",
          "snippet": "static void btrfs_rm_dev_replace_unblocked(struct btrfs_fs_info *fs_info)\n{\n\tclear_bit(BTRFS_FS_STATE_DEV_REPLACING, &fs_info->fs_state);\n\tif (waitqueue_active(&fs_info->replace_wait))\n\t\twake_up(&fs_info->replace_wait);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nstatic void btrfs_rm_dev_replace_unblocked(struct btrfs_fs_info *fs_info)\n{\n\tclear_bit(BTRFS_FS_STATE_DEV_REPLACING, &fs_info->fs_state);\n\tif (waitqueue_active(&fs_info->replace_wait))\n\t\twake_up(&fs_info->replace_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_rm_dev_replace_remove_srcdev",
          "args": [
            "fs_info",
            "src_device"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_rm_dev_replace_remove_srcdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1801-1830",
          "snippet": "void btrfs_rm_dev_replace_remove_srcdev(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tstruct btrfs_device *srcdev)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\n\tWARN_ON(!mutex_is_locked(&fs_info->fs_devices->device_list_mutex));\n\n\t/*\n\t * in case of fs with no seed, srcdev->fs_devices will point\n\t * to fs_devices of fs_info. However when the dev being replaced is\n\t * a seed dev it will point to the seed's local fs_devices. In short\n\t * srcdev will have its correct fs_devices in both the cases.\n\t */\n\tfs_devices = srcdev->fs_devices;\n\n\tlist_del_rcu(&srcdev->dev_list);\n\tlist_del_rcu(&srcdev->dev_alloc_list);\n\tfs_devices->num_devices--;\n\tif (srcdev->missing)\n\t\tfs_devices->missing_devices--;\n\n\tif (srcdev->writeable) {\n\t\tfs_devices->rw_devices--;\n\t\t/* zero out the old super if it is writable */\n\t\tbtrfs_scratch_superblock(srcdev);\n\t}\n\n\tif (srcdev->bdev)\n\t\tfs_devices->open_devices--;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_rm_dev_replace_remove_srcdev(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tstruct btrfs_device *srcdev)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\n\tWARN_ON(!mutex_is_locked(&fs_info->fs_devices->device_list_mutex));\n\n\t/*\n\t * in case of fs with no seed, srcdev->fs_devices will point\n\t * to fs_devices of fs_info. However when the dev being replaced is\n\t * a seed dev it will point to the seed's local fs_devices. In short\n\t * srcdev will have its correct fs_devices in both the cases.\n\t */\n\tfs_devices = srcdev->fs_devices;\n\n\tlist_del_rcu(&srcdev->dev_list);\n\tlist_del_rcu(&srcdev->dev_alloc_list);\n\tfs_devices->num_devices--;\n\tif (srcdev->missing)\n\t\tfs_devices->missing_devices--;\n\n\tif (srcdev->writeable) {\n\t\tfs_devices->rw_devices--;\n\t\t/* zero out the old super if it is writable */\n\t\tbtrfs_scratch_superblock(srcdev);\n\t}\n\n\tif (srcdev->bdev)\n\t\tfs_devices->open_devices--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_rm_dev_replace_blocked",
          "args": [
            "fs_info"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_rm_dev_replace_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "441-446",
          "snippet": "static void btrfs_rm_dev_replace_blocked(struct btrfs_fs_info *fs_info)\n{\n\tset_bit(BTRFS_FS_STATE_DEV_REPLACING, &fs_info->fs_state);\n\twait_event(fs_info->replace_wait, !percpu_counter_sum(\n\t\t   &fs_info->bio_counter));\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nstatic void btrfs_rm_dev_replace_blocked(struct btrfs_fs_info *fs_info)\n{\n\tset_bit(BTRFS_FS_STATE_DEV_REPLACING, &fs_info->fs_state);\n\twait_event(fs_info->replace_wait, !percpu_counter_sum(\n\t\t   &fs_info->bio_counter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_unlock",
          "args": [
            "dev_replace"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "895-909",
          "snippet": "void btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&tgt_device->dev_alloc_list",
            "&fs_info->fs_devices->alloc_list"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&src_device->resized_list)"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&src_device->resized_list"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_set_bytes_used",
          "args": [
            "tgt_device",
            "src_device->bytes_used"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_set_disk_total_bytes",
          "args": [
            "tgt_device",
            "src_device->disk_total_bytes"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_set_total_bytes",
          "args": [
            "tgt_device",
            "src_device->total_bytes"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "src_device->uuid",
            "uuid_tmp",
            "sizeof(src_device->uuid)"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tgt_device->uuid",
            "src_device->uuid",
            "sizeof(tgt_device->uuid)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "uuid_tmp",
            "tgt_device->uuid",
            "sizeof(uuid_tmp)"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_in_rcu",
          "args": [
            "KERN_INFO\n\t\t      \"BTRFS: dev_replace from %s (devid %llu) to %s finished\\n\"",
            "src_device->missing ? \"<missing disk>\" :\n\t\t        rcu_str_deref(src_device->name)",
            "src_device->devid",
            "rcu_str_deref(tgt_device->name)"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "tgt_device->name"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "src_device->name"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dev_replace->lock_finishing_cancel_unmount"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_destroy_dev_replace_tgtdev",
          "args": [
            "fs_info",
            "tgt_device"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_dev_replace_tgtdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1863-1889",
          "snippet": "void btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,\n\t\t\t\t      struct btrfs_device *tgtdev)\n{\n\tstruct btrfs_device *next_device;\n\n\tmutex_lock(&uuid_mutex);\n\tWARN_ON(!tgtdev);\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tif (tgtdev->bdev) {\n\t\tbtrfs_scratch_superblock(tgtdev);\n\t\tfs_info->fs_devices->open_devices--;\n\t}\n\tfs_info->fs_devices->num_devices--;\n\n\tnext_device = list_entry(fs_info->fs_devices->devices.next,\n\t\t\t\t struct btrfs_device, dev_list);\n\tif (tgtdev->bdev == fs_info->sb->s_bdev)\n\t\tfs_info->sb->s_bdev = next_device->bdev;\n\tif (tgtdev->bdev == fs_info->fs_devices->latest_bdev)\n\t\tfs_info->fs_devices->latest_bdev = next_device->bdev;\n\tlist_del_rcu(&tgtdev->dev_list);\n\n\tcall_rcu(&tgtdev->rcu, free_device);\n\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\tmutex_unlock(&uuid_mutex);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,\n\t\t\t\t      struct btrfs_device *tgtdev)\n{\n\tstruct btrfs_device *next_device;\n\n\tmutex_lock(&uuid_mutex);\n\tWARN_ON(!tgtdev);\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tif (tgtdev->bdev) {\n\t\tbtrfs_scratch_superblock(tgtdev);\n\t\tfs_info->fs_devices->open_devices--;\n\t}\n\tfs_info->fs_devices->num_devices--;\n\n\tnext_device = list_entry(fs_info->fs_devices->devices.next,\n\t\t\t\t struct btrfs_device, dev_list);\n\tif (tgtdev->bdev == fs_info->sb->s_bdev)\n\t\tfs_info->sb->s_bdev = next_device->bdev;\n\tif (tgtdev->bdev == fs_info->fs_devices->latest_bdev)\n\t\tfs_info->fs_devices->latest_bdev = next_device->bdev;\n\tlist_del_rcu(&tgtdev->dev_list);\n\n\tcall_rcu(&tgtdev->rcu, free_device);\n\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\tmutex_unlock(&uuid_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->chunk_mutex"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_in_rcu",
          "args": [
            "KERN_ERR\n\t\t\t      \"BTRFS: btrfs_scrub_dev(%s, %llu, %s) failed %d\\n\"",
            "src_device->missing ? \"<missing disk>\" :\n\t\t\t        rcu_str_deref(src_device->name)",
            "src_device->devid",
            "rcu_str_deref(tgt_device->name)",
            "scrub_ret"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "tgt_device->name"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "src_device->name"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_update_device_in_mapping_tree",
          "args": [
            "fs_info",
            "src_device",
            "tgt_device"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_update_device_in_mapping_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "600-624",
          "snippet": "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev)\n{\n\tstruct extent_map_tree *em_tree = &fs_info->mapping_tree.map_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tu64 start = 0;\n\tint i;\n\n\twrite_lock(&em_tree->lock);\n\tdo {\n\t\tem = lookup_extent_mapping(em_tree, start, (u64)-1);\n\t\tif (!em)\n\t\t\tbreak;\n\t\tmap = (struct map_lookup *)em->bdev;\n\t\tfor (i = 0; i < map->num_stripes; i++)\n\t\t\tif (srcdev == map->stripes[i].dev)\n\t\t\t\tmap->stripes[i].dev = tgtdev;\n\t\tstart = em->start + em->len;\n\t\tfree_extent_map(em);\n\t} while (start);\n\twrite_unlock(&em_tree->lock);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);",
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev)\n{\n\tstruct extent_map_tree *em_tree = &fs_info->mapping_tree.map_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tu64 start = 0;\n\tint i;\n\n\twrite_lock(&em_tree->lock);\n\tdo {\n\t\tem = lookup_extent_mapping(em_tree, start, (u64)-1);\n\t\tif (!em)\n\t\t\tbreak;\n\t\tmap = (struct map_lookup *)em->bdev;\n\t\tfor (i = 0; i < map->num_stripes; i++)\n\t\t\tif (srcdev == map->stripes[i].dev)\n\t\t\t\tmap->stripes[i].dev = tgtdev;\n\t\tstart = em->start + em->len;\n\t\tfree_extent_map(em);\n\t} while (start);\n\twrite_unlock(&em_tree->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_lock",
          "args": [
            "dev_replace"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "867-893",
          "snippet": "void btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->chunk_mutex"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->fs_devices->device_list_mutex"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&uuid_mutex"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dev_replace->lock_finishing_cancel_unmount"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_wait_ordered_roots",
          "args": [
            "root->fs_info",
            "-1"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_ordered_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "656-688",
          "snippet": "void btrfs_wait_ordered_roots(struct btrfs_fs_info *fs_info, int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint done;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->ordered_operations_mutex);\n\tspin_lock(&fs_info->ordered_root_lock);\n\tlist_splice_init(&fs_info->ordered_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tordered_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->ordered_root,\n\t\t\t       &fs_info->ordered_roots);\n\t\tspin_unlock(&fs_info->ordered_root_lock);\n\n\t\tdone = btrfs_wait_ordered_extents(root, nr);\n\t\tbtrfs_put_fs_root(root);\n\n\t\tspin_lock(&fs_info->ordered_root_lock);\n\t\tif (nr != -1) {\n\t\t\tnr -= done;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t}\n\tlist_splice_tail(&splice, &fs_info->ordered_roots);\n\tspin_unlock(&fs_info->ordered_root_lock);\n\tmutex_unlock(&fs_info->ordered_operations_mutex);\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_wait_ordered_roots(struct btrfs_fs_info *fs_info, int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint done;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->ordered_operations_mutex);\n\tspin_lock(&fs_info->ordered_root_lock);\n\tlist_splice_init(&fs_info->ordered_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tordered_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->ordered_root,\n\t\t\t       &fs_info->ordered_roots);\n\t\tspin_unlock(&fs_info->ordered_root_lock);\n\n\t\tdone = btrfs_wait_ordered_extents(root, nr);\n\t\tbtrfs_put_fs_root(root);\n\n\t\tspin_lock(&fs_info->ordered_root_lock);\n\t\tif (nr != -1) {\n\t\t\tnr -= done;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t}\n\tlist_splice_tail(&splice, &fs_info->ordered_roots);\n\tspin_unlock(&fs_info->ordered_root_lock);\n\tmutex_unlock(&fs_info->ordered_operations_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dev_replace->lock_finishing_cancel_unmount"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_delalloc_roots",
          "args": [
            "root->fs_info",
            "0",
            "-1"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_delalloc_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "9228-9282",
          "snippet": "int btrfs_start_delalloc_roots(struct btrfs_fs_info *fs_info, int delay_iput,\n\t\t\t       int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint ret;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\treturn -EROFS;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->delalloc_root_mutex);\n\tspin_lock(&fs_info->delalloc_root_lock);\n\tlist_splice_init(&fs_info->delalloc_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tdelalloc_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->delalloc_root,\n\t\t\t       &fs_info->delalloc_roots);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\t\tret = __start_delalloc_inodes(root, delay_iput, nr);\n\t\tbtrfs_put_fs_root(root);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (nr != -1) {\n\t\t\tnr -= ret;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t}\n\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\tret = 0;\n\tatomic_inc(&fs_info->async_submit_draining);\n\twhile (atomic_read(&fs_info->nr_async_submits) ||\n\t      atomic_read(&fs_info->async_delalloc_pages)) {\n\t\twait_event(fs_info->async_submit_wait,\n\t\t   (atomic_read(&fs_info->nr_async_submits) == 0 &&\n\t\t    atomic_read(&fs_info->async_delalloc_pages) == 0));\n\t}\n\tatomic_dec(&fs_info->async_submit_draining);\nout:\n\tif (!list_empty_careful(&splice)) {\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t\tlist_splice_tail(&splice, &fs_info->delalloc_roots);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\t}\n\tmutex_unlock(&fs_info->delalloc_root_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_start_delalloc_roots(struct btrfs_fs_info *fs_info, int delay_iput,\n\t\t\t       int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint ret;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\treturn -EROFS;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->delalloc_root_mutex);\n\tspin_lock(&fs_info->delalloc_root_lock);\n\tlist_splice_init(&fs_info->delalloc_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tdelalloc_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->delalloc_root,\n\t\t\t       &fs_info->delalloc_roots);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\t\tret = __start_delalloc_inodes(root, delay_iput, nr);\n\t\tbtrfs_put_fs_root(root);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (nr != -1) {\n\t\t\tnr -= ret;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t}\n\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\tret = 0;\n\tatomic_inc(&fs_info->async_submit_draining);\n\twhile (atomic_read(&fs_info->nr_async_submits) ||\n\t      atomic_read(&fs_info->async_delalloc_pages)) {\n\t\twait_event(fs_info->async_submit_wait,\n\t\t   (atomic_read(&fs_info->nr_async_submits) == 0 &&\n\t\t    atomic_read(&fs_info->async_delalloc_pages) == 0));\n\t}\n\tatomic_dec(&fs_info->async_submit_draining);\nout:\n\tif (!list_empty_careful(&splice)) {\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t\tlist_splice_tail(&splice, &fs_info->delalloc_roots);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\t}\n\tmutex_unlock(&fs_info->delalloc_root_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dev_replace->lock_finishing_cancel_unmount"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dev_replace->lock_finishing_cancel_unmount"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_dev_replace_finishing(struct btrfs_fs_info *fs_info,\n\t\t\t\t       int scrub_ret);\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\nstatic int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\n\t\t\t\t\t char *srcdev_name,\n\t\t\t\t\t struct btrfs_device **device);\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nstatic int btrfs_dev_replace_finishing(struct btrfs_fs_info *fs_info,\n\t\t\t\t       int scrub_ret)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_device *tgt_device;\n\tstruct btrfs_device *src_device;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tu8 uuid_tmp[BTRFS_UUID_SIZE];\n\tstruct btrfs_trans_handle *trans;\n\tint ret = 0;\n\n\t/* don't allow cancel or unmount to disturb the finishing procedure */\n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\t/* was the operation canceled, or is it finished? */\n\tif (dev_replace->replace_state !=\n\t    BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED) {\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn 0;\n\t}\n\n\ttgt_device = dev_replace->tgtdev;\n\tsrc_device = dev_replace->srcdev;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\t/*\n\t * flush all outstanding I/O and inode extent mappings before the\n\t * copy operation is declared as being finished\n\t */\n\tret = btrfs_start_delalloc_roots(root->fs_info, 0, -1);\n\tif (ret) {\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn ret;\n\t}\n\tbtrfs_wait_ordered_roots(root->fs_info, -1);\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn PTR_ERR(trans);\n\t}\n\tret = btrfs_commit_transaction(trans, root);\n\tWARN_ON(ret);\n\n\tmutex_lock(&uuid_mutex);\n\t/* keep away write_all_supers() during the finishing procedure */\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tmutex_lock(&root->fs_info->chunk_mutex);\n\tbtrfs_dev_replace_lock(dev_replace);\n\tdev_replace->replace_state =\n\t\tscrub_ret ? BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED\n\t\t\t  : BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED;\n\tdev_replace->tgtdev = NULL;\n\tdev_replace->srcdev = NULL;\n\tdev_replace->time_stopped = get_seconds();\n\tdev_replace->item_needs_writeback = 1;\n\n\t/* replace old device with new one in mapping tree */\n\tif (!scrub_ret) {\n\t\tbtrfs_dev_replace_update_device_in_mapping_tree(fs_info,\n\t\t\t\t\t\t\t\tsrc_device,\n\t\t\t\t\t\t\t\ttgt_device);\n\t} else {\n\t\tprintk_in_rcu(KERN_ERR\n\t\t\t      \"BTRFS: btrfs_scrub_dev(%s, %llu, %s) failed %d\\n\",\n\t\t\t      src_device->missing ? \"<missing disk>\" :\n\t\t\t        rcu_str_deref(src_device->name),\n\t\t\t      src_device->devid,\n\t\t\t      rcu_str_deref(tgt_device->name), scrub_ret);\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\tmutex_unlock(&root->fs_info->chunk_mutex);\n\t\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\t\tmutex_unlock(&uuid_mutex);\n\t\tif (tgt_device)\n\t\t\tbtrfs_destroy_dev_replace_tgtdev(fs_info, tgt_device);\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\n\t\treturn scrub_ret;\n\t}\n\n\tprintk_in_rcu(KERN_INFO\n\t\t      \"BTRFS: dev_replace from %s (devid %llu) to %s finished\\n\",\n\t\t      src_device->missing ? \"<missing disk>\" :\n\t\t        rcu_str_deref(src_device->name),\n\t\t      src_device->devid,\n\t\t      rcu_str_deref(tgt_device->name));\n\ttgt_device->is_tgtdev_for_dev_replace = 0;\n\ttgt_device->devid = src_device->devid;\n\tsrc_device->devid = BTRFS_DEV_REPLACE_DEVID;\n\tmemcpy(uuid_tmp, tgt_device->uuid, sizeof(uuid_tmp));\n\tmemcpy(tgt_device->uuid, src_device->uuid, sizeof(tgt_device->uuid));\n\tmemcpy(src_device->uuid, uuid_tmp, sizeof(src_device->uuid));\n\tbtrfs_device_set_total_bytes(tgt_device, src_device->total_bytes);\n\tbtrfs_device_set_disk_total_bytes(tgt_device,\n\t\t\t\t\t  src_device->disk_total_bytes);\n\tbtrfs_device_set_bytes_used(tgt_device, src_device->bytes_used);\n\tASSERT(list_empty(&src_device->resized_list));\n\ttgt_device->commit_total_bytes = src_device->commit_total_bytes;\n\ttgt_device->commit_bytes_used = src_device->bytes_used;\n\tif (fs_info->sb->s_bdev == src_device->bdev)\n\t\tfs_info->sb->s_bdev = tgt_device->bdev;\n\tif (fs_info->fs_devices->latest_bdev == src_device->bdev)\n\t\tfs_info->fs_devices->latest_bdev = tgt_device->bdev;\n\tlist_add(&tgt_device->dev_alloc_list, &fs_info->fs_devices->alloc_list);\n\tfs_info->fs_devices->rw_devices++;\n\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tbtrfs_rm_dev_replace_blocked(fs_info);\n\n\tbtrfs_rm_dev_replace_remove_srcdev(fs_info, src_device);\n\n\tbtrfs_rm_dev_replace_unblocked(fs_info);\n\n\t/*\n\t * this is again a consistent state where no dev_replace procedure\n\t * is running, the target device is part of the filesystem, the\n\t * source device is not part of the filesystem anymore and its 1st\n\t * superblock is scratched out so that it is no longer marked to\n\t * belong to this filesystem.\n\t */\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\tmutex_unlock(&uuid_mutex);\n\n\t/* replace the sysfs entry */\n\tbtrfs_kobj_rm_device(fs_info, src_device);\n\tbtrfs_kobj_add_device(fs_info, tgt_device);\n\tbtrfs_rm_dev_replace_free_srcdev(fs_info, src_device);\n\n\t/* write back the superblocks */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (!IS_ERR(trans))\n\t\tbtrfs_commit_transaction(trans, root);\n\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_rm_dev_replace_unblocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "451-456",
    "snippet": "static void btrfs_rm_dev_replace_unblocked(struct btrfs_fs_info *fs_info)\n{\n\tclear_bit(BTRFS_FS_STATE_DEV_REPLACING, &fs_info->fs_state);\n\tif (waitqueue_active(&fs_info->replace_wait))\n\t\twake_up(&fs_info->replace_wait);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fs_info->replace_wait"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&fs_info->replace_wait"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "BTRFS_FS_STATE_DEV_REPLACING",
            "&fs_info->fs_state"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nstatic void btrfs_rm_dev_replace_unblocked(struct btrfs_fs_info *fs_info)\n{\n\tclear_bit(BTRFS_FS_STATE_DEV_REPLACING, &fs_info->fs_state);\n\tif (waitqueue_active(&fs_info->replace_wait))\n\t\twake_up(&fs_info->replace_wait);\n}"
  },
  {
    "function_name": "btrfs_rm_dev_replace_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "441-446",
    "snippet": "static void btrfs_rm_dev_replace_blocked(struct btrfs_fs_info *fs_info)\n{\n\tset_bit(BTRFS_FS_STATE_DEV_REPLACING, &fs_info->fs_state);\n\twait_event(fs_info->replace_wait, !percpu_counter_sum(\n\t\t   &fs_info->bio_counter));\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "fs_info->replace_wait",
            "!percpu_counter_sum(\n\t\t   &fs_info->bio_counter)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum",
          "args": [
            "&fs_info->bio_counter"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_FS_STATE_DEV_REPLACING",
            "&fs_info->fs_state"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nstatic void btrfs_rm_dev_replace_blocked(struct btrfs_fs_info *fs_info)\n{\n\tset_bit(BTRFS_FS_STATE_DEV_REPLACING, &fs_info->fs_state);\n\twait_event(fs_info->replace_wait, !percpu_counter_sum(\n\t\t   &fs_info->bio_counter));\n}"
  },
  {
    "function_name": "btrfs_dev_replace_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "309-436",
    "snippet": "int btrfs_dev_replace_start(struct btrfs_root *root,\n\t\t\t    struct btrfs_ioctl_dev_replace_args *args)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tint ret;\n\tstruct btrfs_device *tgt_device = NULL;\n\tstruct btrfs_device *src_device = NULL;\n\n\tswitch (args->start.cont_reading_from_srcdev_mode) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_ALWAYS:\n\tcase BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_AVOID:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((args->start.srcdevid == 0 && args->start.srcdev_name[0] == '\\0') ||\n\t    args->start.tgtdev_name[0] == '\\0')\n\t\treturn -EINVAL;\n\n\t/*\n\t * Here we commit the transaction to make sure commit_total_bytes\n\t * of all the devices are updated.\n\t */\n\ttrans = btrfs_attach_transaction(root);\n\tif (!IS_ERR(trans)) {\n\t\tret = btrfs_commit_transaction(trans, root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (PTR_ERR(trans) != -ENOENT) {\n\t\treturn PTR_ERR(trans);\n\t}\n\n\t/* the disk copy procedure reuses the scrub code */\n\tmutex_lock(&fs_info->volume_mutex);\n\tret = btrfs_dev_replace_find_srcdev(root, args->start.srcdevid,\n\t\t\t\t\t    args->start.srcdev_name,\n\t\t\t\t\t    &src_device);\n\tif (ret) {\n\t\tmutex_unlock(&fs_info->volume_mutex);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_init_dev_replace_tgtdev(root, args->start.tgtdev_name,\n\t\t\t\t\t    src_device, &tgt_device);\n\tmutex_unlock(&fs_info->volume_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_ALREADY_STARTED;\n\t\tgoto leave;\n\t}\n\n\tdev_replace->cont_reading_from_srcdev_mode =\n\t\targs->start.cont_reading_from_srcdev_mode;\n\tWARN_ON(!src_device);\n\tdev_replace->srcdev = src_device;\n\tWARN_ON(!tgt_device);\n\tdev_replace->tgtdev = tgt_device;\n\n\tprintk_in_rcu(KERN_INFO\n\t\t      \"BTRFS: dev_replace from %s (devid %llu) to %s started\\n\",\n\t\t      src_device->missing ? \"<missing disk>\" :\n\t\t        rcu_str_deref(src_device->name),\n\t\t      src_device->devid,\n\t\t      rcu_str_deref(tgt_device->name));\n\n\t/*\n\t * from now on, the writes to the srcdev are all duplicated to\n\t * go to the tgtdev as well (refer to btrfs_map_block()).\n\t */\n\tdev_replace->replace_state = BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED;\n\tdev_replace->time_started = get_seconds();\n\tdev_replace->cursor_left = 0;\n\tdev_replace->committed_cursor_left = 0;\n\tdev_replace->cursor_left_last_write_of_item = 0;\n\tdev_replace->cursor_right = 0;\n\tdev_replace->is_valid = 1;\n\tdev_replace->item_needs_writeback = 1;\n\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tbtrfs_wait_ordered_roots(root->fs_info, -1);\n\n\t/* force writing the updated state information to disk */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tbtrfs_dev_replace_lock(dev_replace);\n\t\tgoto leave;\n\t}\n\n\tret = btrfs_commit_transaction(trans, root);\n\tWARN_ON(ret);\n\n\t/* the disk copy procedure reuses the scrub code */\n\tret = btrfs_scrub_dev(fs_info, src_device->devid, 0,\n\t\t\t      btrfs_device_get_total_bytes(src_device),\n\t\t\t      &dev_replace->scrub_progress, 0, 1);\n\n\tret = btrfs_dev_replace_finishing(root->fs_info, ret);\n\t/* don't warn if EINPROGRESS, someone else might be running scrub */\n\tif (ret == -EINPROGRESS) {\n\t\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_SCRUB_INPROGRESS;\n\t\tret = 0;\n\t} else {\n\t\tWARN_ON(ret);\n\t}\n\n\treturn ret;\n\nleave:\n\tdev_replace->srcdev = NULL;\n\tdev_replace->tgtdev = NULL;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\tbtrfs_destroy_dev_replace_tgtdev(fs_info, tgt_device);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);",
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_destroy_dev_replace_tgtdev",
          "args": [
            "fs_info",
            "tgt_device"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_dev_replace_tgtdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1863-1889",
          "snippet": "void btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,\n\t\t\t\t      struct btrfs_device *tgtdev)\n{\n\tstruct btrfs_device *next_device;\n\n\tmutex_lock(&uuid_mutex);\n\tWARN_ON(!tgtdev);\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tif (tgtdev->bdev) {\n\t\tbtrfs_scratch_superblock(tgtdev);\n\t\tfs_info->fs_devices->open_devices--;\n\t}\n\tfs_info->fs_devices->num_devices--;\n\n\tnext_device = list_entry(fs_info->fs_devices->devices.next,\n\t\t\t\t struct btrfs_device, dev_list);\n\tif (tgtdev->bdev == fs_info->sb->s_bdev)\n\t\tfs_info->sb->s_bdev = next_device->bdev;\n\tif (tgtdev->bdev == fs_info->fs_devices->latest_bdev)\n\t\tfs_info->fs_devices->latest_bdev = next_device->bdev;\n\tlist_del_rcu(&tgtdev->dev_list);\n\n\tcall_rcu(&tgtdev->rcu, free_device);\n\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\tmutex_unlock(&uuid_mutex);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,\n\t\t\t\t      struct btrfs_device *tgtdev)\n{\n\tstruct btrfs_device *next_device;\n\n\tmutex_lock(&uuid_mutex);\n\tWARN_ON(!tgtdev);\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tif (tgtdev->bdev) {\n\t\tbtrfs_scratch_superblock(tgtdev);\n\t\tfs_info->fs_devices->open_devices--;\n\t}\n\tfs_info->fs_devices->num_devices--;\n\n\tnext_device = list_entry(fs_info->fs_devices->devices.next,\n\t\t\t\t struct btrfs_device, dev_list);\n\tif (tgtdev->bdev == fs_info->sb->s_bdev)\n\t\tfs_info->sb->s_bdev = next_device->bdev;\n\tif (tgtdev->bdev == fs_info->fs_devices->latest_bdev)\n\t\tfs_info->fs_devices->latest_bdev = next_device->bdev;\n\tlist_del_rcu(&tgtdev->dev_list);\n\n\tcall_rcu(&tgtdev->rcu, free_device);\n\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\tmutex_unlock(&uuid_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_unlock",
          "args": [
            "dev_replace"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "895-909",
          "snippet": "void btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_finishing",
          "args": [
            "root->fs_info",
            "ret"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_finishing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "458-598",
          "snippet": "static int btrfs_dev_replace_finishing(struct btrfs_fs_info *fs_info,\n\t\t\t\t       int scrub_ret)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_device *tgt_device;\n\tstruct btrfs_device *src_device;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tu8 uuid_tmp[BTRFS_UUID_SIZE];\n\tstruct btrfs_trans_handle *trans;\n\tint ret = 0;\n\n\t/* don't allow cancel or unmount to disturb the finishing procedure */\n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\t/* was the operation canceled, or is it finished? */\n\tif (dev_replace->replace_state !=\n\t    BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED) {\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn 0;\n\t}\n\n\ttgt_device = dev_replace->tgtdev;\n\tsrc_device = dev_replace->srcdev;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\t/*\n\t * flush all outstanding I/O and inode extent mappings before the\n\t * copy operation is declared as being finished\n\t */\n\tret = btrfs_start_delalloc_roots(root->fs_info, 0, -1);\n\tif (ret) {\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn ret;\n\t}\n\tbtrfs_wait_ordered_roots(root->fs_info, -1);\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn PTR_ERR(trans);\n\t}\n\tret = btrfs_commit_transaction(trans, root);\n\tWARN_ON(ret);\n\n\tmutex_lock(&uuid_mutex);\n\t/* keep away write_all_supers() during the finishing procedure */\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tmutex_lock(&root->fs_info->chunk_mutex);\n\tbtrfs_dev_replace_lock(dev_replace);\n\tdev_replace->replace_state =\n\t\tscrub_ret ? BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED\n\t\t\t  : BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED;\n\tdev_replace->tgtdev = NULL;\n\tdev_replace->srcdev = NULL;\n\tdev_replace->time_stopped = get_seconds();\n\tdev_replace->item_needs_writeback = 1;\n\n\t/* replace old device with new one in mapping tree */\n\tif (!scrub_ret) {\n\t\tbtrfs_dev_replace_update_device_in_mapping_tree(fs_info,\n\t\t\t\t\t\t\t\tsrc_device,\n\t\t\t\t\t\t\t\ttgt_device);\n\t} else {\n\t\tprintk_in_rcu(KERN_ERR\n\t\t\t      \"BTRFS: btrfs_scrub_dev(%s, %llu, %s) failed %d\\n\",\n\t\t\t      src_device->missing ? \"<missing disk>\" :\n\t\t\t        rcu_str_deref(src_device->name),\n\t\t\t      src_device->devid,\n\t\t\t      rcu_str_deref(tgt_device->name), scrub_ret);\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\tmutex_unlock(&root->fs_info->chunk_mutex);\n\t\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\t\tmutex_unlock(&uuid_mutex);\n\t\tif (tgt_device)\n\t\t\tbtrfs_destroy_dev_replace_tgtdev(fs_info, tgt_device);\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\n\t\treturn scrub_ret;\n\t}\n\n\tprintk_in_rcu(KERN_INFO\n\t\t      \"BTRFS: dev_replace from %s (devid %llu) to %s finished\\n\",\n\t\t      src_device->missing ? \"<missing disk>\" :\n\t\t        rcu_str_deref(src_device->name),\n\t\t      src_device->devid,\n\t\t      rcu_str_deref(tgt_device->name));\n\ttgt_device->is_tgtdev_for_dev_replace = 0;\n\ttgt_device->devid = src_device->devid;\n\tsrc_device->devid = BTRFS_DEV_REPLACE_DEVID;\n\tmemcpy(uuid_tmp, tgt_device->uuid, sizeof(uuid_tmp));\n\tmemcpy(tgt_device->uuid, src_device->uuid, sizeof(tgt_device->uuid));\n\tmemcpy(src_device->uuid, uuid_tmp, sizeof(src_device->uuid));\n\tbtrfs_device_set_total_bytes(tgt_device, src_device->total_bytes);\n\tbtrfs_device_set_disk_total_bytes(tgt_device,\n\t\t\t\t\t  src_device->disk_total_bytes);\n\tbtrfs_device_set_bytes_used(tgt_device, src_device->bytes_used);\n\tASSERT(list_empty(&src_device->resized_list));\n\ttgt_device->commit_total_bytes = src_device->commit_total_bytes;\n\ttgt_device->commit_bytes_used = src_device->bytes_used;\n\tif (fs_info->sb->s_bdev == src_device->bdev)\n\t\tfs_info->sb->s_bdev = tgt_device->bdev;\n\tif (fs_info->fs_devices->latest_bdev == src_device->bdev)\n\t\tfs_info->fs_devices->latest_bdev = tgt_device->bdev;\n\tlist_add(&tgt_device->dev_alloc_list, &fs_info->fs_devices->alloc_list);\n\tfs_info->fs_devices->rw_devices++;\n\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tbtrfs_rm_dev_replace_blocked(fs_info);\n\n\tbtrfs_rm_dev_replace_remove_srcdev(fs_info, src_device);\n\n\tbtrfs_rm_dev_replace_unblocked(fs_info);\n\n\t/*\n\t * this is again a consistent state where no dev_replace procedure\n\t * is running, the target device is part of the filesystem, the\n\t * source device is not part of the filesystem anymore and its 1st\n\t * superblock is scratched out so that it is no longer marked to\n\t * belong to this filesystem.\n\t */\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\tmutex_unlock(&uuid_mutex);\n\n\t/* replace the sysfs entry */\n\tbtrfs_kobj_rm_device(fs_info, src_device);\n\tbtrfs_kobj_add_device(fs_info, tgt_device);\n\tbtrfs_rm_dev_replace_free_srcdev(fs_info, src_device);\n\n\t/* write back the superblocks */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (!IS_ERR(trans))\n\t\tbtrfs_commit_transaction(trans, root);\n\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_dev_replace_finishing(struct btrfs_fs_info *fs_info,\n\t\t\t\t       int scrub_ret);",
            "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);",
            "static int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\n\t\t\t\t\t char *srcdev_name,\n\t\t\t\t\t struct btrfs_device **device);",
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_dev_replace_finishing(struct btrfs_fs_info *fs_info,\n\t\t\t\t       int scrub_ret);\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\nstatic int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\n\t\t\t\t\t char *srcdev_name,\n\t\t\t\t\t struct btrfs_device **device);\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nstatic int btrfs_dev_replace_finishing(struct btrfs_fs_info *fs_info,\n\t\t\t\t       int scrub_ret)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_device *tgt_device;\n\tstruct btrfs_device *src_device;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tu8 uuid_tmp[BTRFS_UUID_SIZE];\n\tstruct btrfs_trans_handle *trans;\n\tint ret = 0;\n\n\t/* don't allow cancel or unmount to disturb the finishing procedure */\n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\t/* was the operation canceled, or is it finished? */\n\tif (dev_replace->replace_state !=\n\t    BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED) {\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn 0;\n\t}\n\n\ttgt_device = dev_replace->tgtdev;\n\tsrc_device = dev_replace->srcdev;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\t/*\n\t * flush all outstanding I/O and inode extent mappings before the\n\t * copy operation is declared as being finished\n\t */\n\tret = btrfs_start_delalloc_roots(root->fs_info, 0, -1);\n\tif (ret) {\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn ret;\n\t}\n\tbtrfs_wait_ordered_roots(root->fs_info, -1);\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\t\treturn PTR_ERR(trans);\n\t}\n\tret = btrfs_commit_transaction(trans, root);\n\tWARN_ON(ret);\n\n\tmutex_lock(&uuid_mutex);\n\t/* keep away write_all_supers() during the finishing procedure */\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tmutex_lock(&root->fs_info->chunk_mutex);\n\tbtrfs_dev_replace_lock(dev_replace);\n\tdev_replace->replace_state =\n\t\tscrub_ret ? BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED\n\t\t\t  : BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED;\n\tdev_replace->tgtdev = NULL;\n\tdev_replace->srcdev = NULL;\n\tdev_replace->time_stopped = get_seconds();\n\tdev_replace->item_needs_writeback = 1;\n\n\t/* replace old device with new one in mapping tree */\n\tif (!scrub_ret) {\n\t\tbtrfs_dev_replace_update_device_in_mapping_tree(fs_info,\n\t\t\t\t\t\t\t\tsrc_device,\n\t\t\t\t\t\t\t\ttgt_device);\n\t} else {\n\t\tprintk_in_rcu(KERN_ERR\n\t\t\t      \"BTRFS: btrfs_scrub_dev(%s, %llu, %s) failed %d\\n\",\n\t\t\t      src_device->missing ? \"<missing disk>\" :\n\t\t\t        rcu_str_deref(src_device->name),\n\t\t\t      src_device->devid,\n\t\t\t      rcu_str_deref(tgt_device->name), scrub_ret);\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\tmutex_unlock(&root->fs_info->chunk_mutex);\n\t\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\t\tmutex_unlock(&uuid_mutex);\n\t\tif (tgt_device)\n\t\t\tbtrfs_destroy_dev_replace_tgtdev(fs_info, tgt_device);\n\t\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\n\t\treturn scrub_ret;\n\t}\n\n\tprintk_in_rcu(KERN_INFO\n\t\t      \"BTRFS: dev_replace from %s (devid %llu) to %s finished\\n\",\n\t\t      src_device->missing ? \"<missing disk>\" :\n\t\t        rcu_str_deref(src_device->name),\n\t\t      src_device->devid,\n\t\t      rcu_str_deref(tgt_device->name));\n\ttgt_device->is_tgtdev_for_dev_replace = 0;\n\ttgt_device->devid = src_device->devid;\n\tsrc_device->devid = BTRFS_DEV_REPLACE_DEVID;\n\tmemcpy(uuid_tmp, tgt_device->uuid, sizeof(uuid_tmp));\n\tmemcpy(tgt_device->uuid, src_device->uuid, sizeof(tgt_device->uuid));\n\tmemcpy(src_device->uuid, uuid_tmp, sizeof(src_device->uuid));\n\tbtrfs_device_set_total_bytes(tgt_device, src_device->total_bytes);\n\tbtrfs_device_set_disk_total_bytes(tgt_device,\n\t\t\t\t\t  src_device->disk_total_bytes);\n\tbtrfs_device_set_bytes_used(tgt_device, src_device->bytes_used);\n\tASSERT(list_empty(&src_device->resized_list));\n\ttgt_device->commit_total_bytes = src_device->commit_total_bytes;\n\ttgt_device->commit_bytes_used = src_device->bytes_used;\n\tif (fs_info->sb->s_bdev == src_device->bdev)\n\t\tfs_info->sb->s_bdev = tgt_device->bdev;\n\tif (fs_info->fs_devices->latest_bdev == src_device->bdev)\n\t\tfs_info->fs_devices->latest_bdev = tgt_device->bdev;\n\tlist_add(&tgt_device->dev_alloc_list, &fs_info->fs_devices->alloc_list);\n\tfs_info->fs_devices->rw_devices++;\n\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tbtrfs_rm_dev_replace_blocked(fs_info);\n\n\tbtrfs_rm_dev_replace_remove_srcdev(fs_info, src_device);\n\n\tbtrfs_rm_dev_replace_unblocked(fs_info);\n\n\t/*\n\t * this is again a consistent state where no dev_replace procedure\n\t * is running, the target device is part of the filesystem, the\n\t * source device is not part of the filesystem anymore and its 1st\n\t * superblock is scratched out so that it is no longer marked to\n\t * belong to this filesystem.\n\t */\n\tmutex_unlock(&root->fs_info->chunk_mutex);\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\tmutex_unlock(&uuid_mutex);\n\n\t/* replace the sysfs entry */\n\tbtrfs_kobj_rm_device(fs_info, src_device);\n\tbtrfs_kobj_add_device(fs_info, tgt_device);\n\tbtrfs_rm_dev_replace_free_srcdev(fs_info, src_device);\n\n\t/* write back the superblocks */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (!IS_ERR(trans))\n\t\tbtrfs_commit_transaction(trans, root);\n\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_scrub_dev",
          "args": [
            "fs_info",
            "src_device->devid",
            "0",
            "btrfs_device_get_total_bytes(src_device)",
            "&dev_replace->scrub_progress",
            "0",
            "1"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_scrub_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3611-3754",
          "snippet": "int btrfs_scrub_dev(struct btrfs_fs_info *fs_info, u64 devid, u64 start,\n\t\t    u64 end, struct btrfs_scrub_progress *progress,\n\t\t    int readonly, int is_dev_replace)\n{\n\tstruct scrub_ctx *sctx;\n\tint ret;\n\tstruct btrfs_device *dev;\n\tstruct rcu_string *name;\n\n\tif (btrfs_fs_closing(fs_info))\n\t\treturn -EINVAL;\n\n\tif (fs_info->chunk_root->nodesize > BTRFS_STRIPE_LEN) {\n\t\t/*\n\t\t * in this case scrub is unable to calculate the checksum\n\t\t * the way scrub is implemented. Do not handle this\n\t\t * situation at all because it won't ever happen.\n\t\t */\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"scrub: size assumption nodesize <= BTRFS_STRIPE_LEN (%d <= %d) fails\",\n\t\t       fs_info->chunk_root->nodesize, BTRFS_STRIPE_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fs_info->chunk_root->sectorsize != PAGE_SIZE) {\n\t\t/* not supported for data w/o checksums */\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"scrub: size assumption sectorsize != PAGE_SIZE \"\n\t\t\t   \"(%d != %lu) fails\",\n\t\t       fs_info->chunk_root->sectorsize, PAGE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fs_info->chunk_root->nodesize >\n\t    PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK ||\n\t    fs_info->chunk_root->sectorsize >\n\t    PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK) {\n\t\t/*\n\t\t * would exhaust the array bounds of pagev member in\n\t\t * struct scrub_block\n\t\t */\n\t\tbtrfs_err(fs_info, \"scrub: size assumption nodesize and sectorsize \"\n\t\t\t   \"<= SCRUB_MAX_PAGES_PER_BLOCK (%d <= %d && %d <= %d) fails\",\n\t\t       fs_info->chunk_root->nodesize,\n\t\t       SCRUB_MAX_PAGES_PER_BLOCK,\n\t\t       fs_info->chunk_root->sectorsize,\n\t\t       SCRUB_MAX_PAGES_PER_BLOCK);\n\t\treturn -EINVAL;\n\t}\n\n\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info, devid, NULL, NULL);\n\tif (!dev || (dev->missing && !is_dev_replace)) {\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!is_dev_replace && !readonly && !dev->writeable) {\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(dev->name);\n\t\tbtrfs_err(fs_info, \"scrub: device %s is not writable\",\n\t\t\t  name->str);\n\t\trcu_read_unlock();\n\t\treturn -EROFS;\n\t}\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!dev->in_fs_metadata || dev->is_tgtdev_for_dev_replace) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -EIO;\n\t}\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (dev->scrub_device ||\n\t    (!is_dev_replace &&\n\t     btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))) {\n\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -EINPROGRESS;\n\t}\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\tret = scrub_workers_get(fs_info, is_dev_replace);\n\tif (ret) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn ret;\n\t}\n\n\tsctx = scrub_setup_ctx(dev, is_dev_replace);\n\tif (IS_ERR(sctx)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\tscrub_workers_put(fs_info);\n\t\treturn PTR_ERR(sctx);\n\t}\n\tsctx->readonly = readonly;\n\tdev->scrub_device = sctx;\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\n\t/*\n\t * checking @scrub_pause_req here, we can avoid\n\t * race between committing transaction and scrubbing.\n\t */\n\t__scrub_blocked_if_needed(fs_info);\n\tatomic_inc(&fs_info->scrubs_running);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\tif (!is_dev_replace) {\n\t\t/*\n\t\t * by holding device list mutex, we can\n\t\t * kick off writing super in log tree sync.\n\t\t */\n\t\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\t\tret = scrub_supers(sctx, dev);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t}\n\n\tif (!ret)\n\t\tret = scrub_enumerate_chunks(sctx, dev, start, end,\n\t\t\t\t\t     is_dev_replace);\n\n\twait_event(sctx->list_wait, atomic_read(&sctx->bios_in_flight) == 0);\n\tatomic_dec(&fs_info->scrubs_running);\n\twake_up(&fs_info->scrub_pause_wait);\n\n\twait_event(sctx->list_wait, atomic_read(&sctx->workers_pending) == 0);\n\n\tif (progress)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tdev->scrub_device = NULL;\n\tscrub_workers_put(fs_info);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\tscrub_put_ctx(sctx);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [
            "#define SCRUB_MAX_PAGES_PER_BLOCK\t16\t/* 64k per node/leaf/sector */"
          ],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_MAX_PAGES_PER_BLOCK\t16\t/* 64k per node/leaf/sector */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_scrub_dev(struct btrfs_fs_info *fs_info, u64 devid, u64 start,\n\t\t    u64 end, struct btrfs_scrub_progress *progress,\n\t\t    int readonly, int is_dev_replace)\n{\n\tstruct scrub_ctx *sctx;\n\tint ret;\n\tstruct btrfs_device *dev;\n\tstruct rcu_string *name;\n\n\tif (btrfs_fs_closing(fs_info))\n\t\treturn -EINVAL;\n\n\tif (fs_info->chunk_root->nodesize > BTRFS_STRIPE_LEN) {\n\t\t/*\n\t\t * in this case scrub is unable to calculate the checksum\n\t\t * the way scrub is implemented. Do not handle this\n\t\t * situation at all because it won't ever happen.\n\t\t */\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"scrub: size assumption nodesize <= BTRFS_STRIPE_LEN (%d <= %d) fails\",\n\t\t       fs_info->chunk_root->nodesize, BTRFS_STRIPE_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fs_info->chunk_root->sectorsize != PAGE_SIZE) {\n\t\t/* not supported for data w/o checksums */\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"scrub: size assumption sectorsize != PAGE_SIZE \"\n\t\t\t   \"(%d != %lu) fails\",\n\t\t       fs_info->chunk_root->sectorsize, PAGE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fs_info->chunk_root->nodesize >\n\t    PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK ||\n\t    fs_info->chunk_root->sectorsize >\n\t    PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK) {\n\t\t/*\n\t\t * would exhaust the array bounds of pagev member in\n\t\t * struct scrub_block\n\t\t */\n\t\tbtrfs_err(fs_info, \"scrub: size assumption nodesize and sectorsize \"\n\t\t\t   \"<= SCRUB_MAX_PAGES_PER_BLOCK (%d <= %d && %d <= %d) fails\",\n\t\t       fs_info->chunk_root->nodesize,\n\t\t       SCRUB_MAX_PAGES_PER_BLOCK,\n\t\t       fs_info->chunk_root->sectorsize,\n\t\t       SCRUB_MAX_PAGES_PER_BLOCK);\n\t\treturn -EINVAL;\n\t}\n\n\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info, devid, NULL, NULL);\n\tif (!dev || (dev->missing && !is_dev_replace)) {\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!is_dev_replace && !readonly && !dev->writeable) {\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(dev->name);\n\t\tbtrfs_err(fs_info, \"scrub: device %s is not writable\",\n\t\t\t  name->str);\n\t\trcu_read_unlock();\n\t\treturn -EROFS;\n\t}\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!dev->in_fs_metadata || dev->is_tgtdev_for_dev_replace) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -EIO;\n\t}\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (dev->scrub_device ||\n\t    (!is_dev_replace &&\n\t     btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))) {\n\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -EINPROGRESS;\n\t}\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\tret = scrub_workers_get(fs_info, is_dev_replace);\n\tif (ret) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn ret;\n\t}\n\n\tsctx = scrub_setup_ctx(dev, is_dev_replace);\n\tif (IS_ERR(sctx)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\tscrub_workers_put(fs_info);\n\t\treturn PTR_ERR(sctx);\n\t}\n\tsctx->readonly = readonly;\n\tdev->scrub_device = sctx;\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\n\t/*\n\t * checking @scrub_pause_req here, we can avoid\n\t * race between committing transaction and scrubbing.\n\t */\n\t__scrub_blocked_if_needed(fs_info);\n\tatomic_inc(&fs_info->scrubs_running);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\tif (!is_dev_replace) {\n\t\t/*\n\t\t * by holding device list mutex, we can\n\t\t * kick off writing super in log tree sync.\n\t\t */\n\t\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\t\tret = scrub_supers(sctx, dev);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t}\n\n\tif (!ret)\n\t\tret = scrub_enumerate_chunks(sctx, dev, start, end,\n\t\t\t\t\t     is_dev_replace);\n\n\twait_event(sctx->list_wait, atomic_read(&sctx->bios_in_flight) == 0);\n\tatomic_dec(&fs_info->scrubs_running);\n\twake_up(&fs_info->scrub_pause_wait);\n\n\twait_event(sctx->list_wait, atomic_read(&sctx->workers_pending) == 0);\n\n\tif (progress)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tdev->scrub_device = NULL;\n\tscrub_workers_put(fs_info);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\tscrub_put_ctx(sctx);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_device_get_total_bytes",
          "args": [
            "src_device"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_lock",
          "args": [
            "dev_replace"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "867-893",
          "snippet": "void btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_wait_ordered_roots",
          "args": [
            "root->fs_info",
            "-1"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_ordered_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "656-688",
          "snippet": "void btrfs_wait_ordered_roots(struct btrfs_fs_info *fs_info, int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint done;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->ordered_operations_mutex);\n\tspin_lock(&fs_info->ordered_root_lock);\n\tlist_splice_init(&fs_info->ordered_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tordered_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->ordered_root,\n\t\t\t       &fs_info->ordered_roots);\n\t\tspin_unlock(&fs_info->ordered_root_lock);\n\n\t\tdone = btrfs_wait_ordered_extents(root, nr);\n\t\tbtrfs_put_fs_root(root);\n\n\t\tspin_lock(&fs_info->ordered_root_lock);\n\t\tif (nr != -1) {\n\t\t\tnr -= done;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t}\n\tlist_splice_tail(&splice, &fs_info->ordered_roots);\n\tspin_unlock(&fs_info->ordered_root_lock);\n\tmutex_unlock(&fs_info->ordered_operations_mutex);\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_wait_ordered_roots(struct btrfs_fs_info *fs_info, int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint done;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->ordered_operations_mutex);\n\tspin_lock(&fs_info->ordered_root_lock);\n\tlist_splice_init(&fs_info->ordered_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tordered_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->ordered_root,\n\t\t\t       &fs_info->ordered_roots);\n\t\tspin_unlock(&fs_info->ordered_root_lock);\n\n\t\tdone = btrfs_wait_ordered_extents(root, nr);\n\t\tbtrfs_put_fs_root(root);\n\n\t\tspin_lock(&fs_info->ordered_root_lock);\n\t\tif (nr != -1) {\n\t\t\tnr -= done;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t}\n\tlist_splice_tail(&splice, &fs_info->ordered_roots);\n\tspin_unlock(&fs_info->ordered_root_lock);\n\tmutex_unlock(&fs_info->ordered_operations_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_in_rcu",
          "args": [
            "KERN_INFO\n\t\t      \"BTRFS: dev_replace from %s (devid %llu) to %s started\\n\"",
            "src_device->missing ? \"<missing disk>\" :\n\t\t        rcu_str_deref(src_device->name)",
            "src_device->devid",
            "rcu_str_deref(tgt_device->name)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "tgt_device->name"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "src_device->name"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!tgt_device"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!src_device"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->volume_mutex"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_dev_replace_tgtdev",
          "args": [
            "root",
            "args->start.tgtdev_name",
            "src_device",
            "&tgt_device"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_dev_replace_tgtdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2296-2390",
          "snippet": "int btrfs_init_dev_replace_tgtdev(struct btrfs_root *root, char *device_path,\n\t\t\t\t  struct btrfs_device *srcdev,\n\t\t\t\t  struct btrfs_device **device_out)\n{\n\tstruct request_queue *q;\n\tstruct btrfs_device *device;\n\tstruct block_device *bdev;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct list_head *devices;\n\tstruct rcu_string *name;\n\tu64 devid = BTRFS_DEV_REPLACE_DEVID;\n\tint ret = 0;\n\n\t*device_out = NULL;\n\tif (fs_info->fs_devices->seeding) {\n\t\tbtrfs_err(fs_info, \"the filesystem is a seed filesystem!\");\n\t\treturn -EINVAL;\n\t}\n\n\tbdev = blkdev_get_by_path(device_path, FMODE_WRITE | FMODE_EXCL,\n\t\t\t\t  fs_info->bdev_holder);\n\tif (IS_ERR(bdev)) {\n\t\tbtrfs_err(fs_info, \"target device %s is invalid!\", device_path);\n\t\treturn PTR_ERR(bdev);\n\t}\n\n\tfilemap_write_and_wait(bdev->bd_inode->i_mapping);\n\n\tdevices = &fs_info->fs_devices->devices;\n\tlist_for_each_entry(device, devices, dev_list) {\n\t\tif (device->bdev == bdev) {\n\t\t\tbtrfs_err(fs_info, \"target device is in the filesystem!\");\n\t\t\tret = -EEXIST;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\n\tif (i_size_read(bdev->bd_inode) <\n\t    btrfs_device_get_total_bytes(srcdev)) {\n\t\tbtrfs_err(fs_info, \"target device is smaller than source device!\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\n\tdevice = btrfs_alloc_device(NULL, &devid, NULL);\n\tif (IS_ERR(device)) {\n\t\tret = PTR_ERR(device);\n\t\tgoto error;\n\t}\n\n\tname = rcu_string_strdup(device_path, GFP_NOFS);\n\tif (!name) {\n\t\tkfree(device);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\trcu_assign_pointer(device->name, name);\n\n\tq = bdev_get_queue(bdev);\n\tif (blk_queue_discard(q))\n\t\tdevice->can_discard = 1;\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tdevice->writeable = 1;\n\tdevice->generation = 0;\n\tdevice->io_width = root->sectorsize;\n\tdevice->io_align = root->sectorsize;\n\tdevice->sector_size = root->sectorsize;\n\tdevice->total_bytes = btrfs_device_get_total_bytes(srcdev);\n\tdevice->disk_total_bytes = btrfs_device_get_disk_total_bytes(srcdev);\n\tdevice->bytes_used = btrfs_device_get_bytes_used(srcdev);\n\tASSERT(list_empty(&srcdev->resized_list));\n\tdevice->commit_total_bytes = srcdev->commit_total_bytes;\n\tdevice->commit_bytes_used = device->bytes_used;\n\tdevice->dev_root = fs_info->dev_root;\n\tdevice->bdev = bdev;\n\tdevice->in_fs_metadata = 1;\n\tdevice->is_tgtdev_for_dev_replace = 1;\n\tdevice->mode = FMODE_EXCL;\n\tdevice->dev_stats_valid = 1;\n\tset_blocksize(device->bdev, 4096);\n\tdevice->fs_devices = fs_info->fs_devices;\n\tlist_add(&device->dev_list, &fs_info->fs_devices->devices);\n\tfs_info->fs_devices->num_devices++;\n\tfs_info->fs_devices->open_devices++;\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\t*device_out = device;\n\treturn ret;\n\nerror:\n\tblkdev_put(bdev, FMODE_EXCL);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_init_dev_replace_tgtdev(struct btrfs_root *root, char *device_path,\n\t\t\t\t  struct btrfs_device *srcdev,\n\t\t\t\t  struct btrfs_device **device_out)\n{\n\tstruct request_queue *q;\n\tstruct btrfs_device *device;\n\tstruct block_device *bdev;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct list_head *devices;\n\tstruct rcu_string *name;\n\tu64 devid = BTRFS_DEV_REPLACE_DEVID;\n\tint ret = 0;\n\n\t*device_out = NULL;\n\tif (fs_info->fs_devices->seeding) {\n\t\tbtrfs_err(fs_info, \"the filesystem is a seed filesystem!\");\n\t\treturn -EINVAL;\n\t}\n\n\tbdev = blkdev_get_by_path(device_path, FMODE_WRITE | FMODE_EXCL,\n\t\t\t\t  fs_info->bdev_holder);\n\tif (IS_ERR(bdev)) {\n\t\tbtrfs_err(fs_info, \"target device %s is invalid!\", device_path);\n\t\treturn PTR_ERR(bdev);\n\t}\n\n\tfilemap_write_and_wait(bdev->bd_inode->i_mapping);\n\n\tdevices = &fs_info->fs_devices->devices;\n\tlist_for_each_entry(device, devices, dev_list) {\n\t\tif (device->bdev == bdev) {\n\t\t\tbtrfs_err(fs_info, \"target device is in the filesystem!\");\n\t\t\tret = -EEXIST;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\n\tif (i_size_read(bdev->bd_inode) <\n\t    btrfs_device_get_total_bytes(srcdev)) {\n\t\tbtrfs_err(fs_info, \"target device is smaller than source device!\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\n\tdevice = btrfs_alloc_device(NULL, &devid, NULL);\n\tif (IS_ERR(device)) {\n\t\tret = PTR_ERR(device);\n\t\tgoto error;\n\t}\n\n\tname = rcu_string_strdup(device_path, GFP_NOFS);\n\tif (!name) {\n\t\tkfree(device);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\trcu_assign_pointer(device->name, name);\n\n\tq = bdev_get_queue(bdev);\n\tif (blk_queue_discard(q))\n\t\tdevice->can_discard = 1;\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tdevice->writeable = 1;\n\tdevice->generation = 0;\n\tdevice->io_width = root->sectorsize;\n\tdevice->io_align = root->sectorsize;\n\tdevice->sector_size = root->sectorsize;\n\tdevice->total_bytes = btrfs_device_get_total_bytes(srcdev);\n\tdevice->disk_total_bytes = btrfs_device_get_disk_total_bytes(srcdev);\n\tdevice->bytes_used = btrfs_device_get_bytes_used(srcdev);\n\tASSERT(list_empty(&srcdev->resized_list));\n\tdevice->commit_total_bytes = srcdev->commit_total_bytes;\n\tdevice->commit_bytes_used = device->bytes_used;\n\tdevice->dev_root = fs_info->dev_root;\n\tdevice->bdev = bdev;\n\tdevice->in_fs_metadata = 1;\n\tdevice->is_tgtdev_for_dev_replace = 1;\n\tdevice->mode = FMODE_EXCL;\n\tdevice->dev_stats_valid = 1;\n\tset_blocksize(device->bdev, 4096);\n\tdevice->fs_devices = fs_info->fs_devices;\n\tlist_add(&device->dev_list, &fs_info->fs_devices->devices);\n\tfs_info->fs_devices->num_devices++;\n\tfs_info->fs_devices->open_devices++;\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\t*device_out = device;\n\treturn ret;\n\nerror:\n\tblkdev_put(bdev, FMODE_EXCL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->volume_mutex"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_find_srcdev",
          "args": [
            "root",
            "args->start.srcdevid",
            "args->start.srcdev_name",
            "&src_device"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_find_srcdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "626-643",
          "snippet": "static int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\n\t\t\t\t\t char *srcdev_name,\n\t\t\t\t\t struct btrfs_device **device)\n{\n\tint ret;\n\n\tif (srcdevid) {\n\t\tret = 0;\n\t\t*device = btrfs_find_device(root->fs_info, srcdevid, NULL,\n\t\t\t\t\t    NULL);\n\t\tif (!*device)\n\t\t\tret = -ENOENT;\n\t} else {\n\t\tret = btrfs_find_device_missing_or_by_path(root, srcdev_name,\n\t\t\t\t\t\t\t   device);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\n\t\t\t\t\t char *srcdev_name,\n\t\t\t\t\t struct btrfs_device **device);",
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\n\t\t\t\t\t char *srcdev_name,\n\t\t\t\t\t struct btrfs_device **device);\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nstatic int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\n\t\t\t\t\t char *srcdev_name,\n\t\t\t\t\t struct btrfs_device **device)\n{\n\tint ret;\n\n\tif (srcdevid) {\n\t\tret = 0;\n\t\t*device = btrfs_find_device(root->fs_info, srcdevid, NULL,\n\t\t\t\t\t    NULL);\n\t\tif (!*device)\n\t\t\tret = -ENOENT;\n\t} else {\n\t\tret = btrfs_find_device_missing_or_by_path(root, srcdev_name,\n\t\t\t\t\t\t\t   device);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->volume_mutex"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_attach_transaction",
          "args": [
            "root"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_attach_transaction_barrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "616-626",
          "snippet": "struct btrfs_trans_handle *\nbtrfs_attach_transaction_barrier(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = start_transaction(root, 0, TRANS_ATTACH, 0);\n\tif (IS_ERR(trans) && PTR_ERR(trans) == -ENOENT)\n\t\tbtrfs_wait_for_commit(root, 0);\n\n\treturn trans;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *\nbtrfs_attach_transaction_barrier(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = start_transaction(root, 0, TRANS_ATTACH, 0);\n\tif (IS_ERR(trans) && PTR_ERR(trans) == -ENOENT)\n\t\tbtrfs_wait_for_commit(root, 0);\n\n\treturn trans;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nint btrfs_dev_replace_start(struct btrfs_root *root,\n\t\t\t    struct btrfs_ioctl_dev_replace_args *args)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tint ret;\n\tstruct btrfs_device *tgt_device = NULL;\n\tstruct btrfs_device *src_device = NULL;\n\n\tswitch (args->start.cont_reading_from_srcdev_mode) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_ALWAYS:\n\tcase BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_AVOID:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((args->start.srcdevid == 0 && args->start.srcdev_name[0] == '\\0') ||\n\t    args->start.tgtdev_name[0] == '\\0')\n\t\treturn -EINVAL;\n\n\t/*\n\t * Here we commit the transaction to make sure commit_total_bytes\n\t * of all the devices are updated.\n\t */\n\ttrans = btrfs_attach_transaction(root);\n\tif (!IS_ERR(trans)) {\n\t\tret = btrfs_commit_transaction(trans, root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (PTR_ERR(trans) != -ENOENT) {\n\t\treturn PTR_ERR(trans);\n\t}\n\n\t/* the disk copy procedure reuses the scrub code */\n\tmutex_lock(&fs_info->volume_mutex);\n\tret = btrfs_dev_replace_find_srcdev(root, args->start.srcdevid,\n\t\t\t\t\t    args->start.srcdev_name,\n\t\t\t\t\t    &src_device);\n\tif (ret) {\n\t\tmutex_unlock(&fs_info->volume_mutex);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_init_dev_replace_tgtdev(root, args->start.tgtdev_name,\n\t\t\t\t\t    src_device, &tgt_device);\n\tmutex_unlock(&fs_info->volume_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_ALREADY_STARTED;\n\t\tgoto leave;\n\t}\n\n\tdev_replace->cont_reading_from_srcdev_mode =\n\t\targs->start.cont_reading_from_srcdev_mode;\n\tWARN_ON(!src_device);\n\tdev_replace->srcdev = src_device;\n\tWARN_ON(!tgt_device);\n\tdev_replace->tgtdev = tgt_device;\n\n\tprintk_in_rcu(KERN_INFO\n\t\t      \"BTRFS: dev_replace from %s (devid %llu) to %s started\\n\",\n\t\t      src_device->missing ? \"<missing disk>\" :\n\t\t        rcu_str_deref(src_device->name),\n\t\t      src_device->devid,\n\t\t      rcu_str_deref(tgt_device->name));\n\n\t/*\n\t * from now on, the writes to the srcdev are all duplicated to\n\t * go to the tgtdev as well (refer to btrfs_map_block()).\n\t */\n\tdev_replace->replace_state = BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED;\n\tdev_replace->time_started = get_seconds();\n\tdev_replace->cursor_left = 0;\n\tdev_replace->committed_cursor_left = 0;\n\tdev_replace->cursor_left_last_write_of_item = 0;\n\tdev_replace->cursor_right = 0;\n\tdev_replace->is_valid = 1;\n\tdev_replace->item_needs_writeback = 1;\n\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tbtrfs_wait_ordered_roots(root->fs_info, -1);\n\n\t/* force writing the updated state information to disk */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tbtrfs_dev_replace_lock(dev_replace);\n\t\tgoto leave;\n\t}\n\n\tret = btrfs_commit_transaction(trans, root);\n\tWARN_ON(ret);\n\n\t/* the disk copy procedure reuses the scrub code */\n\tret = btrfs_scrub_dev(fs_info, src_device->devid, 0,\n\t\t\t      btrfs_device_get_total_bytes(src_device),\n\t\t\t      &dev_replace->scrub_progress, 0, 1);\n\n\tret = btrfs_dev_replace_finishing(root->fs_info, ret);\n\t/* don't warn if EINPROGRESS, someone else might be running scrub */\n\tif (ret == -EINPROGRESS) {\n\t\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_SCRUB_INPROGRESS;\n\t\tret = 0;\n\t} else {\n\t\tWARN_ON(ret);\n\t}\n\n\treturn ret;\n\nleave:\n\tdev_replace->srcdev = NULL;\n\tdev_replace->tgtdev = NULL;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\tbtrfs_destroy_dev_replace_tgtdev(fs_info, tgt_device);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_after_dev_replace_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "301-307",
    "snippet": "void btrfs_after_dev_replace_commit(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tdev_replace->committed_cursor_left =\n\t\tdev_replace->cursor_left_last_write_of_item;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_after_dev_replace_commit(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tdev_replace->committed_cursor_left =\n\t\tdev_replace->cursor_left_last_write_of_item;\n}"
  },
  {
    "function_name": "btrfs_run_dev_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "195-299",
    "snippet": "int btrfs_run_dev_replace(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_fs_info *fs_info)\n{\n\tint ret;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_dev_replace_item *ptr;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tif (!dev_replace->is_valid ||\n\t    !dev_replace->item_needs_writeback) {\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\treturn 0;\n\t}\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_DEV_REPLACE_KEY;\n\tkey.offset = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tret = btrfs_search_slot(trans, dev_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tbtrfs_warn(fs_info, \"error %d while searching for dev_replace item!\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tif (ret == 0 &&\n\t    btrfs_item_size_nr(path->nodes[0], path->slots[0]) < sizeof(*ptr)) {\n\t\t/*\n\t\t * need to delete old one and insert a new one.\n\t\t * Since no attempt is made to recover any old state, if the\n\t\t * dev_replace state is 'running', the data on the target\n\t\t * drive is lost.\n\t\t * It would be possible to recover the state: just make sure\n\t\t * that the beginning of the item is never changed and always\n\t\t * contains all the essential information. Then read this\n\t\t * minimal set of information and use it as a base for the\n\t\t * new state.\n\t\t */\n\t\tret = btrfs_del_item(trans, dev_root, path);\n\t\tif (ret != 0) {\n\t\t\tbtrfs_warn(fs_info, \"delete too small dev_replace item failed %d!\",\n\t\t\t\tret);\n\t\t\tgoto out;\n\t\t}\n\t\tret = 1;\n\t}\n\n\tif (ret == 1) {\n\t\t/* need to insert a new item */\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, dev_root, path,\n\t\t\t\t\t      &key, sizeof(*ptr));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_warn(fs_info, \"insert dev_replace item failed %d!\",\n\t\t\t\tret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\teb = path->nodes[0];\n\tptr = btrfs_item_ptr(eb, path->slots[0],\n\t\t\t     struct btrfs_dev_replace_item);\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tif (dev_replace->srcdev)\n\t\tbtrfs_set_dev_replace_src_devid(eb, ptr,\n\t\t\tdev_replace->srcdev->devid);\n\telse\n\t\tbtrfs_set_dev_replace_src_devid(eb, ptr, (u64)-1);\n\tbtrfs_set_dev_replace_cont_reading_from_srcdev_mode(eb, ptr,\n\t\tdev_replace->cont_reading_from_srcdev_mode);\n\tbtrfs_set_dev_replace_replace_state(eb, ptr,\n\t\tdev_replace->replace_state);\n\tbtrfs_set_dev_replace_time_started(eb, ptr, dev_replace->time_started);\n\tbtrfs_set_dev_replace_time_stopped(eb, ptr, dev_replace->time_stopped);\n\tbtrfs_set_dev_replace_num_write_errors(eb, ptr,\n\t\tatomic64_read(&dev_replace->num_write_errors));\n\tbtrfs_set_dev_replace_num_uncorrectable_read_errors(eb, ptr,\n\t\tatomic64_read(&dev_replace->num_uncorrectable_read_errors));\n\tdev_replace->cursor_left_last_write_of_item =\n\t\tdev_replace->cursor_left;\n\tbtrfs_set_dev_replace_cursor_left(eb, ptr,\n\t\tdev_replace->cursor_left_last_write_of_item);\n\tbtrfs_set_dev_replace_cursor_right(eb, ptr,\n\t\tdev_replace->cursor_right);\n\tdev_replace->item_needs_writeback = 0;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tbtrfs_mark_buffer_dirty(eb);\n\nout:\n\tbtrfs_free_path(path);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_kthread(void *data);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "eb"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_unlock",
          "args": [
            "dev_replace"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "895-909",
          "snippet": "void btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_dev_replace_cursor_right",
          "args": [
            "eb",
            "ptr",
            "dev_replace->cursor_right"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_dev_replace_cursor_left",
          "args": [
            "eb",
            "ptr",
            "dev_replace->cursor_left_last_write_of_item"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_dev_replace_num_uncorrectable_read_errors",
          "args": [
            "eb",
            "ptr",
            "atomic64_read(&dev_replace->num_uncorrectable_read_errors)"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&dev_replace->num_uncorrectable_read_errors"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_dev_replace_num_write_errors",
          "args": [
            "eb",
            "ptr",
            "atomic64_read(&dev_replace->num_write_errors)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&dev_replace->num_write_errors"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_dev_replace_time_stopped",
          "args": [
            "eb",
            "ptr",
            "dev_replace->time_stopped"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_dev_replace_time_started",
          "args": [
            "eb",
            "ptr",
            "dev_replace->time_started"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_dev_replace_replace_state",
          "args": [
            "eb",
            "ptr",
            "dev_replace->replace_state"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_dev_replace_cont_reading_from_srcdev_mode",
          "args": [
            "eb",
            "ptr",
            "dev_replace->cont_reading_from_srcdev_mode"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_dev_replace_src_devid",
          "args": [
            "eb",
            "ptr",
            "(u64)-1"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_dev_replace_src_devid",
          "args": [
            "eb",
            "ptr",
            "dev_replace->srcdev->devid"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_lock",
          "args": [
            "dev_replace"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "867-893",
          "snippet": "void btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "path->slots[0]",
            "structbtrfs_dev_replace_item"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"insert dev_replace item failed %d!\"",
            "ret"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "dev_root",
            "path",
            "&key",
            "sizeof(*ptr)"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"delete too small dev_replace item failed %d!\"",
            "ret"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_del_item",
          "args": [
            "trans",
            "dev_root",
            "path"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3562-3567",
          "snippet": "static inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"error %d while searching for dev_replace item!\"",
            "ret"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "dev_root",
            "&key",
            "path",
            "-1",
            "1"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_kthread(void *data);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nint btrfs_run_dev_replace(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_fs_info *fs_info)\n{\n\tint ret;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_dev_replace_item *ptr;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tif (!dev_replace->is_valid ||\n\t    !dev_replace->item_needs_writeback) {\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\treturn 0;\n\t}\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_DEV_REPLACE_KEY;\n\tkey.offset = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tret = btrfs_search_slot(trans, dev_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tbtrfs_warn(fs_info, \"error %d while searching for dev_replace item!\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tif (ret == 0 &&\n\t    btrfs_item_size_nr(path->nodes[0], path->slots[0]) < sizeof(*ptr)) {\n\t\t/*\n\t\t * need to delete old one and insert a new one.\n\t\t * Since no attempt is made to recover any old state, if the\n\t\t * dev_replace state is 'running', the data on the target\n\t\t * drive is lost.\n\t\t * It would be possible to recover the state: just make sure\n\t\t * that the beginning of the item is never changed and always\n\t\t * contains all the essential information. Then read this\n\t\t * minimal set of information and use it as a base for the\n\t\t * new state.\n\t\t */\n\t\tret = btrfs_del_item(trans, dev_root, path);\n\t\tif (ret != 0) {\n\t\t\tbtrfs_warn(fs_info, \"delete too small dev_replace item failed %d!\",\n\t\t\t\tret);\n\t\t\tgoto out;\n\t\t}\n\t\tret = 1;\n\t}\n\n\tif (ret == 1) {\n\t\t/* need to insert a new item */\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, dev_root, path,\n\t\t\t\t\t      &key, sizeof(*ptr));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_warn(fs_info, \"insert dev_replace item failed %d!\",\n\t\t\t\tret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\teb = path->nodes[0];\n\tptr = btrfs_item_ptr(eb, path->slots[0],\n\t\t\t     struct btrfs_dev_replace_item);\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tif (dev_replace->srcdev)\n\t\tbtrfs_set_dev_replace_src_devid(eb, ptr,\n\t\t\tdev_replace->srcdev->devid);\n\telse\n\t\tbtrfs_set_dev_replace_src_devid(eb, ptr, (u64)-1);\n\tbtrfs_set_dev_replace_cont_reading_from_srcdev_mode(eb, ptr,\n\t\tdev_replace->cont_reading_from_srcdev_mode);\n\tbtrfs_set_dev_replace_replace_state(eb, ptr,\n\t\tdev_replace->replace_state);\n\tbtrfs_set_dev_replace_time_started(eb, ptr, dev_replace->time_started);\n\tbtrfs_set_dev_replace_time_stopped(eb, ptr, dev_replace->time_stopped);\n\tbtrfs_set_dev_replace_num_write_errors(eb, ptr,\n\t\tatomic64_read(&dev_replace->num_write_errors));\n\tbtrfs_set_dev_replace_num_uncorrectable_read_errors(eb, ptr,\n\t\tatomic64_read(&dev_replace->num_uncorrectable_read_errors));\n\tdev_replace->cursor_left_last_write_of_item =\n\t\tdev_replace->cursor_left;\n\tbtrfs_set_dev_replace_cursor_left(eb, ptr,\n\t\tdev_replace->cursor_left_last_write_of_item);\n\tbtrfs_set_dev_replace_cursor_right(eb, ptr,\n\t\tdev_replace->cursor_right);\n\tdev_replace->item_needs_writeback = 0;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tbtrfs_mark_buffer_dirty(eb);\n\nout:\n\tbtrfs_free_path(path);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_init_dev_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
    "lines": "55-189",
    "snippet": "int btrfs_init_dev_replace(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tint ret = 0;\n\tstruct btrfs_path *path = NULL;\n\tint item_size;\n\tstruct btrfs_dev_replace_item *ptr;\n\tu64 src_devid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_DEV_REPLACE_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, dev_root, &key, path, 0, 0);\n\tif (ret) {\nno_valid_dev_replace_entry_found:\n\t\tret = 0;\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_DEV_REPLACE_ITEM_STATE_NEVER_STARTED;\n\t\tdev_replace->cont_reading_from_srcdev_mode =\n\t\t    BTRFS_DEV_REPLACE_ITEM_CONT_READING_FROM_SRCDEV_MODE_ALWAYS;\n\t\tdev_replace->replace_state = 0;\n\t\tdev_replace->time_started = 0;\n\t\tdev_replace->time_stopped = 0;\n\t\tatomic64_set(&dev_replace->num_write_errors, 0);\n\t\tatomic64_set(&dev_replace->num_uncorrectable_read_errors, 0);\n\t\tdev_replace->cursor_left = 0;\n\t\tdev_replace->committed_cursor_left = 0;\n\t\tdev_replace->cursor_left_last_write_of_item = 0;\n\t\tdev_replace->cursor_right = 0;\n\t\tdev_replace->srcdev = NULL;\n\t\tdev_replace->tgtdev = NULL;\n\t\tdev_replace->is_valid = 0;\n\t\tdev_replace->item_needs_writeback = 0;\n\t\tgoto out;\n\t}\n\tslot = path->slots[0];\n\teb = path->nodes[0];\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tptr = btrfs_item_ptr(eb, slot, struct btrfs_dev_replace_item);\n\n\tif (item_size != sizeof(struct btrfs_dev_replace_item)) {\n\t\tbtrfs_warn(fs_info,\n\t\t\t\"dev_replace entry found has unexpected size, ignore entry\");\n\t\tgoto no_valid_dev_replace_entry_found;\n\t}\n\n\tsrc_devid = btrfs_dev_replace_src_devid(eb, ptr);\n\tdev_replace->cont_reading_from_srcdev_mode =\n\t\tbtrfs_dev_replace_cont_reading_from_srcdev_mode(eb, ptr);\n\tdev_replace->replace_state = btrfs_dev_replace_replace_state(eb, ptr);\n\tdev_replace->time_started = btrfs_dev_replace_time_started(eb, ptr);\n\tdev_replace->time_stopped =\n\t\tbtrfs_dev_replace_time_stopped(eb, ptr);\n\tatomic64_set(&dev_replace->num_write_errors,\n\t\t     btrfs_dev_replace_num_write_errors(eb, ptr));\n\tatomic64_set(&dev_replace->num_uncorrectable_read_errors,\n\t\t     btrfs_dev_replace_num_uncorrectable_read_errors(eb, ptr));\n\tdev_replace->cursor_left = btrfs_dev_replace_cursor_left(eb, ptr);\n\tdev_replace->committed_cursor_left = dev_replace->cursor_left;\n\tdev_replace->cursor_left_last_write_of_item = dev_replace->cursor_left;\n\tdev_replace->cursor_right = btrfs_dev_replace_cursor_right(eb, ptr);\n\tdev_replace->is_valid = 1;\n\n\tdev_replace->item_needs_writeback = 0;\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tdev_replace->srcdev = NULL;\n\t\tdev_replace->tgtdev = NULL;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tdev_replace->srcdev = btrfs_find_device(fs_info, src_devid,\n\t\t\t\t\t\t\tNULL, NULL);\n\t\tdev_replace->tgtdev = btrfs_find_device(fs_info,\n\t\t\t\t\t\t\tBTRFS_DEV_REPLACE_DEVID,\n\t\t\t\t\t\t\tNULL, NULL);\n\t\t/*\n\t\t * allow 'btrfs dev replace_cancel' if src/tgt device is\n\t\t * missing\n\t\t */\n\t\tif (!dev_replace->srcdev &&\n\t\t    !btrfs_test_opt(dev_root, DEGRADED)) {\n\t\t\tret = -EIO;\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"cannot mount because device replace operation is ongoing and\");\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"srcdev (devid %llu) is missing, need to run 'btrfs dev scan'?\",\n\t\t\t   src_devid);\n\t\t}\n\t\tif (!dev_replace->tgtdev &&\n\t\t    !btrfs_test_opt(dev_root, DEGRADED)) {\n\t\t\tret = -EIO;\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"cannot mount because device replace operation is ongoing and\");\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"tgtdev (devid %llu) is missing, need to run 'btrfs dev scan'?\",\n\t\t\t\tBTRFS_DEV_REPLACE_DEVID);\n\t\t}\n\t\tif (dev_replace->tgtdev) {\n\t\t\tif (dev_replace->srcdev) {\n\t\t\t\tdev_replace->tgtdev->total_bytes =\n\t\t\t\t\tdev_replace->srcdev->total_bytes;\n\t\t\t\tdev_replace->tgtdev->disk_total_bytes =\n\t\t\t\t\tdev_replace->srcdev->disk_total_bytes;\n\t\t\t\tdev_replace->tgtdev->commit_total_bytes =\n\t\t\t\t\tdev_replace->srcdev->commit_total_bytes;\n\t\t\t\tdev_replace->tgtdev->bytes_used =\n\t\t\t\t\tdev_replace->srcdev->bytes_used;\n\t\t\t\tdev_replace->tgtdev->commit_bytes_used =\n\t\t\t\t\tdev_replace->srcdev->commit_bytes_used;\n\t\t\t}\n\t\t\tdev_replace->tgtdev->is_tgtdev_for_dev_replace = 1;\n\t\t\tbtrfs_init_dev_replace_tgtdev_for_resume(fs_info,\n\t\t\t\tdev_replace->tgtdev);\n\t\t}\n\t\tbreak;\n\t}\n\nout:\n\tif (path)\n\t\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"async-thread.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <asm/div64.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/capability.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/random.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);",
      "static int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\n\t\t\t\t\t char *srcdev_name,\n\t\t\t\t\t struct btrfs_device **device);",
      "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
      "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_dev_replace_tgtdev_for_resume",
          "args": [
            "fs_info",
            "dev_replace->tgtdev"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_dev_replace_tgtdev_for_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2392-2401",
          "snippet": "void btrfs_init_dev_replace_tgtdev_for_resume(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t      struct btrfs_device *tgtdev)\n{\n\tWARN_ON(fs_info->fs_devices->rw_devices == 0);\n\ttgtdev->io_width = fs_info->dev_root->sectorsize;\n\ttgtdev->io_align = fs_info->dev_root->sectorsize;\n\ttgtdev->sector_size = fs_info->dev_root->sectorsize;\n\ttgtdev->dev_root = fs_info->dev_root;\n\ttgtdev->in_fs_metadata = 1;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_init_dev_replace_tgtdev_for_resume(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t      struct btrfs_device *tgtdev)\n{\n\tWARN_ON(fs_info->fs_devices->rw_devices == 0);\n\ttgtdev->io_width = fs_info->dev_root->sectorsize;\n\ttgtdev->io_align = fs_info->dev_root->sectorsize;\n\ttgtdev->sector_size = fs_info->dev_root->sectorsize;\n\ttgtdev->dev_root = fs_info->dev_root;\n\ttgtdev->in_fs_metadata = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"tgtdev (devid %llu) is missing, need to run 'btrfs dev scan'?\"",
            "BTRFS_DEV_REPLACE_DEVID"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"cannot mount because device replace operation is ongoing and\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "dev_root",
            "DEGRADED"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"srcdev (devid %llu) is missing, need to run 'btrfs dev scan'?\"",
            "src_devid"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"cannot mount because device replace operation is ongoing and\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "dev_root",
            "DEGRADED"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_device",
          "args": [
            "fs_info",
            "BTRFS_DEV_REPLACE_DEVID",
            "NULL",
            "NULL"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5918-5936",
          "snippet": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_cursor_right",
          "args": [
            "eb",
            "ptr"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_cursor_left",
          "args": [
            "eb",
            "ptr"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&dev_replace->num_uncorrectable_read_errors",
            "btrfs_dev_replace_num_uncorrectable_read_errors(eb, ptr)"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_num_uncorrectable_read_errors",
          "args": [
            "eb",
            "ptr"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&dev_replace->num_write_errors",
            "btrfs_dev_replace_num_write_errors(eb, ptr)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_num_write_errors",
          "args": [
            "eb",
            "ptr"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_time_stopped",
          "args": [
            "eb",
            "ptr"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_time_started",
          "args": [
            "eb",
            "ptr"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_replace_state",
          "args": [
            "eb",
            "ptr"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_cont_reading_from_srcdev_mode",
          "args": [
            "eb",
            "ptr"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_src_devid",
          "args": [
            "eb",
            "ptr"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"dev_replace entry found has unexpected size, ignore entry\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "slot",
            "structbtrfs_dev_replace_item"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "eb",
            "slot"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&dev_replace->num_uncorrectable_read_errors",
            "0"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&dev_replace->num_write_errors",
            "0"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "dev_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\nstatic int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\n\t\t\t\t\t char *srcdev_name,\n\t\t\t\t\t struct btrfs_device **device);\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nint btrfs_init_dev_replace(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tint ret = 0;\n\tstruct btrfs_path *path = NULL;\n\tint item_size;\n\tstruct btrfs_dev_replace_item *ptr;\n\tu64 src_devid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_DEV_REPLACE_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, dev_root, &key, path, 0, 0);\n\tif (ret) {\nno_valid_dev_replace_entry_found:\n\t\tret = 0;\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_DEV_REPLACE_ITEM_STATE_NEVER_STARTED;\n\t\tdev_replace->cont_reading_from_srcdev_mode =\n\t\t    BTRFS_DEV_REPLACE_ITEM_CONT_READING_FROM_SRCDEV_MODE_ALWAYS;\n\t\tdev_replace->replace_state = 0;\n\t\tdev_replace->time_started = 0;\n\t\tdev_replace->time_stopped = 0;\n\t\tatomic64_set(&dev_replace->num_write_errors, 0);\n\t\tatomic64_set(&dev_replace->num_uncorrectable_read_errors, 0);\n\t\tdev_replace->cursor_left = 0;\n\t\tdev_replace->committed_cursor_left = 0;\n\t\tdev_replace->cursor_left_last_write_of_item = 0;\n\t\tdev_replace->cursor_right = 0;\n\t\tdev_replace->srcdev = NULL;\n\t\tdev_replace->tgtdev = NULL;\n\t\tdev_replace->is_valid = 0;\n\t\tdev_replace->item_needs_writeback = 0;\n\t\tgoto out;\n\t}\n\tslot = path->slots[0];\n\teb = path->nodes[0];\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tptr = btrfs_item_ptr(eb, slot, struct btrfs_dev_replace_item);\n\n\tif (item_size != sizeof(struct btrfs_dev_replace_item)) {\n\t\tbtrfs_warn(fs_info,\n\t\t\t\"dev_replace entry found has unexpected size, ignore entry\");\n\t\tgoto no_valid_dev_replace_entry_found;\n\t}\n\n\tsrc_devid = btrfs_dev_replace_src_devid(eb, ptr);\n\tdev_replace->cont_reading_from_srcdev_mode =\n\t\tbtrfs_dev_replace_cont_reading_from_srcdev_mode(eb, ptr);\n\tdev_replace->replace_state = btrfs_dev_replace_replace_state(eb, ptr);\n\tdev_replace->time_started = btrfs_dev_replace_time_started(eb, ptr);\n\tdev_replace->time_stopped =\n\t\tbtrfs_dev_replace_time_stopped(eb, ptr);\n\tatomic64_set(&dev_replace->num_write_errors,\n\t\t     btrfs_dev_replace_num_write_errors(eb, ptr));\n\tatomic64_set(&dev_replace->num_uncorrectable_read_errors,\n\t\t     btrfs_dev_replace_num_uncorrectable_read_errors(eb, ptr));\n\tdev_replace->cursor_left = btrfs_dev_replace_cursor_left(eb, ptr);\n\tdev_replace->committed_cursor_left = dev_replace->cursor_left;\n\tdev_replace->cursor_left_last_write_of_item = dev_replace->cursor_left;\n\tdev_replace->cursor_right = btrfs_dev_replace_cursor_right(eb, ptr);\n\tdev_replace->is_valid = 1;\n\n\tdev_replace->item_needs_writeback = 0;\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tdev_replace->srcdev = NULL;\n\t\tdev_replace->tgtdev = NULL;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tdev_replace->srcdev = btrfs_find_device(fs_info, src_devid,\n\t\t\t\t\t\t\tNULL, NULL);\n\t\tdev_replace->tgtdev = btrfs_find_device(fs_info,\n\t\t\t\t\t\t\tBTRFS_DEV_REPLACE_DEVID,\n\t\t\t\t\t\t\tNULL, NULL);\n\t\t/*\n\t\t * allow 'btrfs dev replace_cancel' if src/tgt device is\n\t\t * missing\n\t\t */\n\t\tif (!dev_replace->srcdev &&\n\t\t    !btrfs_test_opt(dev_root, DEGRADED)) {\n\t\t\tret = -EIO;\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"cannot mount because device replace operation is ongoing and\");\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"srcdev (devid %llu) is missing, need to run 'btrfs dev scan'?\",\n\t\t\t   src_devid);\n\t\t}\n\t\tif (!dev_replace->tgtdev &&\n\t\t    !btrfs_test_opt(dev_root, DEGRADED)) {\n\t\t\tret = -EIO;\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"cannot mount because device replace operation is ongoing and\");\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t   \"tgtdev (devid %llu) is missing, need to run 'btrfs dev scan'?\",\n\t\t\t\tBTRFS_DEV_REPLACE_DEVID);\n\t\t}\n\t\tif (dev_replace->tgtdev) {\n\t\t\tif (dev_replace->srcdev) {\n\t\t\t\tdev_replace->tgtdev->total_bytes =\n\t\t\t\t\tdev_replace->srcdev->total_bytes;\n\t\t\t\tdev_replace->tgtdev->disk_total_bytes =\n\t\t\t\t\tdev_replace->srcdev->disk_total_bytes;\n\t\t\t\tdev_replace->tgtdev->commit_total_bytes =\n\t\t\t\t\tdev_replace->srcdev->commit_total_bytes;\n\t\t\t\tdev_replace->tgtdev->bytes_used =\n\t\t\t\t\tdev_replace->srcdev->bytes_used;\n\t\t\t\tdev_replace->tgtdev->commit_bytes_used =\n\t\t\t\t\tdev_replace->srcdev->commit_bytes_used;\n\t\t\t}\n\t\t\tdev_replace->tgtdev->is_tgtdev_for_dev_replace = 1;\n\t\t\tbtrfs_init_dev_replace_tgtdev_for_resume(fs_info,\n\t\t\t\tdev_replace->tgtdev);\n\t\t}\n\t\tbreak;\n\t}\n\nout:\n\tif (path)\n\t\tbtrfs_free_path(path);\n\treturn ret;\n}"
  }
]