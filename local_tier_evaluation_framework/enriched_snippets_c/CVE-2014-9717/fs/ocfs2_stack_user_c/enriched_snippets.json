[
  {
    "function_name": "ocfs2_user_plugin_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "1126-1130",
    "snippet": "static void __exit ocfs2_user_plugin_exit(void)\n{\n\tocfs2_stack_glue_unregister(&ocfs2_user_plugin);\n\tocfs2_control_exit();\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_stack_plugin ocfs2_user_plugin;",
      "static struct ocfs2_stack_plugin ocfs2_user_plugin = {\n\t.sp_name\t= \"user\",\n\t.sp_ops\t\t= &ocfs2_user_plugin_ops,\n\t.sp_owner\t= THIS_MODULE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_control_exit",
          "args": [],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "656-666",
          "snippet": "static void ocfs2_control_exit(void)\n{\n\tint rc;\n\n\trc = misc_deregister(&ocfs2_control_device);\n\tif (rc)\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Unable to deregister ocfs2_control device \"\n\t\t       \"(errno %d)\\n\",\n\t\t       -rc);\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct miscdevice ocfs2_control_device = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"ocfs2_control\",\n\t.fops\t\t= &ocfs2_control_fops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct miscdevice ocfs2_control_device = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"ocfs2_control\",\n\t.fops\t\t= &ocfs2_control_fops,\n};\n\nstatic void ocfs2_control_exit(void)\n{\n\tint rc;\n\n\trc = misc_deregister(&ocfs2_control_device);\n\tif (rc)\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Unable to deregister ocfs2_control device \"\n\t\t       \"(errno %d)\\n\",\n\t\t       -rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_stack_glue_unregister",
          "args": [
            "&ocfs2_user_plugin"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_stack_glue_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "195-213",
          "snippet": "void ocfs2_stack_glue_unregister(struct ocfs2_stack_plugin *plugin)\n{\n\tstruct ocfs2_stack_plugin *p;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tp = ocfs2_stack_lookup(plugin->sp_name);\n\tif (p) {\n\t\tBUG_ON(p != plugin);\n\t\tBUG_ON(plugin == active_stack);\n\t\tBUG_ON(plugin->sp_count != 0);\n\t\tlist_del_init(&plugin->sp_list);\n\t\tprintk(KERN_INFO \"ocfs2: Unregistered cluster interface %s\\n\",\n\t\t       plugin->sp_name);\n\t} else {\n\t\tprintk(KERN_ERR \"Stack \\\"%s\\\" is not registered\\n\",\n\t\t       plugin->sp_name);\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(ocfs2_stack_lock);",
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic DEFINE_SPINLOCK(ocfs2_stack_lock);\nstatic struct ocfs2_stack_plugin *active_stack;\n\nvoid ocfs2_stack_glue_unregister(struct ocfs2_stack_plugin *plugin)\n{\n\tstruct ocfs2_stack_plugin *p;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tp = ocfs2_stack_lookup(plugin->sp_name);\n\tif (p) {\n\t\tBUG_ON(p != plugin);\n\t\tBUG_ON(plugin == active_stack);\n\t\tBUG_ON(plugin->sp_count != 0);\n\t\tlist_del_init(&plugin->sp_list);\n\t\tprintk(KERN_INFO \"ocfs2: Unregistered cluster interface %s\\n\",\n\t\t       plugin->sp_name);\n\t} else {\n\t\tprintk(KERN_ERR \"Stack \\\"%s\\\" is not registered\\n\",\n\t\t       plugin->sp_name);\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct ocfs2_stack_plugin ocfs2_user_plugin;\nstatic struct ocfs2_stack_plugin ocfs2_user_plugin = {\n\t.sp_name\t= \"user\",\n\t.sp_ops\t\t= &ocfs2_user_plugin_ops,\n\t.sp_owner\t= THIS_MODULE,\n};\n\nstatic void __exit ocfs2_user_plugin_exit(void)\n{\n\tocfs2_stack_glue_unregister(&ocfs2_user_plugin);\n\tocfs2_control_exit();\n}"
  },
  {
    "function_name": "ocfs2_user_plugin_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "1112-1124",
    "snippet": "static int __init ocfs2_user_plugin_init(void)\n{\n\tint rc;\n\n\trc = ocfs2_control_init();\n\tif (!rc) {\n\t\trc = ocfs2_stack_glue_register(&ocfs2_user_plugin);\n\t\tif (rc)\n\t\t\tocfs2_control_exit();\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_stack_plugin ocfs2_user_plugin;",
      "static struct ocfs2_stack_plugin ocfs2_user_plugin = {\n\t.sp_name\t= \"user\",\n\t.sp_ops\t\t= &ocfs2_user_plugin_ops,\n\t.sp_owner\t= THIS_MODULE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_control_exit",
          "args": [],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "656-666",
          "snippet": "static void ocfs2_control_exit(void)\n{\n\tint rc;\n\n\trc = misc_deregister(&ocfs2_control_device);\n\tif (rc)\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Unable to deregister ocfs2_control device \"\n\t\t       \"(errno %d)\\n\",\n\t\t       -rc);\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct miscdevice ocfs2_control_device = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"ocfs2_control\",\n\t.fops\t\t= &ocfs2_control_fops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct miscdevice ocfs2_control_device = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"ocfs2_control\",\n\t.fops\t\t= &ocfs2_control_fops,\n};\n\nstatic void ocfs2_control_exit(void)\n{\n\tint rc;\n\n\trc = misc_deregister(&ocfs2_control_device);\n\tif (rc)\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Unable to deregister ocfs2_control device \"\n\t\t       \"(errno %d)\\n\",\n\t\t       -rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_stack_glue_register",
          "args": [
            "&ocfs2_user_plugin"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_stack_glue_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "172-192",
          "snippet": "int ocfs2_stack_glue_register(struct ocfs2_stack_plugin *plugin)\n{\n\tint rc;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tif (!ocfs2_stack_lookup(plugin->sp_name)) {\n\t\tplugin->sp_count = 0;\n\t\tplugin->sp_max_proto = locking_max_version;\n\t\tlist_add(&plugin->sp_list, &ocfs2_stack_list);\n\t\tprintk(KERN_INFO \"ocfs2: Registered cluster interface %s\\n\",\n\t\t       plugin->sp_name);\n\t\trc = 0;\n\t} else {\n\t\tprintk(KERN_ERR \"ocfs2: Stack \\\"%s\\\" already registered\\n\",\n\t\t       plugin->sp_name);\n\t\trc = -EEXIST;\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_protocol_version locking_max_version;",
            "static DEFINE_SPINLOCK(ocfs2_stack_lock);",
            "static LIST_HEAD(ocfs2_stack_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_protocol_version locking_max_version;\nstatic DEFINE_SPINLOCK(ocfs2_stack_lock);\nstatic LIST_HEAD(ocfs2_stack_list);\n\nint ocfs2_stack_glue_register(struct ocfs2_stack_plugin *plugin)\n{\n\tint rc;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tif (!ocfs2_stack_lookup(plugin->sp_name)) {\n\t\tplugin->sp_count = 0;\n\t\tplugin->sp_max_proto = locking_max_version;\n\t\tlist_add(&plugin->sp_list, &ocfs2_stack_list);\n\t\tprintk(KERN_INFO \"ocfs2: Registered cluster interface %s\\n\",\n\t\t       plugin->sp_name);\n\t\trc = 0;\n\t} else {\n\t\tprintk(KERN_ERR \"ocfs2: Stack \\\"%s\\\" already registered\\n\",\n\t\t       plugin->sp_name);\n\t\trc = -EEXIST;\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_control_init",
          "args": [],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "640-654",
          "snippet": "static int ocfs2_control_init(void)\n{\n\tint rc;\n\n\tatomic_set(&ocfs2_control_opened, 0);\n\n\trc = misc_register(&ocfs2_control_device);\n\tif (rc)\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Unable to register ocfs2_control device \"\n\t\t       \"(errno %d)\\n\",\n\t\t       -rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t ocfs2_control_opened;",
            "static struct miscdevice ocfs2_control_device = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"ocfs2_control\",\n\t.fops\t\t= &ocfs2_control_fops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic atomic_t ocfs2_control_opened;\nstatic struct miscdevice ocfs2_control_device = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"ocfs2_control\",\n\t.fops\t\t= &ocfs2_control_fops,\n};\n\nstatic int ocfs2_control_init(void)\n{\n\tint rc;\n\n\tatomic_set(&ocfs2_control_opened, 0);\n\n\trc = misc_register(&ocfs2_control_device);\n\tif (rc)\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Unable to register ocfs2_control device \"\n\t\t       \"(errno %d)\\n\",\n\t\t       -rc);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct ocfs2_stack_plugin ocfs2_user_plugin;\nstatic struct ocfs2_stack_plugin ocfs2_user_plugin = {\n\t.sp_name\t= \"user\",\n\t.sp_ops\t\t= &ocfs2_user_plugin_ops,\n\t.sp_owner\t= THIS_MODULE,\n};\n\nstatic int __init ocfs2_user_plugin_init(void)\n{\n\tint rc;\n\n\trc = ocfs2_control_init();\n\tif (!rc) {\n\t\trc = ocfs2_stack_glue_register(&ocfs2_user_plugin);\n\t\tif (rc)\n\t\t\tocfs2_control_exit();\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "user_cluster_this_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "1072-1090",
    "snippet": "static int user_cluster_this_node(struct ocfs2_cluster_connection *conn,\n\t\t\t\t  unsigned int *this_node)\n{\n\tint rc;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\n\tif (lc->oc_type == WITH_CONTROLD)\n\t\trc = ocfs2_control_get_this_node();\n\telse if (lc->oc_type == NO_CONTROLD)\n\t\trc = atomic_read(&lc->oc_this_node);\n\telse\n\t\trc = -EINVAL;\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*this_node = rc;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&lc->oc_this_node"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_control_get_this_node",
          "args": [],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_get_this_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "354-366",
          "snippet": "static int ocfs2_control_get_this_node(void)\n{\n\tint rc;\n\n\tmutex_lock(&ocfs2_control_lock);\n\tif (ocfs2_control_this_node < 0)\n\t\trc = -EINVAL;\n\telse\n\t\trc = ocfs2_control_this_node;\n\tmutex_unlock(&ocfs2_control_lock);\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_control_this_node = -1;",
            "static DEFINE_MUTEX(ocfs2_control_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_control_this_node = -1;\nstatic DEFINE_MUTEX(ocfs2_control_lock);\n\nstatic int ocfs2_control_get_this_node(void)\n{\n\tint rc;\n\n\tmutex_lock(&ocfs2_control_lock);\n\tif (ocfs2_control_this_node < 0)\n\t\trc = -EINVAL;\n\telse\n\t\trc = ocfs2_control_this_node;\n\tmutex_unlock(&ocfs2_control_lock);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int user_cluster_this_node(struct ocfs2_cluster_connection *conn,\n\t\t\t\t  unsigned int *this_node)\n{\n\tint rc;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\n\tif (lc->oc_type == WITH_CONTROLD)\n\t\trc = ocfs2_control_get_this_node();\n\telse if (lc->oc_type == NO_CONTROLD)\n\t\trc = atomic_read(&lc->oc_this_node);\n\telse\n\t\trc = -EINVAL;\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*this_node = rc;\n\treturn 0;\n}"
  },
  {
    "function_name": "user_cluster_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "998-1069",
    "snippet": "static int user_cluster_connect(struct ocfs2_cluster_connection *conn)\n{\n\tdlm_lockspace_t *fsdlm;\n\tstruct ocfs2_live_connection *lc;\n\tint rc, ops_rv;\n\n\tBUG_ON(conn == NULL);\n\n\tlc = kzalloc(sizeof(struct ocfs2_live_connection), GFP_KERNEL);\n\tif (!lc) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tinit_waitqueue_head(&lc->oc_wait);\n\tinit_completion(&lc->oc_sync_wait);\n\tatomic_set(&lc->oc_this_node, 0);\n\tconn->cc_private = lc;\n\tlc->oc_type = NO_CONTROLD;\n\n\trc = dlm_new_lockspace(conn->cc_name, conn->cc_cluster_name,\n\t\t\t       DLM_LSFL_FS, DLM_LVB_LEN,\n\t\t\t       &ocfs2_ls_ops, conn, &ops_rv, &fsdlm);\n\tif (rc)\n\t\tgoto out;\n\n\tif (ops_rv == -EOPNOTSUPP) {\n\t\tlc->oc_type = WITH_CONTROLD;\n\t\tprintk(KERN_NOTICE \"ocfs2: You seem to be using an older \"\n\t\t\t\t\"version of dlm_controld and/or ocfs2-tools.\"\n\t\t\t\t\" Please consider upgrading.\\n\");\n\t} else if (ops_rv) {\n\t\trc = ops_rv;\n\t\tgoto out;\n\t}\n\tconn->cc_lockspace = fsdlm;\n\n\trc = ocfs2_live_connection_attach(conn, lc);\n\tif (rc)\n\t\tgoto out;\n\n\tif (lc->oc_type == NO_CONTROLD) {\n\t\trc = get_protocol_version(conn);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"ocfs2: Could not determine\"\n\t\t\t\t\t\" locking version\\n\");\n\t\t\tuser_cluster_disconnect(conn);\n\t\t\tgoto out;\n\t\t}\n\t\twait_event(lc->oc_wait, (atomic_read(&lc->oc_this_node) > 0));\n\t}\n\n\t/*\n\t * running_proto must have been set before we allowed any mounts\n\t * to proceed.\n\t */\n\tif (fs_protocol_compare(&running_proto, &conn->cc_version)) {\n\t\tprintk(KERN_ERR\n\t\t       \"Unable to mount with fs locking protocol version \"\n\t\t       \"%u.%u because negotiated protocol is %u.%u\\n\",\n\t\t       conn->cc_version.pv_major, conn->cc_version.pv_minor,\n\t\t       running_proto.pv_major, running_proto.pv_minor);\n\t\trc = -EPROTO;\n\t\tocfs2_live_connection_drop(lc);\n\t\tlc = NULL;\n\t}\n\nout:\n\tif (rc && lc)\n\t\tkfree(lc);\n\treturn rc;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_protocol_version running_proto;",
      "static const struct dlm_lockspace_ops ocfs2_ls_ops = {\n\t.recover_prep = user_recover_prep,\n\t.recover_slot = user_recover_slot,\n\t.recover_done = user_recover_done,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lc"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_live_connection_drop",
          "args": [
            "lc"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_live_connection_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "239-247",
          "snippet": "static void ocfs2_live_connection_drop(struct ocfs2_live_connection *c)\n{\n\tmutex_lock(&ocfs2_control_lock);\n\tlist_del_init(&c->oc_list);\n\tc->oc_conn = NULL;\n\tmutex_unlock(&ocfs2_control_lock);\n\n\tkfree(c);\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ocfs2_control_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(ocfs2_control_lock);\n\nstatic void ocfs2_live_connection_drop(struct ocfs2_live_connection *c)\n{\n\tmutex_lock(&ocfs2_control_lock);\n\tlist_del_init(&c->oc_list);\n\tc->oc_conn = NULL;\n\tmutex_unlock(&ocfs2_control_lock);\n\n\tkfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"Unable to mount with fs locking protocol version \"\n\t\t       \"%u.%u because negotiated protocol is %u.%u\\n\"",
            "conn->cc_version.pv_major",
            "conn->cc_version.pv_minor",
            "running_proto.pv_major",
            "running_proto.pv_minor"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_protocol_compare",
          "args": [
            "&running_proto",
            "&conn->cc_version"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "fs_protocol_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "790-803",
          "snippet": "static int fs_protocol_compare(struct ocfs2_protocol_version *existing,\n\t\t\t       struct ocfs2_protocol_version *request)\n{\n\tif (existing->pv_major != request->pv_major)\n\t\treturn 1;\n\n\tif (existing->pv_minor > request->pv_minor)\n\t\treturn 1;\n\n\tif (existing->pv_minor < request->pv_minor)\n\t\trequest->pv_minor = existing->pv_minor;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int fs_protocol_compare(struct ocfs2_protocol_version *existing,\n\t\t\t       struct ocfs2_protocol_version *request)\n{\n\tif (existing->pv_major != request->pv_major)\n\t\treturn 1;\n\n\tif (existing->pv_minor > request->pv_minor)\n\t\treturn 1;\n\n\tif (existing->pv_minor < request->pv_minor)\n\t\trequest->pv_minor = existing->pv_minor;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "lc->oc_wait",
            "(atomic_read(&lc->oc_this_node) > 0)"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&lc->oc_this_node"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_cluster_disconnect",
          "args": [
            "conn"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "user_cluster_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "988-996",
          "snippet": "static int user_cluster_disconnect(struct ocfs2_cluster_connection *conn)\n{\n\tversion_unlock(conn);\n\tdlm_release_lockspace(conn->cc_lockspace, 2);\n\tconn->cc_lockspace = NULL;\n\tocfs2_live_connection_drop(conn->cc_private);\n\tconn->cc_private = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int user_cluster_disconnect(struct ocfs2_cluster_connection *conn)\n{\n\tversion_unlock(conn);\n\tdlm_release_lockspace(conn->cc_lockspace, 2);\n\tconn->cc_lockspace = NULL;\n\tocfs2_live_connection_drop(conn->cc_private);\n\tconn->cc_private = NULL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_protocol_version",
          "args": [
            "conn"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "get_protocol_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "913-949",
          "snippet": "static int get_protocol_version(struct ocfs2_cluster_connection *conn)\n{\n\tint ret;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\tstruct ocfs2_protocol_version pv;\n\n\trunning_proto.pv_major =\n\t\tocfs2_user_plugin.sp_max_proto.pv_major;\n\trunning_proto.pv_minor =\n\t\tocfs2_user_plugin.sp_max_proto.pv_minor;\n\n\tlc->oc_version_lksb.sb_lvbptr = lc->oc_lvb;\n\tret = version_lock(conn, DLM_LOCK_EX,\n\t\t\tDLM_LKF_VALBLK|DLM_LKF_NOQUEUE);\n\tif (!ret) {\n\t\tconn->cc_version.pv_major = running_proto.pv_major;\n\t\tconn->cc_version.pv_minor = running_proto.pv_minor;\n\t\tversion_to_lvb(&running_proto, lc->oc_lvb);\n\t\tversion_lock(conn, DLM_LOCK_PR, DLM_LKF_CONVERT|DLM_LKF_VALBLK);\n\t} else if (ret == -EAGAIN) {\n\t\tret = version_lock(conn, DLM_LOCK_PR, DLM_LKF_VALBLK);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tlvb_to_version(lc->oc_lvb, &pv);\n\n\t\tif ((pv.pv_major != running_proto.pv_major) ||\n\t\t\t\t(pv.pv_minor > running_proto.pv_minor)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tconn->cc_version.pv_major = pv.pv_major;\n\t\tconn->cc_version.pv_minor = pv.pv_minor;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin ocfs2_user_plugin;",
            "static struct ocfs2_protocol_version running_proto;",
            "static struct ocfs2_stack_plugin ocfs2_user_plugin = {\n\t.sp_name\t= \"user\",\n\t.sp_ops\t\t= &ocfs2_user_plugin_ops,\n\t.sp_owner\t= THIS_MODULE,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct ocfs2_stack_plugin ocfs2_user_plugin;\nstatic struct ocfs2_protocol_version running_proto;\nstatic struct ocfs2_stack_plugin ocfs2_user_plugin = {\n\t.sp_name\t= \"user\",\n\t.sp_ops\t\t= &ocfs2_user_plugin_ops,\n\t.sp_owner\t= THIS_MODULE,\n};\n\nstatic int get_protocol_version(struct ocfs2_cluster_connection *conn)\n{\n\tint ret;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\tstruct ocfs2_protocol_version pv;\n\n\trunning_proto.pv_major =\n\t\tocfs2_user_plugin.sp_max_proto.pv_major;\n\trunning_proto.pv_minor =\n\t\tocfs2_user_plugin.sp_max_proto.pv_minor;\n\n\tlc->oc_version_lksb.sb_lvbptr = lc->oc_lvb;\n\tret = version_lock(conn, DLM_LOCK_EX,\n\t\t\tDLM_LKF_VALBLK|DLM_LKF_NOQUEUE);\n\tif (!ret) {\n\t\tconn->cc_version.pv_major = running_proto.pv_major;\n\t\tconn->cc_version.pv_minor = running_proto.pv_minor;\n\t\tversion_to_lvb(&running_proto, lc->oc_lvb);\n\t\tversion_lock(conn, DLM_LOCK_PR, DLM_LKF_CONVERT|DLM_LKF_VALBLK);\n\t} else if (ret == -EAGAIN) {\n\t\tret = version_lock(conn, DLM_LOCK_PR, DLM_LKF_VALBLK);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tlvb_to_version(lc->oc_lvb, &pv);\n\n\t\tif ((pv.pv_major != running_proto.pv_major) ||\n\t\t\t\t(pv.pv_minor > running_proto.pv_minor)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tconn->cc_version.pv_major = pv.pv_major;\n\t\tconn->cc_version.pv_minor = pv.pv_minor;\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_live_connection_attach",
          "args": [
            "conn",
            "lc"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_live_connection_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "215-233",
          "snippet": "static int ocfs2_live_connection_attach(struct ocfs2_cluster_connection *conn,\n\t\t\t\t     struct ocfs2_live_connection *c)\n{\n\tint rc = 0;\n\n\tmutex_lock(&ocfs2_control_lock);\n\tc->oc_conn = conn;\n\n\tif ((c->oc_type == NO_CONTROLD) || atomic_read(&ocfs2_control_opened))\n\t\tlist_add(&c->oc_list, &ocfs2_live_connection_list);\n\telse {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Userspace control daemon is not present\\n\");\n\t\trc = -ESRCH;\n\t}\n\n\tmutex_unlock(&ocfs2_control_lock);\n\treturn rc;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t ocfs2_control_opened;",
            "static LIST_HEAD(ocfs2_live_connection_list);",
            "static DEFINE_MUTEX(ocfs2_control_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic atomic_t ocfs2_control_opened;\nstatic LIST_HEAD(ocfs2_live_connection_list);\nstatic DEFINE_MUTEX(ocfs2_control_lock);\n\nstatic int ocfs2_live_connection_attach(struct ocfs2_cluster_connection *conn,\n\t\t\t\t     struct ocfs2_live_connection *c)\n{\n\tint rc = 0;\n\n\tmutex_lock(&ocfs2_control_lock);\n\tc->oc_conn = conn;\n\n\tif ((c->oc_type == NO_CONTROLD) || atomic_read(&ocfs2_control_opened))\n\t\tlist_add(&c->oc_list, &ocfs2_live_connection_list);\n\telse {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Userspace control daemon is not present\\n\");\n\t\trc = -ESRCH;\n\t}\n\n\tmutex_unlock(&ocfs2_control_lock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_new_lockspace",
          "args": [
            "conn->cc_name",
            "conn->cc_cluster_name",
            "DLM_LSFL_FS",
            "DLM_LVB_LEN",
            "&ocfs2_ls_ops",
            "conn",
            "&ops_rv",
            "&fsdlm"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_new_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "692-716",
          "snippet": "int dlm_new_lockspace(const char *name, const char *cluster,\n\t\t      uint32_t flags, int lvblen,\n\t\t      const struct dlm_lockspace_ops *ops, void *ops_arg,\n\t\t      int *ops_result, dlm_lockspace_t **lockspace)\n{\n\tint error = 0;\n\n\tmutex_lock(&ls_lock);\n\tif (!ls_count)\n\t\terror = threads_start();\n\tif (error)\n\t\tgoto out;\n\n\terror = new_lockspace(name, cluster, flags, lvblen, ops, ops_arg,\n\t\t\t      ops_result, lockspace);\n\tif (!error)\n\t\tls_count++;\n\tif (error > 0)\n\t\terror = 0;\n\tif (!ls_count)\n\t\tthreads_stop();\n out:\n\tmutex_unlock(&ls_lock);\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct mutex\t\tls_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct mutex\t\tls_lock;\n\nint dlm_new_lockspace(const char *name, const char *cluster,\n\t\t      uint32_t flags, int lvblen,\n\t\t      const struct dlm_lockspace_ops *ops, void *ops_arg,\n\t\t      int *ops_result, dlm_lockspace_t **lockspace)\n{\n\tint error = 0;\n\n\tmutex_lock(&ls_lock);\n\tif (!ls_count)\n\t\terror = threads_start();\n\tif (error)\n\t\tgoto out;\n\n\terror = new_lockspace(name, cluster, flags, lvblen, ops, ops_arg,\n\t\t\t      ops_result, lockspace);\n\tif (!error)\n\t\tls_count++;\n\tif (error > 0)\n\t\terror = 0;\n\tif (!ls_count)\n\t\tthreads_stop();\n out:\n\tmutex_unlock(&ls_lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&lc->oc_this_node",
            "0"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&lc->oc_sync_wait"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&lc->oc_wait"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_live_connection)",
            "GFP_KERNEL"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "conn == NULL"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct ocfs2_protocol_version running_proto;\nstatic const struct dlm_lockspace_ops ocfs2_ls_ops = {\n\t.recover_prep = user_recover_prep,\n\t.recover_slot = user_recover_slot,\n\t.recover_done = user_recover_done,\n};\n\nstatic int user_cluster_connect(struct ocfs2_cluster_connection *conn)\n{\n\tdlm_lockspace_t *fsdlm;\n\tstruct ocfs2_live_connection *lc;\n\tint rc, ops_rv;\n\n\tBUG_ON(conn == NULL);\n\n\tlc = kzalloc(sizeof(struct ocfs2_live_connection), GFP_KERNEL);\n\tif (!lc) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tinit_waitqueue_head(&lc->oc_wait);\n\tinit_completion(&lc->oc_sync_wait);\n\tatomic_set(&lc->oc_this_node, 0);\n\tconn->cc_private = lc;\n\tlc->oc_type = NO_CONTROLD;\n\n\trc = dlm_new_lockspace(conn->cc_name, conn->cc_cluster_name,\n\t\t\t       DLM_LSFL_FS, DLM_LVB_LEN,\n\t\t\t       &ocfs2_ls_ops, conn, &ops_rv, &fsdlm);\n\tif (rc)\n\t\tgoto out;\n\n\tif (ops_rv == -EOPNOTSUPP) {\n\t\tlc->oc_type = WITH_CONTROLD;\n\t\tprintk(KERN_NOTICE \"ocfs2: You seem to be using an older \"\n\t\t\t\t\"version of dlm_controld and/or ocfs2-tools.\"\n\t\t\t\t\" Please consider upgrading.\\n\");\n\t} else if (ops_rv) {\n\t\trc = ops_rv;\n\t\tgoto out;\n\t}\n\tconn->cc_lockspace = fsdlm;\n\n\trc = ocfs2_live_connection_attach(conn, lc);\n\tif (rc)\n\t\tgoto out;\n\n\tif (lc->oc_type == NO_CONTROLD) {\n\t\trc = get_protocol_version(conn);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"ocfs2: Could not determine\"\n\t\t\t\t\t\" locking version\\n\");\n\t\t\tuser_cluster_disconnect(conn);\n\t\t\tgoto out;\n\t\t}\n\t\twait_event(lc->oc_wait, (atomic_read(&lc->oc_this_node) > 0));\n\t}\n\n\t/*\n\t * running_proto must have been set before we allowed any mounts\n\t * to proceed.\n\t */\n\tif (fs_protocol_compare(&running_proto, &conn->cc_version)) {\n\t\tprintk(KERN_ERR\n\t\t       \"Unable to mount with fs locking protocol version \"\n\t\t       \"%u.%u because negotiated protocol is %u.%u\\n\",\n\t\t       conn->cc_version.pv_major, conn->cc_version.pv_minor,\n\t\t       running_proto.pv_major, running_proto.pv_minor);\n\t\trc = -EPROTO;\n\t\tocfs2_live_connection_drop(lc);\n\t\tlc = NULL;\n\t}\n\nout:\n\tif (rc && lc)\n\t\tkfree(lc);\n\treturn rc;\n}"
  },
  {
    "function_name": "user_cluster_disconnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "988-996",
    "snippet": "static int user_cluster_disconnect(struct ocfs2_cluster_connection *conn)\n{\n\tversion_unlock(conn);\n\tdlm_release_lockspace(conn->cc_lockspace, 2);\n\tconn->cc_lockspace = NULL;\n\tocfs2_live_connection_drop(conn->cc_private);\n\tconn->cc_private = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_live_connection_drop",
          "args": [
            "conn->cc_private"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_live_connection_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "239-247",
          "snippet": "static void ocfs2_live_connection_drop(struct ocfs2_live_connection *c)\n{\n\tmutex_lock(&ocfs2_control_lock);\n\tlist_del_init(&c->oc_list);\n\tc->oc_conn = NULL;\n\tmutex_unlock(&ocfs2_control_lock);\n\n\tkfree(c);\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ocfs2_control_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(ocfs2_control_lock);\n\nstatic void ocfs2_live_connection_drop(struct ocfs2_live_connection *c)\n{\n\tmutex_lock(&ocfs2_control_lock);\n\tlist_del_init(&c->oc_list);\n\tc->oc_conn = NULL;\n\tmutex_unlock(&ocfs2_control_lock);\n\n\tkfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_release_lockspace",
          "args": [
            "conn->cc_lockspace",
            "2"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_release_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "873-892",
          "snippet": "int dlm_release_lockspace(void *lockspace, int force)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\tdlm_put_lockspace(ls);\n\n\tmutex_lock(&ls_lock);\n\terror = release_lockspace(ls, force);\n\tif (!error)\n\t\tls_count--;\n\tif (!ls_count)\n\t\tthreads_stop();\n\tmutex_unlock(&ls_lock);\n\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct mutex\t\tls_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct mutex\t\tls_lock;\n\nint dlm_release_lockspace(void *lockspace, int force)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\tdlm_put_lockspace(ls);\n\n\tmutex_lock(&ls_lock);\n\terror = release_lockspace(ls, force);\n\tif (!error)\n\t\tls_count--;\n\tif (!ls_count)\n\t\tthreads_stop();\n\tmutex_unlock(&ls_lock);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "version_unlock",
          "args": [
            "conn"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "version_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "896-900",
          "snippet": "static int version_unlock(struct ocfs2_cluster_connection *conn)\n{\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\treturn sync_unlock(conn, &lc->oc_version_lksb, VERSION_LOCK);\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define VERSION_LOCK\t\t\t\t\"version_lock\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define VERSION_LOCK\t\t\t\t\"version_lock\"\n\nstatic int version_unlock(struct ocfs2_cluster_connection *conn)\n{\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\treturn sync_unlock(conn, &lc->oc_version_lksb, VERSION_LOCK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int user_cluster_disconnect(struct ocfs2_cluster_connection *conn)\n{\n\tversion_unlock(conn);\n\tdlm_release_lockspace(conn->cc_lockspace, 2);\n\tconn->cc_lockspace = NULL;\n\tocfs2_live_connection_drop(conn->cc_private);\n\tconn->cc_private = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "user_recover_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "964-980",
    "snippet": "static void user_recover_done(void *arg, struct dlm_slot *slots,\n\t\tint num_slots, int our_slot,\n\t\tuint32_t generation)\n{\n\tstruct ocfs2_cluster_connection *conn = arg;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\tint i;\n\n\tfor (i = 0; i < num_slots; i++)\n\t\tif (slots[i].slot == our_slot) {\n\t\t\tatomic_set(&lc->oc_this_node, slots[i].nodeid);\n\t\t\tbreak;\n\t\t}\n\n\tlc->oc_our_slot = our_slot;\n\twake_up(&lc->oc_wait);\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&lc->oc_wait"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&lc->oc_this_node",
            "slots[i].nodeid"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void user_recover_done(void *arg, struct dlm_slot *slots,\n\t\tint num_slots, int our_slot,\n\t\tuint32_t generation)\n{\n\tstruct ocfs2_cluster_connection *conn = arg;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\tint i;\n\n\tfor (i = 0; i < num_slots; i++)\n\t\tif (slots[i].slot == our_slot) {\n\t\t\tatomic_set(&lc->oc_this_node, slots[i].nodeid);\n\t\t\tbreak;\n\t\t}\n\n\tlc->oc_our_slot = our_slot;\n\twake_up(&lc->oc_wait);\n}"
  },
  {
    "function_name": "user_recover_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "955-962",
    "snippet": "static void user_recover_slot(void *arg, struct dlm_slot *slot)\n{\n\tstruct ocfs2_cluster_connection *conn = arg;\n\tprintk(KERN_INFO \"ocfs2: Node %d/%d down. Initiating recovery.\\n\",\n\t\t\tslot->nodeid, slot->slot);\n\tconn->cc_recovery_handler(slot->nodeid, conn->cc_recovery_data);\n\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "conn->cc_recovery_handler",
          "args": [
            "slot->nodeid",
            "conn->cc_recovery_data"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"ocfs2: Node %d/%d down. Initiating recovery.\\n\"",
            "slot->nodeid",
            "slot->slot"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void user_recover_slot(void *arg, struct dlm_slot *slot)\n{\n\tstruct ocfs2_cluster_connection *conn = arg;\n\tprintk(KERN_INFO \"ocfs2: Node %d/%d down. Initiating recovery.\\n\",\n\t\t\tslot->nodeid, slot->slot);\n\tconn->cc_recovery_handler(slot->nodeid, conn->cc_recovery_data);\n\n}"
  },
  {
    "function_name": "user_recover_prep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "951-953",
    "snippet": "static void user_recover_prep(void *arg)\n{\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void user_recover_prep(void *arg)\n{\n}"
  },
  {
    "function_name": "get_protocol_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "913-949",
    "snippet": "static int get_protocol_version(struct ocfs2_cluster_connection *conn)\n{\n\tint ret;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\tstruct ocfs2_protocol_version pv;\n\n\trunning_proto.pv_major =\n\t\tocfs2_user_plugin.sp_max_proto.pv_major;\n\trunning_proto.pv_minor =\n\t\tocfs2_user_plugin.sp_max_proto.pv_minor;\n\n\tlc->oc_version_lksb.sb_lvbptr = lc->oc_lvb;\n\tret = version_lock(conn, DLM_LOCK_EX,\n\t\t\tDLM_LKF_VALBLK|DLM_LKF_NOQUEUE);\n\tif (!ret) {\n\t\tconn->cc_version.pv_major = running_proto.pv_major;\n\t\tconn->cc_version.pv_minor = running_proto.pv_minor;\n\t\tversion_to_lvb(&running_proto, lc->oc_lvb);\n\t\tversion_lock(conn, DLM_LOCK_PR, DLM_LKF_CONVERT|DLM_LKF_VALBLK);\n\t} else if (ret == -EAGAIN) {\n\t\tret = version_lock(conn, DLM_LOCK_PR, DLM_LKF_VALBLK);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tlvb_to_version(lc->oc_lvb, &pv);\n\n\t\tif ((pv.pv_major != running_proto.pv_major) ||\n\t\t\t\t(pv.pv_minor > running_proto.pv_minor)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tconn->cc_version.pv_major = pv.pv_major;\n\t\tconn->cc_version.pv_minor = pv.pv_minor;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_stack_plugin ocfs2_user_plugin;",
      "static struct ocfs2_protocol_version running_proto;",
      "static struct ocfs2_stack_plugin ocfs2_user_plugin = {\n\t.sp_name\t= \"user\",\n\t.sp_ops\t\t= &ocfs2_user_plugin_ops,\n\t.sp_owner\t= THIS_MODULE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lvb_to_version",
          "args": [
            "lc->oc_lvb",
            "&pv"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "lvb_to_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "805-815",
          "snippet": "static void lvb_to_version(char *lvb, struct ocfs2_protocol_version *ver)\n{\n\tstruct ocfs2_protocol_version *pv =\n\t\t(struct ocfs2_protocol_version *)lvb;\n\t/*\n\t * ocfs2_protocol_version has two u8 variables, so we don't\n\t * need any endian conversion.\n\t */\n\tver->pv_major = pv->pv_major;\n\tver->pv_minor = pv->pv_minor;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void lvb_to_version(char *lvb, struct ocfs2_protocol_version *ver)\n{\n\tstruct ocfs2_protocol_version *pv =\n\t\t(struct ocfs2_protocol_version *)lvb;\n\t/*\n\t * ocfs2_protocol_version has two u8 variables, so we don't\n\t * need any endian conversion.\n\t */\n\tver->pv_major = pv->pv_major;\n\tver->pv_minor = pv->pv_minor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "version_lock",
          "args": [
            "conn",
            "DLM_LOCK_PR",
            "DLM_LKF_VALBLK"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "version_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "888-894",
          "snippet": "static int version_lock(struct ocfs2_cluster_connection *conn, int mode,\n\t\tint flags)\n{\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\treturn sync_lock(conn, mode, flags,\n\t\t\t&lc->oc_version_lksb, VERSION_LOCK);\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define VERSION_LOCK\t\t\t\t\"version_lock\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define VERSION_LOCK\t\t\t\t\"version_lock\"\n\nstatic int version_lock(struct ocfs2_cluster_connection *conn, int mode,\n\t\tint flags)\n{\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\treturn sync_lock(conn, mode, flags,\n\t\t\t&lc->oc_version_lksb, VERSION_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "version_to_lvb",
          "args": [
            "&running_proto",
            "lc->oc_lvb"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "version_to_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "817-827",
          "snippet": "static void version_to_lvb(struct ocfs2_protocol_version *ver, char *lvb)\n{\n\tstruct ocfs2_protocol_version *pv =\n\t\t(struct ocfs2_protocol_version *)lvb;\n\t/*\n\t * ocfs2_protocol_version has two u8 variables, so we don't\n\t * need any endian conversion.\n\t */\n\tpv->pv_major = ver->pv_major;\n\tpv->pv_minor = ver->pv_minor;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void version_to_lvb(struct ocfs2_protocol_version *ver, char *lvb)\n{\n\tstruct ocfs2_protocol_version *pv =\n\t\t(struct ocfs2_protocol_version *)lvb;\n\t/*\n\t * ocfs2_protocol_version has two u8 variables, so we don't\n\t * need any endian conversion.\n\t */\n\tpv->pv_major = ver->pv_major;\n\tpv->pv_minor = ver->pv_minor;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct ocfs2_stack_plugin ocfs2_user_plugin;\nstatic struct ocfs2_protocol_version running_proto;\nstatic struct ocfs2_stack_plugin ocfs2_user_plugin = {\n\t.sp_name\t= \"user\",\n\t.sp_ops\t\t= &ocfs2_user_plugin_ops,\n\t.sp_owner\t= THIS_MODULE,\n};\n\nstatic int get_protocol_version(struct ocfs2_cluster_connection *conn)\n{\n\tint ret;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\tstruct ocfs2_protocol_version pv;\n\n\trunning_proto.pv_major =\n\t\tocfs2_user_plugin.sp_max_proto.pv_major;\n\trunning_proto.pv_minor =\n\t\tocfs2_user_plugin.sp_max_proto.pv_minor;\n\n\tlc->oc_version_lksb.sb_lvbptr = lc->oc_lvb;\n\tret = version_lock(conn, DLM_LOCK_EX,\n\t\t\tDLM_LKF_VALBLK|DLM_LKF_NOQUEUE);\n\tif (!ret) {\n\t\tconn->cc_version.pv_major = running_proto.pv_major;\n\t\tconn->cc_version.pv_minor = running_proto.pv_minor;\n\t\tversion_to_lvb(&running_proto, lc->oc_lvb);\n\t\tversion_lock(conn, DLM_LOCK_PR, DLM_LKF_CONVERT|DLM_LKF_VALBLK);\n\t} else if (ret == -EAGAIN) {\n\t\tret = version_lock(conn, DLM_LOCK_PR, DLM_LKF_VALBLK);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tlvb_to_version(lc->oc_lvb, &pv);\n\n\t\tif ((pv.pv_major != running_proto.pv_major) ||\n\t\t\t\t(pv.pv_minor > running_proto.pv_minor)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tconn->cc_version.pv_major = pv.pv_major;\n\t\tconn->cc_version.pv_minor = pv.pv_minor;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "version_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "896-900",
    "snippet": "static int version_unlock(struct ocfs2_cluster_connection *conn)\n{\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\treturn sync_unlock(conn, &lc->oc_version_lksb, VERSION_LOCK);\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define VERSION_LOCK\t\t\t\t\"version_lock\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_unlock",
          "args": [
            "conn",
            "&lc->oc_version_lksb",
            "VERSION_LOCK"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "sync_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "836-857",
          "snippet": "static int sync_unlock(struct ocfs2_cluster_connection *conn,\n\t\tstruct dlm_lksb *lksb, char *name)\n{\n\tint error;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\n\terror = dlm_unlock(conn->cc_lockspace, lksb->sb_lkid, 0, lksb, conn);\n\tif (error) {\n\t\tprintk(KERN_ERR \"%s lkid %x error %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&lc->oc_sync_wait);\n\n\tif (lksb->sb_status != -DLM_EUNLOCK) {\n\t\tprintk(KERN_ERR \"%s lkid %x status %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, lksb->sb_status);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int sync_unlock(struct ocfs2_cluster_connection *conn,\n\t\tstruct dlm_lksb *lksb, char *name)\n{\n\tint error;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\n\terror = dlm_unlock(conn->cc_lockspace, lksb->sb_lkid, 0, lksb, conn);\n\tif (error) {\n\t\tprintk(KERN_ERR \"%s lkid %x error %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&lc->oc_sync_wait);\n\n\tif (lksb->sb_status != -DLM_EUNLOCK) {\n\t\tprintk(KERN_ERR \"%s lkid %x status %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, lksb->sb_status);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define VERSION_LOCK\t\t\t\t\"version_lock\"\n\nstatic int version_unlock(struct ocfs2_cluster_connection *conn)\n{\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\treturn sync_unlock(conn, &lc->oc_version_lksb, VERSION_LOCK);\n}"
  },
  {
    "function_name": "version_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "888-894",
    "snippet": "static int version_lock(struct ocfs2_cluster_connection *conn, int mode,\n\t\tint flags)\n{\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\treturn sync_lock(conn, mode, flags,\n\t\t\t&lc->oc_version_lksb, VERSION_LOCK);\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define VERSION_LOCK\t\t\t\t\"version_lock\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_lock",
          "args": [
            "conn",
            "mode",
            "flags",
            "&lc->oc_version_lksb",
            "VERSION_LOCK"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "sync_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "859-885",
          "snippet": "static int sync_lock(struct ocfs2_cluster_connection *conn,\n\t\tint mode, uint32_t flags,\n\t\tstruct dlm_lksb *lksb, char *name)\n{\n\tint error, status;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\n\terror = dlm_lock(conn->cc_lockspace, mode, lksb, flags,\n\t\t\tname, strlen(name),\n\t\t\t0, sync_wait_cb, conn, NULL);\n\tif (error) {\n\t\tprintk(KERN_ERR \"%s lkid %x flags %x mode %d error %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, flags, mode, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&lc->oc_sync_wait);\n\n\tstatus = lksb->sb_status;\n\n\tif (status && status != -EAGAIN) {\n\t\tprintk(KERN_ERR \"%s lkid %x flags %x mode %d status %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, flags, mode, status);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int sync_lock(struct ocfs2_cluster_connection *conn,\n\t\tint mode, uint32_t flags,\n\t\tstruct dlm_lksb *lksb, char *name)\n{\n\tint error, status;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\n\terror = dlm_lock(conn->cc_lockspace, mode, lksb, flags,\n\t\t\tname, strlen(name),\n\t\t\t0, sync_wait_cb, conn, NULL);\n\tif (error) {\n\t\tprintk(KERN_ERR \"%s lkid %x flags %x mode %d error %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, flags, mode, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&lc->oc_sync_wait);\n\n\tstatus = lksb->sb_status;\n\n\tif (status && status != -EAGAIN) {\n\t\tprintk(KERN_ERR \"%s lkid %x flags %x mode %d status %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, flags, mode, status);\n\t}\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define VERSION_LOCK\t\t\t\t\"version_lock\"\n\nstatic int version_lock(struct ocfs2_cluster_connection *conn, int mode,\n\t\tint flags)\n{\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\treturn sync_lock(conn, mode, flags,\n\t\t\t&lc->oc_version_lksb, VERSION_LOCK);\n}"
  },
  {
    "function_name": "sync_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "859-885",
    "snippet": "static int sync_lock(struct ocfs2_cluster_connection *conn,\n\t\tint mode, uint32_t flags,\n\t\tstruct dlm_lksb *lksb, char *name)\n{\n\tint error, status;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\n\terror = dlm_lock(conn->cc_lockspace, mode, lksb, flags,\n\t\t\tname, strlen(name),\n\t\t\t0, sync_wait_cb, conn, NULL);\n\tif (error) {\n\t\tprintk(KERN_ERR \"%s lkid %x flags %x mode %d error %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, flags, mode, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&lc->oc_sync_wait);\n\n\tstatus = lksb->sb_status;\n\n\tif (status && status != -EAGAIN) {\n\t\tprintk(KERN_ERR \"%s lkid %x flags %x mode %d status %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, flags, mode, status);\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s lkid %x flags %x mode %d status %d\\n\"",
            "name",
            "lksb->sb_lkid",
            "flags",
            "mode",
            "status"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&lc->oc_sync_wait"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock",
          "args": [
            "conn->cc_lockspace",
            "mode",
            "lksb",
            "flags",
            "name",
            "strlen(name)",
            "0",
            "sync_wait_cb",
            "conn",
            "NULL"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3409-3460",
          "snippet": "int dlm_lock(dlm_lockspace_t *lockspace,\n\t     int mode,\n\t     struct dlm_lksb *lksb,\n\t     uint32_t flags,\n\t     void *name,\n\t     unsigned int namelen,\n\t     uint32_t parent_lkid,\n\t     void (*ast) (void *astarg),\n\t     void *astarg,\n\t     void (*bast) (void *astarg, int mode))\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error, convert = flags & DLM_LKF_CONVERT;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\tif (convert)\n\t\terror = find_lkb(ls, lksb->sb_lkid, &lkb);\n\telse\n\t\terror = create_lkb(ls, &lkb);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = set_lock_args(mode, lksb, flags, namelen, 0, ast,\n\t\t\t      astarg, bast, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (convert)\n\t\terror = convert_lock(ls, lkb, &args);\n\telse\n\t\terror = request_lock(ls, lkb, name, namelen, &args);\n\n\tif (error == -EINPROGRESS)\n\t\terror = 0;\n out_put:\n\tif (convert || error)\n\t\t__put_lkb(ls, lkb);\n\tif (error == -EAGAIN || error == -EDEADLK)\n\t\terror = 0;\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_lock(dlm_lockspace_t *lockspace,\n\t     int mode,\n\t     struct dlm_lksb *lksb,\n\t     uint32_t flags,\n\t     void *name,\n\t     unsigned int namelen,\n\t     uint32_t parent_lkid,\n\t     void (*ast) (void *astarg),\n\t     void *astarg,\n\t     void (*bast) (void *astarg, int mode))\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error, convert = flags & DLM_LKF_CONVERT;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\tif (convert)\n\t\terror = find_lkb(ls, lksb->sb_lkid, &lkb);\n\telse\n\t\terror = create_lkb(ls, &lkb);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = set_lock_args(mode, lksb, flags, namelen, 0, ast,\n\t\t\t      astarg, bast, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (convert)\n\t\terror = convert_lock(ls, lkb, &args);\n\telse\n\t\terror = request_lock(ls, lkb, name, namelen, &args);\n\n\tif (error == -EINPROGRESS)\n\t\terror = 0;\n out_put:\n\tif (convert || error)\n\t\t__put_lkb(ls, lkb);\n\tif (error == -EAGAIN || error == -EDEADLK)\n\t\terror = 0;\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int sync_lock(struct ocfs2_cluster_connection *conn,\n\t\tint mode, uint32_t flags,\n\t\tstruct dlm_lksb *lksb, char *name)\n{\n\tint error, status;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\n\terror = dlm_lock(conn->cc_lockspace, mode, lksb, flags,\n\t\t\tname, strlen(name),\n\t\t\t0, sync_wait_cb, conn, NULL);\n\tif (error) {\n\t\tprintk(KERN_ERR \"%s lkid %x flags %x mode %d error %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, flags, mode, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&lc->oc_sync_wait);\n\n\tstatus = lksb->sb_status;\n\n\tif (status && status != -EAGAIN) {\n\t\tprintk(KERN_ERR \"%s lkid %x flags %x mode %d status %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, flags, mode, status);\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "sync_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "836-857",
    "snippet": "static int sync_unlock(struct ocfs2_cluster_connection *conn,\n\t\tstruct dlm_lksb *lksb, char *name)\n{\n\tint error;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\n\terror = dlm_unlock(conn->cc_lockspace, lksb->sb_lkid, 0, lksb, conn);\n\tif (error) {\n\t\tprintk(KERN_ERR \"%s lkid %x error %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&lc->oc_sync_wait);\n\n\tif (lksb->sb_status != -DLM_EUNLOCK) {\n\t\tprintk(KERN_ERR \"%s lkid %x status %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, lksb->sb_status);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s lkid %x status %d\\n\"",
            "name",
            "lksb->sb_lkid",
            "lksb->sb_status"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&lc->oc_sync_wait"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_unlock",
          "args": [
            "conn->cc_lockspace",
            "lksb->sb_lkid",
            "0",
            "lksb",
            "conn"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3462-3502",
          "snippet": "int dlm_unlock(dlm_lockspace_t *lockspace,\n\t       uint32_t lkid,\n\t       uint32_t flags,\n\t       struct dlm_lksb *lksb,\n\t       void *astarg)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\terror = set_unlock_args(flags, astarg, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\terror = cancel_lock(ls, lkb, &args);\n\telse\n\t\terror = unlock_lock(ls, lkb, &args);\n\n\tif (error == -DLM_EUNLOCK || error == -DLM_ECANCEL)\n\t\terror = 0;\n\tif (error == -EBUSY && (flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)))\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_unlock(dlm_lockspace_t *lockspace,\n\t       uint32_t lkid,\n\t       uint32_t flags,\n\t       struct dlm_lksb *lksb,\n\t       void *astarg)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\terror = set_unlock_args(flags, astarg, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\terror = cancel_lock(ls, lkb, &args);\n\telse\n\t\terror = unlock_lock(ls, lkb, &args);\n\n\tif (error == -DLM_EUNLOCK || error == -DLM_ECANCEL)\n\t\terror = 0;\n\tif (error == -EBUSY && (flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)))\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int sync_unlock(struct ocfs2_cluster_connection *conn,\n\t\tstruct dlm_lksb *lksb, char *name)\n{\n\tint error;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\n\terror = dlm_unlock(conn->cc_lockspace, lksb->sb_lkid, 0, lksb, conn);\n\tif (error) {\n\t\tprintk(KERN_ERR \"%s lkid %x error %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&lc->oc_sync_wait);\n\n\tif (lksb->sb_status != -DLM_EUNLOCK) {\n\t\tprintk(KERN_ERR \"%s lkid %x status %d\\n\",\n\t\t\t\tname, lksb->sb_lkid, lksb->sb_status);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "sync_wait_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "829-834",
    "snippet": "static void sync_wait_cb(void *arg)\n{\n\tstruct ocfs2_cluster_connection *conn = arg;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\tcomplete(&lc->oc_sync_wait);\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&lc->oc_sync_wait"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_quota_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1332-1343",
          "snippet": "void ocfs2_complete_quota_recovery(struct ocfs2_super *osb)\n{\n\tif (osb->quota_rec) {\n\t\tocfs2_queue_recovery_completion(osb->journal,\n\t\t\t\t\t\tosb->slot_num,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tosb->quota_rec,\n\t\t\t\t\t\tORPHAN_NEED_TRUNCATE);\n\t\tosb->quota_rec = NULL;\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nvoid ocfs2_complete_quota_recovery(struct ocfs2_super *osb)\n{\n\tif (osb->quota_rec) {\n\t\tocfs2_queue_recovery_completion(osb->journal,\n\t\t\t\t\t\tosb->slot_num,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tosb->quota_rec,\n\t\t\t\t\t\tORPHAN_NEED_TRUNCATE);\n\t\tosb->quota_rec = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void sync_wait_cb(void *arg)\n{\n\tstruct ocfs2_cluster_connection *conn = arg;\n\tstruct ocfs2_live_connection *lc = conn->cc_private;\n\tcomplete(&lc->oc_sync_wait);\n}"
  },
  {
    "function_name": "version_to_lvb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "817-827",
    "snippet": "static void version_to_lvb(struct ocfs2_protocol_version *ver, char *lvb)\n{\n\tstruct ocfs2_protocol_version *pv =\n\t\t(struct ocfs2_protocol_version *)lvb;\n\t/*\n\t * ocfs2_protocol_version has two u8 variables, so we don't\n\t * need any endian conversion.\n\t */\n\tpv->pv_major = ver->pv_major;\n\tpv->pv_minor = ver->pv_minor;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void version_to_lvb(struct ocfs2_protocol_version *ver, char *lvb)\n{\n\tstruct ocfs2_protocol_version *pv =\n\t\t(struct ocfs2_protocol_version *)lvb;\n\t/*\n\t * ocfs2_protocol_version has two u8 variables, so we don't\n\t * need any endian conversion.\n\t */\n\tpv->pv_major = ver->pv_major;\n\tpv->pv_minor = ver->pv_minor;\n}"
  },
  {
    "function_name": "lvb_to_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "805-815",
    "snippet": "static void lvb_to_version(char *lvb, struct ocfs2_protocol_version *ver)\n{\n\tstruct ocfs2_protocol_version *pv =\n\t\t(struct ocfs2_protocol_version *)lvb;\n\t/*\n\t * ocfs2_protocol_version has two u8 variables, so we don't\n\t * need any endian conversion.\n\t */\n\tver->pv_major = pv->pv_major;\n\tver->pv_minor = pv->pv_minor;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void lvb_to_version(char *lvb, struct ocfs2_protocol_version *ver)\n{\n\tstruct ocfs2_protocol_version *pv =\n\t\t(struct ocfs2_protocol_version *)lvb;\n\t/*\n\t * ocfs2_protocol_version has two u8 variables, so we don't\n\t * need any endian conversion.\n\t */\n\tver->pv_major = pv->pv_major;\n\tver->pv_minor = pv->pv_minor;\n}"
  },
  {
    "function_name": "fs_protocol_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "790-803",
    "snippet": "static int fs_protocol_compare(struct ocfs2_protocol_version *existing,\n\t\t\t       struct ocfs2_protocol_version *request)\n{\n\tif (existing->pv_major != request->pv_major)\n\t\treturn 1;\n\n\tif (existing->pv_minor > request->pv_minor)\n\t\treturn 1;\n\n\tif (existing->pv_minor < request->pv_minor)\n\t\trequest->pv_minor = existing->pv_minor;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int fs_protocol_compare(struct ocfs2_protocol_version *existing,\n\t\t\t       struct ocfs2_protocol_version *request)\n{\n\tif (existing->pv_major != request->pv_major)\n\t\treturn 1;\n\n\tif (existing->pv_minor > request->pv_minor)\n\t\treturn 1;\n\n\tif (existing->pv_minor < request->pv_minor)\n\t\trequest->pv_minor = existing->pv_minor;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "user_plock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "751-780",
    "snippet": "static int user_plock(struct ocfs2_cluster_connection *conn,\n\t\t      u64 ino,\n\t\t      struct file *file,\n\t\t      int cmd,\n\t\t      struct file_lock *fl)\n{\n\t/*\n\t * This more or less just demuxes the plock request into any\n\t * one of three dlm calls.\n\t *\n\t * Internally, fs/dlm will pass these to a misc device, which\n\t * a userspace daemon will read and write to.\n\t *\n\t * For now, cancel requests (which happen internally only),\n\t * are turned into unlocks. Most of this function taken from\n\t * gfs2_lock.\n\t */\n\n\tif (cmd == F_CANCELLK) {\n\t\tcmd = F_SETLK;\n\t\tfl->fl_type = F_UNLCK;\n\t}\n\n\tif (IS_GETLK(cmd))\n\t\treturn dlm_posix_get(conn->cc_lockspace, ino, file, fl);\n\telse if (fl->fl_type == F_UNLCK)\n\t\treturn dlm_posix_unlock(conn->cc_lockspace, ino, file, fl);\n\telse\n\t\treturn dlm_posix_lock(conn->cc_lockspace, ino, file, cmd, fl);\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_posix_lock",
          "args": [
            "conn->cc_lockspace",
            "ino",
            "file",
            "cmd",
            "fl"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_posix_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
          "lines": "104-184",
          "snippet": "int dlm_posix_lock(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t   int cmd, struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tstruct plock_xop *xop;\n\tint rv;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\txop = kzalloc(sizeof(*xop), GFP_NOFS);\n\tif (!xop) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\top = &xop->xop;\n\top->info.optype\t\t= DLM_PLOCK_OP_LOCK;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.ex\t\t= (fl->fl_type == F_WRLCK);\n\top->info.wait\t\t= IS_SETLKW(cmd);\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant) {\n\t\t/* fl_owner is lockd which doesn't distinguish\n\t\t   processes on the nfs client */\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\t\txop->callback\t= fl->fl_lmops->lm_grant;\n\t\tlocks_init_lock(&xop->flc);\n\t\tlocks_copy_lock(&xop->flc, fl);\n\t\txop->fl\t\t= fl;\n\t\txop->file\t= file;\n\t} else {\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\t\txop->callback\t= NULL;\n\t}\n\n\tsend_op(op);\n\n\tif (xop->callback == NULL) {\n\t\trv = wait_event_killable(recv_wq, (op->done != 0));\n\t\tif (rv == -ERESTARTSYS) {\n\t\t\tlog_debug(ls, \"dlm_posix_lock: wait killed %llx\",\n\t\t\t\t  (unsigned long long)number);\n\t\t\tspin_lock(&ops_lock);\n\t\t\tlist_del(&op->list);\n\t\t\tspin_unlock(&ops_lock);\n\t\t\tkfree(xop);\n\t\t\tdo_unlock_close(ls, number, file, fl);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\trv = FILE_LOCK_DEFERRED;\n\t\tgoto out;\n\t}\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_error(ls, \"dlm_posix_lock: op on list %llx\",\n\t\t\t  (unsigned long long)number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\trv = op->info.rv;\n\n\tif (!rv) {\n\t\tif (posix_lock_file_wait(file, fl) < 0)\n\t\t\tlog_error(ls, \"dlm_posix_lock: vfs lock error %llx\",\n\t\t\t\t  (unsigned long long)number);\n\t}\n\n\tkfree(xop);\nout:\n\tdlm_put_lockspace(ls);\n\treturn rv;\n}",
          "includes": [
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <linux/poll.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static spinlock_t ops_lock;",
            "static wait_queue_head_t recv_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\nstatic wait_queue_head_t recv_wq;\n\nint dlm_posix_lock(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t   int cmd, struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tstruct plock_xop *xop;\n\tint rv;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\txop = kzalloc(sizeof(*xop), GFP_NOFS);\n\tif (!xop) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\top = &xop->xop;\n\top->info.optype\t\t= DLM_PLOCK_OP_LOCK;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.ex\t\t= (fl->fl_type == F_WRLCK);\n\top->info.wait\t\t= IS_SETLKW(cmd);\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant) {\n\t\t/* fl_owner is lockd which doesn't distinguish\n\t\t   processes on the nfs client */\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\t\txop->callback\t= fl->fl_lmops->lm_grant;\n\t\tlocks_init_lock(&xop->flc);\n\t\tlocks_copy_lock(&xop->flc, fl);\n\t\txop->fl\t\t= fl;\n\t\txop->file\t= file;\n\t} else {\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\t\txop->callback\t= NULL;\n\t}\n\n\tsend_op(op);\n\n\tif (xop->callback == NULL) {\n\t\trv = wait_event_killable(recv_wq, (op->done != 0));\n\t\tif (rv == -ERESTARTSYS) {\n\t\t\tlog_debug(ls, \"dlm_posix_lock: wait killed %llx\",\n\t\t\t\t  (unsigned long long)number);\n\t\t\tspin_lock(&ops_lock);\n\t\t\tlist_del(&op->list);\n\t\t\tspin_unlock(&ops_lock);\n\t\t\tkfree(xop);\n\t\t\tdo_unlock_close(ls, number, file, fl);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\trv = FILE_LOCK_DEFERRED;\n\t\tgoto out;\n\t}\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_error(ls, \"dlm_posix_lock: op on list %llx\",\n\t\t\t  (unsigned long long)number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\trv = op->info.rv;\n\n\tif (!rv) {\n\t\tif (posix_lock_file_wait(file, fl) < 0)\n\t\t\tlog_error(ls, \"dlm_posix_lock: vfs lock error %llx\",\n\t\t\t\t  (unsigned long long)number);\n\t}\n\n\tkfree(xop);\nout:\n\tdlm_put_lockspace(ls);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_posix_unlock",
          "args": [
            "conn->cc_lockspace",
            "ino",
            "file",
            "fl"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_posix_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
          "lines": "244-315",
          "snippet": "int dlm_posix_unlock(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t     struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tint rv;\n\tunsigned char fl_flags = fl->fl_flags;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* cause the vfs unlock to return ENOENT if lock is not found */\n\tfl->fl_flags |= FL_EXISTS;\n\n\trv = posix_lock_file_wait(file, fl);\n\tif (rv == -ENOENT) {\n\t\trv = 0;\n\t\tgoto out_free;\n\t}\n\tif (rv < 0) {\n\t\tlog_error(ls, \"dlm_posix_unlock: vfs unlock error %d %llx\",\n\t\t\t  rv, (unsigned long long)number);\n\t}\n\n\top->info.optype\t\t= DLM_PLOCK_OP_UNLOCK;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant)\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\telse\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\n\tif (fl->fl_flags & FL_CLOSE) {\n\t\top->info.flags |= DLM_PLOCK_FL_CLOSE;\n\t\tsend_op(op);\n\t\trv = 0;\n\t\tgoto out;\n\t}\n\n\tsend_op(op);\n\twait_event(recv_wq, (op->done != 0));\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_error(ls, \"dlm_posix_unlock: op on list %llx\",\n\t\t\t  (unsigned long long)number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\trv = op->info.rv;\n\n\tif (rv == -ENOENT)\n\t\trv = 0;\n\nout_free:\n\tkfree(op);\nout:\n\tdlm_put_lockspace(ls);\n\tfl->fl_flags = fl_flags;\n\treturn rv;\n}",
          "includes": [
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <linux/poll.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static spinlock_t ops_lock;",
            "static wait_queue_head_t recv_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\nstatic wait_queue_head_t recv_wq;\n\nint dlm_posix_unlock(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t     struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tint rv;\n\tunsigned char fl_flags = fl->fl_flags;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* cause the vfs unlock to return ENOENT if lock is not found */\n\tfl->fl_flags |= FL_EXISTS;\n\n\trv = posix_lock_file_wait(file, fl);\n\tif (rv == -ENOENT) {\n\t\trv = 0;\n\t\tgoto out_free;\n\t}\n\tif (rv < 0) {\n\t\tlog_error(ls, \"dlm_posix_unlock: vfs unlock error %d %llx\",\n\t\t\t  rv, (unsigned long long)number);\n\t}\n\n\top->info.optype\t\t= DLM_PLOCK_OP_UNLOCK;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant)\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\telse\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\n\tif (fl->fl_flags & FL_CLOSE) {\n\t\top->info.flags |= DLM_PLOCK_FL_CLOSE;\n\t\tsend_op(op);\n\t\trv = 0;\n\t\tgoto out;\n\t}\n\n\tsend_op(op);\n\twait_event(recv_wq, (op->done != 0));\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_error(ls, \"dlm_posix_unlock: op on list %llx\",\n\t\t\t  (unsigned long long)number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\trv = op->info.rv;\n\n\tif (rv == -ENOENT)\n\t\trv = 0;\n\nout_free:\n\tkfree(op);\nout:\n\tdlm_put_lockspace(ls);\n\tfl->fl_flags = fl_flags;\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_posix_get",
          "args": [
            "conn->cc_lockspace",
            "ino",
            "file",
            "fl"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_posix_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
          "lines": "318-380",
          "snippet": "int dlm_posix_get(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t  struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tint rv;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\top->info.optype\t\t= DLM_PLOCK_OP_GET;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.ex\t\t= (fl->fl_type == F_WRLCK);\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant)\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\telse\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\n\tsend_op(op);\n\twait_event(recv_wq, (op->done != 0));\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_error(ls, \"dlm_posix_get: op on list %llx\",\n\t\t\t  (unsigned long long)number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\t/* info.rv from userspace is 1 for conflict, 0 for no-conflict,\n\t   -ENOENT if there are no locks on the file */\n\n\trv = op->info.rv;\n\n\tfl->fl_type = F_UNLCK;\n\tif (rv == -ENOENT)\n\t\trv = 0;\n\telse if (rv > 0) {\n\t\tlocks_init_lock(fl);\n\t\tfl->fl_type = (op->info.ex) ? F_WRLCK : F_RDLCK;\n\t\tfl->fl_flags = FL_POSIX;\n\t\tfl->fl_pid = op->info.pid;\n\t\tfl->fl_start = op->info.start;\n\t\tfl->fl_end = op->info.end;\n\t\trv = 0;\n\t}\n\n\tkfree(op);\nout:\n\tdlm_put_lockspace(ls);\n\treturn rv;\n}",
          "includes": [
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <linux/poll.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static spinlock_t ops_lock;",
            "static wait_queue_head_t recv_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\nstatic wait_queue_head_t recv_wq;\n\nint dlm_posix_get(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t  struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tint rv;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\top->info.optype\t\t= DLM_PLOCK_OP_GET;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.ex\t\t= (fl->fl_type == F_WRLCK);\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant)\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\telse\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\n\tsend_op(op);\n\twait_event(recv_wq, (op->done != 0));\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_error(ls, \"dlm_posix_get: op on list %llx\",\n\t\t\t  (unsigned long long)number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\t/* info.rv from userspace is 1 for conflict, 0 for no-conflict,\n\t   -ENOENT if there are no locks on the file */\n\n\trv = op->info.rv;\n\n\tfl->fl_type = F_UNLCK;\n\tif (rv == -ENOENT)\n\t\trv = 0;\n\telse if (rv > 0) {\n\t\tlocks_init_lock(fl);\n\t\tfl->fl_type = (op->info.ex) ? F_WRLCK : F_RDLCK;\n\t\tfl->fl_flags = FL_POSIX;\n\t\tfl->fl_pid = op->info.pid;\n\t\tfl->fl_start = op->info.start;\n\t\tfl->fl_end = op->info.end;\n\t\trv = 0;\n\t}\n\n\tkfree(op);\nout:\n\tdlm_put_lockspace(ls);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_GETLK",
          "args": [
            "cmd"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int user_plock(struct ocfs2_cluster_connection *conn,\n\t\t      u64 ino,\n\t\t      struct file *file,\n\t\t      int cmd,\n\t\t      struct file_lock *fl)\n{\n\t/*\n\t * This more or less just demuxes the plock request into any\n\t * one of three dlm calls.\n\t *\n\t * Internally, fs/dlm will pass these to a misc device, which\n\t * a userspace daemon will read and write to.\n\t *\n\t * For now, cancel requests (which happen internally only),\n\t * are turned into unlocks. Most of this function taken from\n\t * gfs2_lock.\n\t */\n\n\tif (cmd == F_CANCELLK) {\n\t\tcmd = F_SETLK;\n\t\tfl->fl_type = F_UNLCK;\n\t}\n\n\tif (IS_GETLK(cmd))\n\t\treturn dlm_posix_get(conn->cc_lockspace, ino, file, fl);\n\telse if (fl->fl_type == F_UNLCK)\n\t\treturn dlm_posix_unlock(conn->cc_lockspace, ino, file, fl);\n\telse\n\t\treturn dlm_posix_lock(conn->cc_lockspace, ino, file, cmd, fl);\n}"
  },
  {
    "function_name": "user_dlm_dump_lksb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "747-749",
    "snippet": "static void user_dlm_dump_lksb(struct ocfs2_dlm_lksb *lksb)\n{\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void user_dlm_dump_lksb(struct ocfs2_dlm_lksb *lksb)\n{\n}"
  },
  {
    "function_name": "user_dlm_lvb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "739-745",
    "snippet": "static void *user_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\tif (!lksb->lksb_fsdlm.sb_lvbptr)\n\t\tlksb->lksb_fsdlm.sb_lvbptr = (char *)lksb +\n\t\t\t\t\t     sizeof(struct dlm_lksb);\n\treturn (void *)(lksb->lksb_fsdlm.sb_lvbptr);\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void *user_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\tif (!lksb->lksb_fsdlm.sb_lvbptr)\n\t\tlksb->lksb_fsdlm.sb_lvbptr = (char *)lksb +\n\t\t\t\t\t     sizeof(struct dlm_lksb);\n\treturn (void *)(lksb->lksb_fsdlm.sb_lvbptr);\n}"
  },
  {
    "function_name": "user_dlm_lvb_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "732-737",
    "snippet": "static int user_dlm_lvb_valid(struct ocfs2_dlm_lksb *lksb)\n{\n\tint invalid = lksb->lksb_fsdlm.sb_flags & DLM_SBF_VALNOTVALID;\n\n\treturn !invalid;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int user_dlm_lvb_valid(struct ocfs2_dlm_lksb *lksb)\n{\n\tint invalid = lksb->lksb_fsdlm.sb_flags & DLM_SBF_VALNOTVALID;\n\n\treturn !invalid;\n}"
  },
  {
    "function_name": "user_dlm_lock_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "727-730",
    "snippet": "static int user_dlm_lock_status(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn lksb->lksb_fsdlm.sb_status;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int user_dlm_lock_status(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn lksb->lksb_fsdlm.sb_status;\n}"
  },
  {
    "function_name": "user_dlm_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "716-725",
    "snippet": "static int user_dlm_unlock(struct ocfs2_cluster_connection *conn,\n\t\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t\t   u32 flags)\n{\n\tint ret;\n\n\tret = dlm_unlock(conn->cc_lockspace, lksb->lksb_fsdlm.sb_lkid,\n\t\t\t flags, &lksb->lksb_fsdlm, lksb);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_unlock",
          "args": [
            "conn->cc_lockspace",
            "lksb->lksb_fsdlm.sb_lkid",
            "flags",
            "&lksb->lksb_fsdlm",
            "lksb"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3462-3502",
          "snippet": "int dlm_unlock(dlm_lockspace_t *lockspace,\n\t       uint32_t lkid,\n\t       uint32_t flags,\n\t       struct dlm_lksb *lksb,\n\t       void *astarg)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\terror = set_unlock_args(flags, astarg, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\terror = cancel_lock(ls, lkb, &args);\n\telse\n\t\terror = unlock_lock(ls, lkb, &args);\n\n\tif (error == -DLM_EUNLOCK || error == -DLM_ECANCEL)\n\t\terror = 0;\n\tif (error == -EBUSY && (flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)))\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_unlock(dlm_lockspace_t *lockspace,\n\t       uint32_t lkid,\n\t       uint32_t flags,\n\t       struct dlm_lksb *lksb,\n\t       void *astarg)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\terror = set_unlock_args(flags, astarg, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\terror = cancel_lock(ls, lkb, &args);\n\telse\n\t\terror = unlock_lock(ls, lkb, &args);\n\n\tif (error == -DLM_EUNLOCK || error == -DLM_ECANCEL)\n\t\terror = 0;\n\tif (error == -EBUSY && (flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)))\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int user_dlm_unlock(struct ocfs2_cluster_connection *conn,\n\t\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t\t   u32 flags)\n{\n\tint ret;\n\n\tret = dlm_unlock(conn->cc_lockspace, lksb->lksb_fsdlm.sb_lkid,\n\t\t\t flags, &lksb->lksb_fsdlm, lksb);\n\treturn ret;\n}"
  },
  {
    "function_name": "user_dlm_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "696-714",
    "snippet": "static int user_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t\t int mode,\n\t\t\t struct ocfs2_dlm_lksb *lksb,\n\t\t\t u32 flags,\n\t\t\t void *name,\n\t\t\t unsigned int namelen)\n{\n\tint ret;\n\n\tif (!lksb->lksb_fsdlm.sb_lvbptr)\n\t\tlksb->lksb_fsdlm.sb_lvbptr = (char *)lksb +\n\t\t\t\t\t     sizeof(struct dlm_lksb);\n\n\tret = dlm_lock(conn->cc_lockspace, mode, &lksb->lksb_fsdlm,\n\t\t       flags|DLM_LKF_NODLCKWT, name, namelen, 0,\n\t\t       fsdlm_lock_ast_wrapper, lksb,\n\t\t       fsdlm_blocking_ast_wrapper);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lock",
          "args": [
            "conn->cc_lockspace",
            "mode",
            "&lksb->lksb_fsdlm",
            "flags|DLM_LKF_NODLCKWT",
            "name",
            "namelen",
            "0",
            "fsdlm_lock_ast_wrapper",
            "lksb",
            "fsdlm_blocking_ast_wrapper"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3409-3460",
          "snippet": "int dlm_lock(dlm_lockspace_t *lockspace,\n\t     int mode,\n\t     struct dlm_lksb *lksb,\n\t     uint32_t flags,\n\t     void *name,\n\t     unsigned int namelen,\n\t     uint32_t parent_lkid,\n\t     void (*ast) (void *astarg),\n\t     void *astarg,\n\t     void (*bast) (void *astarg, int mode))\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error, convert = flags & DLM_LKF_CONVERT;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\tif (convert)\n\t\terror = find_lkb(ls, lksb->sb_lkid, &lkb);\n\telse\n\t\terror = create_lkb(ls, &lkb);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = set_lock_args(mode, lksb, flags, namelen, 0, ast,\n\t\t\t      astarg, bast, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (convert)\n\t\terror = convert_lock(ls, lkb, &args);\n\telse\n\t\terror = request_lock(ls, lkb, name, namelen, &args);\n\n\tif (error == -EINPROGRESS)\n\t\terror = 0;\n out_put:\n\tif (convert || error)\n\t\t__put_lkb(ls, lkb);\n\tif (error == -EAGAIN || error == -EDEADLK)\n\t\terror = 0;\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_lock(dlm_lockspace_t *lockspace,\n\t     int mode,\n\t     struct dlm_lksb *lksb,\n\t     uint32_t flags,\n\t     void *name,\n\t     unsigned int namelen,\n\t     uint32_t parent_lkid,\n\t     void (*ast) (void *astarg),\n\t     void *astarg,\n\t     void (*bast) (void *astarg, int mode))\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error, convert = flags & DLM_LKF_CONVERT;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\tif (convert)\n\t\terror = find_lkb(ls, lksb->sb_lkid, &lkb);\n\telse\n\t\terror = create_lkb(ls, &lkb);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = set_lock_args(mode, lksb, flags, namelen, 0, ast,\n\t\t\t      astarg, bast, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (convert)\n\t\terror = convert_lock(ls, lkb, &args);\n\telse\n\t\terror = request_lock(ls, lkb, name, namelen, &args);\n\n\tif (error == -EINPROGRESS)\n\t\terror = 0;\n out_put:\n\tif (convert || error)\n\t\t__put_lkb(ls, lkb);\n\tif (error == -EAGAIN || error == -EDEADLK)\n\t\terror = 0;\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int user_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t\t int mode,\n\t\t\t struct ocfs2_dlm_lksb *lksb,\n\t\t\t u32 flags,\n\t\t\t void *name,\n\t\t\t unsigned int namelen)\n{\n\tint ret;\n\n\tif (!lksb->lksb_fsdlm.sb_lvbptr)\n\t\tlksb->lksb_fsdlm.sb_lvbptr = (char *)lksb +\n\t\t\t\t\t     sizeof(struct dlm_lksb);\n\n\tret = dlm_lock(conn->cc_lockspace, mode, &lksb->lksb_fsdlm,\n\t\t       flags|DLM_LKF_NODLCKWT, name, namelen, 0,\n\t\t       fsdlm_lock_ast_wrapper, lksb,\n\t\t       fsdlm_blocking_ast_wrapper);\n\treturn ret;\n}"
  },
  {
    "function_name": "fsdlm_blocking_ast_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "689-694",
    "snippet": "static void fsdlm_blocking_ast_wrapper(void *astarg, int level)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\n\tlksb->lksb_conn->cc_proto->lp_blocking_ast(lksb, level);\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lksb->lksb_conn->cc_proto->lp_blocking_ast",
          "args": [
            "lksb",
            "level"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fsdlm_blocking_ast_wrapper(void *astarg, int level)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\n\tlksb->lksb_conn->cc_proto->lp_blocking_ast(lksb, level);\n}"
  },
  {
    "function_name": "fsdlm_lock_ast_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "668-687",
    "snippet": "static void fsdlm_lock_ast_wrapper(void *astarg)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\tint status = lksb->lksb_fsdlm.sb_status;\n\n\t/*\n\t * For now we're punting on the issue of other non-standard errors\n\t * where we can't tell if the unlock_ast or lock_ast should be called.\n\t * The main \"other error\" that's possible is EINVAL which means the\n\t * function was called with invalid args, which shouldn't be possible\n\t * since the caller here is under our control.  Other non-standard\n\t * errors probably fall into the same category, or otherwise are fatal\n\t * which means we can't carry on anyway.\n\t */\n\n\tif (status == -DLM_EUNLOCK || status == -DLM_ECANCEL)\n\t\tlksb->lksb_conn->cc_proto->lp_unlock_ast(lksb, 0);\n\telse\n\t\tlksb->lksb_conn->cc_proto->lp_lock_ast(lksb);\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lksb->lksb_conn->cc_proto->lp_lock_ast",
          "args": [
            "lksb"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lksb->lksb_conn->cc_proto->lp_unlock_ast",
          "args": [
            "lksb",
            "0"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fsdlm_lock_ast_wrapper(void *astarg)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\tint status = lksb->lksb_fsdlm.sb_status;\n\n\t/*\n\t * For now we're punting on the issue of other non-standard errors\n\t * where we can't tell if the unlock_ast or lock_ast should be called.\n\t * The main \"other error\" that's possible is EINVAL which means the\n\t * function was called with invalid args, which shouldn't be possible\n\t * since the caller here is under our control.  Other non-standard\n\t * errors probably fall into the same category, or otherwise are fatal\n\t * which means we can't carry on anyway.\n\t */\n\n\tif (status == -DLM_EUNLOCK || status == -DLM_ECANCEL)\n\t\tlksb->lksb_conn->cc_proto->lp_unlock_ast(lksb, 0);\n\telse\n\t\tlksb->lksb_conn->cc_proto->lp_lock_ast(lksb);\n}"
  },
  {
    "function_name": "ocfs2_control_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "656-666",
    "snippet": "static void ocfs2_control_exit(void)\n{\n\tint rc;\n\n\trc = misc_deregister(&ocfs2_control_device);\n\tif (rc)\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Unable to deregister ocfs2_control device \"\n\t\t       \"(errno %d)\\n\",\n\t\t       -rc);\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct miscdevice ocfs2_control_device = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"ocfs2_control\",\n\t.fops\t\t= &ocfs2_control_fops,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"ocfs2: Unable to deregister ocfs2_control device \"\n\t\t       \"(errno %d)\\n\"",
            "-rc"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "misc_deregister",
          "args": [
            "&ocfs2_control_device"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct miscdevice ocfs2_control_device = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"ocfs2_control\",\n\t.fops\t\t= &ocfs2_control_fops,\n};\n\nstatic void ocfs2_control_exit(void)\n{\n\tint rc;\n\n\trc = misc_deregister(&ocfs2_control_device);\n\tif (rc)\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Unable to deregister ocfs2_control device \"\n\t\t       \"(errno %d)\\n\",\n\t\t       -rc);\n}"
  },
  {
    "function_name": "ocfs2_control_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "640-654",
    "snippet": "static int ocfs2_control_init(void)\n{\n\tint rc;\n\n\tatomic_set(&ocfs2_control_opened, 0);\n\n\trc = misc_register(&ocfs2_control_device);\n\tif (rc)\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Unable to register ocfs2_control device \"\n\t\t       \"(errno %d)\\n\",\n\t\t       -rc);\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t ocfs2_control_opened;",
      "static struct miscdevice ocfs2_control_device = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"ocfs2_control\",\n\t.fops\t\t= &ocfs2_control_fops,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"ocfs2: Unable to register ocfs2_control device \"\n\t\t       \"(errno %d)\\n\"",
            "-rc"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "misc_register",
          "args": [
            "&ocfs2_control_device"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ocfs2_control_opened",
            "0"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic atomic_t ocfs2_control_opened;\nstatic struct miscdevice ocfs2_control_device = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"ocfs2_control\",\n\t.fops\t\t= &ocfs2_control_fops,\n};\n\nstatic int ocfs2_control_init(void)\n{\n\tint rc;\n\n\tatomic_set(&ocfs2_control_opened, 0);\n\n\trc = misc_register(&ocfs2_control_device);\n\tif (rc)\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Unable to register ocfs2_control device \"\n\t\t       \"(errno %d)\\n\",\n\t\t       -rc);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_control_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "608-623",
    "snippet": "static int ocfs2_control_open(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_control_private *p;\n\n\tp = kzalloc(sizeof(struct ocfs2_control_private), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\tp->op_this_node = -1;\n\n\tmutex_lock(&ocfs2_control_lock);\n\tfile->private_data = p;\n\tlist_add(&p->op_list, &ocfs2_control_private_list);\n\tmutex_unlock(&ocfs2_control_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(ocfs2_control_private_list);",
      "static DEFINE_MUTEX(ocfs2_control_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ocfs2_control_lock"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&p->op_list",
            "&ocfs2_control_private_list"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ocfs2_control_lock"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_control_private)",
            "GFP_KERNEL"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(ocfs2_control_private_list);\nstatic DEFINE_MUTEX(ocfs2_control_lock);\n\nstatic int ocfs2_control_open(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_control_private *p;\n\n\tp = kzalloc(sizeof(struct ocfs2_control_private), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\tp->op_this_node = -1;\n\n\tmutex_lock(&ocfs2_control_lock);\n\tfile->private_data = p;\n\tlist_add(&p->op_list, &ocfs2_control_private_list);\n\tmutex_unlock(&ocfs2_control_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_control_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "569-606",
    "snippet": "static int ocfs2_control_release(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\n\tmutex_lock(&ocfs2_control_lock);\n\n\tif (ocfs2_control_get_handshake_state(file) !=\n\t    OCFS2_CONTROL_HANDSHAKE_VALID)\n\t\tgoto out;\n\n\tif (atomic_dec_and_test(&ocfs2_control_opened)) {\n\t\tif (!list_empty(&ocfs2_live_connection_list)) {\n\t\t\t/* XXX: Do bad things! */\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"ocfs2: Unexpected release of ocfs2_control!\\n\"\n\t\t\t       \"       Loss of cluster connection requires \"\n\t\t\t       \"an emergency restart!\\n\");\n\t\t\temergency_restart();\n\t\t}\n\t\t/*\n\t\t * Last valid close clears the node number and resets\n\t\t * the locking protocol version\n\t\t */\n\t\tocfs2_control_this_node = -1;\n\t\trunning_proto.pv_major = 0;\n\t\trunning_proto.pv_minor = 0;\n\t}\n\nout:\n\tlist_del_init(&p->op_list);\n\tfile->private_data = NULL;\n\n\tmutex_unlock(&ocfs2_control_lock);\n\n\tkfree(p);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define OCFS2_CONTROL_HANDSHAKE_VALID\t\t(3)"
    ],
    "globals_used": [
      "static atomic_t ocfs2_control_opened;",
      "static int ocfs2_control_this_node = -1;",
      "static struct ocfs2_protocol_version running_proto;",
      "static LIST_HEAD(ocfs2_live_connection_list);",
      "static DEFINE_MUTEX(ocfs2_control_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ocfs2_control_lock"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&p->op_list"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emergency_restart",
          "args": [],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\t       \"ocfs2: Unexpected release of ocfs2_control!\\n\"\n\t\t\t       \"       Loss of cluster connection requires \"\n\t\t\t       \"an emergency restart!\\n\""
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ocfs2_live_connection_list"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&ocfs2_control_opened"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_control_get_handshake_state",
          "args": [
            "file"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_get_handshake_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "188-192",
          "snippet": "static inline int ocfs2_control_get_handshake_state(struct file *file)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\treturn p->op_state;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int ocfs2_control_get_handshake_state(struct file *file)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\treturn p->op_state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ocfs2_control_lock"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define OCFS2_CONTROL_HANDSHAKE_VALID\t\t(3)\n\nstatic atomic_t ocfs2_control_opened;\nstatic int ocfs2_control_this_node = -1;\nstatic struct ocfs2_protocol_version running_proto;\nstatic LIST_HEAD(ocfs2_live_connection_list);\nstatic DEFINE_MUTEX(ocfs2_control_lock);\n\nstatic int ocfs2_control_release(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\n\tmutex_lock(&ocfs2_control_lock);\n\n\tif (ocfs2_control_get_handshake_state(file) !=\n\t    OCFS2_CONTROL_HANDSHAKE_VALID)\n\t\tgoto out;\n\n\tif (atomic_dec_and_test(&ocfs2_control_opened)) {\n\t\tif (!list_empty(&ocfs2_live_connection_list)) {\n\t\t\t/* XXX: Do bad things! */\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"ocfs2: Unexpected release of ocfs2_control!\\n\"\n\t\t\t       \"       Loss of cluster connection requires \"\n\t\t\t       \"an emergency restart!\\n\");\n\t\t\temergency_restart();\n\t\t}\n\t\t/*\n\t\t * Last valid close clears the node number and resets\n\t\t * the locking protocol version\n\t\t */\n\t\tocfs2_control_this_node = -1;\n\t\trunning_proto.pv_major = 0;\n\t\trunning_proto.pv_minor = 0;\n\t}\n\nout:\n\tlist_del_init(&p->op_list);\n\tfile->private_data = NULL;\n\n\tmutex_unlock(&ocfs2_control_lock);\n\n\tkfree(p);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_control_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "551-567",
    "snippet": "static ssize_t ocfs2_control_read(struct file *file,\n\t\t\t\t  char __user *buf,\n\t\t\t\t  size_t count,\n\t\t\t\t  loff_t *ppos)\n{\n\tssize_t ret;\n\n\tret = simple_read_from_buffer(buf, count, ppos,\n\t\t\tOCFS2_CONTROL_PROTO, OCFS2_CONTROL_PROTO_LEN);\n\n\t/* Have we read the whole protocol list? */\n\tif (ret > 0 && *ppos >= OCFS2_CONTROL_PROTO_LEN)\n\t\tocfs2_control_set_handshake_state(file,\n\t\t\t\t\t\t  OCFS2_CONTROL_HANDSHAKE_READ);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define OCFS2_CONTROL_HANDSHAKE_READ\t\t(1)",
      "#define OCFS2_CONTROL_PROTO_LEN\t\t\t4",
      "#define OCFS2_CONTROL_PROTO\t\t\t\"T01\\n\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_control_set_handshake_state",
          "args": [
            "file",
            "OCFS2_CONTROL_HANDSHAKE_READ"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_set_handshake_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "181-186",
          "snippet": "static inline void ocfs2_control_set_handshake_state(struct file *file,\n\t\t\t\t\t\t     int state)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\tp->op_state = state;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline void ocfs2_control_set_handshake_state(struct file *file,\n\t\t\t\t\t\t     int state)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\tp->op_state = state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "OCFS2_CONTROL_PROTO",
            "OCFS2_CONTROL_PROTO_LEN"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "590-608",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define OCFS2_CONTROL_HANDSHAKE_READ\t\t(1)\n#define OCFS2_CONTROL_PROTO_LEN\t\t\t4\n#define OCFS2_CONTROL_PROTO\t\t\t\"T01\\n\"\n\nstatic ssize_t ocfs2_control_read(struct file *file,\n\t\t\t\t  char __user *buf,\n\t\t\t\t  size_t count,\n\t\t\t\t  loff_t *ppos)\n{\n\tssize_t ret;\n\n\tret = simple_read_from_buffer(buf, count, ppos,\n\t\t\tOCFS2_CONTROL_PROTO, OCFS2_CONTROL_PROTO_LEN);\n\n\t/* Have we read the whole protocol list? */\n\tif (ret > 0 && *ppos >= OCFS2_CONTROL_PROTO_LEN)\n\t\tocfs2_control_set_handshake_state(file,\n\t\t\t\t\t\t  OCFS2_CONTROL_HANDSHAKE_READ);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_control_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "516-545",
    "snippet": "static ssize_t ocfs2_control_write(struct file *file,\n\t\t\t\t   const char __user *buf,\n\t\t\t\t   size_t count,\n\t\t\t\t   loff_t *ppos)\n{\n\tssize_t ret;\n\n\tswitch (ocfs2_control_get_handshake_state(file)) {\n\t\tcase OCFS2_CONTROL_HANDSHAKE_INVALID:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\n\t\tcase OCFS2_CONTROL_HANDSHAKE_READ:\n\t\t\tret = ocfs2_control_validate_protocol(file, buf,\n\t\t\t\t\t\t\t      count);\n\t\t\tbreak;\n\n\t\tcase OCFS2_CONTROL_HANDSHAKE_PROTOCOL:\n\t\tcase OCFS2_CONTROL_HANDSHAKE_VALID:\n\t\t\tret = ocfs2_control_message(file, buf, count);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define OCFS2_CONTROL_HANDSHAKE_VALID\t\t(3)",
      "#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)",
      "#define OCFS2_CONTROL_HANDSHAKE_READ\t\t(1)",
      "#define OCFS2_CONTROL_HANDSHAKE_INVALID\t\t(0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_control_message",
          "args": [
            "file",
            "buf",
            "count"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "481-514",
          "snippet": "static ssize_t ocfs2_control_message(struct file *file,\n\t\t\t\t     const char __user *buf,\n\t\t\t\t     size_t count)\n{\n\tssize_t ret;\n\tunion ocfs2_control_message msg;\n\n\t/* Try to catch padding issues */\n\tWARN_ON(offsetof(struct ocfs2_control_message_down, uuid) !=\n\t\t(sizeof(msg.u_down.tag) + sizeof(msg.u_down.space1)));\n\n\tmemset(&msg, 0, sizeof(union ocfs2_control_message));\n\tret = ocfs2_control_cfu(&msg, count, buf, count);\n\tif (ret)\n\t\tgoto out;\n\n\tif ((count == OCFS2_CONTROL_MESSAGE_SETNODE_TOTAL_LEN) &&\n\t    !strncmp(msg.tag, OCFS2_CONTROL_MESSAGE_SETNODE_OP,\n\t\t     OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\tret = ocfs2_control_do_setnode_msg(file, &msg.u_setn);\n\telse if ((count == OCFS2_CONTROL_MESSAGE_SETVERSION_TOTAL_LEN) &&\n\t\t !strncmp(msg.tag, OCFS2_CONTROL_MESSAGE_SETVERSION_OP,\n\t\t\t  OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\tret = ocfs2_control_do_setversion_msg(file, &msg.u_setv);\n\telse if ((count == OCFS2_CONTROL_MESSAGE_DOWN_TOTAL_LEN) &&\n\t\t !strncmp(msg.tag, OCFS2_CONTROL_MESSAGE_DOWN_OP,\n\t\t\t  OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\tret = ocfs2_control_do_down_msg(file, &msg.u_down);\n\telse\n\t\tret = -EINVAL;\n\nout:\n\treturn ret ? ret : count;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define OCFS2_CONTROL_MESSAGE_DOWN_TOTAL_LEN\t47",
            "#define OCFS2_CONTROL_MESSAGE_DOWN_OP\t\t\"DOWN\"",
            "#define OCFS2_CONTROL_MESSAGE_SETVERSION_TOTAL_LEN\t11",
            "#define OCFS2_CONTROL_MESSAGE_SETVERSION_OP\t\"SETV\"",
            "#define OCFS2_CONTROL_MESSAGE_SETNODE_TOTAL_LEN\t14",
            "#define OCFS2_CONTROL_MESSAGE_SETNODE_OP\t\"SETN\"",
            "#define OCFS2_CONTROL_MESSAGE_OP_LEN\t\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define OCFS2_CONTROL_MESSAGE_DOWN_TOTAL_LEN\t47\n#define OCFS2_CONTROL_MESSAGE_DOWN_OP\t\t\"DOWN\"\n#define OCFS2_CONTROL_MESSAGE_SETVERSION_TOTAL_LEN\t11\n#define OCFS2_CONTROL_MESSAGE_SETVERSION_OP\t\"SETV\"\n#define OCFS2_CONTROL_MESSAGE_SETNODE_TOTAL_LEN\t14\n#define OCFS2_CONTROL_MESSAGE_SETNODE_OP\t\"SETN\"\n#define OCFS2_CONTROL_MESSAGE_OP_LEN\t\t4\n\nstatic ssize_t ocfs2_control_message(struct file *file,\n\t\t\t\t     const char __user *buf,\n\t\t\t\t     size_t count)\n{\n\tssize_t ret;\n\tunion ocfs2_control_message msg;\n\n\t/* Try to catch padding issues */\n\tWARN_ON(offsetof(struct ocfs2_control_message_down, uuid) !=\n\t\t(sizeof(msg.u_down.tag) + sizeof(msg.u_down.space1)));\n\n\tmemset(&msg, 0, sizeof(union ocfs2_control_message));\n\tret = ocfs2_control_cfu(&msg, count, buf, count);\n\tif (ret)\n\t\tgoto out;\n\n\tif ((count == OCFS2_CONTROL_MESSAGE_SETNODE_TOTAL_LEN) &&\n\t    !strncmp(msg.tag, OCFS2_CONTROL_MESSAGE_SETNODE_OP,\n\t\t     OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\tret = ocfs2_control_do_setnode_msg(file, &msg.u_setn);\n\telse if ((count == OCFS2_CONTROL_MESSAGE_SETVERSION_TOTAL_LEN) &&\n\t\t !strncmp(msg.tag, OCFS2_CONTROL_MESSAGE_SETVERSION_OP,\n\t\t\t  OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\tret = ocfs2_control_do_setversion_msg(file, &msg.u_setv);\n\telse if ((count == OCFS2_CONTROL_MESSAGE_DOWN_TOTAL_LEN) &&\n\t\t !strncmp(msg.tag, OCFS2_CONTROL_MESSAGE_DOWN_OP,\n\t\t\t  OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\tret = ocfs2_control_do_down_msg(file, &msg.u_down);\n\telse\n\t\tret = -EINVAL;\n\nout:\n\treturn ret ? ret : count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_control_validate_protocol",
          "args": [
            "file",
            "buf",
            "count"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_validate_protocol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "263-282",
          "snippet": "static ssize_t ocfs2_control_validate_protocol(struct file *file,\n\t\t\t\t\t       const char __user *buf,\n\t\t\t\t\t       size_t count)\n{\n\tssize_t ret;\n\tchar kbuf[OCFS2_CONTROL_PROTO_LEN];\n\n\tret = ocfs2_control_cfu(kbuf, OCFS2_CONTROL_PROTO_LEN,\n\t\t\t\tbuf, count);\n\tif (ret)\n\t\treturn ret;\n\n\tif (strncmp(kbuf, OCFS2_CONTROL_PROTO, OCFS2_CONTROL_PROTO_LEN))\n\t\treturn -EINVAL;\n\n\tocfs2_control_set_handshake_state(file,\n\t\t\t\t\t  OCFS2_CONTROL_HANDSHAKE_PROTOCOL);\n\n\treturn count;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)",
            "#define OCFS2_CONTROL_PROTO_LEN\t\t\t4",
            "#define OCFS2_CONTROL_PROTO\t\t\t\"T01\\n\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)\n#define OCFS2_CONTROL_PROTO_LEN\t\t\t4\n#define OCFS2_CONTROL_PROTO\t\t\t\"T01\\n\"\n\nstatic ssize_t ocfs2_control_validate_protocol(struct file *file,\n\t\t\t\t\t       const char __user *buf,\n\t\t\t\t\t       size_t count)\n{\n\tssize_t ret;\n\tchar kbuf[OCFS2_CONTROL_PROTO_LEN];\n\n\tret = ocfs2_control_cfu(kbuf, OCFS2_CONTROL_PROTO_LEN,\n\t\t\t\tbuf, count);\n\tif (ret)\n\t\treturn ret;\n\n\tif (strncmp(kbuf, OCFS2_CONTROL_PROTO, OCFS2_CONTROL_PROTO_LEN))\n\t\treturn -EINVAL;\n\n\tocfs2_control_set_handshake_state(file,\n\t\t\t\t\t  OCFS2_CONTROL_HANDSHAKE_PROTOCOL);\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_control_get_handshake_state",
          "args": [
            "file"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_get_handshake_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "188-192",
          "snippet": "static inline int ocfs2_control_get_handshake_state(struct file *file)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\treturn p->op_state;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int ocfs2_control_get_handshake_state(struct file *file)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\treturn p->op_state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define OCFS2_CONTROL_HANDSHAKE_VALID\t\t(3)\n#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)\n#define OCFS2_CONTROL_HANDSHAKE_READ\t\t(1)\n#define OCFS2_CONTROL_HANDSHAKE_INVALID\t\t(0)\n\nstatic ssize_t ocfs2_control_write(struct file *file,\n\t\t\t\t   const char __user *buf,\n\t\t\t\t   size_t count,\n\t\t\t\t   loff_t *ppos)\n{\n\tssize_t ret;\n\n\tswitch (ocfs2_control_get_handshake_state(file)) {\n\t\tcase OCFS2_CONTROL_HANDSHAKE_INVALID:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\n\t\tcase OCFS2_CONTROL_HANDSHAKE_READ:\n\t\t\tret = ocfs2_control_validate_protocol(file, buf,\n\t\t\t\t\t\t\t      count);\n\t\t\tbreak;\n\n\t\tcase OCFS2_CONTROL_HANDSHAKE_PROTOCOL:\n\t\tcase OCFS2_CONTROL_HANDSHAKE_VALID:\n\t\t\tret = ocfs2_control_message(file, buf, count);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_control_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "481-514",
    "snippet": "static ssize_t ocfs2_control_message(struct file *file,\n\t\t\t\t     const char __user *buf,\n\t\t\t\t     size_t count)\n{\n\tssize_t ret;\n\tunion ocfs2_control_message msg;\n\n\t/* Try to catch padding issues */\n\tWARN_ON(offsetof(struct ocfs2_control_message_down, uuid) !=\n\t\t(sizeof(msg.u_down.tag) + sizeof(msg.u_down.space1)));\n\n\tmemset(&msg, 0, sizeof(union ocfs2_control_message));\n\tret = ocfs2_control_cfu(&msg, count, buf, count);\n\tif (ret)\n\t\tgoto out;\n\n\tif ((count == OCFS2_CONTROL_MESSAGE_SETNODE_TOTAL_LEN) &&\n\t    !strncmp(msg.tag, OCFS2_CONTROL_MESSAGE_SETNODE_OP,\n\t\t     OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\tret = ocfs2_control_do_setnode_msg(file, &msg.u_setn);\n\telse if ((count == OCFS2_CONTROL_MESSAGE_SETVERSION_TOTAL_LEN) &&\n\t\t !strncmp(msg.tag, OCFS2_CONTROL_MESSAGE_SETVERSION_OP,\n\t\t\t  OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\tret = ocfs2_control_do_setversion_msg(file, &msg.u_setv);\n\telse if ((count == OCFS2_CONTROL_MESSAGE_DOWN_TOTAL_LEN) &&\n\t\t !strncmp(msg.tag, OCFS2_CONTROL_MESSAGE_DOWN_OP,\n\t\t\t  OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\tret = ocfs2_control_do_down_msg(file, &msg.u_down);\n\telse\n\t\tret = -EINVAL;\n\nout:\n\treturn ret ? ret : count;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define OCFS2_CONTROL_MESSAGE_DOWN_TOTAL_LEN\t47",
      "#define OCFS2_CONTROL_MESSAGE_DOWN_OP\t\t\"DOWN\"",
      "#define OCFS2_CONTROL_MESSAGE_SETVERSION_TOTAL_LEN\t11",
      "#define OCFS2_CONTROL_MESSAGE_SETVERSION_OP\t\"SETV\"",
      "#define OCFS2_CONTROL_MESSAGE_SETNODE_TOTAL_LEN\t14",
      "#define OCFS2_CONTROL_MESSAGE_SETNODE_OP\t\"SETN\"",
      "#define OCFS2_CONTROL_MESSAGE_OP_LEN\t\t4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_control_do_down_msg",
          "args": [
            "file",
            "&msg.u_down"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_do_down_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "449-479",
          "snippet": "static int ocfs2_control_do_down_msg(struct file *file,\n\t\t\t\t     struct ocfs2_control_message_down *msg)\n{\n\tlong nodenum;\n\tchar *p = NULL;\n\n\tif (ocfs2_control_get_handshake_state(file) !=\n\t    OCFS2_CONTROL_HANDSHAKE_VALID)\n\t\treturn -EINVAL;\n\n\tif (strncmp(msg->tag, OCFS2_CONTROL_MESSAGE_DOWN_OP,\n\t\t    OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\treturn -EINVAL;\n\n\tif ((msg->space1 != ' ') || (msg->space2 != ' ') ||\n\t    (msg->newline != '\\n'))\n\t\treturn -EINVAL;\n\tmsg->space1 = msg->space2 = msg->newline = '\\0';\n\n\tnodenum = simple_strtol(msg->nodestr, &p, 16);\n\tif (!p || *p)\n\t\treturn -EINVAL;\n\n\tif ((nodenum == LONG_MIN) || (nodenum == LONG_MAX) ||\n\t    (nodenum > INT_MAX) || (nodenum < 0))\n\t\treturn -ERANGE;\n\n\tocfs2_control_send_down(msg->uuid, nodenum);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define OCFS2_CONTROL_MESSAGE_DOWN_OP\t\t\"DOWN\"",
            "#define OCFS2_CONTROL_MESSAGE_OP_LEN\t\t4",
            "#define OCFS2_CONTROL_HANDSHAKE_VALID\t\t(3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define OCFS2_CONTROL_MESSAGE_DOWN_OP\t\t\"DOWN\"\n#define OCFS2_CONTROL_MESSAGE_OP_LEN\t\t4\n#define OCFS2_CONTROL_HANDSHAKE_VALID\t\t(3)\n\nstatic int ocfs2_control_do_down_msg(struct file *file,\n\t\t\t\t     struct ocfs2_control_message_down *msg)\n{\n\tlong nodenum;\n\tchar *p = NULL;\n\n\tif (ocfs2_control_get_handshake_state(file) !=\n\t    OCFS2_CONTROL_HANDSHAKE_VALID)\n\t\treturn -EINVAL;\n\n\tif (strncmp(msg->tag, OCFS2_CONTROL_MESSAGE_DOWN_OP,\n\t\t    OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\treturn -EINVAL;\n\n\tif ((msg->space1 != ' ') || (msg->space2 != ' ') ||\n\t    (msg->newline != '\\n'))\n\t\treturn -EINVAL;\n\tmsg->space1 = msg->space2 = msg->newline = '\\0';\n\n\tnodenum = simple_strtol(msg->nodestr, &p, 16);\n\tif (!p || *p)\n\t\treturn -EINVAL;\n\n\tif ((nodenum == LONG_MIN) || (nodenum == LONG_MAX) ||\n\t    (nodenum > INT_MAX) || (nodenum < 0))\n\t\treturn -ERANGE;\n\n\tocfs2_control_send_down(msg->uuid, nodenum);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "msg.tag",
            "OCFS2_CONTROL_MESSAGE_DOWN_OP",
            "OCFS2_CONTROL_MESSAGE_OP_LEN"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_control_do_setversion_msg",
          "args": [
            "file",
            "&msg.u_setv"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_do_setversion_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "399-447",
          "snippet": "static int ocfs2_control_do_setversion_msg(struct file *file,\n\t\t\t\t\t   struct ocfs2_control_message_setv *msg)\n {\n\tlong major, minor;\n\tchar *ptr = NULL;\n\tstruct ocfs2_control_private *p = file->private_data;\n\tstruct ocfs2_protocol_version *max =\n\t\t&ocfs2_user_plugin.sp_max_proto;\n\n\tif (ocfs2_control_get_handshake_state(file) !=\n\t    OCFS2_CONTROL_HANDSHAKE_PROTOCOL)\n\t\treturn -EINVAL;\n\n\tif (strncmp(msg->tag, OCFS2_CONTROL_MESSAGE_SETVERSION_OP,\n\t\t    OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\treturn -EINVAL;\n\n\tif ((msg->space1 != ' ') || (msg->space2 != ' ') ||\n\t    (msg->newline != '\\n'))\n\t\treturn -EINVAL;\n\tmsg->space1 = msg->space2 = msg->newline = '\\0';\n\n\tmajor = simple_strtol(msg->major, &ptr, 16);\n\tif (!ptr || *ptr)\n\t\treturn -EINVAL;\n\tminor = simple_strtol(msg->minor, &ptr, 16);\n\tif (!ptr || *ptr)\n\t\treturn -EINVAL;\n\n\t/*\n\t * The major must be between 1 and 255, inclusive.  The minor\n\t * must be between 0 and 255, inclusive.  The version passed in\n\t * must be within the maximum version supported by the filesystem.\n\t */\n\tif ((major == LONG_MIN) || (major == LONG_MAX) ||\n\t    (major > (u8)-1) || (major < 1))\n\t\treturn -ERANGE;\n\tif ((minor == LONG_MIN) || (minor == LONG_MAX) ||\n\t    (minor > (u8)-1) || (minor < 0))\n\t\treturn -ERANGE;\n\tif ((major != max->pv_major) ||\n\t    (minor > max->pv_minor))\n\t\treturn -EINVAL;\n\n\tp->op_proto.pv_major = major;\n\tp->op_proto.pv_minor = minor;\n\n\treturn ocfs2_control_install_private(file);\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define OCFS2_CONTROL_MESSAGE_SETVERSION_OP\t\"SETV\"",
            "#define OCFS2_CONTROL_MESSAGE_OP_LEN\t\t4",
            "#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)"
          ],
          "globals_used": [
            "static struct ocfs2_stack_plugin ocfs2_user_plugin;",
            "static struct ocfs2_stack_plugin ocfs2_user_plugin = {\n\t.sp_name\t= \"user\",\n\t.sp_ops\t\t= &ocfs2_user_plugin_ops,\n\t.sp_owner\t= THIS_MODULE,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define OCFS2_CONTROL_MESSAGE_SETVERSION_OP\t\"SETV\"\n#define OCFS2_CONTROL_MESSAGE_OP_LEN\t\t4\n#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)\n\nstatic struct ocfs2_stack_plugin ocfs2_user_plugin;\nstatic struct ocfs2_stack_plugin ocfs2_user_plugin = {\n\t.sp_name\t= \"user\",\n\t.sp_ops\t\t= &ocfs2_user_plugin_ops,\n\t.sp_owner\t= THIS_MODULE,\n};\n\nstatic int ocfs2_control_do_setversion_msg(struct file *file,\n\t\t\t\t\t   struct ocfs2_control_message_setv *msg)\n {\n\tlong major, minor;\n\tchar *ptr = NULL;\n\tstruct ocfs2_control_private *p = file->private_data;\n\tstruct ocfs2_protocol_version *max =\n\t\t&ocfs2_user_plugin.sp_max_proto;\n\n\tif (ocfs2_control_get_handshake_state(file) !=\n\t    OCFS2_CONTROL_HANDSHAKE_PROTOCOL)\n\t\treturn -EINVAL;\n\n\tif (strncmp(msg->tag, OCFS2_CONTROL_MESSAGE_SETVERSION_OP,\n\t\t    OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\treturn -EINVAL;\n\n\tif ((msg->space1 != ' ') || (msg->space2 != ' ') ||\n\t    (msg->newline != '\\n'))\n\t\treturn -EINVAL;\n\tmsg->space1 = msg->space2 = msg->newline = '\\0';\n\n\tmajor = simple_strtol(msg->major, &ptr, 16);\n\tif (!ptr || *ptr)\n\t\treturn -EINVAL;\n\tminor = simple_strtol(msg->minor, &ptr, 16);\n\tif (!ptr || *ptr)\n\t\treturn -EINVAL;\n\n\t/*\n\t * The major must be between 1 and 255, inclusive.  The minor\n\t * must be between 0 and 255, inclusive.  The version passed in\n\t * must be within the maximum version supported by the filesystem.\n\t */\n\tif ((major == LONG_MIN) || (major == LONG_MAX) ||\n\t    (major > (u8)-1) || (major < 1))\n\t\treturn -ERANGE;\n\tif ((minor == LONG_MIN) || (minor == LONG_MAX) ||\n\t    (minor > (u8)-1) || (minor < 0))\n\t\treturn -ERANGE;\n\tif ((major != max->pv_major) ||\n\t    (minor > max->pv_minor))\n\t\treturn -EINVAL;\n\n\tp->op_proto.pv_major = major;\n\tp->op_proto.pv_minor = minor;\n\n\treturn ocfs2_control_install_private(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "msg.tag",
            "OCFS2_CONTROL_MESSAGE_SETVERSION_OP",
            "OCFS2_CONTROL_MESSAGE_OP_LEN"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_control_do_setnode_msg",
          "args": [
            "file",
            "&msg.u_setn"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_do_setnode_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "368-397",
          "snippet": "static int ocfs2_control_do_setnode_msg(struct file *file,\n\t\t\t\t\tstruct ocfs2_control_message_setn *msg)\n{\n\tlong nodenum;\n\tchar *ptr = NULL;\n\tstruct ocfs2_control_private *p = file->private_data;\n\n\tif (ocfs2_control_get_handshake_state(file) !=\n\t    OCFS2_CONTROL_HANDSHAKE_PROTOCOL)\n\t\treturn -EINVAL;\n\n\tif (strncmp(msg->tag, OCFS2_CONTROL_MESSAGE_SETNODE_OP,\n\t\t    OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\treturn -EINVAL;\n\n\tif ((msg->space != ' ') || (msg->newline != '\\n'))\n\t\treturn -EINVAL;\n\tmsg->space = msg->newline = '\\0';\n\n\tnodenum = simple_strtol(msg->nodestr, &ptr, 16);\n\tif (!ptr || *ptr)\n\t\treturn -EINVAL;\n\n\tif ((nodenum == LONG_MIN) || (nodenum == LONG_MAX) ||\n\t    (nodenum > INT_MAX) || (nodenum < 0))\n\t\treturn -ERANGE;\n\tp->op_this_node = nodenum;\n\n\treturn ocfs2_control_install_private(file);\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define OCFS2_CONTROL_MESSAGE_SETNODE_OP\t\"SETN\"",
            "#define OCFS2_CONTROL_MESSAGE_OP_LEN\t\t4",
            "#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define OCFS2_CONTROL_MESSAGE_SETNODE_OP\t\"SETN\"\n#define OCFS2_CONTROL_MESSAGE_OP_LEN\t\t4\n#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)\n\nstatic int ocfs2_control_do_setnode_msg(struct file *file,\n\t\t\t\t\tstruct ocfs2_control_message_setn *msg)\n{\n\tlong nodenum;\n\tchar *ptr = NULL;\n\tstruct ocfs2_control_private *p = file->private_data;\n\n\tif (ocfs2_control_get_handshake_state(file) !=\n\t    OCFS2_CONTROL_HANDSHAKE_PROTOCOL)\n\t\treturn -EINVAL;\n\n\tif (strncmp(msg->tag, OCFS2_CONTROL_MESSAGE_SETNODE_OP,\n\t\t    OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\treturn -EINVAL;\n\n\tif ((msg->space != ' ') || (msg->newline != '\\n'))\n\t\treturn -EINVAL;\n\tmsg->space = msg->newline = '\\0';\n\n\tnodenum = simple_strtol(msg->nodestr, &ptr, 16);\n\tif (!ptr || *ptr)\n\t\treturn -EINVAL;\n\n\tif ((nodenum == LONG_MIN) || (nodenum == LONG_MAX) ||\n\t    (nodenum > INT_MAX) || (nodenum < 0))\n\t\treturn -ERANGE;\n\tp->op_this_node = nodenum;\n\n\treturn ocfs2_control_install_private(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "msg.tag",
            "OCFS2_CONTROL_MESSAGE_SETNODE_OP",
            "OCFS2_CONTROL_MESSAGE_OP_LEN"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_control_cfu",
          "args": [
            "&msg",
            "count",
            "buf",
            "count"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_cfu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "249-261",
          "snippet": "static int ocfs2_control_cfu(void *target, size_t target_len,\n\t\t\t     const char __user *buf, size_t count)\n{\n\t/* The T01 expects write(2) calls to have exactly one command */\n\tif ((count != target_len) ||\n\t    (count > sizeof(union ocfs2_control_message)))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(target, buf, target_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_control_cfu(void *target, size_t target_len,\n\t\t\t     const char __user *buf, size_t count)\n{\n\t/* The T01 expects write(2) calls to have exactly one command */\n\tif ((count != target_len) ||\n\t    (count > sizeof(union ocfs2_control_message)))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(target, buf, target_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&msg",
            "0",
            "sizeof(union ocfs2_control_message)"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "offsetof(struct ocfs2_control_message_down, uuid) !=\n\t\t(sizeof(msg.u_down.tag) + sizeof(msg.u_down.space1))"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define OCFS2_CONTROL_MESSAGE_DOWN_TOTAL_LEN\t47\n#define OCFS2_CONTROL_MESSAGE_DOWN_OP\t\t\"DOWN\"\n#define OCFS2_CONTROL_MESSAGE_SETVERSION_TOTAL_LEN\t11\n#define OCFS2_CONTROL_MESSAGE_SETVERSION_OP\t\"SETV\"\n#define OCFS2_CONTROL_MESSAGE_SETNODE_TOTAL_LEN\t14\n#define OCFS2_CONTROL_MESSAGE_SETNODE_OP\t\"SETN\"\n#define OCFS2_CONTROL_MESSAGE_OP_LEN\t\t4\n\nstatic ssize_t ocfs2_control_message(struct file *file,\n\t\t\t\t     const char __user *buf,\n\t\t\t\t     size_t count)\n{\n\tssize_t ret;\n\tunion ocfs2_control_message msg;\n\n\t/* Try to catch padding issues */\n\tWARN_ON(offsetof(struct ocfs2_control_message_down, uuid) !=\n\t\t(sizeof(msg.u_down.tag) + sizeof(msg.u_down.space1)));\n\n\tmemset(&msg, 0, sizeof(union ocfs2_control_message));\n\tret = ocfs2_control_cfu(&msg, count, buf, count);\n\tif (ret)\n\t\tgoto out;\n\n\tif ((count == OCFS2_CONTROL_MESSAGE_SETNODE_TOTAL_LEN) &&\n\t    !strncmp(msg.tag, OCFS2_CONTROL_MESSAGE_SETNODE_OP,\n\t\t     OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\tret = ocfs2_control_do_setnode_msg(file, &msg.u_setn);\n\telse if ((count == OCFS2_CONTROL_MESSAGE_SETVERSION_TOTAL_LEN) &&\n\t\t !strncmp(msg.tag, OCFS2_CONTROL_MESSAGE_SETVERSION_OP,\n\t\t\t  OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\tret = ocfs2_control_do_setversion_msg(file, &msg.u_setv);\n\telse if ((count == OCFS2_CONTROL_MESSAGE_DOWN_TOTAL_LEN) &&\n\t\t !strncmp(msg.tag, OCFS2_CONTROL_MESSAGE_DOWN_OP,\n\t\t\t  OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\tret = ocfs2_control_do_down_msg(file, &msg.u_down);\n\telse\n\t\tret = -EINVAL;\n\nout:\n\treturn ret ? ret : count;\n}"
  },
  {
    "function_name": "ocfs2_control_do_down_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "449-479",
    "snippet": "static int ocfs2_control_do_down_msg(struct file *file,\n\t\t\t\t     struct ocfs2_control_message_down *msg)\n{\n\tlong nodenum;\n\tchar *p = NULL;\n\n\tif (ocfs2_control_get_handshake_state(file) !=\n\t    OCFS2_CONTROL_HANDSHAKE_VALID)\n\t\treturn -EINVAL;\n\n\tif (strncmp(msg->tag, OCFS2_CONTROL_MESSAGE_DOWN_OP,\n\t\t    OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\treturn -EINVAL;\n\n\tif ((msg->space1 != ' ') || (msg->space2 != ' ') ||\n\t    (msg->newline != '\\n'))\n\t\treturn -EINVAL;\n\tmsg->space1 = msg->space2 = msg->newline = '\\0';\n\n\tnodenum = simple_strtol(msg->nodestr, &p, 16);\n\tif (!p || *p)\n\t\treturn -EINVAL;\n\n\tif ((nodenum == LONG_MIN) || (nodenum == LONG_MAX) ||\n\t    (nodenum > INT_MAX) || (nodenum < 0))\n\t\treturn -ERANGE;\n\n\tocfs2_control_send_down(msg->uuid, nodenum);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define OCFS2_CONTROL_MESSAGE_DOWN_OP\t\t\"DOWN\"",
      "#define OCFS2_CONTROL_MESSAGE_OP_LEN\t\t4",
      "#define OCFS2_CONTROL_HANDSHAKE_VALID\t\t(3)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_control_send_down",
          "args": [
            "msg->uuid",
            "nodenum"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_send_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "284-299",
          "snippet": "static void ocfs2_control_send_down(const char *uuid,\n\t\t\t\t    int nodenum)\n{\n\tstruct ocfs2_live_connection *c;\n\n\tmutex_lock(&ocfs2_control_lock);\n\n\tc = ocfs2_connection_find(uuid);\n\tif (c) {\n\t\tBUG_ON(c->oc_conn == NULL);\n\t\tc->oc_conn->cc_recovery_handler(nodenum,\n\t\t\t\t\t\tc->oc_conn->cc_recovery_data);\n\t}\n\n\tmutex_unlock(&ocfs2_control_lock);\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ocfs2_control_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(ocfs2_control_lock);\n\nstatic void ocfs2_control_send_down(const char *uuid,\n\t\t\t\t    int nodenum)\n{\n\tstruct ocfs2_live_connection *c;\n\n\tmutex_lock(&ocfs2_control_lock);\n\n\tc = ocfs2_connection_find(uuid);\n\tif (c) {\n\t\tBUG_ON(c->oc_conn == NULL);\n\t\tc->oc_conn->cc_recovery_handler(nodenum,\n\t\t\t\t\t\tc->oc_conn->cc_recovery_data);\n\t}\n\n\tmutex_unlock(&ocfs2_control_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "msg->nodestr",
            "&p",
            "16"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "msg->tag",
            "OCFS2_CONTROL_MESSAGE_DOWN_OP",
            "OCFS2_CONTROL_MESSAGE_OP_LEN"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_control_get_handshake_state",
          "args": [
            "file"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_get_handshake_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "188-192",
          "snippet": "static inline int ocfs2_control_get_handshake_state(struct file *file)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\treturn p->op_state;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int ocfs2_control_get_handshake_state(struct file *file)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\treturn p->op_state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define OCFS2_CONTROL_MESSAGE_DOWN_OP\t\t\"DOWN\"\n#define OCFS2_CONTROL_MESSAGE_OP_LEN\t\t4\n#define OCFS2_CONTROL_HANDSHAKE_VALID\t\t(3)\n\nstatic int ocfs2_control_do_down_msg(struct file *file,\n\t\t\t\t     struct ocfs2_control_message_down *msg)\n{\n\tlong nodenum;\n\tchar *p = NULL;\n\n\tif (ocfs2_control_get_handshake_state(file) !=\n\t    OCFS2_CONTROL_HANDSHAKE_VALID)\n\t\treturn -EINVAL;\n\n\tif (strncmp(msg->tag, OCFS2_CONTROL_MESSAGE_DOWN_OP,\n\t\t    OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\treturn -EINVAL;\n\n\tif ((msg->space1 != ' ') || (msg->space2 != ' ') ||\n\t    (msg->newline != '\\n'))\n\t\treturn -EINVAL;\n\tmsg->space1 = msg->space2 = msg->newline = '\\0';\n\n\tnodenum = simple_strtol(msg->nodestr, &p, 16);\n\tif (!p || *p)\n\t\treturn -EINVAL;\n\n\tif ((nodenum == LONG_MIN) || (nodenum == LONG_MAX) ||\n\t    (nodenum > INT_MAX) || (nodenum < 0))\n\t\treturn -ERANGE;\n\n\tocfs2_control_send_down(msg->uuid, nodenum);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_control_do_setversion_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "399-447",
    "snippet": "static int ocfs2_control_do_setversion_msg(struct file *file,\n\t\t\t\t\t   struct ocfs2_control_message_setv *msg)\n {\n\tlong major, minor;\n\tchar *ptr = NULL;\n\tstruct ocfs2_control_private *p = file->private_data;\n\tstruct ocfs2_protocol_version *max =\n\t\t&ocfs2_user_plugin.sp_max_proto;\n\n\tif (ocfs2_control_get_handshake_state(file) !=\n\t    OCFS2_CONTROL_HANDSHAKE_PROTOCOL)\n\t\treturn -EINVAL;\n\n\tif (strncmp(msg->tag, OCFS2_CONTROL_MESSAGE_SETVERSION_OP,\n\t\t    OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\treturn -EINVAL;\n\n\tif ((msg->space1 != ' ') || (msg->space2 != ' ') ||\n\t    (msg->newline != '\\n'))\n\t\treturn -EINVAL;\n\tmsg->space1 = msg->space2 = msg->newline = '\\0';\n\n\tmajor = simple_strtol(msg->major, &ptr, 16);\n\tif (!ptr || *ptr)\n\t\treturn -EINVAL;\n\tminor = simple_strtol(msg->minor, &ptr, 16);\n\tif (!ptr || *ptr)\n\t\treturn -EINVAL;\n\n\t/*\n\t * The major must be between 1 and 255, inclusive.  The minor\n\t * must be between 0 and 255, inclusive.  The version passed in\n\t * must be within the maximum version supported by the filesystem.\n\t */\n\tif ((major == LONG_MIN) || (major == LONG_MAX) ||\n\t    (major > (u8)-1) || (major < 1))\n\t\treturn -ERANGE;\n\tif ((minor == LONG_MIN) || (minor == LONG_MAX) ||\n\t    (minor > (u8)-1) || (minor < 0))\n\t\treturn -ERANGE;\n\tif ((major != max->pv_major) ||\n\t    (minor > max->pv_minor))\n\t\treturn -EINVAL;\n\n\tp->op_proto.pv_major = major;\n\tp->op_proto.pv_minor = minor;\n\n\treturn ocfs2_control_install_private(file);\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define OCFS2_CONTROL_MESSAGE_SETVERSION_OP\t\"SETV\"",
      "#define OCFS2_CONTROL_MESSAGE_OP_LEN\t\t4",
      "#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)"
    ],
    "globals_used": [
      "static struct ocfs2_stack_plugin ocfs2_user_plugin;",
      "static struct ocfs2_stack_plugin ocfs2_user_plugin = {\n\t.sp_name\t= \"user\",\n\t.sp_ops\t\t= &ocfs2_user_plugin_ops,\n\t.sp_owner\t= THIS_MODULE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_control_install_private",
          "args": [
            "file"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_install_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "308-352",
          "snippet": "static int ocfs2_control_install_private(struct file *file)\n{\n\tint rc = 0;\n\tint set_p = 1;\n\tstruct ocfs2_control_private *p = file->private_data;\n\n\tBUG_ON(p->op_state != OCFS2_CONTROL_HANDSHAKE_PROTOCOL);\n\n\tmutex_lock(&ocfs2_control_lock);\n\n\tif (p->op_this_node < 0) {\n\t\tset_p = 0;\n\t} else if ((ocfs2_control_this_node >= 0) &&\n\t\t   (ocfs2_control_this_node != p->op_this_node)) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!p->op_proto.pv_major) {\n\t\tset_p = 0;\n\t} else if (!list_empty(&ocfs2_live_connection_list) &&\n\t\t   ((running_proto.pv_major != p->op_proto.pv_major) ||\n\t\t    (running_proto.pv_minor != p->op_proto.pv_minor))) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (set_p) {\n\t\tocfs2_control_this_node = p->op_this_node;\n\t\trunning_proto.pv_major = p->op_proto.pv_major;\n\t\trunning_proto.pv_minor = p->op_proto.pv_minor;\n\t}\n\nout_unlock:\n\tmutex_unlock(&ocfs2_control_lock);\n\n\tif (!rc && set_p) {\n\t\t/* We set the global values successfully */\n\t\tatomic_inc(&ocfs2_control_opened);\n\t\tocfs2_control_set_handshake_state(file,\n\t\t\t\t\tOCFS2_CONTROL_HANDSHAKE_VALID);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define OCFS2_CONTROL_HANDSHAKE_VALID\t\t(3)",
            "#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)"
          ],
          "globals_used": [
            "static atomic_t ocfs2_control_opened;",
            "static int ocfs2_control_this_node = -1;",
            "static struct ocfs2_protocol_version running_proto;",
            "static LIST_HEAD(ocfs2_live_connection_list);",
            "static DEFINE_MUTEX(ocfs2_control_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define OCFS2_CONTROL_HANDSHAKE_VALID\t\t(3)\n#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)\n\nstatic atomic_t ocfs2_control_opened;\nstatic int ocfs2_control_this_node = -1;\nstatic struct ocfs2_protocol_version running_proto;\nstatic LIST_HEAD(ocfs2_live_connection_list);\nstatic DEFINE_MUTEX(ocfs2_control_lock);\n\nstatic int ocfs2_control_install_private(struct file *file)\n{\n\tint rc = 0;\n\tint set_p = 1;\n\tstruct ocfs2_control_private *p = file->private_data;\n\n\tBUG_ON(p->op_state != OCFS2_CONTROL_HANDSHAKE_PROTOCOL);\n\n\tmutex_lock(&ocfs2_control_lock);\n\n\tif (p->op_this_node < 0) {\n\t\tset_p = 0;\n\t} else if ((ocfs2_control_this_node >= 0) &&\n\t\t   (ocfs2_control_this_node != p->op_this_node)) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!p->op_proto.pv_major) {\n\t\tset_p = 0;\n\t} else if (!list_empty(&ocfs2_live_connection_list) &&\n\t\t   ((running_proto.pv_major != p->op_proto.pv_major) ||\n\t\t    (running_proto.pv_minor != p->op_proto.pv_minor))) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (set_p) {\n\t\tocfs2_control_this_node = p->op_this_node;\n\t\trunning_proto.pv_major = p->op_proto.pv_major;\n\t\trunning_proto.pv_minor = p->op_proto.pv_minor;\n\t}\n\nout_unlock:\n\tmutex_unlock(&ocfs2_control_lock);\n\n\tif (!rc && set_p) {\n\t\t/* We set the global values successfully */\n\t\tatomic_inc(&ocfs2_control_opened);\n\t\tocfs2_control_set_handshake_state(file,\n\t\t\t\t\tOCFS2_CONTROL_HANDSHAKE_VALID);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "msg->minor",
            "&ptr",
            "16"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "msg->major",
            "&ptr",
            "16"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "msg->tag",
            "OCFS2_CONTROL_MESSAGE_SETVERSION_OP",
            "OCFS2_CONTROL_MESSAGE_OP_LEN"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_control_get_handshake_state",
          "args": [
            "file"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_get_handshake_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "188-192",
          "snippet": "static inline int ocfs2_control_get_handshake_state(struct file *file)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\treturn p->op_state;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int ocfs2_control_get_handshake_state(struct file *file)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\treturn p->op_state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define OCFS2_CONTROL_MESSAGE_SETVERSION_OP\t\"SETV\"\n#define OCFS2_CONTROL_MESSAGE_OP_LEN\t\t4\n#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)\n\nstatic struct ocfs2_stack_plugin ocfs2_user_plugin;\nstatic struct ocfs2_stack_plugin ocfs2_user_plugin = {\n\t.sp_name\t= \"user\",\n\t.sp_ops\t\t= &ocfs2_user_plugin_ops,\n\t.sp_owner\t= THIS_MODULE,\n};\n\nstatic int ocfs2_control_do_setversion_msg(struct file *file,\n\t\t\t\t\t   struct ocfs2_control_message_setv *msg)\n {\n\tlong major, minor;\n\tchar *ptr = NULL;\n\tstruct ocfs2_control_private *p = file->private_data;\n\tstruct ocfs2_protocol_version *max =\n\t\t&ocfs2_user_plugin.sp_max_proto;\n\n\tif (ocfs2_control_get_handshake_state(file) !=\n\t    OCFS2_CONTROL_HANDSHAKE_PROTOCOL)\n\t\treturn -EINVAL;\n\n\tif (strncmp(msg->tag, OCFS2_CONTROL_MESSAGE_SETVERSION_OP,\n\t\t    OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\treturn -EINVAL;\n\n\tif ((msg->space1 != ' ') || (msg->space2 != ' ') ||\n\t    (msg->newline != '\\n'))\n\t\treturn -EINVAL;\n\tmsg->space1 = msg->space2 = msg->newline = '\\0';\n\n\tmajor = simple_strtol(msg->major, &ptr, 16);\n\tif (!ptr || *ptr)\n\t\treturn -EINVAL;\n\tminor = simple_strtol(msg->minor, &ptr, 16);\n\tif (!ptr || *ptr)\n\t\treturn -EINVAL;\n\n\t/*\n\t * The major must be between 1 and 255, inclusive.  The minor\n\t * must be between 0 and 255, inclusive.  The version passed in\n\t * must be within the maximum version supported by the filesystem.\n\t */\n\tif ((major == LONG_MIN) || (major == LONG_MAX) ||\n\t    (major > (u8)-1) || (major < 1))\n\t\treturn -ERANGE;\n\tif ((minor == LONG_MIN) || (minor == LONG_MAX) ||\n\t    (minor > (u8)-1) || (minor < 0))\n\t\treturn -ERANGE;\n\tif ((major != max->pv_major) ||\n\t    (minor > max->pv_minor))\n\t\treturn -EINVAL;\n\n\tp->op_proto.pv_major = major;\n\tp->op_proto.pv_minor = minor;\n\n\treturn ocfs2_control_install_private(file);\n}"
  },
  {
    "function_name": "ocfs2_control_do_setnode_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "368-397",
    "snippet": "static int ocfs2_control_do_setnode_msg(struct file *file,\n\t\t\t\t\tstruct ocfs2_control_message_setn *msg)\n{\n\tlong nodenum;\n\tchar *ptr = NULL;\n\tstruct ocfs2_control_private *p = file->private_data;\n\n\tif (ocfs2_control_get_handshake_state(file) !=\n\t    OCFS2_CONTROL_HANDSHAKE_PROTOCOL)\n\t\treturn -EINVAL;\n\n\tif (strncmp(msg->tag, OCFS2_CONTROL_MESSAGE_SETNODE_OP,\n\t\t    OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\treturn -EINVAL;\n\n\tif ((msg->space != ' ') || (msg->newline != '\\n'))\n\t\treturn -EINVAL;\n\tmsg->space = msg->newline = '\\0';\n\n\tnodenum = simple_strtol(msg->nodestr, &ptr, 16);\n\tif (!ptr || *ptr)\n\t\treturn -EINVAL;\n\n\tif ((nodenum == LONG_MIN) || (nodenum == LONG_MAX) ||\n\t    (nodenum > INT_MAX) || (nodenum < 0))\n\t\treturn -ERANGE;\n\tp->op_this_node = nodenum;\n\n\treturn ocfs2_control_install_private(file);\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define OCFS2_CONTROL_MESSAGE_SETNODE_OP\t\"SETN\"",
      "#define OCFS2_CONTROL_MESSAGE_OP_LEN\t\t4",
      "#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_control_install_private",
          "args": [
            "file"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_install_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "308-352",
          "snippet": "static int ocfs2_control_install_private(struct file *file)\n{\n\tint rc = 0;\n\tint set_p = 1;\n\tstruct ocfs2_control_private *p = file->private_data;\n\n\tBUG_ON(p->op_state != OCFS2_CONTROL_HANDSHAKE_PROTOCOL);\n\n\tmutex_lock(&ocfs2_control_lock);\n\n\tif (p->op_this_node < 0) {\n\t\tset_p = 0;\n\t} else if ((ocfs2_control_this_node >= 0) &&\n\t\t   (ocfs2_control_this_node != p->op_this_node)) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!p->op_proto.pv_major) {\n\t\tset_p = 0;\n\t} else if (!list_empty(&ocfs2_live_connection_list) &&\n\t\t   ((running_proto.pv_major != p->op_proto.pv_major) ||\n\t\t    (running_proto.pv_minor != p->op_proto.pv_minor))) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (set_p) {\n\t\tocfs2_control_this_node = p->op_this_node;\n\t\trunning_proto.pv_major = p->op_proto.pv_major;\n\t\trunning_proto.pv_minor = p->op_proto.pv_minor;\n\t}\n\nout_unlock:\n\tmutex_unlock(&ocfs2_control_lock);\n\n\tif (!rc && set_p) {\n\t\t/* We set the global values successfully */\n\t\tatomic_inc(&ocfs2_control_opened);\n\t\tocfs2_control_set_handshake_state(file,\n\t\t\t\t\tOCFS2_CONTROL_HANDSHAKE_VALID);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define OCFS2_CONTROL_HANDSHAKE_VALID\t\t(3)",
            "#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)"
          ],
          "globals_used": [
            "static atomic_t ocfs2_control_opened;",
            "static int ocfs2_control_this_node = -1;",
            "static struct ocfs2_protocol_version running_proto;",
            "static LIST_HEAD(ocfs2_live_connection_list);",
            "static DEFINE_MUTEX(ocfs2_control_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define OCFS2_CONTROL_HANDSHAKE_VALID\t\t(3)\n#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)\n\nstatic atomic_t ocfs2_control_opened;\nstatic int ocfs2_control_this_node = -1;\nstatic struct ocfs2_protocol_version running_proto;\nstatic LIST_HEAD(ocfs2_live_connection_list);\nstatic DEFINE_MUTEX(ocfs2_control_lock);\n\nstatic int ocfs2_control_install_private(struct file *file)\n{\n\tint rc = 0;\n\tint set_p = 1;\n\tstruct ocfs2_control_private *p = file->private_data;\n\n\tBUG_ON(p->op_state != OCFS2_CONTROL_HANDSHAKE_PROTOCOL);\n\n\tmutex_lock(&ocfs2_control_lock);\n\n\tif (p->op_this_node < 0) {\n\t\tset_p = 0;\n\t} else if ((ocfs2_control_this_node >= 0) &&\n\t\t   (ocfs2_control_this_node != p->op_this_node)) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!p->op_proto.pv_major) {\n\t\tset_p = 0;\n\t} else if (!list_empty(&ocfs2_live_connection_list) &&\n\t\t   ((running_proto.pv_major != p->op_proto.pv_major) ||\n\t\t    (running_proto.pv_minor != p->op_proto.pv_minor))) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (set_p) {\n\t\tocfs2_control_this_node = p->op_this_node;\n\t\trunning_proto.pv_major = p->op_proto.pv_major;\n\t\trunning_proto.pv_minor = p->op_proto.pv_minor;\n\t}\n\nout_unlock:\n\tmutex_unlock(&ocfs2_control_lock);\n\n\tif (!rc && set_p) {\n\t\t/* We set the global values successfully */\n\t\tatomic_inc(&ocfs2_control_opened);\n\t\tocfs2_control_set_handshake_state(file,\n\t\t\t\t\tOCFS2_CONTROL_HANDSHAKE_VALID);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "msg->nodestr",
            "&ptr",
            "16"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "msg->tag",
            "OCFS2_CONTROL_MESSAGE_SETNODE_OP",
            "OCFS2_CONTROL_MESSAGE_OP_LEN"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_control_get_handshake_state",
          "args": [
            "file"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_get_handshake_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "188-192",
          "snippet": "static inline int ocfs2_control_get_handshake_state(struct file *file)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\treturn p->op_state;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int ocfs2_control_get_handshake_state(struct file *file)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\treturn p->op_state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define OCFS2_CONTROL_MESSAGE_SETNODE_OP\t\"SETN\"\n#define OCFS2_CONTROL_MESSAGE_OP_LEN\t\t4\n#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)\n\nstatic int ocfs2_control_do_setnode_msg(struct file *file,\n\t\t\t\t\tstruct ocfs2_control_message_setn *msg)\n{\n\tlong nodenum;\n\tchar *ptr = NULL;\n\tstruct ocfs2_control_private *p = file->private_data;\n\n\tif (ocfs2_control_get_handshake_state(file) !=\n\t    OCFS2_CONTROL_HANDSHAKE_PROTOCOL)\n\t\treturn -EINVAL;\n\n\tif (strncmp(msg->tag, OCFS2_CONTROL_MESSAGE_SETNODE_OP,\n\t\t    OCFS2_CONTROL_MESSAGE_OP_LEN))\n\t\treturn -EINVAL;\n\n\tif ((msg->space != ' ') || (msg->newline != '\\n'))\n\t\treturn -EINVAL;\n\tmsg->space = msg->newline = '\\0';\n\n\tnodenum = simple_strtol(msg->nodestr, &ptr, 16);\n\tif (!ptr || *ptr)\n\t\treturn -EINVAL;\n\n\tif ((nodenum == LONG_MIN) || (nodenum == LONG_MAX) ||\n\t    (nodenum > INT_MAX) || (nodenum < 0))\n\t\treturn -ERANGE;\n\tp->op_this_node = nodenum;\n\n\treturn ocfs2_control_install_private(file);\n}"
  },
  {
    "function_name": "ocfs2_control_get_this_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "354-366",
    "snippet": "static int ocfs2_control_get_this_node(void)\n{\n\tint rc;\n\n\tmutex_lock(&ocfs2_control_lock);\n\tif (ocfs2_control_this_node < 0)\n\t\trc = -EINVAL;\n\telse\n\t\trc = ocfs2_control_this_node;\n\tmutex_unlock(&ocfs2_control_lock);\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_control_this_node = -1;",
      "static DEFINE_MUTEX(ocfs2_control_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ocfs2_control_lock"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ocfs2_control_lock"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_control_this_node = -1;\nstatic DEFINE_MUTEX(ocfs2_control_lock);\n\nstatic int ocfs2_control_get_this_node(void)\n{\n\tint rc;\n\n\tmutex_lock(&ocfs2_control_lock);\n\tif (ocfs2_control_this_node < 0)\n\t\trc = -EINVAL;\n\telse\n\t\trc = ocfs2_control_this_node;\n\tmutex_unlock(&ocfs2_control_lock);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_control_install_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "308-352",
    "snippet": "static int ocfs2_control_install_private(struct file *file)\n{\n\tint rc = 0;\n\tint set_p = 1;\n\tstruct ocfs2_control_private *p = file->private_data;\n\n\tBUG_ON(p->op_state != OCFS2_CONTROL_HANDSHAKE_PROTOCOL);\n\n\tmutex_lock(&ocfs2_control_lock);\n\n\tif (p->op_this_node < 0) {\n\t\tset_p = 0;\n\t} else if ((ocfs2_control_this_node >= 0) &&\n\t\t   (ocfs2_control_this_node != p->op_this_node)) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!p->op_proto.pv_major) {\n\t\tset_p = 0;\n\t} else if (!list_empty(&ocfs2_live_connection_list) &&\n\t\t   ((running_proto.pv_major != p->op_proto.pv_major) ||\n\t\t    (running_proto.pv_minor != p->op_proto.pv_minor))) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (set_p) {\n\t\tocfs2_control_this_node = p->op_this_node;\n\t\trunning_proto.pv_major = p->op_proto.pv_major;\n\t\trunning_proto.pv_minor = p->op_proto.pv_minor;\n\t}\n\nout_unlock:\n\tmutex_unlock(&ocfs2_control_lock);\n\n\tif (!rc && set_p) {\n\t\t/* We set the global values successfully */\n\t\tatomic_inc(&ocfs2_control_opened);\n\t\tocfs2_control_set_handshake_state(file,\n\t\t\t\t\tOCFS2_CONTROL_HANDSHAKE_VALID);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define OCFS2_CONTROL_HANDSHAKE_VALID\t\t(3)",
      "#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)"
    ],
    "globals_used": [
      "static atomic_t ocfs2_control_opened;",
      "static int ocfs2_control_this_node = -1;",
      "static struct ocfs2_protocol_version running_proto;",
      "static LIST_HEAD(ocfs2_live_connection_list);",
      "static DEFINE_MUTEX(ocfs2_control_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_control_set_handshake_state",
          "args": [
            "file",
            "OCFS2_CONTROL_HANDSHAKE_VALID"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_set_handshake_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "181-186",
          "snippet": "static inline void ocfs2_control_set_handshake_state(struct file *file,\n\t\t\t\t\t\t     int state)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\tp->op_state = state;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline void ocfs2_control_set_handshake_state(struct file *file,\n\t\t\t\t\t\t     int state)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\tp->op_state = state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ocfs2_control_opened"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ocfs2_control_lock"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ocfs2_live_connection_list"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ocfs2_control_lock"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "p->op_state != OCFS2_CONTROL_HANDSHAKE_PROTOCOL"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define OCFS2_CONTROL_HANDSHAKE_VALID\t\t(3)\n#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)\n\nstatic atomic_t ocfs2_control_opened;\nstatic int ocfs2_control_this_node = -1;\nstatic struct ocfs2_protocol_version running_proto;\nstatic LIST_HEAD(ocfs2_live_connection_list);\nstatic DEFINE_MUTEX(ocfs2_control_lock);\n\nstatic int ocfs2_control_install_private(struct file *file)\n{\n\tint rc = 0;\n\tint set_p = 1;\n\tstruct ocfs2_control_private *p = file->private_data;\n\n\tBUG_ON(p->op_state != OCFS2_CONTROL_HANDSHAKE_PROTOCOL);\n\n\tmutex_lock(&ocfs2_control_lock);\n\n\tif (p->op_this_node < 0) {\n\t\tset_p = 0;\n\t} else if ((ocfs2_control_this_node >= 0) &&\n\t\t   (ocfs2_control_this_node != p->op_this_node)) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!p->op_proto.pv_major) {\n\t\tset_p = 0;\n\t} else if (!list_empty(&ocfs2_live_connection_list) &&\n\t\t   ((running_proto.pv_major != p->op_proto.pv_major) ||\n\t\t    (running_proto.pv_minor != p->op_proto.pv_minor))) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (set_p) {\n\t\tocfs2_control_this_node = p->op_this_node;\n\t\trunning_proto.pv_major = p->op_proto.pv_major;\n\t\trunning_proto.pv_minor = p->op_proto.pv_minor;\n\t}\n\nout_unlock:\n\tmutex_unlock(&ocfs2_control_lock);\n\n\tif (!rc && set_p) {\n\t\t/* We set the global values successfully */\n\t\tatomic_inc(&ocfs2_control_opened);\n\t\tocfs2_control_set_handshake_state(file,\n\t\t\t\t\tOCFS2_CONTROL_HANDSHAKE_VALID);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_control_send_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "284-299",
    "snippet": "static void ocfs2_control_send_down(const char *uuid,\n\t\t\t\t    int nodenum)\n{\n\tstruct ocfs2_live_connection *c;\n\n\tmutex_lock(&ocfs2_control_lock);\n\n\tc = ocfs2_connection_find(uuid);\n\tif (c) {\n\t\tBUG_ON(c->oc_conn == NULL);\n\t\tc->oc_conn->cc_recovery_handler(nodenum,\n\t\t\t\t\t\tc->oc_conn->cc_recovery_data);\n\t}\n\n\tmutex_unlock(&ocfs2_control_lock);\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ocfs2_control_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ocfs2_control_lock"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->oc_conn->cc_recovery_handler",
          "args": [
            "nodenum",
            "c->oc_conn->cc_recovery_data"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "c->oc_conn == NULL"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_connection_find",
          "args": [
            "uuid"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_connection_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "194-208",
          "snippet": "static struct ocfs2_live_connection *ocfs2_connection_find(const char *name)\n{\n\tsize_t len = strlen(name);\n\tstruct ocfs2_live_connection *c;\n\n\tBUG_ON(!mutex_is_locked(&ocfs2_control_lock));\n\n\tlist_for_each_entry(c, &ocfs2_live_connection_list, oc_list) {\n\t\tif ((c->oc_conn->cc_namelen == len) &&\n\t\t    !strncmp(c->oc_conn->cc_name, name, len))\n\t\t\treturn c;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ocfs2_live_connection_list);",
            "static DEFINE_MUTEX(ocfs2_control_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(ocfs2_live_connection_list);\nstatic DEFINE_MUTEX(ocfs2_control_lock);\n\nstatic struct ocfs2_live_connection *ocfs2_connection_find(const char *name)\n{\n\tsize_t len = strlen(name);\n\tstruct ocfs2_live_connection *c;\n\n\tBUG_ON(!mutex_is_locked(&ocfs2_control_lock));\n\n\tlist_for_each_entry(c, &ocfs2_live_connection_list, oc_list) {\n\t\tif ((c->oc_conn->cc_namelen == len) &&\n\t\t    !strncmp(c->oc_conn->cc_name, name, len))\n\t\t\treturn c;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ocfs2_control_lock"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(ocfs2_control_lock);\n\nstatic void ocfs2_control_send_down(const char *uuid,\n\t\t\t\t    int nodenum)\n{\n\tstruct ocfs2_live_connection *c;\n\n\tmutex_lock(&ocfs2_control_lock);\n\n\tc = ocfs2_connection_find(uuid);\n\tif (c) {\n\t\tBUG_ON(c->oc_conn == NULL);\n\t\tc->oc_conn->cc_recovery_handler(nodenum,\n\t\t\t\t\t\tc->oc_conn->cc_recovery_data);\n\t}\n\n\tmutex_unlock(&ocfs2_control_lock);\n}"
  },
  {
    "function_name": "ocfs2_control_validate_protocol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "263-282",
    "snippet": "static ssize_t ocfs2_control_validate_protocol(struct file *file,\n\t\t\t\t\t       const char __user *buf,\n\t\t\t\t\t       size_t count)\n{\n\tssize_t ret;\n\tchar kbuf[OCFS2_CONTROL_PROTO_LEN];\n\n\tret = ocfs2_control_cfu(kbuf, OCFS2_CONTROL_PROTO_LEN,\n\t\t\t\tbuf, count);\n\tif (ret)\n\t\treturn ret;\n\n\tif (strncmp(kbuf, OCFS2_CONTROL_PROTO, OCFS2_CONTROL_PROTO_LEN))\n\t\treturn -EINVAL;\n\n\tocfs2_control_set_handshake_state(file,\n\t\t\t\t\t  OCFS2_CONTROL_HANDSHAKE_PROTOCOL);\n\n\treturn count;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)",
      "#define OCFS2_CONTROL_PROTO_LEN\t\t\t4",
      "#define OCFS2_CONTROL_PROTO\t\t\t\"T01\\n\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_control_set_handshake_state",
          "args": [
            "file",
            "OCFS2_CONTROL_HANDSHAKE_PROTOCOL"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_set_handshake_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "181-186",
          "snippet": "static inline void ocfs2_control_set_handshake_state(struct file *file,\n\t\t\t\t\t\t     int state)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\tp->op_state = state;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline void ocfs2_control_set_handshake_state(struct file *file,\n\t\t\t\t\t\t     int state)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\tp->op_state = state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "kbuf",
            "OCFS2_CONTROL_PROTO",
            "OCFS2_CONTROL_PROTO_LEN"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_control_cfu",
          "args": [
            "kbuf",
            "OCFS2_CONTROL_PROTO_LEN",
            "buf",
            "count"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_control_cfu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "249-261",
          "snippet": "static int ocfs2_control_cfu(void *target, size_t target_len,\n\t\t\t     const char __user *buf, size_t count)\n{\n\t/* The T01 expects write(2) calls to have exactly one command */\n\tif ((count != target_len) ||\n\t    (count > sizeof(union ocfs2_control_message)))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(target, buf, target_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_control_cfu(void *target, size_t target_len,\n\t\t\t     const char __user *buf, size_t count)\n{\n\t/* The T01 expects write(2) calls to have exactly one command */\n\tif ((count != target_len) ||\n\t    (count > sizeof(union ocfs2_control_message)))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(target, buf, target_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define OCFS2_CONTROL_HANDSHAKE_PROTOCOL\t(2)\n#define OCFS2_CONTROL_PROTO_LEN\t\t\t4\n#define OCFS2_CONTROL_PROTO\t\t\t\"T01\\n\"\n\nstatic ssize_t ocfs2_control_validate_protocol(struct file *file,\n\t\t\t\t\t       const char __user *buf,\n\t\t\t\t\t       size_t count)\n{\n\tssize_t ret;\n\tchar kbuf[OCFS2_CONTROL_PROTO_LEN];\n\n\tret = ocfs2_control_cfu(kbuf, OCFS2_CONTROL_PROTO_LEN,\n\t\t\t\tbuf, count);\n\tif (ret)\n\t\treturn ret;\n\n\tif (strncmp(kbuf, OCFS2_CONTROL_PROTO, OCFS2_CONTROL_PROTO_LEN))\n\t\treturn -EINVAL;\n\n\tocfs2_control_set_handshake_state(file,\n\t\t\t\t\t  OCFS2_CONTROL_HANDSHAKE_PROTOCOL);\n\n\treturn count;\n}"
  },
  {
    "function_name": "ocfs2_control_cfu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "249-261",
    "snippet": "static int ocfs2_control_cfu(void *target, size_t target_len,\n\t\t\t     const char __user *buf, size_t count)\n{\n\t/* The T01 expects write(2) calls to have exactly one command */\n\tif ((count != target_len) ||\n\t    (count > sizeof(union ocfs2_control_message)))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(target, buf, target_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "target",
            "buf",
            "target_len"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_control_cfu(void *target, size_t target_len,\n\t\t\t     const char __user *buf, size_t count)\n{\n\t/* The T01 expects write(2) calls to have exactly one command */\n\tif ((count != target_len) ||\n\t    (count > sizeof(union ocfs2_control_message)))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(target, buf, target_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_live_connection_drop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "239-247",
    "snippet": "static void ocfs2_live_connection_drop(struct ocfs2_live_connection *c)\n{\n\tmutex_lock(&ocfs2_control_lock);\n\tlist_del_init(&c->oc_list);\n\tc->oc_conn = NULL;\n\tmutex_unlock(&ocfs2_control_lock);\n\n\tkfree(c);\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ocfs2_control_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "c"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ocfs2_control_lock"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&c->oc_list"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ocfs2_control_lock"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(ocfs2_control_lock);\n\nstatic void ocfs2_live_connection_drop(struct ocfs2_live_connection *c)\n{\n\tmutex_lock(&ocfs2_control_lock);\n\tlist_del_init(&c->oc_list);\n\tc->oc_conn = NULL;\n\tmutex_unlock(&ocfs2_control_lock);\n\n\tkfree(c);\n}"
  },
  {
    "function_name": "ocfs2_live_connection_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "215-233",
    "snippet": "static int ocfs2_live_connection_attach(struct ocfs2_cluster_connection *conn,\n\t\t\t\t     struct ocfs2_live_connection *c)\n{\n\tint rc = 0;\n\n\tmutex_lock(&ocfs2_control_lock);\n\tc->oc_conn = conn;\n\n\tif ((c->oc_type == NO_CONTROLD) || atomic_read(&ocfs2_control_opened))\n\t\tlist_add(&c->oc_list, &ocfs2_live_connection_list);\n\telse {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Userspace control daemon is not present\\n\");\n\t\trc = -ESRCH;\n\t}\n\n\tmutex_unlock(&ocfs2_control_lock);\n\treturn rc;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t ocfs2_control_opened;",
      "static LIST_HEAD(ocfs2_live_connection_list);",
      "static DEFINE_MUTEX(ocfs2_control_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ocfs2_control_lock"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"ocfs2: Userspace control daemon is not present\\n\""
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&c->oc_list",
            "&ocfs2_live_connection_list"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ocfs2_control_opened"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ocfs2_control_lock"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic atomic_t ocfs2_control_opened;\nstatic LIST_HEAD(ocfs2_live_connection_list);\nstatic DEFINE_MUTEX(ocfs2_control_lock);\n\nstatic int ocfs2_live_connection_attach(struct ocfs2_cluster_connection *conn,\n\t\t\t\t     struct ocfs2_live_connection *c)\n{\n\tint rc = 0;\n\n\tmutex_lock(&ocfs2_control_lock);\n\tc->oc_conn = conn;\n\n\tif ((c->oc_type == NO_CONTROLD) || atomic_read(&ocfs2_control_opened))\n\t\tlist_add(&c->oc_list, &ocfs2_live_connection_list);\n\telse {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Userspace control daemon is not present\\n\");\n\t\trc = -ESRCH;\n\t}\n\n\tmutex_unlock(&ocfs2_control_lock);\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_connection_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "194-208",
    "snippet": "static struct ocfs2_live_connection *ocfs2_connection_find(const char *name)\n{\n\tsize_t len = strlen(name);\n\tstruct ocfs2_live_connection *c;\n\n\tBUG_ON(!mutex_is_locked(&ocfs2_control_lock));\n\n\tlist_for_each_entry(c, &ocfs2_live_connection_list, oc_list) {\n\t\tif ((c->oc_conn->cc_namelen == len) &&\n\t\t    !strncmp(c->oc_conn->cc_name, name, len))\n\t\t\treturn c;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(ocfs2_live_connection_list);",
      "static DEFINE_MUTEX(ocfs2_control_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "c->oc_conn->cc_name",
            "name",
            "len"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "c",
            "&ocfs2_live_connection_list",
            "oc_list"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&ocfs2_control_lock)"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&ocfs2_control_lock"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(ocfs2_live_connection_list);\nstatic DEFINE_MUTEX(ocfs2_control_lock);\n\nstatic struct ocfs2_live_connection *ocfs2_connection_find(const char *name)\n{\n\tsize_t len = strlen(name);\n\tstruct ocfs2_live_connection *c;\n\n\tBUG_ON(!mutex_is_locked(&ocfs2_control_lock));\n\n\tlist_for_each_entry(c, &ocfs2_live_connection_list, oc_list) {\n\t\tif ((c->oc_conn->cc_namelen == len) &&\n\t\t    !strncmp(c->oc_conn->cc_name, name, len))\n\t\t\treturn c;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ocfs2_control_get_handshake_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "188-192",
    "snippet": "static inline int ocfs2_control_get_handshake_state(struct file *file)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\treturn p->op_state;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int ocfs2_control_get_handshake_state(struct file *file)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\treturn p->op_state;\n}"
  },
  {
    "function_name": "ocfs2_control_set_handshake_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
    "lines": "181-186",
    "snippet": "static inline void ocfs2_control_set_handshake_state(struct file *file,\n\t\t\t\t\t\t     int state)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\tp->op_state = state;\n}",
    "includes": [
      "#include <linux/dlm_plock.h>",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline void ocfs2_control_set_handshake_state(struct file *file,\n\t\t\t\t\t\t     int state)\n{\n\tstruct ocfs2_control_private *p = file->private_data;\n\tp->op_state = state;\n}"
  }
]