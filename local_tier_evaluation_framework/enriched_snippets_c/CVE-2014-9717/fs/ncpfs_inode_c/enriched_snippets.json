[
  {
    "function_name": "exit_ncp_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "1063-1068",
    "snippet": "static void __exit exit_ncp_fs(void)\n{\n\tncp_dbg(1, \"called\\n\");\n\tunregister_filesystem(&ncp_fs_type);\n\tdestroy_inodecache();\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type ncp_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ncpfs\",\n\t.mount\t\t= ncp_mount,\n\t.kill_sb\t= kill_anon_super,\n\t.fs_flags\t= FS_BINARY_MOUNTDATA,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "92-100",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ncp_inode_cachep);\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * ncp_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * ncp_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ncp_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&ncp_fs_type"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"called\\n\""
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic struct file_system_type ncp_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ncpfs\",\n\t.mount\t\t= ncp_mount,\n\t.kill_sb\t= kill_anon_super,\n\t.fs_flags\t= FS_BINARY_MOUNTDATA,\n};\n\nstatic void __exit exit_ncp_fs(void)\n{\n\tncp_dbg(1, \"called\\n\");\n\tunregister_filesystem(&ncp_fs_type);\n\tdestroy_inodecache();\n}"
  },
  {
    "function_name": "init_ncp_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "1045-1061",
    "snippet": "static int __init init_ncp_fs(void)\n{\n\tint err;\n\tncp_dbg(1, \"called\\n\");\n\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&ncp_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type ncp_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ncpfs\",\n\t.mount\t\t= ncp_mount,\n\t.kill_sb\t= kill_anon_super,\n\t.fs_flags\t= FS_BINARY_MOUNTDATA,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "92-100",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ncp_inode_cachep);\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * ncp_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * ncp_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ncp_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&ncp_fs_type"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodecache",
          "args": [],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "80-90",
          "snippet": "static int init_inodecache(void)\n{\n\tncp_inode_cachep = kmem_cache_create(\"ncp_inode_cache\",\n\t\t\t\t\t     sizeof(struct ncp_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ncp_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * ncp_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * ncp_inode_cachep;\n\nstatic int init_inodecache(void)\n{\n\tncp_inode_cachep = kmem_cache_create(\"ncp_inode_cache\",\n\t\t\t\t\t     sizeof(struct ncp_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ncp_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"called\\n\""
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic struct file_system_type ncp_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ncpfs\",\n\t.mount\t\t= ncp_mount,\n\t.kill_sb\t= kill_anon_super,\n\t.fs_flags\t= FS_BINARY_MOUNTDATA,\n};\n\nstatic int __init init_ncp_fs(void)\n{\n\tint err;\n\tncp_dbg(1, \"called\\n\");\n\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&ncp_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}"
  },
  {
    "function_name": "ncp_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "1030-1034",
    "snippet": "static struct dentry *ncp_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_nodev(fs_type, flags, data, ncp_fill_super);\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int  ncp_show_options(struct seq_file *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_nodev",
          "args": [
            "fs_type",
            "flags",
            "data",
            "ncp_fill_super"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic int  ncp_show_options(struct seq_file *, struct dentry *);\n\nstatic struct dentry *ncp_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_nodev(fs_type, flags, data, ncp_fill_super);\n}"
  },
  {
    "function_name": "ncp_notify_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "866-1028",
    "snippet": "int ncp_notify_change(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint result = 0;\n\t__le32 info_mask;\n\tstruct nw_modify_dos_info info;\n\tstruct ncp_server *server;\n\n\tresult = -EIO;\n\n\tserver = NCP_SERVER(inode);\n\tif (!server)\t/* How this could happen? */\n\t\tgoto out;\n\n\tresult = -EPERM;\n\tif (IS_DEADDIR(dentry->d_inode))\n\t\tgoto out;\n\n\t/* ageing the dentry to force validation */\n\tncp_age_dentry(server, dentry);\n\n\tresult = inode_change_ok(inode, attr);\n\tif (result < 0)\n\t\tgoto out;\n\n\tresult = -EPERM;\n\tif ((attr->ia_valid & ATTR_UID) && !uid_eq(attr->ia_uid, server->m.uid))\n\t\tgoto out;\n\n\tif ((attr->ia_valid & ATTR_GID) && !gid_eq(attr->ia_gid, server->m.gid))\n\t\tgoto out;\n\n\tif (((attr->ia_valid & ATTR_MODE) &&\n\t     (attr->ia_mode &\n\t      ~(S_IFREG | S_IFDIR | S_IRWXUGO))))\n\t\tgoto out;\n\n\tinfo_mask = 0;\n\tmemset(&info, 0, sizeof(info));\n\n#if 1 \n        if ((attr->ia_valid & ATTR_MODE) != 0)\n        {\n\t\tumode_t newmode = attr->ia_mode;\n\n\t\tinfo_mask |= DM_ATTRIBUTES;\n\n                if (S_ISDIR(inode->i_mode)) {\n                \tnewmode &= server->m.dir_mode;\n\t\t} else {\n#ifdef CONFIG_NCPFS_EXTRAS\t\t\t\n\t\t\tif (server->m.flags & NCP_MOUNT_EXTRAS) {\n\t\t\t\t/* any non-default execute bit set */\n\t\t\t\tif (newmode & ~server->m.file_mode & S_IXUGO)\n\t\t\t\t\tinfo.attributes |= aSHARED | aSYSTEM;\n\t\t\t\t/* read for group/world and not in default file_mode */\n\t\t\t\telse if (newmode & ~server->m.file_mode & S_IRUGO)\n\t\t\t\t\tinfo.attributes |= aSHARED;\n\t\t\t} else\n#endif\n\t\t\t\tnewmode &= server->m.file_mode;\t\t\t\n                }\n                if (newmode & S_IWUGO)\n                \tinfo.attributes &= ~(aRONLY|aRENAMEINHIBIT|aDELETEINHIBIT);\n                else\n\t\t\tinfo.attributes |=  (aRONLY|aRENAMEINHIBIT|aDELETEINHIBIT);\n\n#ifdef CONFIG_NCPFS_NFS_NS\n\t\tif (ncp_is_nfs_extras(server, NCP_FINFO(inode)->volNumber)) {\n\t\t\tresult = ncp_modify_nfs_info(server,\n\t\t\t\t\t\t     NCP_FINFO(inode)->volNumber,\n\t\t\t\t\t\t     NCP_FINFO(inode)->dirEntNum,\n\t\t\t\t\t\t     attr->ia_mode, 0);\n\t\t\tif (result != 0)\n\t\t\t\tgoto out;\n\t\t\tinfo.attributes &= ~(aSHARED | aSYSTEM);\n\t\t\t{\n\t\t\t\t/* mark partial success */\n\t\t\t\tstruct iattr tmpattr;\n\t\t\t\t\n\t\t\t\ttmpattr.ia_valid = ATTR_MODE;\n\t\t\t\ttmpattr.ia_mode = attr->ia_mode;\n\n\t\t\t\tsetattr_copy(inode, &tmpattr);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t}\n#endif\n        }\n#endif\n\n\t/* Do SIZE before attributes, otherwise mtime together with size does not work...\n\t */\n\tif ((attr->ia_valid & ATTR_SIZE) != 0) {\n\t\tint written;\n\n\t\tncp_dbg(1, \"trying to change size to %llu\\n\", attr->ia_size);\n\n\t\tif ((result = ncp_make_open(inode, O_WRONLY)) < 0) {\n\t\t\tresult = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\t\tncp_write_kernel(NCP_SERVER(inode), NCP_FINFO(inode)->file_handle,\n\t\t\t  attr->ia_size, 0, \"\", &written);\n\n\t\t/* According to ndir, the changes only take effect after\n\t\t   closing the file */\n\t\tncp_inode_close(inode);\n\t\tresult = ncp_make_closed(inode);\n\t\tif (result)\n\t\t\tgoto out;\n\n\t\tif (attr->ia_size != i_size_read(inode)) {\n\t\t\ttruncate_setsize(inode, attr->ia_size);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\tif ((attr->ia_valid & ATTR_CTIME) != 0) {\n\t\tinfo_mask |= (DM_CREATE_TIME | DM_CREATE_DATE);\n\t\tncp_date_unix2dos(attr->ia_ctime.tv_sec,\n\t\t\t     &info.creationTime, &info.creationDate);\n\t}\n\tif ((attr->ia_valid & ATTR_MTIME) != 0) {\n\t\tinfo_mask |= (DM_MODIFY_TIME | DM_MODIFY_DATE);\n\t\tncp_date_unix2dos(attr->ia_mtime.tv_sec,\n\t\t\t\t  &info.modifyTime, &info.modifyDate);\n\t}\n\tif ((attr->ia_valid & ATTR_ATIME) != 0) {\n\t\t__le16 dummy;\n\t\tinfo_mask |= (DM_LAST_ACCESS_DATE);\n\t\tncp_date_unix2dos(attr->ia_atime.tv_sec,\n\t\t\t\t  &dummy, &info.lastAccessDate);\n\t}\n\tif (info_mask != 0) {\n\t\tresult = ncp_modify_file_or_subdir_dos_info(NCP_SERVER(inode),\n\t\t\t\t      inode, info_mask, &info);\n\t\tif (result != 0) {\n\t\t\tif (info_mask == (DM_CREATE_TIME | DM_CREATE_DATE)) {\n\t\t\t\t/* NetWare seems not to allow this. I\n\t\t\t\t   do not know why. So, just tell the\n\t\t\t\t   user everything went fine. This is\n\t\t\t\t   a terrible hack, but I do not know\n\t\t\t\t   how to do this correctly. */\n\t\t\t\tresult = 0;\n\t\t\t} else\n\t\t\t\tgoto out;\n\t\t}\n#ifdef CONFIG_NCPFS_STRONG\t\t\n\t\tif ((!result) && (info_mask & DM_ATTRIBUTES))\n\t\t\tNCP_FINFO(inode)->nwattr = info.attributes;\n#endif\n\t}\n\tif (result)\n\t\tgoto out;\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\nout:\n\tif (result > 0)\n\t\tresult = -EACCES;\n\treturn result;\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_evict_inode(struct inode *);",
      "static int  ncp_show_options(struct seq_file *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_modify_file_or_subdir_dos_info",
          "args": [
            "NCP_SERVER(inode)",
            "inode",
            "info_mask",
            "&info"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_modify_file_or_subdir_dos_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "670-677",
          "snippet": "int ncp_modify_file_or_subdir_dos_info(struct ncp_server *server,\n\t\t\t\t       struct inode *dir,\n\t\t\t\t       __le32 info_mask,\n\t\t\t\t       const struct nw_modify_dos_info *info)\n{\n\treturn ncp_modify_file_or_subdir_dos_info_path(server, dir, NULL,\n\t\tinfo_mask, info);\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_modify_file_or_subdir_dos_info(struct ncp_server *server,\n\t\t\t\t       struct inode *dir,\n\t\t\t\t       __le32 info_mask,\n\t\t\t\t       const struct nw_modify_dos_info *info)\n{\n\treturn ncp_modify_file_or_subdir_dos_info_path(server, dir, NULL,\n\t\tinfo_mask, info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_date_unix2dos",
          "args": [
            "attr->ia_atime.tv_sec",
            "&dummy",
            "&info.lastAccessDate"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_date_unix2dos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "1213-1237",
          "snippet": "void\nncp_date_unix2dos(int unix_date, __le16 *time, __le16 *date)\n{\n\tint day, year, nl_day, month;\n\n\tunix_date = utc2local(unix_date);\n\t*time = cpu_to_le16(\n\t\t(unix_date % 60) / 2 + (((unix_date / 60) % 60) << 5) +\n\t\t(((unix_date / 3600) % 24) << 11));\n\tday = unix_date / 86400 - 3652;\n\tyear = day / 365;\n\tif ((year + 3) / 4 + 365 * year > day)\n\t\tyear--;\n\tday -= (year + 3) / 4 + 365 * year;\n\tif (day == 59 && !(year & 3)) {\n\t\tnl_day = day;\n\t\tmonth = 2;\n\t} else {\n\t\tnl_day = (year & 3) || day <= 59 ? day : day - 1;\n\t\tfor (month = 1; month < 12; month++)\n\t\t\tif (day_n[month] > nl_day)\n\t\t\t\tbreak;\n\t}\n\t*date = cpu_to_le16(nl_day - day_n[month - 1] + 1 + (month << 5) + (year << 9));\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int day_n[] =\n{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0, 0};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int day_n[] =\n{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0, 0};\n\nvoid\nncp_date_unix2dos(int unix_date, __le16 *time, __le16 *date)\n{\n\tint day, year, nl_day, month;\n\n\tunix_date = utc2local(unix_date);\n\t*time = cpu_to_le16(\n\t\t(unix_date % 60) / 2 + (((unix_date / 60) % 60) << 5) +\n\t\t(((unix_date / 3600) % 24) << 11));\n\tday = unix_date / 86400 - 3652;\n\tyear = day / 365;\n\tif ((year + 3) / 4 + 365 * year > day)\n\t\tyear--;\n\tday -= (year + 3) / 4 + 365 * year;\n\tif (day == 59 && !(year & 3)) {\n\t\tnl_day = day;\n\t\tmonth = 2;\n\t} else {\n\t\tnl_day = (year & 3) || day <= 59 ? day : day - 1;\n\t\tfor (month = 1; month < 12; month++)\n\t\t\tif (day_n[month] > nl_day)\n\t\t\t\tbreak;\n\t}\n\t*date = cpu_to_le16(nl_day - day_n[month - 1] + 1 + (month << 5) + (year << 9));\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_make_closed",
          "args": [
            "inode"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_make_closed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "286-304",
          "snippet": "int\nncp_make_closed(struct inode *inode)\n{\n\tint err;\n\n\terr = 0;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (atomic_read(&NCP_FINFO(inode)->opened) == 1) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 0);\n\t\terr = ncp_close_file(NCP_SERVER(inode), NCP_FINFO(inode)->file_handle);\n\n\t\tif (!err)\n\t\t\tncp_vdbg(\"volnum=%d, dirent=%u, error=%d\\n\",\n\t\t\t\t NCP_FINFO(inode)->volNumber,\n\t\t\t\t NCP_FINFO(inode)->dirEntNum, err);\n\t}\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\n\treturn err;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_make_closed(struct inode *inode)\n{\n\tint err;\n\n\terr = 0;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (atomic_read(&NCP_FINFO(inode)->opened) == 1) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 0);\n\t\terr = ncp_close_file(NCP_SERVER(inode), NCP_FINFO(inode)->file_handle);\n\n\t\tif (!err)\n\t\t\tncp_vdbg(\"volnum=%d, dirent=%u, error=%d\\n\",\n\t\t\t\t NCP_FINFO(inode)->volNumber,\n\t\t\t\t NCP_FINFO(inode)->dirEntNum, err);\n\t}\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_inode_close",
          "args": [
            "inode"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_inode_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "62-64",
          "snippet": "static inline void ncp_inode_close(struct inode *inode) {\n\tatomic_dec(&NCP_FINFO(inode)->opened);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ncp_inode_close(struct inode *inode) {\n\tatomic_dec(&NCP_FINFO(inode)->opened);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_write_kernel",
          "args": [
            "NCP_SERVER(inode)",
            "NCP_FINFO(inode)->file_handle",
            "attr->ia_size",
            "0",
            "\"\"",
            "&written"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_write_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "1035-1053",
          "snippet": "int\nncp_write_kernel(struct ncp_server *server, const char *file_id,\n\t\t __u32 offset, __u16 to_write,\n\t\t const char *source, int *bytes_written)\n{\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be16(server, to_write);\n\tncp_add_mem(server, source, to_write);\n\t\n\tif ((result = ncp_request(server, 73)) == 0)\n\t\t*bytes_written = to_write;\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_write_kernel(struct ncp_server *server, const char *file_id,\n\t\t __u32 offset, __u16 to_write,\n\t\t const char *source, int *bytes_written)\n{\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be16(server, to_write);\n\tncp_add_mem(server, source, to_write);\n\t\n\tif ((result = ncp_request(server, 73)) == 0)\n\t\t*bytes_written = to_write;\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_make_open",
          "args": [
            "inode",
            "O_WRONLY"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_make_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/file.c",
          "lines": "32-98",
          "snippet": "int ncp_make_open(struct inode *inode, int right)\n{\n\tint error;\n\tint access;\n\n\terror = -EINVAL;\n\tif (!inode) {\n\t\tpr_err(\"%s: got NULL inode\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tncp_dbg(1, \"opened=%d, volume # %u, dir entry # %u\\n\",\n\t\tatomic_read(&NCP_FINFO(inode)->opened), \n\t\tNCP_FINFO(inode)->volNumber, \n\t\tNCP_FINFO(inode)->dirEntNum);\n\terror = -EACCES;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tstruct ncp_entry_info finfo;\n\t\tint result;\n\n\t\t/* tries max. rights */\n\t\tfinfo.access = O_RDWR;\n\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ | AR_WRITE, &finfo);\n\t\tif (!result)\n\t\t\tgoto update;\n\t\t/* RDWR did not succeeded, try readonly or writeonly as requested */\n\t\tswitch (right) {\n\t\t\tcase O_RDONLY:\n\t\t\t\tfinfo.access = O_RDONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ, &finfo);\n\t\t\t\tbreak;\n\t\t\tcase O_WRONLY:\n\t\t\t\tfinfo.access = O_WRONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_WRITE, &finfo);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result) {\n\t\t\tncp_vdbg(\"failed, result=%d\\n\", result);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * Update the inode information.\n\t\t */\n\tupdate:\n\t\tncp_update_inode(inode, &finfo);\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 1);\n\t}\n\n\taccess = NCP_FINFO(inode)->access;\n\tncp_vdbg(\"file open, access=%x\\n\", access);\n\tif (access == right || access == O_RDWR) {\n\t\tatomic_inc(&NCP_FINFO(inode)->opened);\n\t\terror = 0;\n\t}\n\nout_unlock:\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/uaccess.h>\n\nint ncp_make_open(struct inode *inode, int right)\n{\n\tint error;\n\tint access;\n\n\terror = -EINVAL;\n\tif (!inode) {\n\t\tpr_err(\"%s: got NULL inode\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tncp_dbg(1, \"opened=%d, volume # %u, dir entry # %u\\n\",\n\t\tatomic_read(&NCP_FINFO(inode)->opened), \n\t\tNCP_FINFO(inode)->volNumber, \n\t\tNCP_FINFO(inode)->dirEntNum);\n\terror = -EACCES;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tstruct ncp_entry_info finfo;\n\t\tint result;\n\n\t\t/* tries max. rights */\n\t\tfinfo.access = O_RDWR;\n\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ | AR_WRITE, &finfo);\n\t\tif (!result)\n\t\t\tgoto update;\n\t\t/* RDWR did not succeeded, try readonly or writeonly as requested */\n\t\tswitch (right) {\n\t\t\tcase O_RDONLY:\n\t\t\t\tfinfo.access = O_RDONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ, &finfo);\n\t\t\t\tbreak;\n\t\t\tcase O_WRONLY:\n\t\t\t\tfinfo.access = O_WRONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_WRITE, &finfo);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result) {\n\t\t\tncp_vdbg(\"failed, result=%d\\n\", result);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * Update the inode information.\n\t\t */\n\tupdate:\n\t\tncp_update_inode(inode, &finfo);\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 1);\n\t}\n\n\taccess = NCP_FINFO(inode)->access;\n\tncp_vdbg(\"file open, access=%x\\n\", access);\n\tif (access == right || access == O_RDWR) {\n\t\tatomic_inc(&NCP_FINFO(inode)->opened);\n\t\terror = 0;\n\t}\n\nout_unlock:\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"trying to change size to %llu\\n\"",
            "attr->ia_size"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_modify_nfs_info",
          "args": [
            "server",
            "NCP_FINFO(inode)->volNumber",
            "NCP_FINFO(inode)->dirEntNum",
            "attr->ia_mode",
            "0"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_modify_nfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "680-703",
          "snippet": "int ncp_modify_nfs_info(struct ncp_server *server, __u8 volnum, __le32 dirent,\n\t\t\t       __u32 mode, __u32 rdev)\n\n{\n\tint result = 0;\n\n\tncp_init_request(server);\n\tif (server->name_space[volnum] == NW_NS_NFS) {\n\t\tncp_add_byte(server, 25);\t/* subfunction */\n\t\tncp_add_byte(server, server->name_space[volnum]);\n\t\tncp_add_byte(server, NW_NS_NFS);\n\t\tncp_add_byte(server, volnum);\n\t\tncp_add_dword(server, dirent);\n\t\t/* we must always operate on both nlinks and rdev, otherwise\n\t\t   rdev is not set */\n\t\tncp_add_dword_lh(server, NSIBM_NFS_MODE | NSIBM_NFS_NLINKS | NSIBM_NFS_RDEV);\n\t\tncp_add_dword_lh(server, mode);\n\t\tncp_add_dword_lh(server, 1);\t/* nlinks */\n\t\tncp_add_dword_lh(server, rdev);\n\t\tresult = ncp_request(server, 87);\n\t}\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_modify_nfs_info(struct ncp_server *server, __u8 volnum, __le32 dirent,\n\t\t\t       __u32 mode, __u32 rdev)\n\n{\n\tint result = 0;\n\n\tncp_init_request(server);\n\tif (server->name_space[volnum] == NW_NS_NFS) {\n\t\tncp_add_byte(server, 25);\t/* subfunction */\n\t\tncp_add_byte(server, server->name_space[volnum]);\n\t\tncp_add_byte(server, NW_NS_NFS);\n\t\tncp_add_byte(server, volnum);\n\t\tncp_add_dword(server, dirent);\n\t\t/* we must always operate on both nlinks and rdev, otherwise\n\t\t   rdev is not set */\n\t\tncp_add_dword_lh(server, NSIBM_NFS_MODE | NSIBM_NFS_NLINKS | NSIBM_NFS_RDEV);\n\t\tncp_add_dword_lh(server, mode);\n\t\tncp_add_dword_lh(server, 1);\t/* nlinks */\n\t\tncp_add_dword_lh(server, rdev);\n\t\tresult = ncp_request(server, 87);\n\t}\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_is_nfs_extras",
          "args": [
            "server",
            "NCP_FINFO(inode)->volNumber"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_is_nfs_extras",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "119-126",
          "snippet": "static inline int ncp_is_nfs_extras(struct ncp_server* server, unsigned int volnum) {\n#ifdef CONFIG_NCPFS_NFS_NS\n\treturn (server->m.flags & NCP_MOUNT_NFS_EXTRAS) &&\n\t       (server->name_space[volnum] == NW_NS_NFS);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ncp_is_nfs_extras(struct ncp_server* server, unsigned int volnum) {\n#ifdef CONFIG_NCPFS_NFS_NS\n\treturn (server->m.flags & NCP_MOUNT_NFS_EXTRAS) &&\n\t       (server->name_space[volnum] == NW_NS_NFS);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&info",
            "0",
            "sizeof(info)"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "attr->ia_gid",
            "server->m.gid"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "attr->ia_uid",
            "server->m.uid"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_age_dentry",
          "args": [
            "server",
            "dentry"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_age_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "175-179",
          "snippet": "static inline void\nncp_age_dentry(struct ncp_server* server, struct dentry* dentry)\n{\n\tdentry->d_time = jiffies - NCP_MAX_AGE(server);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void\nncp_age_dentry(struct ncp_server* server, struct dentry* dentry)\n{\n\tdentry->d_time = jiffies - NCP_MAX_AGE(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DEADDIR",
          "args": [
            "dentry->d_inode"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\nstatic int  ncp_show_options(struct seq_file *, struct dentry *);\n\nint ncp_notify_change(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint result = 0;\n\t__le32 info_mask;\n\tstruct nw_modify_dos_info info;\n\tstruct ncp_server *server;\n\n\tresult = -EIO;\n\n\tserver = NCP_SERVER(inode);\n\tif (!server)\t/* How this could happen? */\n\t\tgoto out;\n\n\tresult = -EPERM;\n\tif (IS_DEADDIR(dentry->d_inode))\n\t\tgoto out;\n\n\t/* ageing the dentry to force validation */\n\tncp_age_dentry(server, dentry);\n\n\tresult = inode_change_ok(inode, attr);\n\tif (result < 0)\n\t\tgoto out;\n\n\tresult = -EPERM;\n\tif ((attr->ia_valid & ATTR_UID) && !uid_eq(attr->ia_uid, server->m.uid))\n\t\tgoto out;\n\n\tif ((attr->ia_valid & ATTR_GID) && !gid_eq(attr->ia_gid, server->m.gid))\n\t\tgoto out;\n\n\tif (((attr->ia_valid & ATTR_MODE) &&\n\t     (attr->ia_mode &\n\t      ~(S_IFREG | S_IFDIR | S_IRWXUGO))))\n\t\tgoto out;\n\n\tinfo_mask = 0;\n\tmemset(&info, 0, sizeof(info));\n\n#if 1 \n        if ((attr->ia_valid & ATTR_MODE) != 0)\n        {\n\t\tumode_t newmode = attr->ia_mode;\n\n\t\tinfo_mask |= DM_ATTRIBUTES;\n\n                if (S_ISDIR(inode->i_mode)) {\n                \tnewmode &= server->m.dir_mode;\n\t\t} else {\n#ifdef CONFIG_NCPFS_EXTRAS\t\t\t\n\t\t\tif (server->m.flags & NCP_MOUNT_EXTRAS) {\n\t\t\t\t/* any non-default execute bit set */\n\t\t\t\tif (newmode & ~server->m.file_mode & S_IXUGO)\n\t\t\t\t\tinfo.attributes |= aSHARED | aSYSTEM;\n\t\t\t\t/* read for group/world and not in default file_mode */\n\t\t\t\telse if (newmode & ~server->m.file_mode & S_IRUGO)\n\t\t\t\t\tinfo.attributes |= aSHARED;\n\t\t\t} else\n#endif\n\t\t\t\tnewmode &= server->m.file_mode;\t\t\t\n                }\n                if (newmode & S_IWUGO)\n                \tinfo.attributes &= ~(aRONLY|aRENAMEINHIBIT|aDELETEINHIBIT);\n                else\n\t\t\tinfo.attributes |=  (aRONLY|aRENAMEINHIBIT|aDELETEINHIBIT);\n\n#ifdef CONFIG_NCPFS_NFS_NS\n\t\tif (ncp_is_nfs_extras(server, NCP_FINFO(inode)->volNumber)) {\n\t\t\tresult = ncp_modify_nfs_info(server,\n\t\t\t\t\t\t     NCP_FINFO(inode)->volNumber,\n\t\t\t\t\t\t     NCP_FINFO(inode)->dirEntNum,\n\t\t\t\t\t\t     attr->ia_mode, 0);\n\t\t\tif (result != 0)\n\t\t\t\tgoto out;\n\t\t\tinfo.attributes &= ~(aSHARED | aSYSTEM);\n\t\t\t{\n\t\t\t\t/* mark partial success */\n\t\t\t\tstruct iattr tmpattr;\n\t\t\t\t\n\t\t\t\ttmpattr.ia_valid = ATTR_MODE;\n\t\t\t\ttmpattr.ia_mode = attr->ia_mode;\n\n\t\t\t\tsetattr_copy(inode, &tmpattr);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t}\n#endif\n        }\n#endif\n\n\t/* Do SIZE before attributes, otherwise mtime together with size does not work...\n\t */\n\tif ((attr->ia_valid & ATTR_SIZE) != 0) {\n\t\tint written;\n\n\t\tncp_dbg(1, \"trying to change size to %llu\\n\", attr->ia_size);\n\n\t\tif ((result = ncp_make_open(inode, O_WRONLY)) < 0) {\n\t\t\tresult = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\t\tncp_write_kernel(NCP_SERVER(inode), NCP_FINFO(inode)->file_handle,\n\t\t\t  attr->ia_size, 0, \"\", &written);\n\n\t\t/* According to ndir, the changes only take effect after\n\t\t   closing the file */\n\t\tncp_inode_close(inode);\n\t\tresult = ncp_make_closed(inode);\n\t\tif (result)\n\t\t\tgoto out;\n\n\t\tif (attr->ia_size != i_size_read(inode)) {\n\t\t\ttruncate_setsize(inode, attr->ia_size);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\tif ((attr->ia_valid & ATTR_CTIME) != 0) {\n\t\tinfo_mask |= (DM_CREATE_TIME | DM_CREATE_DATE);\n\t\tncp_date_unix2dos(attr->ia_ctime.tv_sec,\n\t\t\t     &info.creationTime, &info.creationDate);\n\t}\n\tif ((attr->ia_valid & ATTR_MTIME) != 0) {\n\t\tinfo_mask |= (DM_MODIFY_TIME | DM_MODIFY_DATE);\n\t\tncp_date_unix2dos(attr->ia_mtime.tv_sec,\n\t\t\t\t  &info.modifyTime, &info.modifyDate);\n\t}\n\tif ((attr->ia_valid & ATTR_ATIME) != 0) {\n\t\t__le16 dummy;\n\t\tinfo_mask |= (DM_LAST_ACCESS_DATE);\n\t\tncp_date_unix2dos(attr->ia_atime.tv_sec,\n\t\t\t\t  &dummy, &info.lastAccessDate);\n\t}\n\tif (info_mask != 0) {\n\t\tresult = ncp_modify_file_or_subdir_dos_info(NCP_SERVER(inode),\n\t\t\t\t      inode, info_mask, &info);\n\t\tif (result != 0) {\n\t\t\tif (info_mask == (DM_CREATE_TIME | DM_CREATE_DATE)) {\n\t\t\t\t/* NetWare seems not to allow this. I\n\t\t\t\t   do not know why. So, just tell the\n\t\t\t\t   user everything went fine. This is\n\t\t\t\t   a terrible hack, but I do not know\n\t\t\t\t   how to do this correctly. */\n\t\t\t\tresult = 0;\n\t\t\t} else\n\t\t\t\tgoto out;\n\t\t}\n#ifdef CONFIG_NCPFS_STRONG\t\t\n\t\tif ((!result) && (info_mask & DM_ATTRIBUTES))\n\t\t\tNCP_FINFO(inode)->nwattr = info.attributes;\n#endif\n\t}\n\tif (result)\n\t\tgoto out;\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\nout:\n\tif (result > 0)\n\t\tresult = -EACCES;\n\treturn result;\n}"
  },
  {
    "function_name": "ncp_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "800-864",
    "snippet": "static int ncp_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct dentry* d;\n\tstruct inode* i;\n\tstruct ncp_inode_info* ni;\n\tstruct ncp_server* s;\n\tstruct ncp_volume_info vi;\n\tstruct super_block *sb = dentry->d_sb;\n\tint err;\n\t__u8 dh;\n\t\n\td = sb->s_root;\n\tif (!d) {\n\t\tgoto dflt;\n\t}\n\ti = d->d_inode;\n\tif (!i) {\n\t\tgoto dflt;\n\t}\n\tni = NCP_FINFO(i);\n\tif (!ni) {\n\t\tgoto dflt;\n\t}\n\ts = NCP_SBP(sb);\n\tif (!s) {\n\t\tgoto dflt;\n\t}\n\tif (!s->m.mounted_vol[0]) {\n\t\tgoto dflt;\n\t}\n\n\terr = ncp_dirhandle_alloc(s, ni->volNumber, ni->DosDirNum, &dh);\n\tif (err) {\n\t\tgoto dflt;\n\t}\n\terr = ncp_get_directory_info(s, dh, &vi);\n\tncp_dirhandle_free(s, dh);\n\tif (err) {\n\t\tgoto dflt;\n\t}\n\tbuf->f_type = NCP_SUPER_MAGIC;\n\tbuf->f_bsize = vi.sectors_per_block * 512;\n\tbuf->f_blocks = vi.total_blocks;\n\tbuf->f_bfree = vi.free_blocks;\n\tbuf->f_bavail = vi.free_blocks;\n\tbuf->f_files = vi.total_dir_entries;\n\tbuf->f_ffree = vi.available_dir_entries;\n\tbuf->f_namelen = 12;\n\treturn 0;\n\n\t/* We cannot say how much disk space is left on a mounted\n\t   NetWare Server, because free space is distributed over\n\t   volumes, and the current user might have disk quotas. So\n\t   free space is not that simple to determine. Our decision\n\t   here is to err conservatively. */\n\ndflt:;\n\tbuf->f_type = NCP_SUPER_MAGIC;\n\tbuf->f_bsize = NCP_BLOCK_SIZE;\n\tbuf->f_blocks = 0;\n\tbuf->f_bfree = 0;\n\tbuf->f_bavail = 0;\n\tbuf->f_namelen = 12;\n\treturn 0;\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_evict_inode(struct inode *);",
      "static void ncp_put_super(struct super_block *);",
      "static int  ncp_statfs(struct dentry *, struct kstatfs *);",
      "static int  ncp_show_options(struct seq_file *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_dirhandle_free",
          "args": [
            "s",
            "dh"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_dirhandle_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "342-350",
          "snippet": "int ncp_dirhandle_free(struct ncp_server* server, __u8 dirhandle) {\n\tint result;\n\t\n\tncp_init_request_s(server, 20);\n\tncp_add_byte(server, dirhandle);\n\tresult = ncp_request(server, 22);\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_dirhandle_free(struct ncp_server* server, __u8 dirhandle) {\n\tint result;\n\t\n\tncp_init_request_s(server, 20);\n\tncp_add_byte(server, dirhandle);\n\tresult = ncp_request(server, 22);\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_get_directory_info",
          "args": [
            "s",
            "dh",
            "&vi"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_get_directory_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "238-270",
          "snippet": "int ncp_get_directory_info(struct ncp_server* server, __u8 n, \n\t\t\t   struct ncp_volume_info* target) {\n\tint result;\n\tint len;\n\n\tncp_init_request_s(server, 45);\n\tncp_add_byte(server, n);\n\n\tif ((result = ncp_request(server, 22)) != 0) {\n\t\tgoto out;\n\t}\n\ttarget->total_blocks = ncp_reply_dword_lh(server, 0);\n\ttarget->free_blocks = ncp_reply_dword_lh(server, 4);\n\ttarget->purgeable_blocks = 0;\n\ttarget->not_yet_purgeable_blocks = 0;\n\ttarget->total_dir_entries = ncp_reply_dword_lh(server, 8);\n\ttarget->available_dir_entries = ncp_reply_dword_lh(server, 12);\n\ttarget->sectors_per_block = ncp_reply_byte(server, 20);\n\n\tmemset(&(target->volume_name), 0, sizeof(target->volume_name));\n\n\tresult = -EIO;\n\tlen = ncp_reply_byte(server, 21);\n\tif (len > NCP_VOLNAME_LEN) {\n\t\tncp_dbg(1, \"volume name too long: %d\\n\", len);\n\t\tgoto out;\n\t}\n\tmemcpy(&(target->volume_name), ncp_reply_data(server, 22), len);\n\tresult = 0;\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_get_directory_info(struct ncp_server* server, __u8 n, \n\t\t\t   struct ncp_volume_info* target) {\n\tint result;\n\tint len;\n\n\tncp_init_request_s(server, 45);\n\tncp_add_byte(server, n);\n\n\tif ((result = ncp_request(server, 22)) != 0) {\n\t\tgoto out;\n\t}\n\ttarget->total_blocks = ncp_reply_dword_lh(server, 0);\n\ttarget->free_blocks = ncp_reply_dword_lh(server, 4);\n\ttarget->purgeable_blocks = 0;\n\ttarget->not_yet_purgeable_blocks = 0;\n\ttarget->total_dir_entries = ncp_reply_dword_lh(server, 8);\n\ttarget->available_dir_entries = ncp_reply_dword_lh(server, 12);\n\ttarget->sectors_per_block = ncp_reply_byte(server, 20);\n\n\tmemset(&(target->volume_name), 0, sizeof(target->volume_name));\n\n\tresult = -EIO;\n\tlen = ncp_reply_byte(server, 21);\n\tif (len > NCP_VOLNAME_LEN) {\n\t\tncp_dbg(1, \"volume name too long: %d\\n\", len);\n\t\tgoto out;\n\t}\n\tmemcpy(&(target->volume_name), ncp_reply_data(server, 22), len);\n\tresult = 0;\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dirhandle_alloc",
          "args": [
            "s",
            "ni->volNumber",
            "ni->DosDirNum",
            "&dh"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_dirhandle_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "325-340",
          "snippet": "int ncp_dirhandle_alloc(struct ncp_server* server, __u8 volnum, __le32 dirent,\n\t\t\t__u8* dirhandle) {\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 12);\t\t/* subfunction */\n\tncp_add_byte(server, NW_NS_DOS);\n\tncp_add_byte(server, 0);\n\tncp_add_word(server, 0);\n\tncp_add_handle_path(server, volnum, dirent, 1, NULL);\n\tif ((result = ncp_request(server, 87)) == 0) {\n\t\t*dirhandle = ncp_reply_byte(server, 0);\n\t}\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_dirhandle_alloc(struct ncp_server* server, __u8 volnum, __le32 dirent,\n\t\t\t__u8* dirhandle) {\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 12);\t\t/* subfunction */\n\tncp_add_byte(server, NW_NS_DOS);\n\tncp_add_byte(server, 0);\n\tncp_add_word(server, 0);\n\tncp_add_handle_path(server, volnum, dirent, 1, NULL);\n\tif ((result = ncp_request(server, 87)) == 0) {\n\t\t*dirhandle = ncp_reply_byte(server, 0);\n\t}\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SBP",
          "args": [
            "sb"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_SBP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "43-46",
          "snippet": "static inline struct ncp_server *NCP_SBP(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_conn_logged_in(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_conn_logged_in(struct super_block *);\n\nstatic inline struct ncp_server *NCP_SBP(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "i"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\nstatic void ncp_put_super(struct super_block *);\nstatic int  ncp_statfs(struct dentry *, struct kstatfs *);\nstatic int  ncp_show_options(struct seq_file *, struct dentry *);\n\nstatic int ncp_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct dentry* d;\n\tstruct inode* i;\n\tstruct ncp_inode_info* ni;\n\tstruct ncp_server* s;\n\tstruct ncp_volume_info vi;\n\tstruct super_block *sb = dentry->d_sb;\n\tint err;\n\t__u8 dh;\n\t\n\td = sb->s_root;\n\tif (!d) {\n\t\tgoto dflt;\n\t}\n\ti = d->d_inode;\n\tif (!i) {\n\t\tgoto dflt;\n\t}\n\tni = NCP_FINFO(i);\n\tif (!ni) {\n\t\tgoto dflt;\n\t}\n\ts = NCP_SBP(sb);\n\tif (!s) {\n\t\tgoto dflt;\n\t}\n\tif (!s->m.mounted_vol[0]) {\n\t\tgoto dflt;\n\t}\n\n\terr = ncp_dirhandle_alloc(s, ni->volNumber, ni->DosDirNum, &dh);\n\tif (err) {\n\t\tgoto dflt;\n\t}\n\terr = ncp_get_directory_info(s, dh, &vi);\n\tncp_dirhandle_free(s, dh);\n\tif (err) {\n\t\tgoto dflt;\n\t}\n\tbuf->f_type = NCP_SUPER_MAGIC;\n\tbuf->f_bsize = vi.sectors_per_block * 512;\n\tbuf->f_blocks = vi.total_blocks;\n\tbuf->f_bfree = vi.free_blocks;\n\tbuf->f_bavail = vi.free_blocks;\n\tbuf->f_files = vi.total_dir_entries;\n\tbuf->f_ffree = vi.available_dir_entries;\n\tbuf->f_namelen = 12;\n\treturn 0;\n\n\t/* We cannot say how much disk space is left on a mounted\n\t   NetWare Server, because free space is distributed over\n\t   volumes, and the current user might have disk quotas. So\n\t   free space is not that simple to determine. Our decision\n\t   here is to err conservatively. */\n\ndflt:;\n\tbuf->f_type = NCP_SUPER_MAGIC;\n\tbuf->f_bsize = NCP_BLOCK_SIZE;\n\tbuf->f_blocks = 0;\n\tbuf->f_bfree = 0;\n\tbuf->f_bavail = 0;\n\tbuf->f_namelen = 12;\n\treturn 0;\n}"
  },
  {
    "function_name": "ncp_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "771-798",
    "snippet": "static void ncp_put_super(struct super_block *sb)\n{\n\tstruct ncp_server *server = NCP_SBP(sb);\n\n\tncp_lock_server(server);\n\tncp_disconnect(server);\n\tncp_unlock_server(server);\n\n\tncp_stop_tasks(server);\n\n\tmutex_destroy(&server->rcv.creq_mutex);\n\tmutex_destroy(&server->root_setup_lock);\n\tmutex_destroy(&server->mutex);\n\n\tif (server->info_sock)\n\t\tsockfd_put(server->info_sock);\n\tsockfd_put(server->ncp_sock);\n\tkill_pid(server->m.wdog_pid, SIGTERM, 1);\n\tput_pid(server->m.wdog_pid);\n\n\tbdi_destroy(&server->bdi);\n\tkfree(server->priv.data);\n\tkfree(server->auth.object_name);\n\tvfree(server->rxbuf);\n\tvfree(server->txbuf);\n\tvfree(server->packet);\n\tcall_rcu(&server->rcu, delayed_free);\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_put_super(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&server->rcu",
            "delayed_free"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "server->packet"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "server->txbuf"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "server->rxbuf"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "server->auth.object_name"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "server->priv.data"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_destroy",
          "args": [
            "&server->bdi"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bdi_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "372-376",
          "snippet": "static void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "server->m.wdog_pid"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_pid",
          "args": [
            "server->m.wdog_pid",
            "SIGTERM",
            "1"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sockfd_put",
          "args": [
            "server->ncp_sock"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sockfd_put",
          "args": [
            "server->info_sock"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&server->mutex"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&server->root_setup_lock"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_stop_tasks",
          "args": [
            "server"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_stop_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "313-328",
          "snippet": "static void ncp_stop_tasks(struct ncp_server *server) {\n\tstruct sock* sk = server->ncp_sock->sk;\n\n\tlock_sock(sk);\n\tsk->sk_error_report = server->error_report;\n\tsk->sk_data_ready   = server->data_ready;\n\tsk->sk_write_space  = server->write_space;\n\trelease_sock(sk);\n\tdel_timer_sync(&server->timeout_tm);\n\n\tflush_work(&server->rcv.tq);\n\tif (sk->sk_socket->type == SOCK_STREAM)\n\t\tflush_work(&server->tx.tq);\n\telse\n\t\tflush_work(&server->timeout_tq);\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_stop_tasks(struct ncp_server *server) {\n\tstruct sock* sk = server->ncp_sock->sk;\n\n\tlock_sock(sk);\n\tsk->sk_error_report = server->error_report;\n\tsk->sk_data_ready   = server->data_ready;\n\tsk->sk_write_space  = server->write_space;\n\trelease_sock(sk);\n\tdel_timer_sync(&server->timeout_tm);\n\n\tflush_work(&server->rcv.tq);\n\tif (sk->sk_socket->type == SOCK_STREAM)\n\t\tflush_work(&server->tx.tq);\n\telse\n\t\tflush_work(&server->timeout_tq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_unlock_server",
          "args": [
            "server"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_unlock_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "873-881",
          "snippet": "void ncp_unlock_server(struct ncp_server *server)\n{\n\tif (!server->lock) {\n\t\tpr_warn(\"%s: was not locked!\\n\", __func__);\n\t\treturn;\n\t}\n\tserver->lock = 0;\n\tmutex_unlock(&server->mutex);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nvoid ncp_unlock_server(struct ncp_server *server)\n{\n\tif (!server->lock) {\n\t\tpr_warn(\"%s: was not locked!\\n\", __func__);\n\t\treturn;\n\t}\n\tserver->lock = 0;\n\tmutex_unlock(&server->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_disconnect",
          "args": [
            "server"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "853-863",
          "snippet": "int ncp_disconnect(struct ncp_server *server)\n{\n\tstruct ncp_request_header *h;\n\n\th = (struct ncp_request_header *) (server->packet);\n\th->type = NCP_DEALLOC_SLOT_REQUEST;\n\th->task\t\t= 2; /* see above */\n\th->function\t= 0;\n\n\treturn ncp_do_request(server, sizeof(*h), server->packet, server->packet_size);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nint ncp_disconnect(struct ncp_server *server)\n{\n\tstruct ncp_request_header *h;\n\n\th = (struct ncp_request_header *) (server->packet);\n\th->type = NCP_DEALLOC_SLOT_REQUEST;\n\th->task\t\t= 2; /* see above */\n\th->function\t= 0;\n\n\treturn ncp_do_request(server, sizeof(*h), server->packet, server->packet_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_lock_server",
          "args": [
            "server"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_lock_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "865-871",
          "snippet": "void ncp_lock_server(struct ncp_server *server)\n{\n\tmutex_lock(&server->mutex);\n\tif (server->lock)\n\t\tpr_warn(\"%s: was locked!\\n\", __func__);\n\tserver->lock = 1;\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nvoid ncp_lock_server(struct ncp_server *server)\n{\n\tmutex_lock(&server->mutex);\n\tif (server->lock)\n\t\tpr_warn(\"%s: was locked!\\n\", __func__);\n\tserver->lock = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SBP",
          "args": [
            "sb"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_SBP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "43-46",
          "snippet": "static inline struct ncp_server *NCP_SBP(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_conn_logged_in(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_conn_logged_in(struct super_block *);\n\nstatic inline struct ncp_server *NCP_SBP(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_put_super(struct super_block *);\n\nstatic void ncp_put_super(struct super_block *sb)\n{\n\tstruct ncp_server *server = NCP_SBP(sb);\n\n\tncp_lock_server(server);\n\tncp_disconnect(server);\n\tncp_unlock_server(server);\n\n\tncp_stop_tasks(server);\n\n\tmutex_destroy(&server->rcv.creq_mutex);\n\tmutex_destroy(&server->root_setup_lock);\n\tmutex_destroy(&server->mutex);\n\n\tif (server->info_sock)\n\t\tsockfd_put(server->info_sock);\n\tsockfd_put(server->ncp_sock);\n\tkill_pid(server->m.wdog_pid, SIGTERM, 1);\n\tput_pid(server->m.wdog_pid);\n\n\tbdi_destroy(&server->bdi);\n\tkfree(server->priv.data);\n\tkfree(server->auth.object_name);\n\tvfree(server->rxbuf);\n\tvfree(server->txbuf);\n\tvfree(server->packet);\n\tcall_rcu(&server->rcu, delayed_free);\n}"
  },
  {
    "function_name": "delayed_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "760-769",
    "snippet": "static void delayed_free(struct rcu_head *p)\n{\n\tstruct ncp_server *server = container_of(p, struct ncp_server, rcu);\n#ifdef CONFIG_NCPFS_NLS\n\t/* unload the NLS charsets */\n\tunload_nls(server->nls_vol);\n\tunload_nls(server->nls_io);\n#endif /* CONFIG_NCPFS_NLS */\n\tkfree(server);\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "server"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "server->nls_io"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structncp_server",
            "rcu"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void delayed_free(struct rcu_head *p)\n{\n\tstruct ncp_server *server = container_of(p, struct ncp_server, rcu);\n#ifdef CONFIG_NCPFS_NLS\n\t/* unload the NLS charsets */\n\tunload_nls(server->nls_vol);\n\tunload_nls(server->nls_io);\n#endif /* CONFIG_NCPFS_NLS */\n\tkfree(server);\n}"
  },
  {
    "function_name": "ncp_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "468-758",
    "snippet": "static int ncp_fill_super(struct super_block *sb, void *raw_data, int silent)\n{\n\tstruct ncp_mount_data_kernel data;\n\tstruct ncp_server *server;\n\tstruct inode *root_inode;\n\tstruct socket *sock;\n\tint error;\n\tint default_bufsize;\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\n\tint options;\n#endif\n\tstruct ncp_entry_info finfo;\n\n\tmemset(&data, 0, sizeof(data));\n\tserver = kzalloc(sizeof(struct ncp_server), GFP_KERNEL);\n\tif (!server)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = server;\n\n\terror = -EFAULT;\n\tif (raw_data == NULL)\n\t\tgoto out;\n\tswitch (*(int*)raw_data) {\n\t\tcase NCP_MOUNT_VERSION:\n\t\t\t{\n\t\t\t\tstruct ncp_mount_data* md = (struct ncp_mount_data*)raw_data;\n\n\t\t\t\tdata.flags = md->flags;\n\t\t\t\tdata.int_flags = NCP_IMOUNT_LOGGEDIN_POSSIBLE;\n\t\t\t\tdata.mounted_uid = make_kuid(current_user_ns(), md->mounted_uid);\n\t\t\t\tdata.wdog_pid = find_get_pid(md->wdog_pid);\n\t\t\t\tdata.ncp_fd = md->ncp_fd;\n\t\t\t\tdata.time_out = md->time_out;\n\t\t\t\tdata.retry_count = md->retry_count;\n\t\t\t\tdata.uid = make_kuid(current_user_ns(), md->uid);\n\t\t\t\tdata.gid = make_kgid(current_user_ns(), md->gid);\n\t\t\t\tdata.file_mode = md->file_mode;\n\t\t\t\tdata.dir_mode = md->dir_mode;\n\t\t\t\tdata.info_fd = -1;\n\t\t\t\tmemcpy(data.mounted_vol, md->mounted_vol,\n\t\t\t\t\tNCP_VOLNAME_LEN+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NCP_MOUNT_VERSION_V4:\n\t\t\t{\n\t\t\t\tstruct ncp_mount_data_v4* md = (struct ncp_mount_data_v4*)raw_data;\n\n\t\t\t\tdata.flags = md->flags;\n\t\t\t\tdata.mounted_uid = make_kuid(current_user_ns(), md->mounted_uid);\n\t\t\t\tdata.wdog_pid = find_get_pid(md->wdog_pid);\n\t\t\t\tdata.ncp_fd = md->ncp_fd;\n\t\t\t\tdata.time_out = md->time_out;\n\t\t\t\tdata.retry_count = md->retry_count;\n\t\t\t\tdata.uid = make_kuid(current_user_ns(), md->uid);\n\t\t\t\tdata.gid = make_kgid(current_user_ns(), md->gid);\n\t\t\t\tdata.file_mode = md->file_mode;\n\t\t\t\tdata.dir_mode = md->dir_mode;\n\t\t\t\tdata.info_fd = -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = -ECHRNG;\n\t\t\tif (memcmp(raw_data, \"vers\", 4) == 0) {\n\t\t\t\terror = ncp_parse_options(&data, raw_data);\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t}\n\terror = -EINVAL;\n\tif (!uid_valid(data.mounted_uid) || !uid_valid(data.uid) ||\n\t    !gid_valid(data.gid))\n\t\tgoto out;\n\tsock = sockfd_lookup(data.ncp_fd, &error);\n\tif (!sock)\n\t\tgoto out;\n\n\tif (sock->type == SOCK_STREAM)\n\t\tdefault_bufsize = 0xF000;\n\telse\n\t\tdefault_bufsize = 1024;\n\n\tsb->s_flags |= MS_NODIRATIME;\t/* probably even noatime */\n\tsb->s_maxbytes = 0xFFFFFFFFU;\n\tsb->s_blocksize = 1024;\t/* Eh...  Is this correct? */\n\tsb->s_blocksize_bits = 10;\n\tsb->s_magic = NCP_SUPER_MAGIC;\n\tsb->s_op = &ncp_sops;\n\tsb->s_d_op = &ncp_dentry_operations;\n\tsb->s_bdi = &server->bdi;\n\n\tserver = NCP_SBP(sb);\n\tmemset(server, 0, sizeof(*server));\n\n\terror = bdi_setup_and_register(&server->bdi, \"ncpfs\");\n\tif (error)\n\t\tgoto out_fput;\n\n\tserver->ncp_sock = sock;\n\t\n\tif (data.info_fd != -1) {\n\t\tstruct socket *info_sock = sockfd_lookup(data.info_fd, &error);\n\t\tif (!info_sock)\n\t\t\tgoto out_bdi;\n\t\tserver->info_sock = info_sock;\n\t\terror = -EBADFD;\n\t\tif (info_sock->type != SOCK_STREAM)\n\t\t\tgoto out_fput2;\n\t}\n\n/*\tserver->lock = 0;\t*/\n\tmutex_init(&server->mutex);\n\tserver->packet = NULL;\n/*\tserver->buffer_size = 0;\t*/\n/*\tserver->conn_status = 0;\t*/\n/*\tserver->root_dentry = NULL;\t*/\n/*\tserver->root_setuped = 0;\t*/\n\tmutex_init(&server->root_setup_lock);\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\n/*\tserver->sign_wanted = 0;\t*/\n/*\tserver->sign_active = 0;\t*/\n#endif\n\tinit_rwsem(&server->auth_rwsem);\n\tserver->auth.auth_type = NCP_AUTH_NONE;\n/*\tserver->auth.object_name_len = 0;\t*/\n/*\tserver->auth.object_name = NULL;\t*/\n/*\tserver->auth.object_type = 0;\t\t*/\n/*\tserver->priv.len = 0;\t\t\t*/\n/*\tserver->priv.data = NULL;\t\t*/\n\n\tserver->m = data;\n\t/* Although anything producing this is buggy, it happens\n\t   now because of PATH_MAX changes.. */\n\tif (server->m.time_out < 1) {\n\t\tserver->m.time_out = 10;\n\t\tpr_info(\"You need to recompile your ncpfs utils..\\n\");\n\t}\n\tserver->m.time_out = server->m.time_out * HZ / 100;\n\tserver->m.file_mode = (server->m.file_mode & S_IRWXUGO) | S_IFREG;\n\tserver->m.dir_mode = (server->m.dir_mode & S_IRWXUGO) | S_IFDIR;\n\n#ifdef CONFIG_NCPFS_NLS\n\t/* load the default NLS charsets */\n\tserver->nls_vol = load_nls_default();\n\tserver->nls_io = load_nls_default();\n#endif /* CONFIG_NCPFS_NLS */\n\n\tatomic_set(&server->dentry_ttl, 0);\t/* no caching */\n\n\tINIT_LIST_HEAD(&server->tx.requests);\n\tmutex_init(&server->rcv.creq_mutex);\n\tserver->tx.creq\t\t= NULL;\n\tserver->rcv.creq\t= NULL;\n\n\tinit_timer(&server->timeout_tm);\n#undef NCP_PACKET_SIZE\n#define NCP_PACKET_SIZE 131072\n\terror = -ENOMEM;\n\tserver->packet_size = NCP_PACKET_SIZE;\n\tserver->packet = vmalloc(NCP_PACKET_SIZE);\n\tif (server->packet == NULL)\n\t\tgoto out_nls;\n\tserver->txbuf = vmalloc(NCP_PACKET_SIZE);\n\tif (server->txbuf == NULL)\n\t\tgoto out_packet;\n\tserver->rxbuf = vmalloc(NCP_PACKET_SIZE);\n\tif (server->rxbuf == NULL)\n\t\tgoto out_txbuf;\n\n\tlock_sock(sock->sk);\n\tserver->data_ready\t= sock->sk->sk_data_ready;\n\tserver->write_space\t= sock->sk->sk_write_space;\n\tserver->error_report\t= sock->sk->sk_error_report;\n\tsock->sk->sk_user_data\t= server;\n\tsock->sk->sk_data_ready\t  = ncp_tcp_data_ready;\n\tsock->sk->sk_error_report = ncp_tcp_error_report;\n\tif (sock->type == SOCK_STREAM) {\n\t\tserver->rcv.ptr = (unsigned char*)&server->rcv.buf;\n\t\tserver->rcv.len = 10;\n\t\tserver->rcv.state = 0;\n\t\tINIT_WORK(&server->rcv.tq, ncp_tcp_rcv_proc);\n\t\tINIT_WORK(&server->tx.tq, ncp_tcp_tx_proc);\n\t\tsock->sk->sk_write_space = ncp_tcp_write_space;\n\t} else {\n\t\tINIT_WORK(&server->rcv.tq, ncpdgram_rcv_proc);\n\t\tINIT_WORK(&server->timeout_tq, ncpdgram_timeout_proc);\n\t\tserver->timeout_tm.data = (unsigned long)server;\n\t\tserver->timeout_tm.function = ncpdgram_timeout_call;\n\t}\n\trelease_sock(sock->sk);\n\n\tncp_lock_server(server);\n\terror = ncp_connect(server);\n\tncp_unlock_server(server);\n\tif (error < 0)\n\t\tgoto out_rxbuf;\n\tncp_dbg(1, \"NCP_SBP(sb) = %p\\n\", NCP_SBP(sb));\n\n\terror = -EMSGSIZE;\t/* -EREMOTESIDEINCOMPATIBLE */\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\n\tif (ncp_negotiate_size_and_options(server, default_bufsize,\n\t\tNCP_DEFAULT_OPTIONS, &(server->buffer_size), &options) == 0)\n\t{\n\t\tif (options != NCP_DEFAULT_OPTIONS)\n\t\t{\n\t\t\tif (ncp_negotiate_size_and_options(server, \n\t\t\t\tdefault_bufsize,\n\t\t\t\toptions & 2, \n\t\t\t\t&(server->buffer_size), &options) != 0)\n\t\t\t\t\n\t\t\t{\n\t\t\t\tgoto out_disconnect;\n\t\t\t}\n\t\t}\n\t\tncp_lock_server(server);\n\t\tif (options & 2)\n\t\t\tserver->sign_wanted = 1;\n\t\tncp_unlock_server(server);\n\t}\n\telse \n#endif\t/* CONFIG_NCPFS_PACKET_SIGNING */\n\tif (ncp_negotiate_buffersize(server, default_bufsize,\n  \t\t\t\t     &(server->buffer_size)) != 0)\n\t\tgoto out_disconnect;\n\tncp_dbg(1, \"bufsize = %d\\n\", server->buffer_size);\n\n\tmemset(&finfo, 0, sizeof(finfo));\n\tfinfo.i.attributes\t= aDIR;\n\tfinfo.i.dataStreamSize\t= 0;\t/* ignored */\n\tfinfo.i.dirEntNum\t= 0;\n\tfinfo.i.DosDirNum\t= 0;\n#ifdef CONFIG_NCPFS_SMALLDOS\n\tfinfo.i.NSCreator\t= NW_NS_DOS;\n#endif\n\tfinfo.volume\t\t= NCP_NUMBER_OF_VOLUMES;\n\t/* set dates of mountpoint to Jan 1, 1986; 00:00 */\n\tfinfo.i.creationTime\t= finfo.i.modifyTime\n\t\t\t\t= cpu_to_le16(0x0000);\n\tfinfo.i.creationDate\t= finfo.i.modifyDate\n\t\t\t\t= finfo.i.lastAccessDate\n\t\t\t\t= cpu_to_le16(0x0C21);\n\tfinfo.i.nameLen\t\t= 0;\n\tfinfo.i.entryName[0]\t= '\\0';\n\n\tfinfo.opened\t\t= 0;\n\tfinfo.ino\t\t= 2;\t/* tradition */\n\n\tserver->name_space[finfo.volume] = NW_NS_DOS;\n\n\terror = -ENOMEM;\n        root_inode = ncp_iget(sb, &finfo);\n        if (!root_inode)\n\t\tgoto out_disconnect;\n\tncp_dbg(1, \"root vol=%d\\n\", NCP_FINFO(root_inode)->volNumber);\n\tsb->s_root = d_make_root(root_inode);\n        if (!sb->s_root)\n\t\tgoto out_disconnect;\n\treturn 0;\n\nout_disconnect:\n\tncp_lock_server(server);\n\tncp_disconnect(server);\n\tncp_unlock_server(server);\nout_rxbuf:\n\tncp_stop_tasks(server);\n\tvfree(server->rxbuf);\nout_txbuf:\n\tvfree(server->txbuf);\nout_packet:\n\tvfree(server->packet);\nout_nls:\n#ifdef CONFIG_NCPFS_NLS\n\tunload_nls(server->nls_io);\n\tunload_nls(server->nls_vol);\n#endif\n\tmutex_destroy(&server->rcv.creq_mutex);\n\tmutex_destroy(&server->root_setup_lock);\n\tmutex_destroy(&server->mutex);\nout_fput2:\n\tif (server->info_sock)\n\t\tsockfd_put(server->info_sock);\nout_bdi:\n\tbdi_destroy(&server->bdi);\nout_fput:\n\tsockfd_put(sock);\nout:\n\tput_pid(data.wdog_pid);\n\tsb->s_fs_info = NULL;\n\tkfree(server);\n\treturn error;\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define NCP_PACKET_SIZE 131072"
    ],
    "globals_used": [
      "static void ncp_evict_inode(struct inode *);",
      "static void ncp_put_super(struct super_block *);",
      "static const struct super_operations ncp_sops =\n{\n\t.alloc_inode\t= ncp_alloc_inode,\n\t.destroy_inode\t= ncp_destroy_inode,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= ncp_evict_inode,\n\t.put_super\t= ncp_put_super,\n\t.statfs\t\t= ncp_statfs,\n\t.remount_fs\t= ncp_remount,\n\t.show_options\t= ncp_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "server"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "data.wdog_pid"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sockfd_put",
          "args": [
            "sock"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_destroy",
          "args": [
            "&server->bdi"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bdi_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "372-376",
          "snippet": "static void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sockfd_put",
          "args": [
            "server->info_sock"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&server->mutex"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&server->root_setup_lock"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "server->nls_vol"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "server->packet"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "server->txbuf"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "server->rxbuf"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_stop_tasks",
          "args": [
            "server"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_stop_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "313-328",
          "snippet": "static void ncp_stop_tasks(struct ncp_server *server) {\n\tstruct sock* sk = server->ncp_sock->sk;\n\n\tlock_sock(sk);\n\tsk->sk_error_report = server->error_report;\n\tsk->sk_data_ready   = server->data_ready;\n\tsk->sk_write_space  = server->write_space;\n\trelease_sock(sk);\n\tdel_timer_sync(&server->timeout_tm);\n\n\tflush_work(&server->rcv.tq);\n\tif (sk->sk_socket->type == SOCK_STREAM)\n\t\tflush_work(&server->tx.tq);\n\telse\n\t\tflush_work(&server->timeout_tq);\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_stop_tasks(struct ncp_server *server) {\n\tstruct sock* sk = server->ncp_sock->sk;\n\n\tlock_sock(sk);\n\tsk->sk_error_report = server->error_report;\n\tsk->sk_data_ready   = server->data_ready;\n\tsk->sk_write_space  = server->write_space;\n\trelease_sock(sk);\n\tdel_timer_sync(&server->timeout_tm);\n\n\tflush_work(&server->rcv.tq);\n\tif (sk->sk_socket->type == SOCK_STREAM)\n\t\tflush_work(&server->tx.tq);\n\telse\n\t\tflush_work(&server->timeout_tq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_unlock_server",
          "args": [
            "server"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_unlock_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "873-881",
          "snippet": "void ncp_unlock_server(struct ncp_server *server)\n{\n\tif (!server->lock) {\n\t\tpr_warn(\"%s: was not locked!\\n\", __func__);\n\t\treturn;\n\t}\n\tserver->lock = 0;\n\tmutex_unlock(&server->mutex);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nvoid ncp_unlock_server(struct ncp_server *server)\n{\n\tif (!server->lock) {\n\t\tpr_warn(\"%s: was not locked!\\n\", __func__);\n\t\treturn;\n\t}\n\tserver->lock = 0;\n\tmutex_unlock(&server->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_disconnect",
          "args": [
            "server"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "853-863",
          "snippet": "int ncp_disconnect(struct ncp_server *server)\n{\n\tstruct ncp_request_header *h;\n\n\th = (struct ncp_request_header *) (server->packet);\n\th->type = NCP_DEALLOC_SLOT_REQUEST;\n\th->task\t\t= 2; /* see above */\n\th->function\t= 0;\n\n\treturn ncp_do_request(server, sizeof(*h), server->packet, server->packet_size);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nint ncp_disconnect(struct ncp_server *server)\n{\n\tstruct ncp_request_header *h;\n\n\th = (struct ncp_request_header *) (server->packet);\n\th->type = NCP_DEALLOC_SLOT_REQUEST;\n\th->task\t\t= 2; /* see above */\n\th->function\t= 0;\n\n\treturn ncp_do_request(server, sizeof(*h), server->packet, server->packet_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_lock_server",
          "args": [
            "server"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_lock_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "865-871",
          "snippet": "void ncp_lock_server(struct ncp_server *server)\n{\n\tmutex_lock(&server->mutex);\n\tif (server->lock)\n\t\tpr_warn(\"%s: was locked!\\n\", __func__);\n\tserver->lock = 1;\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nvoid ncp_lock_server(struct ncp_server *server)\n{\n\tmutex_lock(&server->mutex);\n\tif (server->lock)\n\t\tpr_warn(\"%s: was locked!\\n\", __func__);\n\tserver->lock = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root_inode"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"root vol=%d\\n\"",
            "NCP_FINFO(root_inode)->volNumber"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "root_inode"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_iget",
          "args": [
            "sb",
            "&finfo"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "256-295",
          "snippet": "struct inode * \nncp_iget(struct super_block *sb, struct ncp_entry_info *info)\n{\n\tstruct inode *inode;\n\n\tif (info == NULL) {\n\t\tpr_err(\"%s: info is NULL\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, info->opened);\n\n\t\tinode->i_ino = info->ino;\n\t\tncp_set_attr(inode, info);\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_file_inode_operations;\n\t\t\tinode->i_fop = &ncp_file_operations;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_dir_inode_operations;\n\t\t\tinode->i_fop = &ncp_dir_operations;\n#ifdef CONFIG_NCPFS_NFS_NS\n\t\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) || S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tnew_decode_dev(info->i.nfs.rdev));\n#endif\n#if defined(CONFIG_NCPFS_EXTRAS) || defined(CONFIG_NCPFS_NFS_NS)\n\t\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &ncp_symlink_aops;\n#endif\n\t\t} else {\n\t\t\tmake_bad_inode(inode);\n\t\t}\n\t\tinsert_inode_hash(inode);\n\t} else\n\t\tpr_err(\"%s: iget failed!\\n\", __func__);\n\treturn inode;\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_evict_inode(struct inode *);",
            "static void ncp_put_super(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\nstatic void ncp_put_super(struct super_block *);\n\nstruct inode * \nncp_iget(struct super_block *sb, struct ncp_entry_info *info)\n{\n\tstruct inode *inode;\n\n\tif (info == NULL) {\n\t\tpr_err(\"%s: info is NULL\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, info->opened);\n\n\t\tinode->i_ino = info->ino;\n\t\tncp_set_attr(inode, info);\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_file_inode_operations;\n\t\t\tinode->i_fop = &ncp_file_operations;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_dir_inode_operations;\n\t\t\tinode->i_fop = &ncp_dir_operations;\n#ifdef CONFIG_NCPFS_NFS_NS\n\t\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) || S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tnew_decode_dev(info->i.nfs.rdev));\n#endif\n#if defined(CONFIG_NCPFS_EXTRAS) || defined(CONFIG_NCPFS_NFS_NS)\n\t\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &ncp_symlink_aops;\n#endif\n\t\t} else {\n\t\t\tmake_bad_inode(inode);\n\t\t}\n\t\tinsert_inode_hash(inode);\n\t} else\n\t\tpr_err(\"%s: iget failed!\\n\", __func__);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0x0C21"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0x0000"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&finfo",
            "0",
            "sizeof(finfo)"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"bufsize = %d\\n\"",
            "server->buffer_size"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_negotiate_buffersize",
          "args": [
            "server",
            "default_bufsize",
            "&(server->buffer_size)"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_negotiate_buffersize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "152-168",
          "snippet": "int\nncp_negotiate_buffersize(struct ncp_server *server, int size, int *target)\n{\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_be16(server, size);\n\n\tif ((result = ncp_request(server, 33)) != 0) {\n\t\tncp_unlock_server(server);\n\t\treturn result;\n\t}\n\t*target = min_t(unsigned int, ncp_reply_be16(server, 0), size);\n\n\tncp_unlock_server(server);\n\treturn 0;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_negotiate_buffersize(struct ncp_server *server, int size, int *target)\n{\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_be16(server, size);\n\n\tif ((result = ncp_request(server, 33)) != 0) {\n\t\tncp_unlock_server(server);\n\t\treturn result;\n\t}\n\t*target = min_t(unsigned int, ncp_reply_be16(server, 0), size);\n\n\tncp_unlock_server(server);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_negotiate_size_and_options",
          "args": [
            "server",
            "default_bufsize",
            "options & 2",
            "&(server->buffer_size)",
            "&options"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_negotiate_size_and_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "175-202",
          "snippet": "int\nncp_negotiate_size_and_options(struct ncp_server *server, \n\tint size, int options, int *ret_size, int *ret_options) {\n\tint result;\n\n\t/* there is minimum */\n\tif (size < NCP_BLOCK_SIZE) size = NCP_BLOCK_SIZE;\n\n\tncp_init_request(server);\n\tncp_add_be16(server, size);\n\tncp_add_byte(server, options);\n\t\n\tif ((result = ncp_request(server, 0x61)) != 0)\n\t{\n\t\tncp_unlock_server(server);\n\t\treturn result;\n\t}\n\n\t/* NCP over UDP returns 0 (!!!) */\n\tresult = ncp_reply_be16(server, 0);\n\tif (result >= NCP_BLOCK_SIZE)\n\t\tsize = min(result, size);\n\t*ret_size = size;\n\t*ret_options = ncp_reply_byte(server, 4);\n\n\tncp_unlock_server(server);\n\treturn 0;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_negotiate_size_and_options(struct ncp_server *server, \n\tint size, int options, int *ret_size, int *ret_options) {\n\tint result;\n\n\t/* there is minimum */\n\tif (size < NCP_BLOCK_SIZE) size = NCP_BLOCK_SIZE;\n\n\tncp_init_request(server);\n\tncp_add_be16(server, size);\n\tncp_add_byte(server, options);\n\t\n\tif ((result = ncp_request(server, 0x61)) != 0)\n\t{\n\t\tncp_unlock_server(server);\n\t\treturn result;\n\t}\n\n\t/* NCP over UDP returns 0 (!!!) */\n\tresult = ncp_reply_be16(server, 0);\n\tif (result >= NCP_BLOCK_SIZE)\n\t\tsize = min(result, size);\n\t*ret_size = size;\n\t*ret_options = ncp_reply_byte(server, 4);\n\n\tncp_unlock_server(server);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"NCP_SBP(sb) = %p\\n\"",
            "NCP_SBP(sb)"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SBP",
          "args": [
            "sb"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_SBP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "43-46",
          "snippet": "static inline struct ncp_server *NCP_SBP(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_conn_logged_in(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_conn_logged_in(struct super_block *);\n\nstatic inline struct ncp_server *NCP_SBP(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_connect",
          "args": [
            "server"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "831-851",
          "snippet": "int ncp_connect(struct ncp_server *server)\n{\n\tstruct ncp_request_header *h;\n\tint result;\n\n\tserver->connection = 0xFFFF;\n\tserver->sequence = 255;\n\n\th = (struct ncp_request_header *) (server->packet);\n\th->type = NCP_ALLOC_SLOT_REQUEST;\n\th->task\t\t= 2; /* see above */\n\th->function\t= 0;\n\n\tresult = ncp_do_request(server, sizeof(*h), server->packet, server->packet_size);\n\tif (result < 0)\n\t\tgoto out;\n\tserver->connection = h->conn_low + (h->conn_high * 256);\n\tresult = 0;\nout:\n\treturn result;\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nint ncp_connect(struct ncp_server *server)\n{\n\tstruct ncp_request_header *h;\n\tint result;\n\n\tserver->connection = 0xFFFF;\n\tserver->sequence = 255;\n\n\th = (struct ncp_request_header *) (server->packet);\n\th->type = NCP_ALLOC_SLOT_REQUEST;\n\th->task\t\t= 2; /* see above */\n\th->function\t= 0;\n\n\tresult = ncp_do_request(server, sizeof(*h), server->packet, server->packet_size);\n\tif (result < 0)\n\t\tgoto out;\n\tserver->connection = h->conn_low + (h->conn_high * 256);\n\tresult = 0;\nout:\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_sock",
          "args": [
            "sock->sk"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&server->timeout_tq",
            "ncpdgram_timeout_proc"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&server->rcv.tq",
            "ncpdgram_rcv_proc"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&server->tx.tq",
            "ncp_tcp_tx_proc"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&server->rcv.tq",
            "ncp_tcp_rcv_proc"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_sock",
          "args": [
            "sock->sk"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "NCP_PACKET_SIZE"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_timer",
          "args": [
            "&server->timeout_tm"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&server->tx.requests"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&server->dentry_ttl",
            "0"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_nls_default",
          "args": [],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "load_nls_default",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "532-541",
          "snippet": "struct nls_table *load_nls_default(void)\n{\n\tstruct nls_table *default_nls;\n\t\n\tdefault_nls = load_nls(CONFIG_NLS_DEFAULT);\n\tif (default_nls != NULL)\n\t\treturn default_nls;\n\telse\n\t\treturn &default_table;\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nls_table default_table;",
            "static struct nls_table default_table = {\n\t.charset\t= \"default\",\n\t.uni2char\t= uni2char,\n\t.char2uni\t= char2uni,\n\t.charset2lower\t= charset2lower,\n\t.charset2upper\t= charset2upper,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct nls_table default_table;\nstatic struct nls_table default_table = {\n\t.charset\t= \"default\",\n\t.uni2char\t= uni2char,\n\t.char2uni\t= char2uni,\n\t.charset2lower\t= charset2lower,\n\t.charset2upper\t= charset2upper,\n};\n\nstruct nls_table *load_nls_default(void)\n{\n\tstruct nls_table *default_nls;\n\t\n\tdefault_nls = load_nls(CONFIG_NLS_DEFAULT);\n\tif (default_nls != NULL)\n\t\treturn default_nls;\n\telse\n\t\treturn &default_table;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"You need to recompile your ncpfs utils..\\n\""
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&server->auth_rwsem"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&server->root_setup_lock"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&server->mutex"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sockfd_lookup",
          "args": [
            "data.info_fd",
            "&error"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_setup_and_register",
          "args": [
            "&server->bdi",
            "\"ncpfs\""
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "server",
            "0",
            "sizeof(*server)"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sockfd_lookup",
          "args": [
            "data.ncp_fd",
            "&error"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "data.gid"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "data.uid"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_parse_options",
          "args": [
            "&data",
            "raw_data"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "379-466",
          "snippet": "static int ncp_parse_options(struct ncp_mount_data_kernel *data, char *options) {\n\tint optval;\n\tchar *optarg;\n\tunsigned long optint;\n\tint version = 0;\n\tint ret;\n\n\tdata->flags = 0;\n\tdata->int_flags = 0;\n\tdata->mounted_uid = GLOBAL_ROOT_UID;\n\tdata->wdog_pid = NULL;\n\tdata->ncp_fd = ~0;\n\tdata->time_out = NCP_DEFAULT_TIME_OUT;\n\tdata->retry_count = NCP_DEFAULT_RETRY_COUNT;\n\tdata->uid = GLOBAL_ROOT_UID;\n\tdata->gid = GLOBAL_ROOT_GID;\n\tdata->file_mode = NCP_DEFAULT_FILE_MODE;\n\tdata->dir_mode = NCP_DEFAULT_DIR_MODE;\n\tdata->info_fd = -1;\n\tdata->mounted_vol[0] = 0;\n\t\n\twhile ((optval = ncp_getopt(\"ncpfs\", &options, ncp_opts, NULL, &optarg, &optint)) != 0) {\n\t\tret = optval;\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tswitch (optval) {\n\t\t\tcase 'u':\n\t\t\t\tdata->uid = make_kuid(current_user_ns(), optint);\n\t\t\t\tif (!uid_valid(data->uid)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tdata->gid = make_kgid(current_user_ns(), optint);\n\t\t\t\tif (!gid_valid(data->gid)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tdata->mounted_uid = make_kuid(current_user_ns(), optint);\n\t\t\t\tif (!uid_valid(data->mounted_uid)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tdata->file_mode = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tdata->dir_mode = optint;\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tdata->time_out = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tdata->retry_count = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tdata->flags = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\tdata->wdog_pid = find_get_pid(optint);\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tdata->ncp_fd = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tdata->info_fd = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tret = -ECHRNG;\n\t\t\t\tif (optint < NCP_MOUNT_VERSION_V4)\n\t\t\t\t\tgoto err;\n\t\t\t\tif (optint > NCP_MOUNT_VERSION_V5)\n\t\t\t\t\tgoto err;\n\t\t\t\tversion = optint;\n\t\t\t\tbreak;\n\t\t\t\n\t\t}\n\t}\n\treturn 0;\nerr:\n\tput_pid(data->wdog_pid);\n\tdata->wdog_pid = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define NCP_DEFAULT_RETRY_COUNT 20",
            "#define NCP_DEFAULT_TIME_OUT 10",
            "#define NCP_DEFAULT_DIR_MODE 0700",
            "#define NCP_DEFAULT_FILE_MODE 0600"
          ],
          "globals_used": [
            "static const struct ncp_option ncp_opts[] = {\n\t{ \"uid\",\tOPT_INT,\t'u' },\n\t{ \"gid\",\tOPT_INT,\t'g' },\n\t{ \"owner\",\tOPT_INT,\t'o' },\n\t{ \"mode\",\tOPT_INT,\t'm' },\n\t{ \"dirmode\",\tOPT_INT,\t'd' },\n\t{ \"timeout\",\tOPT_INT,\t't' },\n\t{ \"retry\",\tOPT_INT,\t'r' },\n\t{ \"flags\",\tOPT_INT,\t'f' },\n\t{ \"wdogpid\",\tOPT_INT,\t'w' },\n\t{ \"ncpfd\",\tOPT_INT,\t'n' },\n\t{ \"infofd\",\tOPT_INT,\t'i' },\t/* v5 */\n\t{ \"version\",\tOPT_INT,\t'v' },\n\t{ NULL,\t\t0,\t\t0 } };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\n#define NCP_DEFAULT_RETRY_COUNT 20\n#define NCP_DEFAULT_TIME_OUT 10\n#define NCP_DEFAULT_DIR_MODE 0700\n#define NCP_DEFAULT_FILE_MODE 0600\n\nstatic const struct ncp_option ncp_opts[] = {\n\t{ \"uid\",\tOPT_INT,\t'u' },\n\t{ \"gid\",\tOPT_INT,\t'g' },\n\t{ \"owner\",\tOPT_INT,\t'o' },\n\t{ \"mode\",\tOPT_INT,\t'm' },\n\t{ \"dirmode\",\tOPT_INT,\t'd' },\n\t{ \"timeout\",\tOPT_INT,\t't' },\n\t{ \"retry\",\tOPT_INT,\t'r' },\n\t{ \"flags\",\tOPT_INT,\t'f' },\n\t{ \"wdogpid\",\tOPT_INT,\t'w' },\n\t{ \"ncpfd\",\tOPT_INT,\t'n' },\n\t{ \"infofd\",\tOPT_INT,\t'i' },\t/* v5 */\n\t{ \"version\",\tOPT_INT,\t'v' },\n\t{ NULL,\t\t0,\t\t0 } };\n\nstatic int ncp_parse_options(struct ncp_mount_data_kernel *data, char *options) {\n\tint optval;\n\tchar *optarg;\n\tunsigned long optint;\n\tint version = 0;\n\tint ret;\n\n\tdata->flags = 0;\n\tdata->int_flags = 0;\n\tdata->mounted_uid = GLOBAL_ROOT_UID;\n\tdata->wdog_pid = NULL;\n\tdata->ncp_fd = ~0;\n\tdata->time_out = NCP_DEFAULT_TIME_OUT;\n\tdata->retry_count = NCP_DEFAULT_RETRY_COUNT;\n\tdata->uid = GLOBAL_ROOT_UID;\n\tdata->gid = GLOBAL_ROOT_GID;\n\tdata->file_mode = NCP_DEFAULT_FILE_MODE;\n\tdata->dir_mode = NCP_DEFAULT_DIR_MODE;\n\tdata->info_fd = -1;\n\tdata->mounted_vol[0] = 0;\n\t\n\twhile ((optval = ncp_getopt(\"ncpfs\", &options, ncp_opts, NULL, &optarg, &optint)) != 0) {\n\t\tret = optval;\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tswitch (optval) {\n\t\t\tcase 'u':\n\t\t\t\tdata->uid = make_kuid(current_user_ns(), optint);\n\t\t\t\tif (!uid_valid(data->uid)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tdata->gid = make_kgid(current_user_ns(), optint);\n\t\t\t\tif (!gid_valid(data->gid)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tdata->mounted_uid = make_kuid(current_user_ns(), optint);\n\t\t\t\tif (!uid_valid(data->mounted_uid)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tdata->file_mode = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tdata->dir_mode = optint;\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tdata->time_out = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tdata->retry_count = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tdata->flags = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\tdata->wdog_pid = find_get_pid(optint);\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tdata->ncp_fd = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tdata->info_fd = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tret = -ECHRNG;\n\t\t\t\tif (optint < NCP_MOUNT_VERSION_V4)\n\t\t\t\t\tgoto err;\n\t\t\t\tif (optint > NCP_MOUNT_VERSION_V5)\n\t\t\t\t\tgoto err;\n\t\t\t\tversion = optint;\n\t\t\t\tbreak;\n\t\t\t\n\t\t}\n\t}\n\treturn 0;\nerr:\n\tput_pid(data->wdog_pid);\n\tdata->wdog_pid = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "raw_data",
            "\"vers\"",
            "4"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "md->gid"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "md->uid"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_pid",
          "args": [
            "md->wdog_pid"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "md->mounted_uid"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data.mounted_vol",
            "md->mounted_vol",
            "NCP_VOLNAME_LEN+1"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "md->gid"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "md->uid"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_pid",
          "args": [
            "md->wdog_pid"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "md->mounted_uid"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ncp_server)",
            "GFP_KERNEL"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data",
            "0",
            "sizeof(data)"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\n#define NCP_PACKET_SIZE 131072\n\nstatic void ncp_evict_inode(struct inode *);\nstatic void ncp_put_super(struct super_block *);\nstatic const struct super_operations ncp_sops =\n{\n\t.alloc_inode\t= ncp_alloc_inode,\n\t.destroy_inode\t= ncp_destroy_inode,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= ncp_evict_inode,\n\t.put_super\t= ncp_put_super,\n\t.statfs\t\t= ncp_statfs,\n\t.remount_fs\t= ncp_remount,\n\t.show_options\t= ncp_show_options,\n};\n\nstatic int ncp_fill_super(struct super_block *sb, void *raw_data, int silent)\n{\n\tstruct ncp_mount_data_kernel data;\n\tstruct ncp_server *server;\n\tstruct inode *root_inode;\n\tstruct socket *sock;\n\tint error;\n\tint default_bufsize;\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\n\tint options;\n#endif\n\tstruct ncp_entry_info finfo;\n\n\tmemset(&data, 0, sizeof(data));\n\tserver = kzalloc(sizeof(struct ncp_server), GFP_KERNEL);\n\tif (!server)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = server;\n\n\terror = -EFAULT;\n\tif (raw_data == NULL)\n\t\tgoto out;\n\tswitch (*(int*)raw_data) {\n\t\tcase NCP_MOUNT_VERSION:\n\t\t\t{\n\t\t\t\tstruct ncp_mount_data* md = (struct ncp_mount_data*)raw_data;\n\n\t\t\t\tdata.flags = md->flags;\n\t\t\t\tdata.int_flags = NCP_IMOUNT_LOGGEDIN_POSSIBLE;\n\t\t\t\tdata.mounted_uid = make_kuid(current_user_ns(), md->mounted_uid);\n\t\t\t\tdata.wdog_pid = find_get_pid(md->wdog_pid);\n\t\t\t\tdata.ncp_fd = md->ncp_fd;\n\t\t\t\tdata.time_out = md->time_out;\n\t\t\t\tdata.retry_count = md->retry_count;\n\t\t\t\tdata.uid = make_kuid(current_user_ns(), md->uid);\n\t\t\t\tdata.gid = make_kgid(current_user_ns(), md->gid);\n\t\t\t\tdata.file_mode = md->file_mode;\n\t\t\t\tdata.dir_mode = md->dir_mode;\n\t\t\t\tdata.info_fd = -1;\n\t\t\t\tmemcpy(data.mounted_vol, md->mounted_vol,\n\t\t\t\t\tNCP_VOLNAME_LEN+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NCP_MOUNT_VERSION_V4:\n\t\t\t{\n\t\t\t\tstruct ncp_mount_data_v4* md = (struct ncp_mount_data_v4*)raw_data;\n\n\t\t\t\tdata.flags = md->flags;\n\t\t\t\tdata.mounted_uid = make_kuid(current_user_ns(), md->mounted_uid);\n\t\t\t\tdata.wdog_pid = find_get_pid(md->wdog_pid);\n\t\t\t\tdata.ncp_fd = md->ncp_fd;\n\t\t\t\tdata.time_out = md->time_out;\n\t\t\t\tdata.retry_count = md->retry_count;\n\t\t\t\tdata.uid = make_kuid(current_user_ns(), md->uid);\n\t\t\t\tdata.gid = make_kgid(current_user_ns(), md->gid);\n\t\t\t\tdata.file_mode = md->file_mode;\n\t\t\t\tdata.dir_mode = md->dir_mode;\n\t\t\t\tdata.info_fd = -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = -ECHRNG;\n\t\t\tif (memcmp(raw_data, \"vers\", 4) == 0) {\n\t\t\t\terror = ncp_parse_options(&data, raw_data);\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t}\n\terror = -EINVAL;\n\tif (!uid_valid(data.mounted_uid) || !uid_valid(data.uid) ||\n\t    !gid_valid(data.gid))\n\t\tgoto out;\n\tsock = sockfd_lookup(data.ncp_fd, &error);\n\tif (!sock)\n\t\tgoto out;\n\n\tif (sock->type == SOCK_STREAM)\n\t\tdefault_bufsize = 0xF000;\n\telse\n\t\tdefault_bufsize = 1024;\n\n\tsb->s_flags |= MS_NODIRATIME;\t/* probably even noatime */\n\tsb->s_maxbytes = 0xFFFFFFFFU;\n\tsb->s_blocksize = 1024;\t/* Eh...  Is this correct? */\n\tsb->s_blocksize_bits = 10;\n\tsb->s_magic = NCP_SUPER_MAGIC;\n\tsb->s_op = &ncp_sops;\n\tsb->s_d_op = &ncp_dentry_operations;\n\tsb->s_bdi = &server->bdi;\n\n\tserver = NCP_SBP(sb);\n\tmemset(server, 0, sizeof(*server));\n\n\terror = bdi_setup_and_register(&server->bdi, \"ncpfs\");\n\tif (error)\n\t\tgoto out_fput;\n\n\tserver->ncp_sock = sock;\n\t\n\tif (data.info_fd != -1) {\n\t\tstruct socket *info_sock = sockfd_lookup(data.info_fd, &error);\n\t\tif (!info_sock)\n\t\t\tgoto out_bdi;\n\t\tserver->info_sock = info_sock;\n\t\terror = -EBADFD;\n\t\tif (info_sock->type != SOCK_STREAM)\n\t\t\tgoto out_fput2;\n\t}\n\n/*\tserver->lock = 0;\t*/\n\tmutex_init(&server->mutex);\n\tserver->packet = NULL;\n/*\tserver->buffer_size = 0;\t*/\n/*\tserver->conn_status = 0;\t*/\n/*\tserver->root_dentry = NULL;\t*/\n/*\tserver->root_setuped = 0;\t*/\n\tmutex_init(&server->root_setup_lock);\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\n/*\tserver->sign_wanted = 0;\t*/\n/*\tserver->sign_active = 0;\t*/\n#endif\n\tinit_rwsem(&server->auth_rwsem);\n\tserver->auth.auth_type = NCP_AUTH_NONE;\n/*\tserver->auth.object_name_len = 0;\t*/\n/*\tserver->auth.object_name = NULL;\t*/\n/*\tserver->auth.object_type = 0;\t\t*/\n/*\tserver->priv.len = 0;\t\t\t*/\n/*\tserver->priv.data = NULL;\t\t*/\n\n\tserver->m = data;\n\t/* Although anything producing this is buggy, it happens\n\t   now because of PATH_MAX changes.. */\n\tif (server->m.time_out < 1) {\n\t\tserver->m.time_out = 10;\n\t\tpr_info(\"You need to recompile your ncpfs utils..\\n\");\n\t}\n\tserver->m.time_out = server->m.time_out * HZ / 100;\n\tserver->m.file_mode = (server->m.file_mode & S_IRWXUGO) | S_IFREG;\n\tserver->m.dir_mode = (server->m.dir_mode & S_IRWXUGO) | S_IFDIR;\n\n#ifdef CONFIG_NCPFS_NLS\n\t/* load the default NLS charsets */\n\tserver->nls_vol = load_nls_default();\n\tserver->nls_io = load_nls_default();\n#endif /* CONFIG_NCPFS_NLS */\n\n\tatomic_set(&server->dentry_ttl, 0);\t/* no caching */\n\n\tINIT_LIST_HEAD(&server->tx.requests);\n\tmutex_init(&server->rcv.creq_mutex);\n\tserver->tx.creq\t\t= NULL;\n\tserver->rcv.creq\t= NULL;\n\n\tinit_timer(&server->timeout_tm);\n#undef NCP_PACKET_SIZE\n#define NCP_PACKET_SIZE 131072\n\terror = -ENOMEM;\n\tserver->packet_size = NCP_PACKET_SIZE;\n\tserver->packet = vmalloc(NCP_PACKET_SIZE);\n\tif (server->packet == NULL)\n\t\tgoto out_nls;\n\tserver->txbuf = vmalloc(NCP_PACKET_SIZE);\n\tif (server->txbuf == NULL)\n\t\tgoto out_packet;\n\tserver->rxbuf = vmalloc(NCP_PACKET_SIZE);\n\tif (server->rxbuf == NULL)\n\t\tgoto out_txbuf;\n\n\tlock_sock(sock->sk);\n\tserver->data_ready\t= sock->sk->sk_data_ready;\n\tserver->write_space\t= sock->sk->sk_write_space;\n\tserver->error_report\t= sock->sk->sk_error_report;\n\tsock->sk->sk_user_data\t= server;\n\tsock->sk->sk_data_ready\t  = ncp_tcp_data_ready;\n\tsock->sk->sk_error_report = ncp_tcp_error_report;\n\tif (sock->type == SOCK_STREAM) {\n\t\tserver->rcv.ptr = (unsigned char*)&server->rcv.buf;\n\t\tserver->rcv.len = 10;\n\t\tserver->rcv.state = 0;\n\t\tINIT_WORK(&server->rcv.tq, ncp_tcp_rcv_proc);\n\t\tINIT_WORK(&server->tx.tq, ncp_tcp_tx_proc);\n\t\tsock->sk->sk_write_space = ncp_tcp_write_space;\n\t} else {\n\t\tINIT_WORK(&server->rcv.tq, ncpdgram_rcv_proc);\n\t\tINIT_WORK(&server->timeout_tq, ncpdgram_timeout_proc);\n\t\tserver->timeout_tm.data = (unsigned long)server;\n\t\tserver->timeout_tm.function = ncpdgram_timeout_call;\n\t}\n\trelease_sock(sock->sk);\n\n\tncp_lock_server(server);\n\terror = ncp_connect(server);\n\tncp_unlock_server(server);\n\tif (error < 0)\n\t\tgoto out_rxbuf;\n\tncp_dbg(1, \"NCP_SBP(sb) = %p\\n\", NCP_SBP(sb));\n\n\terror = -EMSGSIZE;\t/* -EREMOTESIDEINCOMPATIBLE */\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\n\tif (ncp_negotiate_size_and_options(server, default_bufsize,\n\t\tNCP_DEFAULT_OPTIONS, &(server->buffer_size), &options) == 0)\n\t{\n\t\tif (options != NCP_DEFAULT_OPTIONS)\n\t\t{\n\t\t\tif (ncp_negotiate_size_and_options(server, \n\t\t\t\tdefault_bufsize,\n\t\t\t\toptions & 2, \n\t\t\t\t&(server->buffer_size), &options) != 0)\n\t\t\t\t\n\t\t\t{\n\t\t\t\tgoto out_disconnect;\n\t\t\t}\n\t\t}\n\t\tncp_lock_server(server);\n\t\tif (options & 2)\n\t\t\tserver->sign_wanted = 1;\n\t\tncp_unlock_server(server);\n\t}\n\telse \n#endif\t/* CONFIG_NCPFS_PACKET_SIGNING */\n\tif (ncp_negotiate_buffersize(server, default_bufsize,\n  \t\t\t\t     &(server->buffer_size)) != 0)\n\t\tgoto out_disconnect;\n\tncp_dbg(1, \"bufsize = %d\\n\", server->buffer_size);\n\n\tmemset(&finfo, 0, sizeof(finfo));\n\tfinfo.i.attributes\t= aDIR;\n\tfinfo.i.dataStreamSize\t= 0;\t/* ignored */\n\tfinfo.i.dirEntNum\t= 0;\n\tfinfo.i.DosDirNum\t= 0;\n#ifdef CONFIG_NCPFS_SMALLDOS\n\tfinfo.i.NSCreator\t= NW_NS_DOS;\n#endif\n\tfinfo.volume\t\t= NCP_NUMBER_OF_VOLUMES;\n\t/* set dates of mountpoint to Jan 1, 1986; 00:00 */\n\tfinfo.i.creationTime\t= finfo.i.modifyTime\n\t\t\t\t= cpu_to_le16(0x0000);\n\tfinfo.i.creationDate\t= finfo.i.modifyDate\n\t\t\t\t= finfo.i.lastAccessDate\n\t\t\t\t= cpu_to_le16(0x0C21);\n\tfinfo.i.nameLen\t\t= 0;\n\tfinfo.i.entryName[0]\t= '\\0';\n\n\tfinfo.opened\t\t= 0;\n\tfinfo.ino\t\t= 2;\t/* tradition */\n\n\tserver->name_space[finfo.volume] = NW_NS_DOS;\n\n\terror = -ENOMEM;\n        root_inode = ncp_iget(sb, &finfo);\n        if (!root_inode)\n\t\tgoto out_disconnect;\n\tncp_dbg(1, \"root vol=%d\\n\", NCP_FINFO(root_inode)->volNumber);\n\tsb->s_root = d_make_root(root_inode);\n        if (!sb->s_root)\n\t\tgoto out_disconnect;\n\treturn 0;\n\nout_disconnect:\n\tncp_lock_server(server);\n\tncp_disconnect(server);\n\tncp_unlock_server(server);\nout_rxbuf:\n\tncp_stop_tasks(server);\n\tvfree(server->rxbuf);\nout_txbuf:\n\tvfree(server->txbuf);\nout_packet:\n\tvfree(server->packet);\nout_nls:\n#ifdef CONFIG_NCPFS_NLS\n\tunload_nls(server->nls_io);\n\tunload_nls(server->nls_vol);\n#endif\n\tmutex_destroy(&server->rcv.creq_mutex);\n\tmutex_destroy(&server->root_setup_lock);\n\tmutex_destroy(&server->mutex);\nout_fput2:\n\tif (server->info_sock)\n\t\tsockfd_put(server->info_sock);\nout_bdi:\n\tbdi_destroy(&server->bdi);\nout_fput:\n\tsockfd_put(sock);\nout:\n\tput_pid(data.wdog_pid);\n\tsb->s_fs_info = NULL;\n\tkfree(server);\n\treturn error;\n}"
  },
  {
    "function_name": "ncp_parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "379-466",
    "snippet": "static int ncp_parse_options(struct ncp_mount_data_kernel *data, char *options) {\n\tint optval;\n\tchar *optarg;\n\tunsigned long optint;\n\tint version = 0;\n\tint ret;\n\n\tdata->flags = 0;\n\tdata->int_flags = 0;\n\tdata->mounted_uid = GLOBAL_ROOT_UID;\n\tdata->wdog_pid = NULL;\n\tdata->ncp_fd = ~0;\n\tdata->time_out = NCP_DEFAULT_TIME_OUT;\n\tdata->retry_count = NCP_DEFAULT_RETRY_COUNT;\n\tdata->uid = GLOBAL_ROOT_UID;\n\tdata->gid = GLOBAL_ROOT_GID;\n\tdata->file_mode = NCP_DEFAULT_FILE_MODE;\n\tdata->dir_mode = NCP_DEFAULT_DIR_MODE;\n\tdata->info_fd = -1;\n\tdata->mounted_vol[0] = 0;\n\t\n\twhile ((optval = ncp_getopt(\"ncpfs\", &options, ncp_opts, NULL, &optarg, &optint)) != 0) {\n\t\tret = optval;\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tswitch (optval) {\n\t\t\tcase 'u':\n\t\t\t\tdata->uid = make_kuid(current_user_ns(), optint);\n\t\t\t\tif (!uid_valid(data->uid)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tdata->gid = make_kgid(current_user_ns(), optint);\n\t\t\t\tif (!gid_valid(data->gid)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tdata->mounted_uid = make_kuid(current_user_ns(), optint);\n\t\t\t\tif (!uid_valid(data->mounted_uid)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tdata->file_mode = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tdata->dir_mode = optint;\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tdata->time_out = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tdata->retry_count = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tdata->flags = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\tdata->wdog_pid = find_get_pid(optint);\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tdata->ncp_fd = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tdata->info_fd = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tret = -ECHRNG;\n\t\t\t\tif (optint < NCP_MOUNT_VERSION_V4)\n\t\t\t\t\tgoto err;\n\t\t\t\tif (optint > NCP_MOUNT_VERSION_V5)\n\t\t\t\t\tgoto err;\n\t\t\t\tversion = optint;\n\t\t\t\tbreak;\n\t\t\t\n\t\t}\n\t}\n\treturn 0;\nerr:\n\tput_pid(data->wdog_pid);\n\tdata->wdog_pid = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define NCP_DEFAULT_RETRY_COUNT 20",
      "#define NCP_DEFAULT_TIME_OUT 10",
      "#define NCP_DEFAULT_DIR_MODE 0700",
      "#define NCP_DEFAULT_FILE_MODE 0600"
    ],
    "globals_used": [
      "static const struct ncp_option ncp_opts[] = {\n\t{ \"uid\",\tOPT_INT,\t'u' },\n\t{ \"gid\",\tOPT_INT,\t'g' },\n\t{ \"owner\",\tOPT_INT,\t'o' },\n\t{ \"mode\",\tOPT_INT,\t'm' },\n\t{ \"dirmode\",\tOPT_INT,\t'd' },\n\t{ \"timeout\",\tOPT_INT,\t't' },\n\t{ \"retry\",\tOPT_INT,\t'r' },\n\t{ \"flags\",\tOPT_INT,\t'f' },\n\t{ \"wdogpid\",\tOPT_INT,\t'w' },\n\t{ \"ncpfd\",\tOPT_INT,\t'n' },\n\t{ \"infofd\",\tOPT_INT,\t'i' },\t/* v5 */\n\t{ \"version\",\tOPT_INT,\t'v' },\n\t{ NULL,\t\t0,\t\t0 } };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "data->wdog_pid"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_pid",
          "args": [
            "optint"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "data->mounted_uid"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "optint"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "data->gid"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "optint"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "optint"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_getopt",
          "args": [
            "\"ncpfs\"",
            "&options",
            "ncp_opts",
            "NULL",
            "&optarg",
            "&optint"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_getopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/getopt.c",
          "lines": "28-75",
          "snippet": "int ncp_getopt(const char *caller, char **options, const struct ncp_option *opts,\n\t       char **optopt, char **optarg, unsigned long *value)\n{\n\tchar *token;\n\tchar *val;\n\n\tdo {\n\t\tif ((token = strsep(options, \",\")) == NULL)\n\t\t\treturn 0;\n\t} while (*token == '\\0');\n\tif (optopt)\n\t\t*optopt = token;\n\n\tif ((val = strchr (token, '=')) != NULL) {\n\t\t*val++ = 0;\n\t}\n\t*optarg = val;\n\tfor (; opts->name; opts++) {\n\t\tif (!strcmp(opts->name, token)) {\n\t\t\tif (!val) {\n\t\t\t\tif (opts->has_arg & OPT_NOPARAM) {\n\t\t\t\t\treturn opts->val;\n\t\t\t\t}\n\t\t\t\tpr_info(\"%s: the %s option requires an argument\\n\",\n\t\t\t\t\tcaller, token);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (opts->has_arg & OPT_INT) {\n\t\t\t\tint rc = kstrtoul(val, 0, value);\n\n\t\t\t\tif (rc) {\n\t\t\t\t\tpr_info(\"%s: invalid numeric value in %s=%s\\n\",\n\t\t\t\t\t\tcaller, token, val);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\treturn opts->val;\n\t\t\t}\n\t\t\tif (opts->has_arg & OPT_STRING) {\n\t\t\t\treturn opts->val;\n\t\t\t}\n\t\t\tpr_info(\"%s: unexpected argument %s to the %s option\\n\",\n\t\t\t\tcaller, val, token);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tpr_info(\"%s: Unrecognized mount option %s\\n\", caller, token);\n\treturn -EOPNOTSUPP;\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include <asm/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include <asm/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint ncp_getopt(const char *caller, char **options, const struct ncp_option *opts,\n\t       char **optopt, char **optarg, unsigned long *value)\n{\n\tchar *token;\n\tchar *val;\n\n\tdo {\n\t\tif ((token = strsep(options, \",\")) == NULL)\n\t\t\treturn 0;\n\t} while (*token == '\\0');\n\tif (optopt)\n\t\t*optopt = token;\n\n\tif ((val = strchr (token, '=')) != NULL) {\n\t\t*val++ = 0;\n\t}\n\t*optarg = val;\n\tfor (; opts->name; opts++) {\n\t\tif (!strcmp(opts->name, token)) {\n\t\t\tif (!val) {\n\t\t\t\tif (opts->has_arg & OPT_NOPARAM) {\n\t\t\t\t\treturn opts->val;\n\t\t\t\t}\n\t\t\t\tpr_info(\"%s: the %s option requires an argument\\n\",\n\t\t\t\t\tcaller, token);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (opts->has_arg & OPT_INT) {\n\t\t\t\tint rc = kstrtoul(val, 0, value);\n\n\t\t\t\tif (rc) {\n\t\t\t\t\tpr_info(\"%s: invalid numeric value in %s=%s\\n\",\n\t\t\t\t\t\tcaller, token, val);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\treturn opts->val;\n\t\t\t}\n\t\t\tif (opts->has_arg & OPT_STRING) {\n\t\t\t\treturn opts->val;\n\t\t\t}\n\t\t\tpr_info(\"%s: unexpected argument %s to the %s option\\n\",\n\t\t\t\tcaller, val, token);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tpr_info(\"%s: Unrecognized mount option %s\\n\", caller, token);\n\treturn -EOPNOTSUPP;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\n#define NCP_DEFAULT_RETRY_COUNT 20\n#define NCP_DEFAULT_TIME_OUT 10\n#define NCP_DEFAULT_DIR_MODE 0700\n#define NCP_DEFAULT_FILE_MODE 0600\n\nstatic const struct ncp_option ncp_opts[] = {\n\t{ \"uid\",\tOPT_INT,\t'u' },\n\t{ \"gid\",\tOPT_INT,\t'g' },\n\t{ \"owner\",\tOPT_INT,\t'o' },\n\t{ \"mode\",\tOPT_INT,\t'm' },\n\t{ \"dirmode\",\tOPT_INT,\t'd' },\n\t{ \"timeout\",\tOPT_INT,\t't' },\n\t{ \"retry\",\tOPT_INT,\t'r' },\n\t{ \"flags\",\tOPT_INT,\t'f' },\n\t{ \"wdogpid\",\tOPT_INT,\t'w' },\n\t{ \"ncpfd\",\tOPT_INT,\t'n' },\n\t{ \"infofd\",\tOPT_INT,\t'i' },\t/* v5 */\n\t{ \"version\",\tOPT_INT,\t'v' },\n\t{ NULL,\t\t0,\t\t0 } };\n\nstatic int ncp_parse_options(struct ncp_mount_data_kernel *data, char *options) {\n\tint optval;\n\tchar *optarg;\n\tunsigned long optint;\n\tint version = 0;\n\tint ret;\n\n\tdata->flags = 0;\n\tdata->int_flags = 0;\n\tdata->mounted_uid = GLOBAL_ROOT_UID;\n\tdata->wdog_pid = NULL;\n\tdata->ncp_fd = ~0;\n\tdata->time_out = NCP_DEFAULT_TIME_OUT;\n\tdata->retry_count = NCP_DEFAULT_RETRY_COUNT;\n\tdata->uid = GLOBAL_ROOT_UID;\n\tdata->gid = GLOBAL_ROOT_GID;\n\tdata->file_mode = NCP_DEFAULT_FILE_MODE;\n\tdata->dir_mode = NCP_DEFAULT_DIR_MODE;\n\tdata->info_fd = -1;\n\tdata->mounted_vol[0] = 0;\n\t\n\twhile ((optval = ncp_getopt(\"ncpfs\", &options, ncp_opts, NULL, &optarg, &optint)) != 0) {\n\t\tret = optval;\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tswitch (optval) {\n\t\t\tcase 'u':\n\t\t\t\tdata->uid = make_kuid(current_user_ns(), optint);\n\t\t\t\tif (!uid_valid(data->uid)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tdata->gid = make_kgid(current_user_ns(), optint);\n\t\t\t\tif (!gid_valid(data->gid)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tdata->mounted_uid = make_kuid(current_user_ns(), optint);\n\t\t\t\tif (!uid_valid(data->mounted_uid)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tdata->file_mode = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tdata->dir_mode = optint;\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tdata->time_out = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tdata->retry_count = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tdata->flags = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\tdata->wdog_pid = find_get_pid(optint);\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tdata->ncp_fd = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tdata->info_fd = optint;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tret = -ECHRNG;\n\t\t\t\tif (optint < NCP_MOUNT_VERSION_V4)\n\t\t\t\t\tgoto err;\n\t\t\t\tif (optint > NCP_MOUNT_VERSION_V5)\n\t\t\t\t\tgoto err;\n\t\t\t\tversion = optint;\n\t\t\t\tbreak;\n\t\t\t\n\t\t}\n\t}\n\treturn 0;\nerr:\n\tput_pid(data->wdog_pid);\n\tdata->wdog_pid = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "ncp_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "330-362",
    "snippet": "static int  ncp_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct ncp_server *server = NCP_SBP(root->d_sb);\n\tunsigned int tmp;\n\n\tif (!uid_eq(server->m.uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(seq, \",uid=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns, server->m.uid));\n\tif (!gid_eq(server->m.gid, GLOBAL_ROOT_GID))\n\t\tseq_printf(seq, \",gid=%u\",\n\t\t\t   from_kgid_munged(&init_user_ns, server->m.gid));\n\tif (!uid_eq(server->m.mounted_uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(seq, \",owner=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns, server->m.mounted_uid));\n\ttmp = server->m.file_mode & S_IALLUGO;\n\tif (tmp != NCP_DEFAULT_FILE_MODE)\n\t\tseq_printf(seq, \",mode=0%o\", tmp);\n\ttmp = server->m.dir_mode & S_IALLUGO;\n\tif (tmp != NCP_DEFAULT_DIR_MODE)\n\t\tseq_printf(seq, \",dirmode=0%o\", tmp);\n\tif (server->m.time_out != NCP_DEFAULT_TIME_OUT * HZ / 100) {\n\t\ttmp = server->m.time_out * 100 / HZ;\n\t\tseq_printf(seq, \",timeout=%u\", tmp);\n\t}\n\tif (server->m.retry_count != NCP_DEFAULT_RETRY_COUNT)\n\t\tseq_printf(seq, \",retry=%u\", server->m.retry_count);\n\tif (server->m.flags != 0)\n\t\tseq_printf(seq, \",flags=%lu\", server->m.flags);\n\tif (server->m.wdog_pid != NULL)\n\t\tseq_printf(seq, \",wdogpid=%u\", pid_vnr(server->m.wdog_pid));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define NCP_DEFAULT_RETRY_COUNT 20",
      "#define NCP_DEFAULT_TIME_OUT 10",
      "#define NCP_DEFAULT_DIR_MODE 0700",
      "#define NCP_DEFAULT_FILE_MODE 0600"
    ],
    "globals_used": [
      "static int  ncp_show_options(struct seq_file *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\",wdogpid=%u\"",
            "pid_vnr(server->m.wdog_pid)"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_vnr",
          "args": [
            "server->m.wdog_pid"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "server->m.mounted_uid"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "server->m.mounted_uid",
            "GLOBAL_ROOT_UID"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "&init_user_ns",
            "server->m.gid"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "server->m.gid",
            "GLOBAL_ROOT_GID"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "server->m.uid"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SBP",
          "args": [
            "root->d_sb"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_SBP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "43-46",
          "snippet": "static inline struct ncp_server *NCP_SBP(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_conn_logged_in(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_conn_logged_in(struct super_block *);\n\nstatic inline struct ncp_server *NCP_SBP(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\n#define NCP_DEFAULT_RETRY_COUNT 20\n#define NCP_DEFAULT_TIME_OUT 10\n#define NCP_DEFAULT_DIR_MODE 0700\n#define NCP_DEFAULT_FILE_MODE 0600\n\nstatic int  ncp_show_options(struct seq_file *, struct dentry *);\n\nstatic int  ncp_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct ncp_server *server = NCP_SBP(root->d_sb);\n\tunsigned int tmp;\n\n\tif (!uid_eq(server->m.uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(seq, \",uid=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns, server->m.uid));\n\tif (!gid_eq(server->m.gid, GLOBAL_ROOT_GID))\n\t\tseq_printf(seq, \",gid=%u\",\n\t\t\t   from_kgid_munged(&init_user_ns, server->m.gid));\n\tif (!uid_eq(server->m.mounted_uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(seq, \",owner=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns, server->m.mounted_uid));\n\ttmp = server->m.file_mode & S_IALLUGO;\n\tif (tmp != NCP_DEFAULT_FILE_MODE)\n\t\tseq_printf(seq, \",mode=0%o\", tmp);\n\ttmp = server->m.dir_mode & S_IALLUGO;\n\tif (tmp != NCP_DEFAULT_DIR_MODE)\n\t\tseq_printf(seq, \",dirmode=0%o\", tmp);\n\tif (server->m.time_out != NCP_DEFAULT_TIME_OUT * HZ / 100) {\n\t\ttmp = server->m.time_out * 100 / HZ;\n\t\tseq_printf(seq, \",timeout=%u\", tmp);\n\t}\n\tif (server->m.retry_count != NCP_DEFAULT_RETRY_COUNT)\n\t\tseq_printf(seq, \",retry=%u\", server->m.retry_count);\n\tif (server->m.flags != 0)\n\t\tseq_printf(seq, \",flags=%lu\", server->m.flags);\n\tif (server->m.wdog_pid != NULL)\n\t\tseq_printf(seq, \",wdogpid=%u\", pid_vnr(server->m.wdog_pid));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ncp_stop_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "313-328",
    "snippet": "static void ncp_stop_tasks(struct ncp_server *server) {\n\tstruct sock* sk = server->ncp_sock->sk;\n\n\tlock_sock(sk);\n\tsk->sk_error_report = server->error_report;\n\tsk->sk_data_ready   = server->data_ready;\n\tsk->sk_write_space  = server->write_space;\n\trelease_sock(sk);\n\tdel_timer_sync(&server->timeout_tm);\n\n\tflush_work(&server->rcv.tq);\n\tif (sk->sk_socket->type == SOCK_STREAM)\n\t\tflush_work(&server->tx.tq);\n\telse\n\t\tflush_work(&server->timeout_tq);\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&server->timeout_tq"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&server->tx.tq"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&server->rcv.tq"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&server->timeout_tm"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_sock",
          "args": [
            "sk"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_sock",
          "args": [
            "sk"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_stop_tasks(struct ncp_server *server) {\n\tstruct sock* sk = server->ncp_sock->sk;\n\n\tlock_sock(sk);\n\tsk->sk_error_report = server->error_report;\n\tsk->sk_data_ready   = server->data_ready;\n\tsk->sk_write_space  = server->write_space;\n\trelease_sock(sk);\n\tdel_timer_sync(&server->timeout_tm);\n\n\tflush_work(&server->rcv.tq);\n\tif (sk->sk_socket->type == SOCK_STREAM)\n\t\tflush_work(&server->tx.tq);\n\telse\n\t\tflush_work(&server->timeout_tq);\n}"
  },
  {
    "function_name": "ncp_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "297-311",
    "snippet": "static void\nncp_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tncp_dbg(2, \"put directory %ld\\n\", inode->i_ino);\n\t}\n\n\tif (ncp_make_closed(inode) != 0) {\n\t\t/* We can't do anything but complain. */\n\t\tpr_err(\"%s: could not close\\n\", __func__);\n\t}\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_evict_inode(struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: could not close\\n\"",
            "__func__"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_make_closed",
          "args": [
            "inode"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_make_closed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "286-304",
          "snippet": "int\nncp_make_closed(struct inode *inode)\n{\n\tint err;\n\n\terr = 0;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (atomic_read(&NCP_FINFO(inode)->opened) == 1) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 0);\n\t\terr = ncp_close_file(NCP_SERVER(inode), NCP_FINFO(inode)->file_handle);\n\n\t\tif (!err)\n\t\t\tncp_vdbg(\"volnum=%d, dirent=%u, error=%d\\n\",\n\t\t\t\t NCP_FINFO(inode)->volNumber,\n\t\t\t\t NCP_FINFO(inode)->dirEntNum, err);\n\t}\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\n\treturn err;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_make_closed(struct inode *inode)\n{\n\tint err;\n\n\terr = 0;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (atomic_read(&NCP_FINFO(inode)->opened) == 1) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 0);\n\t\terr = ncp_close_file(NCP_SERVER(inode), NCP_FINFO(inode)->file_handle);\n\n\t\tif (!err)\n\t\t\tncp_vdbg(\"volnum=%d, dirent=%u, error=%d\\n\",\n\t\t\t\t NCP_FINFO(inode)->volNumber,\n\t\t\t\t NCP_FINFO(inode)->dirEntNum, err);\n\t}\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "2",
            "\"put directory %ld\\n\"",
            "inode->i_ino"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nstatic void\nncp_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tncp_dbg(2, \"put directory %ld\\n\", inode->i_ino);\n\t}\n\n\tif (ncp_make_closed(inode) != 0) {\n\t\t/* We can't do anything but complain. */\n\t\tpr_err(\"%s: could not close\\n\", __func__);\n\t}\n}"
  },
  {
    "function_name": "ncp_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "256-295",
    "snippet": "struct inode * \nncp_iget(struct super_block *sb, struct ncp_entry_info *info)\n{\n\tstruct inode *inode;\n\n\tif (info == NULL) {\n\t\tpr_err(\"%s: info is NULL\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, info->opened);\n\n\t\tinode->i_ino = info->ino;\n\t\tncp_set_attr(inode, info);\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_file_inode_operations;\n\t\t\tinode->i_fop = &ncp_file_operations;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_dir_inode_operations;\n\t\t\tinode->i_fop = &ncp_dir_operations;\n#ifdef CONFIG_NCPFS_NFS_NS\n\t\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) || S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tnew_decode_dev(info->i.nfs.rdev));\n#endif\n#if defined(CONFIG_NCPFS_EXTRAS) || defined(CONFIG_NCPFS_NFS_NS)\n\t\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &ncp_symlink_aops;\n#endif\n\t\t} else {\n\t\t\tmake_bad_inode(inode);\n\t\t}\n\t\tinsert_inode_hash(inode);\n\t} else\n\t\tpr_err(\"%s: iget failed!\\n\", __func__);\n\treturn inode;\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_evict_inode(struct inode *);",
      "static void ncp_put_super(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: iget failed!\\n\"",
            "__func__"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "inode"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "new_decode_dev(info->i.nfs.rdev)"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "info->i.nfs.rdev"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "inode->i_mode"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "inode->i_mode"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_set_attr",
          "args": [
            "inode",
            "info"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_set_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "226-242",
          "snippet": "static void ncp_set_attr(struct inode *inode, struct ncp_entry_info *nwinfo)\n{\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\n\tNCP_FINFO(inode)->flags = 0;\n\t\n\tncp_update_attrs(inode, nwinfo);\n\n\tncp_dbg(2, \"inode->i_mode = %u\\n\", inode->i_mode);\n\n\tset_nlink(inode, 1);\n\tinode->i_uid = server->m.uid;\n\tinode->i_gid = server->m.gid;\n\n\tncp_update_dates(inode, &nwinfo->i);\n\tncp_update_inode(inode, nwinfo);\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nstatic void ncp_set_attr(struct inode *inode, struct ncp_entry_info *nwinfo)\n{\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\n\tNCP_FINFO(inode)->flags = 0;\n\t\n\tncp_update_attrs(inode, nwinfo);\n\n\tncp_dbg(2, \"inode->i_mode = %u\\n\", inode->i_mode);\n\n\tset_nlink(inode, 1);\n\tinode->i_uid = server->m.uid;\n\tinode->i_gid = server->m.gid;\n\n\tncp_update_dates(inode, &nwinfo->i);\n\tncp_update_inode(inode, nwinfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&NCP_FINFO(inode)->opened",
            "info->opened"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: info is NULL\\n\"",
            "__func__"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\nstatic void ncp_put_super(struct super_block *);\n\nstruct inode * \nncp_iget(struct super_block *sb, struct ncp_entry_info *info)\n{\n\tstruct inode *inode;\n\n\tif (info == NULL) {\n\t\tpr_err(\"%s: info is NULL\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, info->opened);\n\n\t\tinode->i_ino = info->ino;\n\t\tncp_set_attr(inode, info);\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_file_inode_operations;\n\t\t\tinode->i_fop = &ncp_file_operations;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_dir_inode_operations;\n\t\t\tinode->i_fop = &ncp_dir_operations;\n#ifdef CONFIG_NCPFS_NFS_NS\n\t\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) || S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tnew_decode_dev(info->i.nfs.rdev));\n#endif\n#if defined(CONFIG_NCPFS_EXTRAS) || defined(CONFIG_NCPFS_NFS_NS)\n\t\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &ncp_symlink_aops;\n#endif\n\t\t} else {\n\t\t\tmake_bad_inode(inode);\n\t\t}\n\t\tinsert_inode_hash(inode);\n\t} else\n\t\tpr_err(\"%s: iget failed!\\n\", __func__);\n\treturn inode;\n}"
  },
  {
    "function_name": "ncp_set_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "226-242",
    "snippet": "static void ncp_set_attr(struct inode *inode, struct ncp_entry_info *nwinfo)\n{\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\n\tNCP_FINFO(inode)->flags = 0;\n\t\n\tncp_update_attrs(inode, nwinfo);\n\n\tncp_dbg(2, \"inode->i_mode = %u\\n\", inode->i_mode);\n\n\tset_nlink(inode, 1);\n\tinode->i_uid = server->m.uid;\n\tinode->i_gid = server->m.gid;\n\n\tncp_update_dates(inode, &nwinfo->i);\n\tncp_update_inode(inode, nwinfo);\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_evict_inode(struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_update_inode",
          "args": [
            "inode",
            "nwinfo"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_update_inode2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "211-221",
          "snippet": "void ncp_update_inode2(struct inode* inode, struct ncp_entry_info *nwinfo)\n{\n\tNCP_FINFO(inode)->flags = 0;\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tNCP_FINFO(inode)->nwattr = nwinfo->i.attributes;\n\t\tncp_update_attrs(inode, nwinfo);\n\t}\n\n\tncp_update_dates(inode, &nwinfo->i);\n\tncp_update_dirent(inode, nwinfo);\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nvoid ncp_update_inode2(struct inode* inode, struct ncp_entry_info *nwinfo)\n{\n\tNCP_FINFO(inode)->flags = 0;\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tNCP_FINFO(inode)->nwattr = nwinfo->i.attributes;\n\t\tncp_update_attrs(inode, nwinfo);\n\t}\n\n\tncp_update_dates(inode, &nwinfo->i);\n\tncp_update_dirent(inode, nwinfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_update_dates",
          "args": [
            "inode",
            "&nwinfo->i"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_update_dates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "143-160",
          "snippet": "static void ncp_update_dates(struct inode *inode, struct nw_info_struct *nwi)\n{\n\t/* NFS namespace mode overrides others if it's set. */\n\tncp_dbg(1, \"(%s) nfs.mode=0%o\\n\", nwi->entryName, nwi->nfs.mode);\n\tif (nwi->nfs.mode) {\n\t\t/* XXX Security? */\n\t\tinode->i_mode = nwi->nfs.mode;\n\t}\n\n\tinode->i_blocks = (i_size_read(inode) + NCP_BLOCK_SIZE - 1) >> NCP_BLOCK_SHIFT;\n\n\tinode->i_mtime.tv_sec = ncp_date_dos2unix(nwi->modifyTime, nwi->modifyDate);\n\tinode->i_ctime.tv_sec = ncp_date_dos2unix(nwi->creationTime, nwi->creationDate);\n\tinode->i_atime.tv_sec = ncp_date_dos2unix(0, nwi->lastAccessDate);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nstatic void ncp_update_dates(struct inode *inode, struct nw_info_struct *nwi)\n{\n\t/* NFS namespace mode overrides others if it's set. */\n\tncp_dbg(1, \"(%s) nfs.mode=0%o\\n\", nwi->entryName, nwi->nfs.mode);\n\tif (nwi->nfs.mode) {\n\t\t/* XXX Security? */\n\t\tinode->i_mode = nwi->nfs.mode;\n\t}\n\n\tinode->i_blocks = (i_size_read(inode) + NCP_BLOCK_SIZE - 1) >> NCP_BLOCK_SHIFT;\n\n\tinode->i_mtime.tv_sec = ncp_date_dos2unix(nwi->modifyTime, nwi->modifyDate);\n\tinode->i_ctime.tv_sec = ncp_date_dos2unix(nwi->creationTime, nwi->creationDate);\n\tinode->i_atime.tv_sec = ncp_date_dos2unix(0, nwi->lastAccessDate);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "1"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "2",
            "\"inode->i_mode = %u\\n\"",
            "inode->i_mode"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_update_attrs",
          "args": [
            "inode",
            "nwinfo"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_update_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "162-209",
          "snippet": "static void ncp_update_attrs(struct inode *inode, struct ncp_entry_info *nwinfo)\n{\n\tstruct nw_info_struct *nwi = &nwinfo->i;\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\n\tif (nwi->attributes & aDIR) {\n\t\tinode->i_mode = server->m.dir_mode;\n\t\t/* for directories dataStreamSize seems to be some\n\t\t   Object ID ??? */\n\t\ti_size_write(inode, NCP_BLOCK_SIZE);\n\t} else {\n\t\tu32 size;\n\n\t\tinode->i_mode = server->m.file_mode;\n\t\tsize = le32_to_cpu(nwi->dataStreamSize);\n\t\ti_size_write(inode, size);\n#ifdef CONFIG_NCPFS_EXTRAS\n\t\tif ((server->m.flags & (NCP_MOUNT_EXTRAS|NCP_MOUNT_SYMLINKS)) \n\t\t && (nwi->attributes & aSHARED)) {\n\t\t\tswitch (nwi->attributes & (aHIDDEN|aSYSTEM)) {\n\t\t\t\tcase aHIDDEN:\n\t\t\t\t\tif (server->m.flags & NCP_MOUNT_SYMLINKS) {\n\t\t\t\t\t\tif (/* (size >= NCP_MIN_SYMLINK_SIZE)\n\t\t\t\t\t\t && */ (size <= NCP_MAX_SYMLINK_SIZE)) {\n\t\t\t\t\t\t\tinode->i_mode = (inode->i_mode & ~S_IFMT) | S_IFLNK;\n\t\t\t\t\t\t\tNCP_FINFO(inode)->flags |= NCPI_KLUDGE_SYMLINK;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 0:\n\t\t\t\t\tif (server->m.flags & NCP_MOUNT_EXTRAS)\n\t\t\t\t\t\tinode->i_mode |= S_IRUGO;\n\t\t\t\t\tbreak;\n\t\t\t\tcase aSYSTEM:\n\t\t\t\t\tif (server->m.flags & NCP_MOUNT_EXTRAS)\n\t\t\t\t\t\tinode->i_mode |= (inode->i_mode >> 2) & S_IXUGO;\n\t\t\t\t\tbreak;\n\t\t\t\t/* case aSYSTEM|aHIDDEN: */\n\t\t\t\tdefault:\n\t\t\t\t\t/* reserved combination */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tif (nwi->attributes & aRONLY) inode->i_mode &= ~S_IWUGO;\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nstatic void ncp_update_attrs(struct inode *inode, struct ncp_entry_info *nwinfo)\n{\n\tstruct nw_info_struct *nwi = &nwinfo->i;\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\n\tif (nwi->attributes & aDIR) {\n\t\tinode->i_mode = server->m.dir_mode;\n\t\t/* for directories dataStreamSize seems to be some\n\t\t   Object ID ??? */\n\t\ti_size_write(inode, NCP_BLOCK_SIZE);\n\t} else {\n\t\tu32 size;\n\n\t\tinode->i_mode = server->m.file_mode;\n\t\tsize = le32_to_cpu(nwi->dataStreamSize);\n\t\ti_size_write(inode, size);\n#ifdef CONFIG_NCPFS_EXTRAS\n\t\tif ((server->m.flags & (NCP_MOUNT_EXTRAS|NCP_MOUNT_SYMLINKS)) \n\t\t && (nwi->attributes & aSHARED)) {\n\t\t\tswitch (nwi->attributes & (aHIDDEN|aSYSTEM)) {\n\t\t\t\tcase aHIDDEN:\n\t\t\t\t\tif (server->m.flags & NCP_MOUNT_SYMLINKS) {\n\t\t\t\t\t\tif (/* (size >= NCP_MIN_SYMLINK_SIZE)\n\t\t\t\t\t\t && */ (size <= NCP_MAX_SYMLINK_SIZE)) {\n\t\t\t\t\t\t\tinode->i_mode = (inode->i_mode & ~S_IFMT) | S_IFLNK;\n\t\t\t\t\t\t\tNCP_FINFO(inode)->flags |= NCPI_KLUDGE_SYMLINK;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 0:\n\t\t\t\t\tif (server->m.flags & NCP_MOUNT_EXTRAS)\n\t\t\t\t\t\tinode->i_mode |= S_IRUGO;\n\t\t\t\t\tbreak;\n\t\t\t\tcase aSYSTEM:\n\t\t\t\t\tif (server->m.flags & NCP_MOUNT_EXTRAS)\n\t\t\t\t\t\tinode->i_mode |= (inode->i_mode >> 2) & S_IXUGO;\n\t\t\t\t\tbreak;\n\t\t\t\t/* case aSYSTEM|aHIDDEN: */\n\t\t\t\tdefault:\n\t\t\t\t\t/* reserved combination */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tif (nwi->attributes & aRONLY) inode->i_mode &= ~S_IWUGO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nstatic void ncp_set_attr(struct inode *inode, struct ncp_entry_info *nwinfo)\n{\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\n\tNCP_FINFO(inode)->flags = 0;\n\t\n\tncp_update_attrs(inode, nwinfo);\n\n\tncp_dbg(2, \"inode->i_mode = %u\\n\", inode->i_mode);\n\n\tset_nlink(inode, 1);\n\tinode->i_uid = server->m.uid;\n\tinode->i_gid = server->m.gid;\n\n\tncp_update_dates(inode, &nwinfo->i);\n\tncp_update_inode(inode, nwinfo);\n}"
  },
  {
    "function_name": "ncp_update_inode2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "211-221",
    "snippet": "void ncp_update_inode2(struct inode* inode, struct ncp_entry_info *nwinfo)\n{\n\tNCP_FINFO(inode)->flags = 0;\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tNCP_FINFO(inode)->nwattr = nwinfo->i.attributes;\n\t\tncp_update_attrs(inode, nwinfo);\n\t}\n\n\tncp_update_dates(inode, &nwinfo->i);\n\tncp_update_dirent(inode, nwinfo);\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_evict_inode(struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_update_dirent",
          "args": [
            "inode",
            "nwinfo"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_update_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "124-129",
          "snippet": "static void ncp_update_dirent(struct inode *inode, struct ncp_entry_info *nwinfo)\n{\n\tNCP_FINFO(inode)->DosDirNum = nwinfo->i.DosDirNum;\n\tNCP_FINFO(inode)->dirEntNum = nwinfo->i.dirEntNum;\n\tNCP_FINFO(inode)->volNumber = nwinfo->volume;\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nstatic void ncp_update_dirent(struct inode *inode, struct ncp_entry_info *nwinfo)\n{\n\tNCP_FINFO(inode)->DosDirNum = nwinfo->i.DosDirNum;\n\tNCP_FINFO(inode)->dirEntNum = nwinfo->i.dirEntNum;\n\tNCP_FINFO(inode)->volNumber = nwinfo->volume;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_update_dates",
          "args": [
            "inode",
            "&nwinfo->i"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_update_dates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "143-160",
          "snippet": "static void ncp_update_dates(struct inode *inode, struct nw_info_struct *nwi)\n{\n\t/* NFS namespace mode overrides others if it's set. */\n\tncp_dbg(1, \"(%s) nfs.mode=0%o\\n\", nwi->entryName, nwi->nfs.mode);\n\tif (nwi->nfs.mode) {\n\t\t/* XXX Security? */\n\t\tinode->i_mode = nwi->nfs.mode;\n\t}\n\n\tinode->i_blocks = (i_size_read(inode) + NCP_BLOCK_SIZE - 1) >> NCP_BLOCK_SHIFT;\n\n\tinode->i_mtime.tv_sec = ncp_date_dos2unix(nwi->modifyTime, nwi->modifyDate);\n\tinode->i_ctime.tv_sec = ncp_date_dos2unix(nwi->creationTime, nwi->creationDate);\n\tinode->i_atime.tv_sec = ncp_date_dos2unix(0, nwi->lastAccessDate);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nstatic void ncp_update_dates(struct inode *inode, struct nw_info_struct *nwi)\n{\n\t/* NFS namespace mode overrides others if it's set. */\n\tncp_dbg(1, \"(%s) nfs.mode=0%o\\n\", nwi->entryName, nwi->nfs.mode);\n\tif (nwi->nfs.mode) {\n\t\t/* XXX Security? */\n\t\tinode->i_mode = nwi->nfs.mode;\n\t}\n\n\tinode->i_blocks = (i_size_read(inode) + NCP_BLOCK_SIZE - 1) >> NCP_BLOCK_SHIFT;\n\n\tinode->i_mtime.tv_sec = ncp_date_dos2unix(nwi->modifyTime, nwi->modifyDate);\n\tinode->i_ctime.tv_sec = ncp_date_dos2unix(nwi->creationTime, nwi->creationDate);\n\tinode->i_atime.tv_sec = ncp_date_dos2unix(0, nwi->lastAccessDate);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_update_attrs",
          "args": [
            "inode",
            "nwinfo"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_update_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "162-209",
          "snippet": "static void ncp_update_attrs(struct inode *inode, struct ncp_entry_info *nwinfo)\n{\n\tstruct nw_info_struct *nwi = &nwinfo->i;\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\n\tif (nwi->attributes & aDIR) {\n\t\tinode->i_mode = server->m.dir_mode;\n\t\t/* for directories dataStreamSize seems to be some\n\t\t   Object ID ??? */\n\t\ti_size_write(inode, NCP_BLOCK_SIZE);\n\t} else {\n\t\tu32 size;\n\n\t\tinode->i_mode = server->m.file_mode;\n\t\tsize = le32_to_cpu(nwi->dataStreamSize);\n\t\ti_size_write(inode, size);\n#ifdef CONFIG_NCPFS_EXTRAS\n\t\tif ((server->m.flags & (NCP_MOUNT_EXTRAS|NCP_MOUNT_SYMLINKS)) \n\t\t && (nwi->attributes & aSHARED)) {\n\t\t\tswitch (nwi->attributes & (aHIDDEN|aSYSTEM)) {\n\t\t\t\tcase aHIDDEN:\n\t\t\t\t\tif (server->m.flags & NCP_MOUNT_SYMLINKS) {\n\t\t\t\t\t\tif (/* (size >= NCP_MIN_SYMLINK_SIZE)\n\t\t\t\t\t\t && */ (size <= NCP_MAX_SYMLINK_SIZE)) {\n\t\t\t\t\t\t\tinode->i_mode = (inode->i_mode & ~S_IFMT) | S_IFLNK;\n\t\t\t\t\t\t\tNCP_FINFO(inode)->flags |= NCPI_KLUDGE_SYMLINK;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 0:\n\t\t\t\t\tif (server->m.flags & NCP_MOUNT_EXTRAS)\n\t\t\t\t\t\tinode->i_mode |= S_IRUGO;\n\t\t\t\t\tbreak;\n\t\t\t\tcase aSYSTEM:\n\t\t\t\t\tif (server->m.flags & NCP_MOUNT_EXTRAS)\n\t\t\t\t\t\tinode->i_mode |= (inode->i_mode >> 2) & S_IXUGO;\n\t\t\t\t\tbreak;\n\t\t\t\t/* case aSYSTEM|aHIDDEN: */\n\t\t\t\tdefault:\n\t\t\t\t\t/* reserved combination */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tif (nwi->attributes & aRONLY) inode->i_mode &= ~S_IWUGO;\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nstatic void ncp_update_attrs(struct inode *inode, struct ncp_entry_info *nwinfo)\n{\n\tstruct nw_info_struct *nwi = &nwinfo->i;\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\n\tif (nwi->attributes & aDIR) {\n\t\tinode->i_mode = server->m.dir_mode;\n\t\t/* for directories dataStreamSize seems to be some\n\t\t   Object ID ??? */\n\t\ti_size_write(inode, NCP_BLOCK_SIZE);\n\t} else {\n\t\tu32 size;\n\n\t\tinode->i_mode = server->m.file_mode;\n\t\tsize = le32_to_cpu(nwi->dataStreamSize);\n\t\ti_size_write(inode, size);\n#ifdef CONFIG_NCPFS_EXTRAS\n\t\tif ((server->m.flags & (NCP_MOUNT_EXTRAS|NCP_MOUNT_SYMLINKS)) \n\t\t && (nwi->attributes & aSHARED)) {\n\t\t\tswitch (nwi->attributes & (aHIDDEN|aSYSTEM)) {\n\t\t\t\tcase aHIDDEN:\n\t\t\t\t\tif (server->m.flags & NCP_MOUNT_SYMLINKS) {\n\t\t\t\t\t\tif (/* (size >= NCP_MIN_SYMLINK_SIZE)\n\t\t\t\t\t\t && */ (size <= NCP_MAX_SYMLINK_SIZE)) {\n\t\t\t\t\t\t\tinode->i_mode = (inode->i_mode & ~S_IFMT) | S_IFLNK;\n\t\t\t\t\t\t\tNCP_FINFO(inode)->flags |= NCPI_KLUDGE_SYMLINK;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 0:\n\t\t\t\t\tif (server->m.flags & NCP_MOUNT_EXTRAS)\n\t\t\t\t\t\tinode->i_mode |= S_IRUGO;\n\t\t\t\t\tbreak;\n\t\t\t\tcase aSYSTEM:\n\t\t\t\t\tif (server->m.flags & NCP_MOUNT_EXTRAS)\n\t\t\t\t\t\tinode->i_mode |= (inode->i_mode >> 2) & S_IXUGO;\n\t\t\t\t\tbreak;\n\t\t\t\t/* case aSYSTEM|aHIDDEN: */\n\t\t\t\tdefault:\n\t\t\t\t\t/* reserved combination */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tif (nwi->attributes & aRONLY) inode->i_mode &= ~S_IWUGO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&NCP_FINFO(inode)->opened"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nvoid ncp_update_inode2(struct inode* inode, struct ncp_entry_info *nwinfo)\n{\n\tNCP_FINFO(inode)->flags = 0;\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tNCP_FINFO(inode)->nwattr = nwinfo->i.attributes;\n\t\tncp_update_attrs(inode, nwinfo);\n\t}\n\n\tncp_update_dates(inode, &nwinfo->i);\n\tncp_update_dirent(inode, nwinfo);\n}"
  },
  {
    "function_name": "ncp_update_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "162-209",
    "snippet": "static void ncp_update_attrs(struct inode *inode, struct ncp_entry_info *nwinfo)\n{\n\tstruct nw_info_struct *nwi = &nwinfo->i;\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\n\tif (nwi->attributes & aDIR) {\n\t\tinode->i_mode = server->m.dir_mode;\n\t\t/* for directories dataStreamSize seems to be some\n\t\t   Object ID ??? */\n\t\ti_size_write(inode, NCP_BLOCK_SIZE);\n\t} else {\n\t\tu32 size;\n\n\t\tinode->i_mode = server->m.file_mode;\n\t\tsize = le32_to_cpu(nwi->dataStreamSize);\n\t\ti_size_write(inode, size);\n#ifdef CONFIG_NCPFS_EXTRAS\n\t\tif ((server->m.flags & (NCP_MOUNT_EXTRAS|NCP_MOUNT_SYMLINKS)) \n\t\t && (nwi->attributes & aSHARED)) {\n\t\t\tswitch (nwi->attributes & (aHIDDEN|aSYSTEM)) {\n\t\t\t\tcase aHIDDEN:\n\t\t\t\t\tif (server->m.flags & NCP_MOUNT_SYMLINKS) {\n\t\t\t\t\t\tif (/* (size >= NCP_MIN_SYMLINK_SIZE)\n\t\t\t\t\t\t && */ (size <= NCP_MAX_SYMLINK_SIZE)) {\n\t\t\t\t\t\t\tinode->i_mode = (inode->i_mode & ~S_IFMT) | S_IFLNK;\n\t\t\t\t\t\t\tNCP_FINFO(inode)->flags |= NCPI_KLUDGE_SYMLINK;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 0:\n\t\t\t\t\tif (server->m.flags & NCP_MOUNT_EXTRAS)\n\t\t\t\t\t\tinode->i_mode |= S_IRUGO;\n\t\t\t\t\tbreak;\n\t\t\t\tcase aSYSTEM:\n\t\t\t\t\tif (server->m.flags & NCP_MOUNT_EXTRAS)\n\t\t\t\t\t\tinode->i_mode |= (inode->i_mode >> 2) & S_IXUGO;\n\t\t\t\t\tbreak;\n\t\t\t\t/* case aSYSTEM|aHIDDEN: */\n\t\t\t\tdefault:\n\t\t\t\t\t/* reserved combination */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tif (nwi->attributes & aRONLY) inode->i_mode &= ~S_IWUGO;\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_evict_inode(struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "size"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "nwi->dataStreamSize"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nstatic void ncp_update_attrs(struct inode *inode, struct ncp_entry_info *nwinfo)\n{\n\tstruct nw_info_struct *nwi = &nwinfo->i;\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\n\tif (nwi->attributes & aDIR) {\n\t\tinode->i_mode = server->m.dir_mode;\n\t\t/* for directories dataStreamSize seems to be some\n\t\t   Object ID ??? */\n\t\ti_size_write(inode, NCP_BLOCK_SIZE);\n\t} else {\n\t\tu32 size;\n\n\t\tinode->i_mode = server->m.file_mode;\n\t\tsize = le32_to_cpu(nwi->dataStreamSize);\n\t\ti_size_write(inode, size);\n#ifdef CONFIG_NCPFS_EXTRAS\n\t\tif ((server->m.flags & (NCP_MOUNT_EXTRAS|NCP_MOUNT_SYMLINKS)) \n\t\t && (nwi->attributes & aSHARED)) {\n\t\t\tswitch (nwi->attributes & (aHIDDEN|aSYSTEM)) {\n\t\t\t\tcase aHIDDEN:\n\t\t\t\t\tif (server->m.flags & NCP_MOUNT_SYMLINKS) {\n\t\t\t\t\t\tif (/* (size >= NCP_MIN_SYMLINK_SIZE)\n\t\t\t\t\t\t && */ (size <= NCP_MAX_SYMLINK_SIZE)) {\n\t\t\t\t\t\t\tinode->i_mode = (inode->i_mode & ~S_IFMT) | S_IFLNK;\n\t\t\t\t\t\t\tNCP_FINFO(inode)->flags |= NCPI_KLUDGE_SYMLINK;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 0:\n\t\t\t\t\tif (server->m.flags & NCP_MOUNT_EXTRAS)\n\t\t\t\t\t\tinode->i_mode |= S_IRUGO;\n\t\t\t\t\tbreak;\n\t\t\t\tcase aSYSTEM:\n\t\t\t\t\tif (server->m.flags & NCP_MOUNT_EXTRAS)\n\t\t\t\t\t\tinode->i_mode |= (inode->i_mode >> 2) & S_IXUGO;\n\t\t\t\t\tbreak;\n\t\t\t\t/* case aSYSTEM|aHIDDEN: */\n\t\t\t\tdefault:\n\t\t\t\t\t/* reserved combination */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tif (nwi->attributes & aRONLY) inode->i_mode &= ~S_IWUGO;\n}"
  },
  {
    "function_name": "ncp_update_dates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "143-160",
    "snippet": "static void ncp_update_dates(struct inode *inode, struct nw_info_struct *nwi)\n{\n\t/* NFS namespace mode overrides others if it's set. */\n\tncp_dbg(1, \"(%s) nfs.mode=0%o\\n\", nwi->entryName, nwi->nfs.mode);\n\tif (nwi->nfs.mode) {\n\t\t/* XXX Security? */\n\t\tinode->i_mode = nwi->nfs.mode;\n\t}\n\n\tinode->i_blocks = (i_size_read(inode) + NCP_BLOCK_SIZE - 1) >> NCP_BLOCK_SHIFT;\n\n\tinode->i_mtime.tv_sec = ncp_date_dos2unix(nwi->modifyTime, nwi->modifyDate);\n\tinode->i_ctime.tv_sec = ncp_date_dos2unix(nwi->creationTime, nwi->creationDate);\n\tinode->i_atime.tv_sec = ncp_date_dos2unix(0, nwi->lastAccessDate);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_evict_inode(struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_date_dos2unix",
          "args": [
            "0",
            "nwi->lastAccessDate"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_date_dos2unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "1194-1209",
          "snippet": "int\nncp_date_dos2unix(__le16 t, __le16 d)\n{\n\tunsigned short time = le16_to_cpu(t), date = le16_to_cpu(d);\n\tint month, year, secs;\n\n\t/* first subtract and mask after that... Otherwise, if\n\t   date == 0, bad things happen */\n\tmonth = ((date >> 5) - 1) & 15;\n\tyear = date >> 9;\n\tsecs = (time & 31) * 2 + 60 * ((time >> 5) & 63) + (time >> 11) * 3600 +\n\t\t86400 * ((date & 31) - 1 + day_n[month] + (year / 4) + \n\t\tyear * 365 - ((year & 3) == 0 && month < 2 ? 1 : 0) + 3653);\n\t/* days since 1.1.70 plus 80's leap day */\n\treturn local2utc(secs);\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int day_n[] =\n{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0, 0};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int day_n[] =\n{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0, 0};\n\nint\nncp_date_dos2unix(__le16 t, __le16 d)\n{\n\tunsigned short time = le16_to_cpu(t), date = le16_to_cpu(d);\n\tint month, year, secs;\n\n\t/* first subtract and mask after that... Otherwise, if\n\t   date == 0, bad things happen */\n\tmonth = ((date >> 5) - 1) & 15;\n\tyear = date >> 9;\n\tsecs = (time & 31) * 2 + 60 * ((time >> 5) & 63) + (time >> 11) * 3600 +\n\t\t86400 * ((date & 31) - 1 + day_n[month] + (year / 4) + \n\t\tyear * 365 - ((year & 3) == 0 && month < 2 ? 1 : 0) + 3653);\n\t/* days since 1.1.70 plus 80's leap day */\n\treturn local2utc(secs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"(%s) nfs.mode=0%o\\n\"",
            "nwi->entryName",
            "nwi->nfs.mode"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nstatic void ncp_update_dates(struct inode *inode, struct nw_info_struct *nwi)\n{\n\t/* NFS namespace mode overrides others if it's set. */\n\tncp_dbg(1, \"(%s) nfs.mode=0%o\\n\", nwi->entryName, nwi->nfs.mode);\n\tif (nwi->nfs.mode) {\n\t\t/* XXX Security? */\n\t\tinode->i_mode = nwi->nfs.mode;\n\t}\n\n\tinode->i_blocks = (i_size_read(inode) + NCP_BLOCK_SIZE - 1) >> NCP_BLOCK_SHIFT;\n\n\tinode->i_mtime.tv_sec = ncp_date_dos2unix(nwi->modifyTime, nwi->modifyDate);\n\tinode->i_ctime.tv_sec = ncp_date_dos2unix(nwi->creationTime, nwi->creationDate);\n\tinode->i_atime.tv_sec = ncp_date_dos2unix(0, nwi->lastAccessDate);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n}"
  },
  {
    "function_name": "ncp_update_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "131-141",
    "snippet": "void ncp_update_inode(struct inode *inode, struct ncp_entry_info *nwinfo)\n{\n\tncp_update_dirent(inode, nwinfo);\n\tNCP_FINFO(inode)->nwattr = nwinfo->i.attributes;\n\tNCP_FINFO(inode)->access = nwinfo->access;\n\tmemcpy(NCP_FINFO(inode)->file_handle, nwinfo->file_handle,\n\t\t\tsizeof(nwinfo->file_handle));\n\tncp_dbg(1, \"updated %s, volnum=%d, dirent=%u\\n\",\n\t\tnwinfo->i.entryName, NCP_FINFO(inode)->volNumber,\n\t\tNCP_FINFO(inode)->dirEntNum);\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_evict_inode(struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"updated %s, volnum=%d, dirent=%u\\n\"",
            "nwinfo->i.entryName",
            "NCP_FINFO(inode)->volNumber",
            "NCP_FINFO(inode)->dirEntNum"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "NCP_FINFO(inode)->file_handle",
            "nwinfo->file_handle",
            "sizeof(nwinfo->file_handle)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_update_dirent",
          "args": [
            "inode",
            "nwinfo"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_update_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "124-129",
          "snippet": "static void ncp_update_dirent(struct inode *inode, struct ncp_entry_info *nwinfo)\n{\n\tNCP_FINFO(inode)->DosDirNum = nwinfo->i.DosDirNum;\n\tNCP_FINFO(inode)->dirEntNum = nwinfo->i.dirEntNum;\n\tNCP_FINFO(inode)->volNumber = nwinfo->volume;\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nstatic void ncp_update_dirent(struct inode *inode, struct ncp_entry_info *nwinfo)\n{\n\tNCP_FINFO(inode)->DosDirNum = nwinfo->i.DosDirNum;\n\tNCP_FINFO(inode)->dirEntNum = nwinfo->i.dirEntNum;\n\tNCP_FINFO(inode)->volNumber = nwinfo->volume;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nvoid ncp_update_inode(struct inode *inode, struct ncp_entry_info *nwinfo)\n{\n\tncp_update_dirent(inode, nwinfo);\n\tNCP_FINFO(inode)->nwattr = nwinfo->i.attributes;\n\tNCP_FINFO(inode)->access = nwinfo->access;\n\tmemcpy(NCP_FINFO(inode)->file_handle, nwinfo->file_handle,\n\t\t\tsizeof(nwinfo->file_handle));\n\tncp_dbg(1, \"updated %s, volnum=%d, dirent=%u\\n\",\n\t\tnwinfo->i.entryName, NCP_FINFO(inode)->volNumber,\n\t\tNCP_FINFO(inode)->dirEntNum);\n}"
  },
  {
    "function_name": "ncp_update_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "124-129",
    "snippet": "static void ncp_update_dirent(struct inode *inode, struct ncp_entry_info *nwinfo)\n{\n\tNCP_FINFO(inode)->DosDirNum = nwinfo->i.DosDirNum;\n\tNCP_FINFO(inode)->dirEntNum = nwinfo->i.dirEntNum;\n\tNCP_FINFO(inode)->volNumber = nwinfo->volume;\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_evict_inode(struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nstatic void ncp_update_dirent(struct inode *inode, struct ncp_entry_info *nwinfo)\n{\n\tNCP_FINFO(inode)->DosDirNum = nwinfo->i.DosDirNum;\n\tNCP_FINFO(inode)->dirEntNum = nwinfo->i.dirEntNum;\n\tNCP_FINFO(inode)->volNumber = nwinfo->volume;\n}"
  },
  {
    "function_name": "ncp_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "102-107",
    "snippet": "static int ncp_remount(struct super_block *sb, int *flags, char* data)\n{\n\tsync_filesystem(sb);\n\t*flags |= MS_NODIRATIME;\n\treturn 0;\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_put_super(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_put_super(struct super_block *);\n\nstatic int ncp_remount(struct super_block *sb, int *flags, char* data)\n{\n\tsync_filesystem(sb);\n\t*flags |= MS_NODIRATIME;\n\treturn 0;\n}"
  },
  {
    "function_name": "destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "92-100",
    "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ncp_inode_cachep);\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * ncp_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ncp_inode_cachep"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * ncp_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ncp_inode_cachep);\n}"
  },
  {
    "function_name": "init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "80-90",
    "snippet": "static int init_inodecache(void)\n{\n\tncp_inode_cachep = kmem_cache_create(\"ncp_inode_cache\",\n\t\t\t\t\t     sizeof(struct ncp_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ncp_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * ncp_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"ncp_inode_cache\"",
            "sizeof(struct ncp_inode_info)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD)",
            "init_once"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * ncp_inode_cachep;\n\nstatic int init_inodecache(void)\n{\n\tncp_inode_cachep = kmem_cache_create(\"ncp_inode_cache\",\n\t\t\t\t\t     sizeof(struct ncp_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ncp_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "72-78",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct ncp_inode_info *ei = (struct ncp_inode_info *) foo;\n\n\tmutex_init(&ei->open_mutex);\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "355-367",
          "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ei->open_mutex"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct ncp_inode_info *ei = (struct ncp_inode_info *) foo;\n\n\tmutex_init(&ei->open_mutex);\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "ncp_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "67-70",
    "snippet": "static void ncp_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, ncp_i_callback);\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_evict_inode(struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "ncp_i_callback"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nstatic void ncp_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, ncp_i_callback);\n}"
  },
  {
    "function_name": "ncp_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "61-65",
    "snippet": "static void ncp_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(ncp_inode_cachep, NCP_FINFO(inode));\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_evict_inode(struct inode *);",
      "static struct kmem_cache * ncp_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ncp_inode_cachep",
            "NCP_FINFO(inode)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\nstatic struct kmem_cache * ncp_inode_cachep;\n\nstatic void ncp_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(ncp_inode_cachep, NCP_FINFO(inode));\n}"
  },
  {
    "function_name": "ncp_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
    "lines": "52-59",
    "snippet": "static struct inode *ncp_alloc_inode(struct super_block *sb)\n{\n\tstruct ncp_inode_info *ei;\n\tei = (struct ncp_inode_info *)kmem_cache_alloc(ncp_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}",
    "includes": [
      "#include \"getopt.h\"",
      "#include \"ncp_fs.h\"",
      "#include <net/sock.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/vfs.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_evict_inode(struct inode *);",
      "static void ncp_put_super(struct super_block *);",
      "static struct kmem_cache * ncp_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ncp_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\nstatic void ncp_put_super(struct super_block *);\nstatic struct kmem_cache * ncp_inode_cachep;\n\nstatic struct inode *ncp_alloc_inode(struct super_block *sb)\n{\n\tstruct ncp_inode_info *ei;\n\tei = (struct ncp_inode_info *)kmem_cache_alloc(ncp_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}"
  }
]