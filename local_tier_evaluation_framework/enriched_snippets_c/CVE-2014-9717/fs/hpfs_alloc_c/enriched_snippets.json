[
  {
    "function_name": "hpfs_alloc_anode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
    "lines": "470-486",
    "snippet": "struct anode *hpfs_alloc_anode(struct super_block *s, secno near, anode_secno *ano,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct anode *a;\n\tif (!(*ano = hpfs_alloc_sector(s, near, 1, ANODE_ALLOC_FWD))) return NULL;\n\tif (!(a = hpfs_get_sector(s, *ano, bh))) {\n\t\thpfs_free_sectors(s, *ano, 1);\n\t\treturn NULL;\n\t}\n\tmemset(a, 0, 512);\n\ta->magic = cpu_to_le32(ANODE_MAGIC);\n\ta->self = cpu_to_le32(*ano);\n\ta->btree.n_free_nodes = 40;\n\ta->btree.n_used_nodes = 0;\n\ta->btree.first_free = cpu_to_le16(8);\n\treturn a;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "8"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "*ano"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ANODE_MAGIC"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "a",
            "0",
            "512"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_free_sectors",
          "args": [
            "s",
            "*ano",
            "1"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "314-350",
          "snippet": "void hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_get_sector",
          "args": [
            "s",
            "*ano",
            "bh"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_get_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "65-82",
          "snippet": "void *hpfs_get_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\t/*return hpfs_map_sector(s, secno, bhp, 0);*/\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif ((*bhp = bh = sb_getblk(s, secno)) != NULL) {\n\t\tif (!buffer_uptodate(bh)) wait_on_buffer(bh);\n\t\tset_buffer_uptodate(bh);\n\t\treturn bh->b_data;\n\t} else {\n\t\tpr_err(\"%s(): getblk failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_get_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\t/*return hpfs_map_sector(s, secno, bhp, 0);*/\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif ((*bhp = bh = sb_getblk(s, secno)) != NULL) {\n\t\tif (!buffer_uptodate(bh)) wait_on_buffer(bh);\n\t\tset_buffer_uptodate(bh);\n\t\treturn bh->b_data;\n\t} else {\n\t\tpr_err(\"%s(): getblk failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_alloc_sector",
          "args": [
            "s",
            "near",
            "1",
            "ANODE_ALLOC_FWD"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_alloc_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "202-274",
          "snippet": "secno hpfs_alloc_sector(struct super_block *s, secno near, unsigned n, int forward)\n{\n\tsecno sec;\n\tint i;\n\tunsigned n_bmps;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tint f_p = 0;\n\tint near_bmp;\n\tif (forward < 0) {\n\t\tforward = -forward;\n\t\tf_p = 1;\n\t}\n\tn_bmps = (sbi->sb_fs_size + 0x4000 - 1) >> 14;\n\tif (near && near < sbi->sb_fs_size) {\n\t\tif ((sec = alloc_in_bmp(s, near, n, f_p ? forward : forward/4))) goto ret;\n\t\tnear_bmp = near >> 14;\n\t} else near_bmp = n_bmps / 2;\n\t/*\n\tif (b != -1) {\n\t\tif ((sec = alloc_in_bmp(s, b<<14, n, f_p ? forward : forward/2))) {\n\t\t\tb &= 0x0fffffff;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (b > 0x10000000) if ((sec = alloc_in_bmp(s, (b&0xfffffff)<<14, n, f_p ? forward : 0))) goto ret;\n\t*/\n\tif (!f_p) if (forward > sbi->sb_max_fwd_alloc) forward = sbi->sb_max_fwd_alloc;\n\tless_fwd:\n\tfor (i = 0; i < n_bmps; i++) {\n\t\tif (near_bmp+i < n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i) << 14, n, forward)))) {\n\t\t\tsbi->sb_c_bitmap = near_bmp+i;\n\t\t\tgoto ret;\n\t\t}\t\n\t\tif (!forward) {\n\t\t\tif (near_bmp-i-1 >= 0 && ((sec = alloc_in_bmp(s, (near_bmp-i-1) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp-i-1;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t} else {\n\t\t\tif (near_bmp+i >= n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i-n_bmps) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp+i-n_bmps;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\tif (i == 1 && sbi->sb_c_bitmap != -1 && ((sec = alloc_in_bmp(s, (sbi->sb_c_bitmap) << 14, n, forward)))) {\n\t\t\tgoto ret;\n\t\t}\n\t}\n\tif (!f_p) {\n\t\tif (forward) {\n\t\t\tsbi->sb_max_fwd_alloc = forward * 3 / 4;\n\t\t\tforward /= 2;\n\t\t\tgoto less_fwd;\n\t\t}\n\t}\n\tsec = 0;\n\tret:\n\tif (sec) {\n\t\ti = 0;\n\t\tdo\n\t\t\thpfs_claim_alloc(s, sec + i);\n\t\twhile (unlikely(++i < n));\n\t}\n\tif (sec && f_p) {\n\t\tfor (i = 0; i < forward; i++) {\n\t\t\tif (!hpfs_alloc_if_possible(s, sec + n + i)) {\n\t\t\t\thpfs_error(s, \"Prealloc doesn't work! Wanted %d, allocated at %08x, can't allocate %d\", forward, sec, i);\n\t\t\t\tsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sec;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nsecno hpfs_alloc_sector(struct super_block *s, secno near, unsigned n, int forward)\n{\n\tsecno sec;\n\tint i;\n\tunsigned n_bmps;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tint f_p = 0;\n\tint near_bmp;\n\tif (forward < 0) {\n\t\tforward = -forward;\n\t\tf_p = 1;\n\t}\n\tn_bmps = (sbi->sb_fs_size + 0x4000 - 1) >> 14;\n\tif (near && near < sbi->sb_fs_size) {\n\t\tif ((sec = alloc_in_bmp(s, near, n, f_p ? forward : forward/4))) goto ret;\n\t\tnear_bmp = near >> 14;\n\t} else near_bmp = n_bmps / 2;\n\t/*\n\tif (b != -1) {\n\t\tif ((sec = alloc_in_bmp(s, b<<14, n, f_p ? forward : forward/2))) {\n\t\t\tb &= 0x0fffffff;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (b > 0x10000000) if ((sec = alloc_in_bmp(s, (b&0xfffffff)<<14, n, f_p ? forward : 0))) goto ret;\n\t*/\n\tif (!f_p) if (forward > sbi->sb_max_fwd_alloc) forward = sbi->sb_max_fwd_alloc;\n\tless_fwd:\n\tfor (i = 0; i < n_bmps; i++) {\n\t\tif (near_bmp+i < n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i) << 14, n, forward)))) {\n\t\t\tsbi->sb_c_bitmap = near_bmp+i;\n\t\t\tgoto ret;\n\t\t}\t\n\t\tif (!forward) {\n\t\t\tif (near_bmp-i-1 >= 0 && ((sec = alloc_in_bmp(s, (near_bmp-i-1) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp-i-1;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t} else {\n\t\t\tif (near_bmp+i >= n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i-n_bmps) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp+i-n_bmps;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\tif (i == 1 && sbi->sb_c_bitmap != -1 && ((sec = alloc_in_bmp(s, (sbi->sb_c_bitmap) << 14, n, forward)))) {\n\t\t\tgoto ret;\n\t\t}\n\t}\n\tif (!f_p) {\n\t\tif (forward) {\n\t\t\tsbi->sb_max_fwd_alloc = forward * 3 / 4;\n\t\t\tforward /= 2;\n\t\t\tgoto less_fwd;\n\t\t}\n\t}\n\tsec = 0;\n\tret:\n\tif (sec) {\n\t\ti = 0;\n\t\tdo\n\t\t\thpfs_claim_alloc(s, sec + i);\n\t\twhile (unlikely(++i < n));\n\t}\n\tif (sec && f_p) {\n\t\tfor (i = 0; i < forward; i++) {\n\t\t\tif (!hpfs_alloc_if_possible(s, sec + n + i)) {\n\t\t\t\thpfs_error(s, \"Prealloc doesn't work! Wanted %d, allocated at %08x, can't allocate %d\", forward, sec, i);\n\t\t\t\tsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct anode *hpfs_alloc_anode(struct super_block *s, secno near, anode_secno *ano,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct anode *a;\n\tif (!(*ano = hpfs_alloc_sector(s, near, 1, ANODE_ALLOC_FWD))) return NULL;\n\tif (!(a = hpfs_get_sector(s, *ano, bh))) {\n\t\thpfs_free_sectors(s, *ano, 1);\n\t\treturn NULL;\n\t}\n\tmemset(a, 0, 512);\n\ta->magic = cpu_to_le32(ANODE_MAGIC);\n\ta->self = cpu_to_le32(*ano);\n\ta->btree.n_free_nodes = 40;\n\ta->btree.n_used_nodes = 0;\n\ta->btree.first_free = cpu_to_le16(8);\n\treturn a;\n}"
  },
  {
    "function_name": "hpfs_alloc_fnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
    "lines": "453-468",
    "snippet": "struct fnode *hpfs_alloc_fnode(struct super_block *s, secno near, fnode_secno *fno,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct fnode *f;\n\tif (!(*fno = hpfs_alloc_sector(s, near, 1, FNODE_ALLOC_FWD))) return NULL;\n\tif (!(f = hpfs_get_sector(s, *fno, bh))) {\n\t\thpfs_free_sectors(s, *fno, 1);\n\t\treturn NULL;\n\t}\t\n\tmemset(f, 0, 512);\n\tf->magic = cpu_to_le32(FNODE_MAGIC);\n\tf->ea_offs = cpu_to_le16(0xc4);\n\tf->btree.n_free_nodes = 8;\n\tf->btree.first_free = cpu_to_le16(8);\n\treturn f;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "8"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0xc4"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "FNODE_MAGIC"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "f",
            "0",
            "512"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_free_sectors",
          "args": [
            "s",
            "*fno",
            "1"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "314-350",
          "snippet": "void hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_get_sector",
          "args": [
            "s",
            "*fno",
            "bh"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_get_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "65-82",
          "snippet": "void *hpfs_get_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\t/*return hpfs_map_sector(s, secno, bhp, 0);*/\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif ((*bhp = bh = sb_getblk(s, secno)) != NULL) {\n\t\tif (!buffer_uptodate(bh)) wait_on_buffer(bh);\n\t\tset_buffer_uptodate(bh);\n\t\treturn bh->b_data;\n\t} else {\n\t\tpr_err(\"%s(): getblk failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_get_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\t/*return hpfs_map_sector(s, secno, bhp, 0);*/\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif ((*bhp = bh = sb_getblk(s, secno)) != NULL) {\n\t\tif (!buffer_uptodate(bh)) wait_on_buffer(bh);\n\t\tset_buffer_uptodate(bh);\n\t\treturn bh->b_data;\n\t} else {\n\t\tpr_err(\"%s(): getblk failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_alloc_sector",
          "args": [
            "s",
            "near",
            "1",
            "FNODE_ALLOC_FWD"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_alloc_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "202-274",
          "snippet": "secno hpfs_alloc_sector(struct super_block *s, secno near, unsigned n, int forward)\n{\n\tsecno sec;\n\tint i;\n\tunsigned n_bmps;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tint f_p = 0;\n\tint near_bmp;\n\tif (forward < 0) {\n\t\tforward = -forward;\n\t\tf_p = 1;\n\t}\n\tn_bmps = (sbi->sb_fs_size + 0x4000 - 1) >> 14;\n\tif (near && near < sbi->sb_fs_size) {\n\t\tif ((sec = alloc_in_bmp(s, near, n, f_p ? forward : forward/4))) goto ret;\n\t\tnear_bmp = near >> 14;\n\t} else near_bmp = n_bmps / 2;\n\t/*\n\tif (b != -1) {\n\t\tif ((sec = alloc_in_bmp(s, b<<14, n, f_p ? forward : forward/2))) {\n\t\t\tb &= 0x0fffffff;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (b > 0x10000000) if ((sec = alloc_in_bmp(s, (b&0xfffffff)<<14, n, f_p ? forward : 0))) goto ret;\n\t*/\n\tif (!f_p) if (forward > sbi->sb_max_fwd_alloc) forward = sbi->sb_max_fwd_alloc;\n\tless_fwd:\n\tfor (i = 0; i < n_bmps; i++) {\n\t\tif (near_bmp+i < n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i) << 14, n, forward)))) {\n\t\t\tsbi->sb_c_bitmap = near_bmp+i;\n\t\t\tgoto ret;\n\t\t}\t\n\t\tif (!forward) {\n\t\t\tif (near_bmp-i-1 >= 0 && ((sec = alloc_in_bmp(s, (near_bmp-i-1) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp-i-1;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t} else {\n\t\t\tif (near_bmp+i >= n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i-n_bmps) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp+i-n_bmps;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\tif (i == 1 && sbi->sb_c_bitmap != -1 && ((sec = alloc_in_bmp(s, (sbi->sb_c_bitmap) << 14, n, forward)))) {\n\t\t\tgoto ret;\n\t\t}\n\t}\n\tif (!f_p) {\n\t\tif (forward) {\n\t\t\tsbi->sb_max_fwd_alloc = forward * 3 / 4;\n\t\t\tforward /= 2;\n\t\t\tgoto less_fwd;\n\t\t}\n\t}\n\tsec = 0;\n\tret:\n\tif (sec) {\n\t\ti = 0;\n\t\tdo\n\t\t\thpfs_claim_alloc(s, sec + i);\n\t\twhile (unlikely(++i < n));\n\t}\n\tif (sec && f_p) {\n\t\tfor (i = 0; i < forward; i++) {\n\t\t\tif (!hpfs_alloc_if_possible(s, sec + n + i)) {\n\t\t\t\thpfs_error(s, \"Prealloc doesn't work! Wanted %d, allocated at %08x, can't allocate %d\", forward, sec, i);\n\t\t\t\tsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sec;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nsecno hpfs_alloc_sector(struct super_block *s, secno near, unsigned n, int forward)\n{\n\tsecno sec;\n\tint i;\n\tunsigned n_bmps;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tint f_p = 0;\n\tint near_bmp;\n\tif (forward < 0) {\n\t\tforward = -forward;\n\t\tf_p = 1;\n\t}\n\tn_bmps = (sbi->sb_fs_size + 0x4000 - 1) >> 14;\n\tif (near && near < sbi->sb_fs_size) {\n\t\tif ((sec = alloc_in_bmp(s, near, n, f_p ? forward : forward/4))) goto ret;\n\t\tnear_bmp = near >> 14;\n\t} else near_bmp = n_bmps / 2;\n\t/*\n\tif (b != -1) {\n\t\tif ((sec = alloc_in_bmp(s, b<<14, n, f_p ? forward : forward/2))) {\n\t\t\tb &= 0x0fffffff;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (b > 0x10000000) if ((sec = alloc_in_bmp(s, (b&0xfffffff)<<14, n, f_p ? forward : 0))) goto ret;\n\t*/\n\tif (!f_p) if (forward > sbi->sb_max_fwd_alloc) forward = sbi->sb_max_fwd_alloc;\n\tless_fwd:\n\tfor (i = 0; i < n_bmps; i++) {\n\t\tif (near_bmp+i < n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i) << 14, n, forward)))) {\n\t\t\tsbi->sb_c_bitmap = near_bmp+i;\n\t\t\tgoto ret;\n\t\t}\t\n\t\tif (!forward) {\n\t\t\tif (near_bmp-i-1 >= 0 && ((sec = alloc_in_bmp(s, (near_bmp-i-1) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp-i-1;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t} else {\n\t\t\tif (near_bmp+i >= n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i-n_bmps) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp+i-n_bmps;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\tif (i == 1 && sbi->sb_c_bitmap != -1 && ((sec = alloc_in_bmp(s, (sbi->sb_c_bitmap) << 14, n, forward)))) {\n\t\t\tgoto ret;\n\t\t}\n\t}\n\tif (!f_p) {\n\t\tif (forward) {\n\t\t\tsbi->sb_max_fwd_alloc = forward * 3 / 4;\n\t\t\tforward /= 2;\n\t\t\tgoto less_fwd;\n\t\t}\n\t}\n\tsec = 0;\n\tret:\n\tif (sec) {\n\t\ti = 0;\n\t\tdo\n\t\t\thpfs_claim_alloc(s, sec + i);\n\t\twhile (unlikely(++i < n));\n\t}\n\tif (sec && f_p) {\n\t\tfor (i = 0; i < forward; i++) {\n\t\t\tif (!hpfs_alloc_if_possible(s, sec + n + i)) {\n\t\t\t\thpfs_error(s, \"Prealloc doesn't work! Wanted %d, allocated at %08x, can't allocate %d\", forward, sec, i);\n\t\t\t\tsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_alloc_fnode(struct super_block *s, secno near, fnode_secno *fno,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct fnode *f;\n\tif (!(*fno = hpfs_alloc_sector(s, near, 1, FNODE_ALLOC_FWD))) return NULL;\n\tif (!(f = hpfs_get_sector(s, *fno, bh))) {\n\t\thpfs_free_sectors(s, *fno, 1);\n\t\treturn NULL;\n\t}\t\n\tmemset(f, 0, 512);\n\tf->magic = cpu_to_le32(FNODE_MAGIC);\n\tf->ea_offs = cpu_to_le16(0xc4);\n\tf->btree.n_free_nodes = 8;\n\tf->btree.first_free = cpu_to_le16(8);\n\treturn f;\n}"
  },
  {
    "function_name": "hpfs_alloc_dnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
    "lines": "427-451",
    "snippet": "struct dnode *hpfs_alloc_dnode(struct super_block *s, secno near,\n\t\t\t dnode_secno *dno, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *d;\n\tif (hpfs_get_free_dnodes(s) > FREE_DNODES_ADD) {\n\t\tif (!(*dno = alloc_in_dirband(s, near)))\n\t\t\tif (!(*dno = hpfs_alloc_sector(s, near, 4, 0))) return NULL;\n\t} else {\n\t\tif (!(*dno = hpfs_alloc_sector(s, near, 4, 0)))\n\t\t\tif (!(*dno = alloc_in_dirband(s, near))) return NULL;\n\t}\n\tif (!(d = hpfs_get_4sectors(s, *dno, qbh))) {\n\t\thpfs_free_dnode(s, *dno);\n\t\treturn NULL;\n\t}\n\tmemset(d, 0, 2048);\n\td->magic = cpu_to_le32(DNODE_MAGIC);\n\td->first_free = cpu_to_le32(52);\n\td->dirent[0] = 32;\n\td->dirent[2] = 8;\n\td->dirent[30] = 1;\n\td->dirent[31] = 255;\n\td->self = cpu_to_le32(*dno);\n\treturn d;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "*dno"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "52"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "DNODE_MAGIC"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "d",
            "0",
            "2048"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_free_dnode",
          "args": [
            "s",
            "*dno"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "404-425",
          "snippet": "void hpfs_free_dnode(struct super_block *s, dnode_secno dno)\n{\n\tif (hpfs_sb(s)->sb_chk) if (dno & 3) {\n\t\thpfs_error(s, \"hpfs_free_dnode: dnode %08x not aligned\", dno);\n\t\treturn;\n\t}\n\tif (dno < hpfs_sb(s)->sb_dirband_start ||\n\t    dno >= hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\thpfs_free_sectors(s, dno, 4);\n\t} else {\n\t\tstruct quad_buffer_head qbh;\n\t\t__le32 *bmp;\n\t\tunsigned ssec = (dno - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\t\treturn;\n\t\t}\n\t\tbmp[ssec >> 5] |= cpu_to_le32(1 << (ssec & 0x1f));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_dirband_free(s, dno);\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_dnode(struct super_block *s, dnode_secno dno)\n{\n\tif (hpfs_sb(s)->sb_chk) if (dno & 3) {\n\t\thpfs_error(s, \"hpfs_free_dnode: dnode %08x not aligned\", dno);\n\t\treturn;\n\t}\n\tif (dno < hpfs_sb(s)->sb_dirband_start ||\n\t    dno >= hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\thpfs_free_sectors(s, dno, 4);\n\t} else {\n\t\tstruct quad_buffer_head qbh;\n\t\t__le32 *bmp;\n\t\tunsigned ssec = (dno - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\t\treturn;\n\t\t}\n\t\tbmp[ssec >> 5] |= cpu_to_le32(1 << (ssec & 0x1f));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_dirband_free(s, dno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_get_4sectors",
          "args": [
            "s",
            "*dno",
            "qbh"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_get_4sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "140-179",
          "snippet": "void *hpfs_get_4sectors(struct super_block *s, unsigned secno,\n                          struct quad_buffer_head *qbh)\n{\n\tcond_resched();\n\n\thpfs_lock_assert(s);\n\n\tif (secno & 3) {\n\t\tpr_err(\"%s(): unaligned read\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (!hpfs_get_sector(s, secno + 0, &qbh->bh[0])) goto bail0;\n\tif (!hpfs_get_sector(s, secno + 1, &qbh->bh[1])) goto bail1;\n\tif (!hpfs_get_sector(s, secno + 2, &qbh->bh[2])) goto bail2;\n\tif (!hpfs_get_sector(s, secno + 3, &qbh->bh[3])) goto bail3;\n\n\tif (likely(qbh->bh[1]->b_data == qbh->bh[0]->b_data + 1 * 512) &&\n\t    likely(qbh->bh[2]->b_data == qbh->bh[0]->b_data + 2 * 512) &&\n\t    likely(qbh->bh[3]->b_data == qbh->bh[0]->b_data + 3 * 512)) {\n\t\treturn qbh->data = qbh->bh[0]->b_data;\n\t}\n\n\tif (!(qbh->data = kmalloc(2048, GFP_NOFS))) {\n\t\tpr_err(\"%s(): out of memory\\n\", __func__);\n\t\tgoto bail4;\n\t}\n\treturn qbh->data;\n\nbail4:\n\tbrelse(qbh->bh[3]);\nbail3:\n\tbrelse(qbh->bh[2]);\nbail2:\n\tbrelse(qbh->bh[1]);\nbail1:\n\tbrelse(qbh->bh[0]);\nbail0:\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_get_4sectors(struct super_block *s, unsigned secno,\n                          struct quad_buffer_head *qbh)\n{\n\tcond_resched();\n\n\thpfs_lock_assert(s);\n\n\tif (secno & 3) {\n\t\tpr_err(\"%s(): unaligned read\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (!hpfs_get_sector(s, secno + 0, &qbh->bh[0])) goto bail0;\n\tif (!hpfs_get_sector(s, secno + 1, &qbh->bh[1])) goto bail1;\n\tif (!hpfs_get_sector(s, secno + 2, &qbh->bh[2])) goto bail2;\n\tif (!hpfs_get_sector(s, secno + 3, &qbh->bh[3])) goto bail3;\n\n\tif (likely(qbh->bh[1]->b_data == qbh->bh[0]->b_data + 1 * 512) &&\n\t    likely(qbh->bh[2]->b_data == qbh->bh[0]->b_data + 2 * 512) &&\n\t    likely(qbh->bh[3]->b_data == qbh->bh[0]->b_data + 3 * 512)) {\n\t\treturn qbh->data = qbh->bh[0]->b_data;\n\t}\n\n\tif (!(qbh->data = kmalloc(2048, GFP_NOFS))) {\n\t\tpr_err(\"%s(): out of memory\\n\", __func__);\n\t\tgoto bail4;\n\t}\n\treturn qbh->data;\n\nbail4:\n\tbrelse(qbh->bh[3]);\nbail3:\n\tbrelse(qbh->bh[2]);\nbail2:\n\tbrelse(qbh->bh[1]);\nbail1:\n\tbrelse(qbh->bh[0]);\nbail0:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_in_dirband",
          "args": [
            "s",
            "near"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_in_dirband",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "276-291",
          "snippet": "static secno alloc_in_dirband(struct super_block *s, secno near)\n{\n\tunsigned nr = near;\n\tsecno sec;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (nr < sbi->sb_dirband_start)\n\t\tnr = sbi->sb_dirband_start;\n\tif (nr >= sbi->sb_dirband_start + sbi->sb_dirband_size)\n\t\tnr = sbi->sb_dirband_start + sbi->sb_dirband_size - 4;\n\tnr -= sbi->sb_dirband_start;\n\tnr >>= 2;\n\tsec = alloc_in_bmp(s, (~0x3fff) | nr, 1, 0);\n\tif (!sec) return 0;\n\thpfs_claim_dirband_alloc(s, sec);\n\treturn ((sec & 0x3fff) << 2) + sbi->sb_dirband_start;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic secno alloc_in_dirband(struct super_block *s, secno near)\n{\n\tunsigned nr = near;\n\tsecno sec;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (nr < sbi->sb_dirband_start)\n\t\tnr = sbi->sb_dirband_start;\n\tif (nr >= sbi->sb_dirband_start + sbi->sb_dirband_size)\n\t\tnr = sbi->sb_dirband_start + sbi->sb_dirband_size - 4;\n\tnr -= sbi->sb_dirband_start;\n\tnr >>= 2;\n\tsec = alloc_in_bmp(s, (~0x3fff) | nr, 1, 0);\n\tif (!sec) return 0;\n\thpfs_claim_dirband_alloc(s, sec);\n\treturn ((sec & 0x3fff) << 2) + sbi->sb_dirband_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_alloc_sector",
          "args": [
            "s",
            "near",
            "4",
            "0"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_alloc_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "202-274",
          "snippet": "secno hpfs_alloc_sector(struct super_block *s, secno near, unsigned n, int forward)\n{\n\tsecno sec;\n\tint i;\n\tunsigned n_bmps;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tint f_p = 0;\n\tint near_bmp;\n\tif (forward < 0) {\n\t\tforward = -forward;\n\t\tf_p = 1;\n\t}\n\tn_bmps = (sbi->sb_fs_size + 0x4000 - 1) >> 14;\n\tif (near && near < sbi->sb_fs_size) {\n\t\tif ((sec = alloc_in_bmp(s, near, n, f_p ? forward : forward/4))) goto ret;\n\t\tnear_bmp = near >> 14;\n\t} else near_bmp = n_bmps / 2;\n\t/*\n\tif (b != -1) {\n\t\tif ((sec = alloc_in_bmp(s, b<<14, n, f_p ? forward : forward/2))) {\n\t\t\tb &= 0x0fffffff;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (b > 0x10000000) if ((sec = alloc_in_bmp(s, (b&0xfffffff)<<14, n, f_p ? forward : 0))) goto ret;\n\t*/\n\tif (!f_p) if (forward > sbi->sb_max_fwd_alloc) forward = sbi->sb_max_fwd_alloc;\n\tless_fwd:\n\tfor (i = 0; i < n_bmps; i++) {\n\t\tif (near_bmp+i < n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i) << 14, n, forward)))) {\n\t\t\tsbi->sb_c_bitmap = near_bmp+i;\n\t\t\tgoto ret;\n\t\t}\t\n\t\tif (!forward) {\n\t\t\tif (near_bmp-i-1 >= 0 && ((sec = alloc_in_bmp(s, (near_bmp-i-1) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp-i-1;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t} else {\n\t\t\tif (near_bmp+i >= n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i-n_bmps) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp+i-n_bmps;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\tif (i == 1 && sbi->sb_c_bitmap != -1 && ((sec = alloc_in_bmp(s, (sbi->sb_c_bitmap) << 14, n, forward)))) {\n\t\t\tgoto ret;\n\t\t}\n\t}\n\tif (!f_p) {\n\t\tif (forward) {\n\t\t\tsbi->sb_max_fwd_alloc = forward * 3 / 4;\n\t\t\tforward /= 2;\n\t\t\tgoto less_fwd;\n\t\t}\n\t}\n\tsec = 0;\n\tret:\n\tif (sec) {\n\t\ti = 0;\n\t\tdo\n\t\t\thpfs_claim_alloc(s, sec + i);\n\t\twhile (unlikely(++i < n));\n\t}\n\tif (sec && f_p) {\n\t\tfor (i = 0; i < forward; i++) {\n\t\t\tif (!hpfs_alloc_if_possible(s, sec + n + i)) {\n\t\t\t\thpfs_error(s, \"Prealloc doesn't work! Wanted %d, allocated at %08x, can't allocate %d\", forward, sec, i);\n\t\t\t\tsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sec;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nsecno hpfs_alloc_sector(struct super_block *s, secno near, unsigned n, int forward)\n{\n\tsecno sec;\n\tint i;\n\tunsigned n_bmps;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tint f_p = 0;\n\tint near_bmp;\n\tif (forward < 0) {\n\t\tforward = -forward;\n\t\tf_p = 1;\n\t}\n\tn_bmps = (sbi->sb_fs_size + 0x4000 - 1) >> 14;\n\tif (near && near < sbi->sb_fs_size) {\n\t\tif ((sec = alloc_in_bmp(s, near, n, f_p ? forward : forward/4))) goto ret;\n\t\tnear_bmp = near >> 14;\n\t} else near_bmp = n_bmps / 2;\n\t/*\n\tif (b != -1) {\n\t\tif ((sec = alloc_in_bmp(s, b<<14, n, f_p ? forward : forward/2))) {\n\t\t\tb &= 0x0fffffff;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (b > 0x10000000) if ((sec = alloc_in_bmp(s, (b&0xfffffff)<<14, n, f_p ? forward : 0))) goto ret;\n\t*/\n\tif (!f_p) if (forward > sbi->sb_max_fwd_alloc) forward = sbi->sb_max_fwd_alloc;\n\tless_fwd:\n\tfor (i = 0; i < n_bmps; i++) {\n\t\tif (near_bmp+i < n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i) << 14, n, forward)))) {\n\t\t\tsbi->sb_c_bitmap = near_bmp+i;\n\t\t\tgoto ret;\n\t\t}\t\n\t\tif (!forward) {\n\t\t\tif (near_bmp-i-1 >= 0 && ((sec = alloc_in_bmp(s, (near_bmp-i-1) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp-i-1;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t} else {\n\t\t\tif (near_bmp+i >= n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i-n_bmps) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp+i-n_bmps;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\tif (i == 1 && sbi->sb_c_bitmap != -1 && ((sec = alloc_in_bmp(s, (sbi->sb_c_bitmap) << 14, n, forward)))) {\n\t\t\tgoto ret;\n\t\t}\n\t}\n\tif (!f_p) {\n\t\tif (forward) {\n\t\t\tsbi->sb_max_fwd_alloc = forward * 3 / 4;\n\t\t\tforward /= 2;\n\t\t\tgoto less_fwd;\n\t\t}\n\t}\n\tsec = 0;\n\tret:\n\tif (sec) {\n\t\ti = 0;\n\t\tdo\n\t\t\thpfs_claim_alloc(s, sec + i);\n\t\twhile (unlikely(++i < n));\n\t}\n\tif (sec && f_p) {\n\t\tfor (i = 0; i < forward; i++) {\n\t\t\tif (!hpfs_alloc_if_possible(s, sec + n + i)) {\n\t\t\t\thpfs_error(s, \"Prealloc doesn't work! Wanted %d, allocated at %08x, can't allocate %d\", forward, sec, i);\n\t\t\t\tsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_get_free_dnodes",
          "args": [
            "s"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_get_free_dnodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "160-170",
          "snippet": "unsigned hpfs_get_free_dnodes(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free_dnodes == (unsigned)-1) {\n\t\tunsigned c = hpfs_count_one_bitmap(s, sbi->sb_dmap);\n\t\tif (c == (unsigned)-1)\n\t\t\treturn 0;\n\t\tsbi->sb_n_free_dnodes = c;\n\t}\n\treturn sbi->sb_n_free_dnodes;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nunsigned hpfs_get_free_dnodes(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free_dnodes == (unsigned)-1) {\n\t\tunsigned c = hpfs_count_one_bitmap(s, sbi->sb_dmap);\n\t\tif (c == (unsigned)-1)\n\t\t\treturn 0;\n\t\tsbi->sb_n_free_dnodes = c;\n\t}\n\treturn sbi->sb_n_free_dnodes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct dnode *hpfs_alloc_dnode(struct super_block *s, secno near,\n\t\t\t dnode_secno *dno, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *d;\n\tif (hpfs_get_free_dnodes(s) > FREE_DNODES_ADD) {\n\t\tif (!(*dno = alloc_in_dirband(s, near)))\n\t\t\tif (!(*dno = hpfs_alloc_sector(s, near, 4, 0))) return NULL;\n\t} else {\n\t\tif (!(*dno = hpfs_alloc_sector(s, near, 4, 0)))\n\t\t\tif (!(*dno = alloc_in_dirband(s, near))) return NULL;\n\t}\n\tif (!(d = hpfs_get_4sectors(s, *dno, qbh))) {\n\t\thpfs_free_dnode(s, *dno);\n\t\treturn NULL;\n\t}\n\tmemset(d, 0, 2048);\n\td->magic = cpu_to_le32(DNODE_MAGIC);\n\td->first_free = cpu_to_le32(52);\n\td->dirent[0] = 32;\n\td->dirent[2] = 8;\n\td->dirent[30] = 1;\n\td->dirent[31] = 255;\n\td->self = cpu_to_le32(*dno);\n\treturn d;\n}"
  },
  {
    "function_name": "hpfs_free_dnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
    "lines": "404-425",
    "snippet": "void hpfs_free_dnode(struct super_block *s, dnode_secno dno)\n{\n\tif (hpfs_sb(s)->sb_chk) if (dno & 3) {\n\t\thpfs_error(s, \"hpfs_free_dnode: dnode %08x not aligned\", dno);\n\t\treturn;\n\t}\n\tif (dno < hpfs_sb(s)->sb_dirband_start ||\n\t    dno >= hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\thpfs_free_sectors(s, dno, 4);\n\t} else {\n\t\tstruct quad_buffer_head qbh;\n\t\t__le32 *bmp;\n\t\tunsigned ssec = (dno - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\t\treturn;\n\t\t}\n\t\tbmp[ssec >> 5] |= cpu_to_le32(1 << (ssec & 0x1f));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_dirband_free(s, dno);\n\t}\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_claim_dirband_free",
          "args": [
            "s",
            "dno"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_claim_dirband_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "50-61",
          "snippet": "static void hpfs_claim_dirband_free(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free_dnodes != (unsigned)-1) {\n\t\tif (unlikely(sbi->sb_n_free_dnodes >= sbi->sb_dirband_size / 4)) {\n\t\t\thpfs_error(s, \"dirband free count overflow, freeing sector %08x\", sec);\n\t\t\tsbi->sb_n_free_dnodes = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free_dnodes++;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void hpfs_claim_dirband_free(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free_dnodes != (unsigned)-1) {\n\t\tif (unlikely(sbi->sb_n_free_dnodes >= sbi->sb_dirband_size / 4)) {\n\t\t\thpfs_error(s, \"dirband free count overflow, freeing sector %08x\", sec);\n\t\t\tsbi->sb_n_free_dnodes = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free_dnodes++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_mark_4buffers_dirty",
          "args": [
            "&qbh"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_mark_4buffers_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "192-204",
          "snippet": "void hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1 << (ssec & 0x1f)"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_map_dnode_bitmap",
          "args": [
            "s",
            "&qbh"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_dnode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "11-14",
          "snippet": "__le32 *hpfs_map_dnode_bitmap(struct super_block *s, struct quad_buffer_head *qbh)\n{\n\treturn hpfs_map_4sectors(s, hpfs_sb(s)->sb_dmap, qbh, 0);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\n__le32 *hpfs_map_dnode_bitmap(struct super_block *s, struct quad_buffer_head *qbh)\n{\n\treturn hpfs_map_4sectors(s, hpfs_sb(s)->sb_dmap, qbh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_free_sectors",
          "args": [
            "s",
            "dno",
            "4"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "314-350",
          "snippet": "void hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"hpfs_free_dnode: dnode %08x not aligned\"",
            "dno"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_dnode(struct super_block *s, dnode_secno dno)\n{\n\tif (hpfs_sb(s)->sb_chk) if (dno & 3) {\n\t\thpfs_error(s, \"hpfs_free_dnode: dnode %08x not aligned\", dno);\n\t\treturn;\n\t}\n\tif (dno < hpfs_sb(s)->sb_dirband_start ||\n\t    dno >= hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\thpfs_free_sectors(s, dno, 4);\n\t} else {\n\t\tstruct quad_buffer_head qbh;\n\t\t__le32 *bmp;\n\t\tunsigned ssec = (dno - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\t\treturn;\n\t\t}\n\t\tbmp[ssec >> 5] |= cpu_to_le32(1 << (ssec & 0x1f));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_dirband_free(s, dno);\n\t}\n}"
  },
  {
    "function_name": "hpfs_check_free_dnodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
    "lines": "358-402",
    "snippet": "int hpfs_check_free_dnodes(struct super_block *s, int n)\n{\n\tint n_bmps = (hpfs_sb(s)->sb_fs_size + 0x4000 - 1) >> 14;\n\tint b = hpfs_sb(s)->sb_c_bitmap & 0x0fffffff;\n\tint i, j;\n\t__le32 *bmp;\n\tstruct quad_buffer_head qbh;\n\tif ((bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\tfor (j = 0; j < 512; j++) {\n\t\t\tunsigned k;\n\t\t\tif (!le32_to_cpu(bmp[j])) continue;\n\t\t\tfor (k = le32_to_cpu(bmp[j]); k; k >>= 1) if (k & 1) if (!--n) {\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\ti = 0;\n\tif (hpfs_sb(s)->sb_c_bitmap != -1) {\n\t\tbmp = hpfs_map_bitmap(s, b, &qbh, \"chkdn1\");\n\t\tgoto chk_bmp;\n\t}\n\tchk_next:\n\tif (i == b) i++;\n\tif (i >= n_bmps) return 1;\n\tbmp = hpfs_map_bitmap(s, i, &qbh, \"chkdn2\");\n\tchk_bmp:\n\tif (bmp) {\n\t\tfor (j = 0; j < 512; j++) {\n\t\t\tu32 k;\n\t\t\tif (!le32_to_cpu(bmp[j])) continue;\n\t\t\tfor (k = 0xf; k; k <<= 4)\n\t\t\t\tif ((le32_to_cpu(bmp[j]) & k) == k) {\n\t\t\t\t\tif (!--n) {\n\t\t\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\thpfs_brelse4(&qbh);\n\t}\n\ti++;\n\tgoto chk_next;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "bmp[j]"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_bitmap",
          "args": [
            "s",
            "i",
            "&qbh",
            "\"chkdn2\""
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "16-34",
          "snippet": "__le32 *hpfs_map_bitmap(struct super_block *s, unsigned bmp_block,\n\t\t\t struct quad_buffer_head *qbh, char *id)\n{\n\tsecno sec;\n\t__le32 *ret;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (hpfs_sb(s)->sb_chk) if (bmp_block >= n_bands) {\n\t\thpfs_error(s, \"hpfs_map_bitmap called with bad parameter: %08x at %s\", bmp_block, id);\n\t\treturn NULL;\n\t}\n\tsec = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (!sec || sec > hpfs_sb(s)->sb_fs_size-4) {\n\t\thpfs_error(s, \"invalid bitmap block pointer %08x -> %08x at %s\", bmp_block, sec, id);\n\t\treturn NULL;\n\t}\n\tret = hpfs_map_4sectors(s, sec, qbh, 4);\n\tif (ret) hpfs_prefetch_bitmap(s, bmp_block + 1);\n\treturn ret;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\n__le32 *hpfs_map_bitmap(struct super_block *s, unsigned bmp_block,\n\t\t\t struct quad_buffer_head *qbh, char *id)\n{\n\tsecno sec;\n\t__le32 *ret;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (hpfs_sb(s)->sb_chk) if (bmp_block >= n_bands) {\n\t\thpfs_error(s, \"hpfs_map_bitmap called with bad parameter: %08x at %s\", bmp_block, id);\n\t\treturn NULL;\n\t}\n\tsec = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (!sec || sec > hpfs_sb(s)->sb_fs_size-4) {\n\t\thpfs_error(s, \"invalid bitmap block pointer %08x -> %08x at %s\", bmp_block, sec, id);\n\t\treturn NULL;\n\t}\n\tret = hpfs_map_4sectors(s, sec, qbh, 4);\n\tif (ret) hpfs_prefetch_bitmap(s, bmp_block + 1);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_dnode_bitmap",
          "args": [
            "s",
            "&qbh"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_dnode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "11-14",
          "snippet": "__le32 *hpfs_map_dnode_bitmap(struct super_block *s, struct quad_buffer_head *qbh)\n{\n\treturn hpfs_map_4sectors(s, hpfs_sb(s)->sb_dmap, qbh, 0);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\n__le32 *hpfs_map_dnode_bitmap(struct super_block *s, struct quad_buffer_head *qbh)\n{\n\treturn hpfs_map_4sectors(s, hpfs_sb(s)->sb_dmap, qbh, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_check_free_dnodes(struct super_block *s, int n)\n{\n\tint n_bmps = (hpfs_sb(s)->sb_fs_size + 0x4000 - 1) >> 14;\n\tint b = hpfs_sb(s)->sb_c_bitmap & 0x0fffffff;\n\tint i, j;\n\t__le32 *bmp;\n\tstruct quad_buffer_head qbh;\n\tif ((bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\tfor (j = 0; j < 512; j++) {\n\t\t\tunsigned k;\n\t\t\tif (!le32_to_cpu(bmp[j])) continue;\n\t\t\tfor (k = le32_to_cpu(bmp[j]); k; k >>= 1) if (k & 1) if (!--n) {\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\ti = 0;\n\tif (hpfs_sb(s)->sb_c_bitmap != -1) {\n\t\tbmp = hpfs_map_bitmap(s, b, &qbh, \"chkdn1\");\n\t\tgoto chk_bmp;\n\t}\n\tchk_next:\n\tif (i == b) i++;\n\tif (i >= n_bmps) return 1;\n\tbmp = hpfs_map_bitmap(s, i, &qbh, \"chkdn2\");\n\tchk_bmp:\n\tif (bmp) {\n\t\tfor (j = 0; j < 512; j++) {\n\t\t\tu32 k;\n\t\t\tif (!le32_to_cpu(bmp[j])) continue;\n\t\t\tfor (k = 0xf; k; k <<= 4)\n\t\t\t\tif ((le32_to_cpu(bmp[j]) & k) == k) {\n\t\t\t\t\tif (!--n) {\n\t\t\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\thpfs_brelse4(&qbh);\n\t}\n\ti++;\n\tgoto chk_next;\n}"
  },
  {
    "function_name": "hpfs_free_sectors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
    "lines": "314-350",
    "snippet": "void hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_mark_4buffers_dirty",
          "args": [
            "&qbh"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_mark_4buffers_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "192-204",
          "snippet": "void hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_claim_free",
          "args": [
            "s",
            "sec"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_claim_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "24-35",
          "snippet": "static void hpfs_claim_free(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free != (unsigned)-1) {\n\t\tif (unlikely(sbi->sb_n_free >= sbi->sb_fs_size)) {\n\t\t\thpfs_error(s, \"free count overflow, freeing sector %08x\", sec);\n\t\t\tsbi->sb_n_free = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free++;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void hpfs_claim_free(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free != (unsigned)-1) {\n\t\tif (unlikely(sbi->sb_n_free >= sbi->sb_fs_size)) {\n\t\t\thpfs_error(s, \"free count overflow, freeing sector %08x\", sec);\n\t\t\tsbi->sb_n_free = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1 << (sec & 0x1f)"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"sector %08x not allocated\"",
            "sec"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "bmp[(sec & 0x3fff) >> 5]"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_bitmap",
          "args": [
            "s",
            "sec >> 14",
            "&qbh",
            "\"free\""
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "16-34",
          "snippet": "__le32 *hpfs_map_bitmap(struct super_block *s, unsigned bmp_block,\n\t\t\t struct quad_buffer_head *qbh, char *id)\n{\n\tsecno sec;\n\t__le32 *ret;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (hpfs_sb(s)->sb_chk) if (bmp_block >= n_bands) {\n\t\thpfs_error(s, \"hpfs_map_bitmap called with bad parameter: %08x at %s\", bmp_block, id);\n\t\treturn NULL;\n\t}\n\tsec = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (!sec || sec > hpfs_sb(s)->sb_fs_size-4) {\n\t\thpfs_error(s, \"invalid bitmap block pointer %08x -> %08x at %s\", bmp_block, sec, id);\n\t\treturn NULL;\n\t}\n\tret = hpfs_map_4sectors(s, sec, qbh, 4);\n\tif (ret) hpfs_prefetch_bitmap(s, bmp_block + 1);\n\treturn ret;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\n__le32 *hpfs_map_bitmap(struct super_block *s, unsigned bmp_block,\n\t\t\t struct quad_buffer_head *qbh, char *id)\n{\n\tsecno sec;\n\t__le32 *ret;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (hpfs_sb(s)->sb_chk) if (bmp_block >= n_bands) {\n\t\thpfs_error(s, \"hpfs_map_bitmap called with bad parameter: %08x at %s\", bmp_block, id);\n\t\treturn NULL;\n\t}\n\tsec = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (!sec || sec > hpfs_sb(s)->sb_fs_size-4) {\n\t\thpfs_error(s, \"invalid bitmap block pointer %08x -> %08x at %s\", bmp_block, sec, id);\n\t\treturn NULL;\n\t}\n\tret = hpfs_map_4sectors(s, sec, qbh, 4);\n\tif (ret) hpfs_prefetch_bitmap(s, bmp_block + 1);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}"
  },
  {
    "function_name": "hpfs_alloc_if_possible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
    "lines": "295-310",
    "snippet": "int hpfs_alloc_if_possible(struct super_block *s, secno sec)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"aip\"))) goto end;\n\tif (le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) & (1 << (sec & 0x1f))) {\n\t\tbmp[(sec & 0x3fff) >> 5] &= cpu_to_le32(~(1 << (sec & 0x1f)));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_alloc(s, sec);\n\t\treturn 1;\n\t}\n\thpfs_brelse4(&qbh);\n\tend:\n\treturn 0;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_claim_alloc",
          "args": [
            "s",
            "sec"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_claim_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "11-22",
          "snippet": "static void hpfs_claim_alloc(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free != (unsigned)-1) {\n\t\tif (unlikely(!sbi->sb_n_free)) {\n\t\t\thpfs_error(s, \"free count underflow, allocating sector %08x\", sec);\n\t\t\tsbi->sb_n_free = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free--;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void hpfs_claim_alloc(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free != (unsigned)-1) {\n\t\tif (unlikely(!sbi->sb_n_free)) {\n\t\t\thpfs_error(s, \"free count underflow, allocating sector %08x\", sec);\n\t\t\tsbi->sb_n_free = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_mark_4buffers_dirty",
          "args": [
            "&qbh"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_mark_4buffers_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "192-204",
          "snippet": "void hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "~(1 << (sec & 0x1f))"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "bmp[(sec & 0x3fff) >> 5]"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_bitmap",
          "args": [
            "s",
            "sec >> 14",
            "&qbh",
            "\"aip\""
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "16-34",
          "snippet": "__le32 *hpfs_map_bitmap(struct super_block *s, unsigned bmp_block,\n\t\t\t struct quad_buffer_head *qbh, char *id)\n{\n\tsecno sec;\n\t__le32 *ret;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (hpfs_sb(s)->sb_chk) if (bmp_block >= n_bands) {\n\t\thpfs_error(s, \"hpfs_map_bitmap called with bad parameter: %08x at %s\", bmp_block, id);\n\t\treturn NULL;\n\t}\n\tsec = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (!sec || sec > hpfs_sb(s)->sb_fs_size-4) {\n\t\thpfs_error(s, \"invalid bitmap block pointer %08x -> %08x at %s\", bmp_block, sec, id);\n\t\treturn NULL;\n\t}\n\tret = hpfs_map_4sectors(s, sec, qbh, 4);\n\tif (ret) hpfs_prefetch_bitmap(s, bmp_block + 1);\n\treturn ret;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\n__le32 *hpfs_map_bitmap(struct super_block *s, unsigned bmp_block,\n\t\t\t struct quad_buffer_head *qbh, char *id)\n{\n\tsecno sec;\n\t__le32 *ret;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (hpfs_sb(s)->sb_chk) if (bmp_block >= n_bands) {\n\t\thpfs_error(s, \"hpfs_map_bitmap called with bad parameter: %08x at %s\", bmp_block, id);\n\t\treturn NULL;\n\t}\n\tsec = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (!sec || sec > hpfs_sb(s)->sb_fs_size-4) {\n\t\thpfs_error(s, \"invalid bitmap block pointer %08x -> %08x at %s\", bmp_block, sec, id);\n\t\treturn NULL;\n\t}\n\tret = hpfs_map_4sectors(s, sec, qbh, 4);\n\tif (ret) hpfs_prefetch_bitmap(s, bmp_block + 1);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_alloc_if_possible(struct super_block *s, secno sec)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"aip\"))) goto end;\n\tif (le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) & (1 << (sec & 0x1f))) {\n\t\tbmp[(sec & 0x3fff) >> 5] &= cpu_to_le32(~(1 << (sec & 0x1f)));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_alloc(s, sec);\n\t\treturn 1;\n\t}\n\thpfs_brelse4(&qbh);\n\tend:\n\treturn 0;\n}"
  },
  {
    "function_name": "alloc_in_dirband",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
    "lines": "276-291",
    "snippet": "static secno alloc_in_dirband(struct super_block *s, secno near)\n{\n\tunsigned nr = near;\n\tsecno sec;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (nr < sbi->sb_dirband_start)\n\t\tnr = sbi->sb_dirband_start;\n\tif (nr >= sbi->sb_dirband_start + sbi->sb_dirband_size)\n\t\tnr = sbi->sb_dirband_start + sbi->sb_dirband_size - 4;\n\tnr -= sbi->sb_dirband_start;\n\tnr >>= 2;\n\tsec = alloc_in_bmp(s, (~0x3fff) | nr, 1, 0);\n\tif (!sec) return 0;\n\thpfs_claim_dirband_alloc(s, sec);\n\treturn ((sec & 0x3fff) << 2) + sbi->sb_dirband_start;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_claim_dirband_alloc",
          "args": [
            "s",
            "sec"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_claim_dirband_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "37-48",
          "snippet": "static void hpfs_claim_dirband_alloc(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free_dnodes != (unsigned)-1) {\n\t\tif (unlikely(!sbi->sb_n_free_dnodes)) {\n\t\t\thpfs_error(s, \"dirband free count underflow, allocating sector %08x\", sec);\n\t\t\tsbi->sb_n_free_dnodes = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free_dnodes--;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void hpfs_claim_dirband_alloc(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free_dnodes != (unsigned)-1) {\n\t\tif (unlikely(!sbi->sb_n_free_dnodes)) {\n\t\t\thpfs_error(s, \"dirband free count underflow, allocating sector %08x\", sec);\n\t\t\tsbi->sb_n_free_dnodes = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free_dnodes--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_in_bmp",
          "args": [
            "s",
            "(~0x3fff) | nr",
            "1",
            "0"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_in_bmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "114-192",
          "snippet": "static secno alloc_in_bmp(struct super_block *s, secno near, unsigned n, unsigned forward)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tunsigned bs = near & ~0x3fff;\n\tunsigned nr = (near & 0x3fff) & ~(n - 1);\n\t/*unsigned mnr;*/\n\tunsigned i, q;\n\tint a, b;\n\tsecno ret = 0;\n\tif (n != 1 && n != 4) {\n\t\thpfs_error(s, \"Bad allocation size: %d\", n);\n\t\treturn 0;\n\t}\n\tif (bs != ~0x3fff) {\n\t\tif (!(bmp = hpfs_map_bitmap(s, near >> 14, &qbh, \"aib\"))) goto uls;\n\t} else {\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) goto uls;\n\t}\n\tif (!tstbits(bmp, nr, n + forward)) {\n\t\tret = bs + nr;\n\t\tgoto rt;\n\t}\n\tq = nr + n; b = 0;\n\twhile ((a = tstbits(bmp, q, n + forward)) != 0) {\n\t\tq += a;\n\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\tif (!b) {\n\t\t\tif (q>>5 != nr>>5) {\n\t\t\t\tb = 1;\n\t\t\t\tq = nr & 0x1f;\n\t\t\t}\n\t\t} else if (q > nr) break;\n\t}\n\tif (!a) {\n\t\tret = bs + q;\n\t\tgoto rt;\n\t}\n\tnr >>= 5;\n\t/*for (i = nr + 1; i != nr; i++, i &= 0x1ff) */\n\ti = nr;\n\tdo {\n\t\tif (!le32_to_cpu(bmp[i])) goto cont;\n\t\tif (n + forward >= 0x3f && le32_to_cpu(bmp[i]) != 0xffffffff) goto cont;\n\t\tq = i<<5;\n\t\tif (i > 0) {\n\t\t\tunsigned k = le32_to_cpu(bmp[i-1]);\n\t\t\twhile (k & 0x80000000) {\n\t\t\t\tq--; k <<= 1;\n\t\t\t}\n\t\t}\n\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\twhile ((a = tstbits(bmp, q, n + forward)) != 0) {\n\t\t\tq += a;\n\t\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\t\tif (q>>5 > i) break;\n\t\t}\n\t\tif (!a) {\n\t\t\tret = bs + q;\n\t\t\tgoto rt;\n\t\t}\n\t\tcont:\n\t\ti++, i &= 0x1ff;\n\t} while (i != nr);\n\trt:\n\tif (ret) {\n\t\tif (hpfs_sb(s)->sb_chk && ((ret >> 14) != (bs >> 14) || (le32_to_cpu(bmp[(ret & 0x3fff) >> 5]) | ~(((1 << n) - 1) << (ret & 0x1f))) != 0xffffffff)) {\n\t\t\thpfs_error(s, \"Allocation doesn't work! Wanted %d, allocated at %08x\", n, ret);\n\t\t\tret = 0;\n\t\t\tgoto b;\n\t\t}\n\t\tbmp[(ret & 0x3fff) >> 5] &= cpu_to_le32(~(((1 << n) - 1) << (ret & 0x1f)));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t}\n\tb:\n\thpfs_brelse4(&qbh);\n\tuls:\n\treturn ret;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic secno alloc_in_bmp(struct super_block *s, secno near, unsigned n, unsigned forward)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tunsigned bs = near & ~0x3fff;\n\tunsigned nr = (near & 0x3fff) & ~(n - 1);\n\t/*unsigned mnr;*/\n\tunsigned i, q;\n\tint a, b;\n\tsecno ret = 0;\n\tif (n != 1 && n != 4) {\n\t\thpfs_error(s, \"Bad allocation size: %d\", n);\n\t\treturn 0;\n\t}\n\tif (bs != ~0x3fff) {\n\t\tif (!(bmp = hpfs_map_bitmap(s, near >> 14, &qbh, \"aib\"))) goto uls;\n\t} else {\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) goto uls;\n\t}\n\tif (!tstbits(bmp, nr, n + forward)) {\n\t\tret = bs + nr;\n\t\tgoto rt;\n\t}\n\tq = nr + n; b = 0;\n\twhile ((a = tstbits(bmp, q, n + forward)) != 0) {\n\t\tq += a;\n\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\tif (!b) {\n\t\t\tif (q>>5 != nr>>5) {\n\t\t\t\tb = 1;\n\t\t\t\tq = nr & 0x1f;\n\t\t\t}\n\t\t} else if (q > nr) break;\n\t}\n\tif (!a) {\n\t\tret = bs + q;\n\t\tgoto rt;\n\t}\n\tnr >>= 5;\n\t/*for (i = nr + 1; i != nr; i++, i &= 0x1ff) */\n\ti = nr;\n\tdo {\n\t\tif (!le32_to_cpu(bmp[i])) goto cont;\n\t\tif (n + forward >= 0x3f && le32_to_cpu(bmp[i]) != 0xffffffff) goto cont;\n\t\tq = i<<5;\n\t\tif (i > 0) {\n\t\t\tunsigned k = le32_to_cpu(bmp[i-1]);\n\t\t\twhile (k & 0x80000000) {\n\t\t\t\tq--; k <<= 1;\n\t\t\t}\n\t\t}\n\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\twhile ((a = tstbits(bmp, q, n + forward)) != 0) {\n\t\t\tq += a;\n\t\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\t\tif (q>>5 > i) break;\n\t\t}\n\t\tif (!a) {\n\t\t\tret = bs + q;\n\t\t\tgoto rt;\n\t\t}\n\t\tcont:\n\t\ti++, i &= 0x1ff;\n\t} while (i != nr);\n\trt:\n\tif (ret) {\n\t\tif (hpfs_sb(s)->sb_chk && ((ret >> 14) != (bs >> 14) || (le32_to_cpu(bmp[(ret & 0x3fff) >> 5]) | ~(((1 << n) - 1) << (ret & 0x1f))) != 0xffffffff)) {\n\t\t\thpfs_error(s, \"Allocation doesn't work! Wanted %d, allocated at %08x\", n, ret);\n\t\t\tret = 0;\n\t\t\tgoto b;\n\t\t}\n\t\tbmp[(ret & 0x3fff) >> 5] &= cpu_to_le32(~(((1 << n) - 1) << (ret & 0x1f)));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t}\n\tb:\n\thpfs_brelse4(&qbh);\n\tuls:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic secno alloc_in_dirband(struct super_block *s, secno near)\n{\n\tunsigned nr = near;\n\tsecno sec;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (nr < sbi->sb_dirband_start)\n\t\tnr = sbi->sb_dirband_start;\n\tif (nr >= sbi->sb_dirband_start + sbi->sb_dirband_size)\n\t\tnr = sbi->sb_dirband_start + sbi->sb_dirband_size - 4;\n\tnr -= sbi->sb_dirband_start;\n\tnr >>= 2;\n\tsec = alloc_in_bmp(s, (~0x3fff) | nr, 1, 0);\n\tif (!sec) return 0;\n\thpfs_claim_dirband_alloc(s, sec);\n\treturn ((sec & 0x3fff) << 2) + sbi->sb_dirband_start;\n}"
  },
  {
    "function_name": "hpfs_alloc_sector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
    "lines": "202-274",
    "snippet": "secno hpfs_alloc_sector(struct super_block *s, secno near, unsigned n, int forward)\n{\n\tsecno sec;\n\tint i;\n\tunsigned n_bmps;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tint f_p = 0;\n\tint near_bmp;\n\tif (forward < 0) {\n\t\tforward = -forward;\n\t\tf_p = 1;\n\t}\n\tn_bmps = (sbi->sb_fs_size + 0x4000 - 1) >> 14;\n\tif (near && near < sbi->sb_fs_size) {\n\t\tif ((sec = alloc_in_bmp(s, near, n, f_p ? forward : forward/4))) goto ret;\n\t\tnear_bmp = near >> 14;\n\t} else near_bmp = n_bmps / 2;\n\t/*\n\tif (b != -1) {\n\t\tif ((sec = alloc_in_bmp(s, b<<14, n, f_p ? forward : forward/2))) {\n\t\t\tb &= 0x0fffffff;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (b > 0x10000000) if ((sec = alloc_in_bmp(s, (b&0xfffffff)<<14, n, f_p ? forward : 0))) goto ret;\n\t*/\n\tif (!f_p) if (forward > sbi->sb_max_fwd_alloc) forward = sbi->sb_max_fwd_alloc;\n\tless_fwd:\n\tfor (i = 0; i < n_bmps; i++) {\n\t\tif (near_bmp+i < n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i) << 14, n, forward)))) {\n\t\t\tsbi->sb_c_bitmap = near_bmp+i;\n\t\t\tgoto ret;\n\t\t}\t\n\t\tif (!forward) {\n\t\t\tif (near_bmp-i-1 >= 0 && ((sec = alloc_in_bmp(s, (near_bmp-i-1) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp-i-1;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t} else {\n\t\t\tif (near_bmp+i >= n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i-n_bmps) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp+i-n_bmps;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\tif (i == 1 && sbi->sb_c_bitmap != -1 && ((sec = alloc_in_bmp(s, (sbi->sb_c_bitmap) << 14, n, forward)))) {\n\t\t\tgoto ret;\n\t\t}\n\t}\n\tif (!f_p) {\n\t\tif (forward) {\n\t\t\tsbi->sb_max_fwd_alloc = forward * 3 / 4;\n\t\t\tforward /= 2;\n\t\t\tgoto less_fwd;\n\t\t}\n\t}\n\tsec = 0;\n\tret:\n\tif (sec) {\n\t\ti = 0;\n\t\tdo\n\t\t\thpfs_claim_alloc(s, sec + i);\n\t\twhile (unlikely(++i < n));\n\t}\n\tif (sec && f_p) {\n\t\tfor (i = 0; i < forward; i++) {\n\t\t\tif (!hpfs_alloc_if_possible(s, sec + n + i)) {\n\t\t\t\thpfs_error(s, \"Prealloc doesn't work! Wanted %d, allocated at %08x, can't allocate %d\", forward, sec, i);\n\t\t\t\tsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sec;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"Prealloc doesn't work! Wanted %d, allocated at %08x, can't allocate %d\"",
            "forward",
            "sec",
            "i"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_alloc_if_possible",
          "args": [
            "s",
            "sec + n + i"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_alloc_if_possible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "295-310",
          "snippet": "int hpfs_alloc_if_possible(struct super_block *s, secno sec)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"aip\"))) goto end;\n\tif (le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) & (1 << (sec & 0x1f))) {\n\t\tbmp[(sec & 0x3fff) >> 5] &= cpu_to_le32(~(1 << (sec & 0x1f)));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_alloc(s, sec);\n\t\treturn 1;\n\t}\n\thpfs_brelse4(&qbh);\n\tend:\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_alloc_if_possible(struct super_block *s, secno sec)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"aip\"))) goto end;\n\tif (le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) & (1 << (sec & 0x1f))) {\n\t\tbmp[(sec & 0x3fff) >> 5] &= cpu_to_le32(~(1 << (sec & 0x1f)));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_alloc(s, sec);\n\t\treturn 1;\n\t}\n\thpfs_brelse4(&qbh);\n\tend:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "++i < n"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_claim_alloc",
          "args": [
            "s",
            "sec + i"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_claim_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "11-22",
          "snippet": "static void hpfs_claim_alloc(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free != (unsigned)-1) {\n\t\tif (unlikely(!sbi->sb_n_free)) {\n\t\t\thpfs_error(s, \"free count underflow, allocating sector %08x\", sec);\n\t\t\tsbi->sb_n_free = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free--;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void hpfs_claim_alloc(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free != (unsigned)-1) {\n\t\tif (unlikely(!sbi->sb_n_free)) {\n\t\t\thpfs_error(s, \"free count underflow, allocating sector %08x\", sec);\n\t\t\tsbi->sb_n_free = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_in_bmp",
          "args": [
            "s",
            "(sbi->sb_c_bitmap) << 14",
            "n",
            "forward"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_in_bmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "114-192",
          "snippet": "static secno alloc_in_bmp(struct super_block *s, secno near, unsigned n, unsigned forward)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tunsigned bs = near & ~0x3fff;\n\tunsigned nr = (near & 0x3fff) & ~(n - 1);\n\t/*unsigned mnr;*/\n\tunsigned i, q;\n\tint a, b;\n\tsecno ret = 0;\n\tif (n != 1 && n != 4) {\n\t\thpfs_error(s, \"Bad allocation size: %d\", n);\n\t\treturn 0;\n\t}\n\tif (bs != ~0x3fff) {\n\t\tif (!(bmp = hpfs_map_bitmap(s, near >> 14, &qbh, \"aib\"))) goto uls;\n\t} else {\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) goto uls;\n\t}\n\tif (!tstbits(bmp, nr, n + forward)) {\n\t\tret = bs + nr;\n\t\tgoto rt;\n\t}\n\tq = nr + n; b = 0;\n\twhile ((a = tstbits(bmp, q, n + forward)) != 0) {\n\t\tq += a;\n\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\tif (!b) {\n\t\t\tif (q>>5 != nr>>5) {\n\t\t\t\tb = 1;\n\t\t\t\tq = nr & 0x1f;\n\t\t\t}\n\t\t} else if (q > nr) break;\n\t}\n\tif (!a) {\n\t\tret = bs + q;\n\t\tgoto rt;\n\t}\n\tnr >>= 5;\n\t/*for (i = nr + 1; i != nr; i++, i &= 0x1ff) */\n\ti = nr;\n\tdo {\n\t\tif (!le32_to_cpu(bmp[i])) goto cont;\n\t\tif (n + forward >= 0x3f && le32_to_cpu(bmp[i]) != 0xffffffff) goto cont;\n\t\tq = i<<5;\n\t\tif (i > 0) {\n\t\t\tunsigned k = le32_to_cpu(bmp[i-1]);\n\t\t\twhile (k & 0x80000000) {\n\t\t\t\tq--; k <<= 1;\n\t\t\t}\n\t\t}\n\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\twhile ((a = tstbits(bmp, q, n + forward)) != 0) {\n\t\t\tq += a;\n\t\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\t\tif (q>>5 > i) break;\n\t\t}\n\t\tif (!a) {\n\t\t\tret = bs + q;\n\t\t\tgoto rt;\n\t\t}\n\t\tcont:\n\t\ti++, i &= 0x1ff;\n\t} while (i != nr);\n\trt:\n\tif (ret) {\n\t\tif (hpfs_sb(s)->sb_chk && ((ret >> 14) != (bs >> 14) || (le32_to_cpu(bmp[(ret & 0x3fff) >> 5]) | ~(((1 << n) - 1) << (ret & 0x1f))) != 0xffffffff)) {\n\t\t\thpfs_error(s, \"Allocation doesn't work! Wanted %d, allocated at %08x\", n, ret);\n\t\t\tret = 0;\n\t\t\tgoto b;\n\t\t}\n\t\tbmp[(ret & 0x3fff) >> 5] &= cpu_to_le32(~(((1 << n) - 1) << (ret & 0x1f)));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t}\n\tb:\n\thpfs_brelse4(&qbh);\n\tuls:\n\treturn ret;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic secno alloc_in_bmp(struct super_block *s, secno near, unsigned n, unsigned forward)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tunsigned bs = near & ~0x3fff;\n\tunsigned nr = (near & 0x3fff) & ~(n - 1);\n\t/*unsigned mnr;*/\n\tunsigned i, q;\n\tint a, b;\n\tsecno ret = 0;\n\tif (n != 1 && n != 4) {\n\t\thpfs_error(s, \"Bad allocation size: %d\", n);\n\t\treturn 0;\n\t}\n\tif (bs != ~0x3fff) {\n\t\tif (!(bmp = hpfs_map_bitmap(s, near >> 14, &qbh, \"aib\"))) goto uls;\n\t} else {\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) goto uls;\n\t}\n\tif (!tstbits(bmp, nr, n + forward)) {\n\t\tret = bs + nr;\n\t\tgoto rt;\n\t}\n\tq = nr + n; b = 0;\n\twhile ((a = tstbits(bmp, q, n + forward)) != 0) {\n\t\tq += a;\n\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\tif (!b) {\n\t\t\tif (q>>5 != nr>>5) {\n\t\t\t\tb = 1;\n\t\t\t\tq = nr & 0x1f;\n\t\t\t}\n\t\t} else if (q > nr) break;\n\t}\n\tif (!a) {\n\t\tret = bs + q;\n\t\tgoto rt;\n\t}\n\tnr >>= 5;\n\t/*for (i = nr + 1; i != nr; i++, i &= 0x1ff) */\n\ti = nr;\n\tdo {\n\t\tif (!le32_to_cpu(bmp[i])) goto cont;\n\t\tif (n + forward >= 0x3f && le32_to_cpu(bmp[i]) != 0xffffffff) goto cont;\n\t\tq = i<<5;\n\t\tif (i > 0) {\n\t\t\tunsigned k = le32_to_cpu(bmp[i-1]);\n\t\t\twhile (k & 0x80000000) {\n\t\t\t\tq--; k <<= 1;\n\t\t\t}\n\t\t}\n\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\twhile ((a = tstbits(bmp, q, n + forward)) != 0) {\n\t\t\tq += a;\n\t\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\t\tif (q>>5 > i) break;\n\t\t}\n\t\tif (!a) {\n\t\t\tret = bs + q;\n\t\t\tgoto rt;\n\t\t}\n\t\tcont:\n\t\ti++, i &= 0x1ff;\n\t} while (i != nr);\n\trt:\n\tif (ret) {\n\t\tif (hpfs_sb(s)->sb_chk && ((ret >> 14) != (bs >> 14) || (le32_to_cpu(bmp[(ret & 0x3fff) >> 5]) | ~(((1 << n) - 1) << (ret & 0x1f))) != 0xffffffff)) {\n\t\t\thpfs_error(s, \"Allocation doesn't work! Wanted %d, allocated at %08x\", n, ret);\n\t\t\tret = 0;\n\t\t\tgoto b;\n\t\t}\n\t\tbmp[(ret & 0x3fff) >> 5] &= cpu_to_le32(~(((1 << n) - 1) << (ret & 0x1f)));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t}\n\tb:\n\thpfs_brelse4(&qbh);\n\tuls:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nsecno hpfs_alloc_sector(struct super_block *s, secno near, unsigned n, int forward)\n{\n\tsecno sec;\n\tint i;\n\tunsigned n_bmps;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tint f_p = 0;\n\tint near_bmp;\n\tif (forward < 0) {\n\t\tforward = -forward;\n\t\tf_p = 1;\n\t}\n\tn_bmps = (sbi->sb_fs_size + 0x4000 - 1) >> 14;\n\tif (near && near < sbi->sb_fs_size) {\n\t\tif ((sec = alloc_in_bmp(s, near, n, f_p ? forward : forward/4))) goto ret;\n\t\tnear_bmp = near >> 14;\n\t} else near_bmp = n_bmps / 2;\n\t/*\n\tif (b != -1) {\n\t\tif ((sec = alloc_in_bmp(s, b<<14, n, f_p ? forward : forward/2))) {\n\t\t\tb &= 0x0fffffff;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (b > 0x10000000) if ((sec = alloc_in_bmp(s, (b&0xfffffff)<<14, n, f_p ? forward : 0))) goto ret;\n\t*/\n\tif (!f_p) if (forward > sbi->sb_max_fwd_alloc) forward = sbi->sb_max_fwd_alloc;\n\tless_fwd:\n\tfor (i = 0; i < n_bmps; i++) {\n\t\tif (near_bmp+i < n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i) << 14, n, forward)))) {\n\t\t\tsbi->sb_c_bitmap = near_bmp+i;\n\t\t\tgoto ret;\n\t\t}\t\n\t\tif (!forward) {\n\t\t\tif (near_bmp-i-1 >= 0 && ((sec = alloc_in_bmp(s, (near_bmp-i-1) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp-i-1;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t} else {\n\t\t\tif (near_bmp+i >= n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i-n_bmps) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp+i-n_bmps;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\tif (i == 1 && sbi->sb_c_bitmap != -1 && ((sec = alloc_in_bmp(s, (sbi->sb_c_bitmap) << 14, n, forward)))) {\n\t\t\tgoto ret;\n\t\t}\n\t}\n\tif (!f_p) {\n\t\tif (forward) {\n\t\t\tsbi->sb_max_fwd_alloc = forward * 3 / 4;\n\t\t\tforward /= 2;\n\t\t\tgoto less_fwd;\n\t\t}\n\t}\n\tsec = 0;\n\tret:\n\tif (sec) {\n\t\ti = 0;\n\t\tdo\n\t\t\thpfs_claim_alloc(s, sec + i);\n\t\twhile (unlikely(++i < n));\n\t}\n\tif (sec && f_p) {\n\t\tfor (i = 0; i < forward; i++) {\n\t\t\tif (!hpfs_alloc_if_possible(s, sec + n + i)) {\n\t\t\t\thpfs_error(s, \"Prealloc doesn't work! Wanted %d, allocated at %08x, can't allocate %d\", forward, sec, i);\n\t\t\t\tsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sec;\n}"
  },
  {
    "function_name": "alloc_in_bmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
    "lines": "114-192",
    "snippet": "static secno alloc_in_bmp(struct super_block *s, secno near, unsigned n, unsigned forward)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tunsigned bs = near & ~0x3fff;\n\tunsigned nr = (near & 0x3fff) & ~(n - 1);\n\t/*unsigned mnr;*/\n\tunsigned i, q;\n\tint a, b;\n\tsecno ret = 0;\n\tif (n != 1 && n != 4) {\n\t\thpfs_error(s, \"Bad allocation size: %d\", n);\n\t\treturn 0;\n\t}\n\tif (bs != ~0x3fff) {\n\t\tif (!(bmp = hpfs_map_bitmap(s, near >> 14, &qbh, \"aib\"))) goto uls;\n\t} else {\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) goto uls;\n\t}\n\tif (!tstbits(bmp, nr, n + forward)) {\n\t\tret = bs + nr;\n\t\tgoto rt;\n\t}\n\tq = nr + n; b = 0;\n\twhile ((a = tstbits(bmp, q, n + forward)) != 0) {\n\t\tq += a;\n\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\tif (!b) {\n\t\t\tif (q>>5 != nr>>5) {\n\t\t\t\tb = 1;\n\t\t\t\tq = nr & 0x1f;\n\t\t\t}\n\t\t} else if (q > nr) break;\n\t}\n\tif (!a) {\n\t\tret = bs + q;\n\t\tgoto rt;\n\t}\n\tnr >>= 5;\n\t/*for (i = nr + 1; i != nr; i++, i &= 0x1ff) */\n\ti = nr;\n\tdo {\n\t\tif (!le32_to_cpu(bmp[i])) goto cont;\n\t\tif (n + forward >= 0x3f && le32_to_cpu(bmp[i]) != 0xffffffff) goto cont;\n\t\tq = i<<5;\n\t\tif (i > 0) {\n\t\t\tunsigned k = le32_to_cpu(bmp[i-1]);\n\t\t\twhile (k & 0x80000000) {\n\t\t\t\tq--; k <<= 1;\n\t\t\t}\n\t\t}\n\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\twhile ((a = tstbits(bmp, q, n + forward)) != 0) {\n\t\t\tq += a;\n\t\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\t\tif (q>>5 > i) break;\n\t\t}\n\t\tif (!a) {\n\t\t\tret = bs + q;\n\t\t\tgoto rt;\n\t\t}\n\t\tcont:\n\t\ti++, i &= 0x1ff;\n\t} while (i != nr);\n\trt:\n\tif (ret) {\n\t\tif (hpfs_sb(s)->sb_chk && ((ret >> 14) != (bs >> 14) || (le32_to_cpu(bmp[(ret & 0x3fff) >> 5]) | ~(((1 << n) - 1) << (ret & 0x1f))) != 0xffffffff)) {\n\t\t\thpfs_error(s, \"Allocation doesn't work! Wanted %d, allocated at %08x\", n, ret);\n\t\t\tret = 0;\n\t\t\tgoto b;\n\t\t}\n\t\tbmp[(ret & 0x3fff) >> 5] &= cpu_to_le32(~(((1 << n) - 1) << (ret & 0x1f)));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t}\n\tb:\n\thpfs_brelse4(&qbh);\n\tuls:\n\treturn ret;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_mark_4buffers_dirty",
          "args": [
            "&qbh"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_mark_4buffers_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "192-204",
          "snippet": "void hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "~(((1 << n) - 1) << (ret & 0x1f))"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"Allocation doesn't work! Wanted %d, allocated at %08x\"",
            "n",
            "ret"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "bmp[(ret & 0x3fff) >> 5]"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tstbits",
          "args": [
            "bmp",
            "q",
            "n + forward"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "tstbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "181-190",
          "snippet": "static inline unsigned tstbits(__le32 *bmp, unsigned b, unsigned n)\n{\n\tint i;\n\tif ((b >= 0x4000) || (b + n - 1 >= 0x4000)) return n;\n\tif (!((le32_to_cpu(bmp[(b & 0x3fff) >> 5]) >> (b & 0x1f)) & 1)) return 1;\n\tfor (i = 1; i < n; i++)\n\t\tif (!((le32_to_cpu(bmp[((b+i) & 0x3fff) >> 5]) >> ((b+i) & 0x1f)) & 1))\n\t\t\treturn i + 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__le32 *hpfs_load_bitmap_directory(struct super_block *, secno bmp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\n__le32 *hpfs_load_bitmap_directory(struct super_block *, secno bmp);\n\nstatic inline unsigned tstbits(__le32 *bmp, unsigned b, unsigned n)\n{\n\tint i;\n\tif ((b >= 0x4000) || (b + n - 1 >= 0x4000)) return n;\n\tif (!((le32_to_cpu(bmp[(b & 0x3fff) >> 5]) >> (b & 0x1f)) & 1)) return 1;\n\tfor (i = 1; i < n; i++)\n\t\tif (!((le32_to_cpu(bmp[((b+i) & 0x3fff) >> 5]) >> ((b+i) & 0x1f)) & 1))\n\t\t\treturn i + 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_dnode_bitmap",
          "args": [
            "s",
            "&qbh"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_dnode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "11-14",
          "snippet": "__le32 *hpfs_map_dnode_bitmap(struct super_block *s, struct quad_buffer_head *qbh)\n{\n\treturn hpfs_map_4sectors(s, hpfs_sb(s)->sb_dmap, qbh, 0);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\n__le32 *hpfs_map_dnode_bitmap(struct super_block *s, struct quad_buffer_head *qbh)\n{\n\treturn hpfs_map_4sectors(s, hpfs_sb(s)->sb_dmap, qbh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_bitmap",
          "args": [
            "s",
            "near >> 14",
            "&qbh",
            "\"aib\""
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "16-34",
          "snippet": "__le32 *hpfs_map_bitmap(struct super_block *s, unsigned bmp_block,\n\t\t\t struct quad_buffer_head *qbh, char *id)\n{\n\tsecno sec;\n\t__le32 *ret;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (hpfs_sb(s)->sb_chk) if (bmp_block >= n_bands) {\n\t\thpfs_error(s, \"hpfs_map_bitmap called with bad parameter: %08x at %s\", bmp_block, id);\n\t\treturn NULL;\n\t}\n\tsec = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (!sec || sec > hpfs_sb(s)->sb_fs_size-4) {\n\t\thpfs_error(s, \"invalid bitmap block pointer %08x -> %08x at %s\", bmp_block, sec, id);\n\t\treturn NULL;\n\t}\n\tret = hpfs_map_4sectors(s, sec, qbh, 4);\n\tif (ret) hpfs_prefetch_bitmap(s, bmp_block + 1);\n\treturn ret;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\n__le32 *hpfs_map_bitmap(struct super_block *s, unsigned bmp_block,\n\t\t\t struct quad_buffer_head *qbh, char *id)\n{\n\tsecno sec;\n\t__le32 *ret;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (hpfs_sb(s)->sb_chk) if (bmp_block >= n_bands) {\n\t\thpfs_error(s, \"hpfs_map_bitmap called with bad parameter: %08x at %s\", bmp_block, id);\n\t\treturn NULL;\n\t}\n\tsec = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (!sec || sec > hpfs_sb(s)->sb_fs_size-4) {\n\t\thpfs_error(s, \"invalid bitmap block pointer %08x -> %08x at %s\", bmp_block, sec, id);\n\t\treturn NULL;\n\t}\n\tret = hpfs_map_4sectors(s, sec, qbh, 4);\n\tif (ret) hpfs_prefetch_bitmap(s, bmp_block + 1);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic secno alloc_in_bmp(struct super_block *s, secno near, unsigned n, unsigned forward)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tunsigned bs = near & ~0x3fff;\n\tunsigned nr = (near & 0x3fff) & ~(n - 1);\n\t/*unsigned mnr;*/\n\tunsigned i, q;\n\tint a, b;\n\tsecno ret = 0;\n\tif (n != 1 && n != 4) {\n\t\thpfs_error(s, \"Bad allocation size: %d\", n);\n\t\treturn 0;\n\t}\n\tif (bs != ~0x3fff) {\n\t\tif (!(bmp = hpfs_map_bitmap(s, near >> 14, &qbh, \"aib\"))) goto uls;\n\t} else {\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) goto uls;\n\t}\n\tif (!tstbits(bmp, nr, n + forward)) {\n\t\tret = bs + nr;\n\t\tgoto rt;\n\t}\n\tq = nr + n; b = 0;\n\twhile ((a = tstbits(bmp, q, n + forward)) != 0) {\n\t\tq += a;\n\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\tif (!b) {\n\t\t\tif (q>>5 != nr>>5) {\n\t\t\t\tb = 1;\n\t\t\t\tq = nr & 0x1f;\n\t\t\t}\n\t\t} else if (q > nr) break;\n\t}\n\tif (!a) {\n\t\tret = bs + q;\n\t\tgoto rt;\n\t}\n\tnr >>= 5;\n\t/*for (i = nr + 1; i != nr; i++, i &= 0x1ff) */\n\ti = nr;\n\tdo {\n\t\tif (!le32_to_cpu(bmp[i])) goto cont;\n\t\tif (n + forward >= 0x3f && le32_to_cpu(bmp[i]) != 0xffffffff) goto cont;\n\t\tq = i<<5;\n\t\tif (i > 0) {\n\t\t\tunsigned k = le32_to_cpu(bmp[i-1]);\n\t\t\twhile (k & 0x80000000) {\n\t\t\t\tq--; k <<= 1;\n\t\t\t}\n\t\t}\n\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\twhile ((a = tstbits(bmp, q, n + forward)) != 0) {\n\t\t\tq += a;\n\t\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\t\tif (q>>5 > i) break;\n\t\t}\n\t\tif (!a) {\n\t\t\tret = bs + q;\n\t\t\tgoto rt;\n\t\t}\n\t\tcont:\n\t\ti++, i &= 0x1ff;\n\t} while (i != nr);\n\trt:\n\tif (ret) {\n\t\tif (hpfs_sb(s)->sb_chk && ((ret >> 14) != (bs >> 14) || (le32_to_cpu(bmp[(ret & 0x3fff) >> 5]) | ~(((1 << n) - 1) << (ret & 0x1f))) != 0xffffffff)) {\n\t\t\thpfs_error(s, \"Allocation doesn't work! Wanted %d, allocated at %08x\", n, ret);\n\t\t\tret = 0;\n\t\t\tgoto b;\n\t\t}\n\t\tbmp[(ret & 0x3fff) >> 5] &= cpu_to_le32(~(((1 << n) - 1) << (ret & 0x1f)));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t}\n\tb:\n\thpfs_brelse4(&qbh);\n\tuls:\n\treturn ret;\n}"
  },
  {
    "function_name": "hpfs_chk_sectors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
    "lines": "99-112",
    "snippet": "int hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chk_if_allocated",
          "args": [
            "s",
            "start + i",
            "msg"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "chk_if_allocated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "68-92",
          "snippet": "static int chk_if_allocated(struct super_block *s, secno sec, char *msg)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"chk\"))) goto fail;\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f)) & 1) {\n\t\thpfs_error(s, \"sector '%s' - %08x not allocated in bitmap\", msg, sec);\n\t\tgoto fail1;\n\t}\n\thpfs_brelse4(&qbh);\n\tif (sec >= hpfs_sb(s)->sb_dirband_start && sec < hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\tunsigned ssec = (sec - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) goto fail;\n\t\tif ((le32_to_cpu(bmp[ssec >> 5]) >> (ssec & 0x1f)) & 1) {\n\t\t\thpfs_error(s, \"sector '%s' - %08x not allocated in directory bitmap\", msg, sec);\n\t\t\tgoto fail1;\n\t\t}\n\t\thpfs_brelse4(&qbh);\n\t}\n\treturn 0;\n\tfail1:\n\thpfs_brelse4(&qbh);\n\tfail:\n\treturn 1;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic int chk_if_allocated(struct super_block *s, secno sec, char *msg)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"chk\"))) goto fail;\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f)) & 1) {\n\t\thpfs_error(s, \"sector '%s' - %08x not allocated in bitmap\", msg, sec);\n\t\tgoto fail1;\n\t}\n\thpfs_brelse4(&qbh);\n\tif (sec >= hpfs_sb(s)->sb_dirband_start && sec < hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\tunsigned ssec = (sec - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) goto fail;\n\t\tif ((le32_to_cpu(bmp[ssec >> 5]) >> (ssec & 0x1f)) & 1) {\n\t\t\thpfs_error(s, \"sector '%s' - %08x not allocated in directory bitmap\", msg, sec);\n\t\t\tgoto fail1;\n\t\t}\n\t\thpfs_brelse4(&qbh);\n\t}\n\treturn 0;\n\tfail1:\n\thpfs_brelse4(&qbh);\n\tfail:\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"sector(s) '%s' badly placed at %08x\"",
            "msg",
            "start"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "chk_if_allocated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
    "lines": "68-92",
    "snippet": "static int chk_if_allocated(struct super_block *s, secno sec, char *msg)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"chk\"))) goto fail;\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f)) & 1) {\n\t\thpfs_error(s, \"sector '%s' - %08x not allocated in bitmap\", msg, sec);\n\t\tgoto fail1;\n\t}\n\thpfs_brelse4(&qbh);\n\tif (sec >= hpfs_sb(s)->sb_dirband_start && sec < hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\tunsigned ssec = (sec - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) goto fail;\n\t\tif ((le32_to_cpu(bmp[ssec >> 5]) >> (ssec & 0x1f)) & 1) {\n\t\t\thpfs_error(s, \"sector '%s' - %08x not allocated in directory bitmap\", msg, sec);\n\t\t\tgoto fail1;\n\t\t}\n\t\thpfs_brelse4(&qbh);\n\t}\n\treturn 0;\n\tfail1:\n\thpfs_brelse4(&qbh);\n\tfail:\n\treturn 1;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"sector '%s' - %08x not allocated in directory bitmap\"",
            "msg",
            "sec"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "bmp[ssec >> 5]"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_dnode_bitmap",
          "args": [
            "s",
            "&qbh"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_dnode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "11-14",
          "snippet": "__le32 *hpfs_map_dnode_bitmap(struct super_block *s, struct quad_buffer_head *qbh)\n{\n\treturn hpfs_map_4sectors(s, hpfs_sb(s)->sb_dmap, qbh, 0);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\n__le32 *hpfs_map_dnode_bitmap(struct super_block *s, struct quad_buffer_head *qbh)\n{\n\treturn hpfs_map_4sectors(s, hpfs_sb(s)->sb_dmap, qbh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_bitmap",
          "args": [
            "s",
            "sec >> 14",
            "&qbh",
            "\"chk\""
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "16-34",
          "snippet": "__le32 *hpfs_map_bitmap(struct super_block *s, unsigned bmp_block,\n\t\t\t struct quad_buffer_head *qbh, char *id)\n{\n\tsecno sec;\n\t__le32 *ret;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (hpfs_sb(s)->sb_chk) if (bmp_block >= n_bands) {\n\t\thpfs_error(s, \"hpfs_map_bitmap called with bad parameter: %08x at %s\", bmp_block, id);\n\t\treturn NULL;\n\t}\n\tsec = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (!sec || sec > hpfs_sb(s)->sb_fs_size-4) {\n\t\thpfs_error(s, \"invalid bitmap block pointer %08x -> %08x at %s\", bmp_block, sec, id);\n\t\treturn NULL;\n\t}\n\tret = hpfs_map_4sectors(s, sec, qbh, 4);\n\tif (ret) hpfs_prefetch_bitmap(s, bmp_block + 1);\n\treturn ret;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\n__le32 *hpfs_map_bitmap(struct super_block *s, unsigned bmp_block,\n\t\t\t struct quad_buffer_head *qbh, char *id)\n{\n\tsecno sec;\n\t__le32 *ret;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (hpfs_sb(s)->sb_chk) if (bmp_block >= n_bands) {\n\t\thpfs_error(s, \"hpfs_map_bitmap called with bad parameter: %08x at %s\", bmp_block, id);\n\t\treturn NULL;\n\t}\n\tsec = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (!sec || sec > hpfs_sb(s)->sb_fs_size-4) {\n\t\thpfs_error(s, \"invalid bitmap block pointer %08x -> %08x at %s\", bmp_block, sec, id);\n\t\treturn NULL;\n\t}\n\tret = hpfs_map_4sectors(s, sec, qbh, 4);\n\tif (ret) hpfs_prefetch_bitmap(s, bmp_block + 1);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic int chk_if_allocated(struct super_block *s, secno sec, char *msg)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"chk\"))) goto fail;\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f)) & 1) {\n\t\thpfs_error(s, \"sector '%s' - %08x not allocated in bitmap\", msg, sec);\n\t\tgoto fail1;\n\t}\n\thpfs_brelse4(&qbh);\n\tif (sec >= hpfs_sb(s)->sb_dirband_start && sec < hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\tunsigned ssec = (sec - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) goto fail;\n\t\tif ((le32_to_cpu(bmp[ssec >> 5]) >> (ssec & 0x1f)) & 1) {\n\t\t\thpfs_error(s, \"sector '%s' - %08x not allocated in directory bitmap\", msg, sec);\n\t\t\tgoto fail1;\n\t\t}\n\t\thpfs_brelse4(&qbh);\n\t}\n\treturn 0;\n\tfail1:\n\thpfs_brelse4(&qbh);\n\tfail:\n\treturn 1;\n}"
  },
  {
    "function_name": "hpfs_claim_dirband_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
    "lines": "50-61",
    "snippet": "static void hpfs_claim_dirband_free(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free_dnodes != (unsigned)-1) {\n\t\tif (unlikely(sbi->sb_n_free_dnodes >= sbi->sb_dirband_size / 4)) {\n\t\t\thpfs_error(s, \"dirband free count overflow, freeing sector %08x\", sec);\n\t\t\tsbi->sb_n_free_dnodes = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free_dnodes++;\n\t}\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"dirband free count overflow, freeing sector %08x\"",
            "sec"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sbi->sb_n_free_dnodes >= sbi->sb_dirband_size / 4"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void hpfs_claim_dirband_free(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free_dnodes != (unsigned)-1) {\n\t\tif (unlikely(sbi->sb_n_free_dnodes >= sbi->sb_dirband_size / 4)) {\n\t\t\thpfs_error(s, \"dirband free count overflow, freeing sector %08x\", sec);\n\t\t\tsbi->sb_n_free_dnodes = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free_dnodes++;\n\t}\n}"
  },
  {
    "function_name": "hpfs_claim_dirband_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
    "lines": "37-48",
    "snippet": "static void hpfs_claim_dirband_alloc(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free_dnodes != (unsigned)-1) {\n\t\tif (unlikely(!sbi->sb_n_free_dnodes)) {\n\t\t\thpfs_error(s, \"dirband free count underflow, allocating sector %08x\", sec);\n\t\t\tsbi->sb_n_free_dnodes = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free_dnodes--;\n\t}\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"dirband free count underflow, allocating sector %08x\"",
            "sec"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!sbi->sb_n_free_dnodes"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void hpfs_claim_dirband_alloc(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free_dnodes != (unsigned)-1) {\n\t\tif (unlikely(!sbi->sb_n_free_dnodes)) {\n\t\t\thpfs_error(s, \"dirband free count underflow, allocating sector %08x\", sec);\n\t\t\tsbi->sb_n_free_dnodes = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free_dnodes--;\n\t}\n}"
  },
  {
    "function_name": "hpfs_claim_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
    "lines": "24-35",
    "snippet": "static void hpfs_claim_free(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free != (unsigned)-1) {\n\t\tif (unlikely(sbi->sb_n_free >= sbi->sb_fs_size)) {\n\t\t\thpfs_error(s, \"free count overflow, freeing sector %08x\", sec);\n\t\t\tsbi->sb_n_free = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free++;\n\t}\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"free count overflow, freeing sector %08x\"",
            "sec"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sbi->sb_n_free >= sbi->sb_fs_size"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void hpfs_claim_free(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free != (unsigned)-1) {\n\t\tif (unlikely(sbi->sb_n_free >= sbi->sb_fs_size)) {\n\t\t\thpfs_error(s, \"free count overflow, freeing sector %08x\", sec);\n\t\t\tsbi->sb_n_free = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free++;\n\t}\n}"
  },
  {
    "function_name": "hpfs_claim_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
    "lines": "11-22",
    "snippet": "static void hpfs_claim_alloc(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free != (unsigned)-1) {\n\t\tif (unlikely(!sbi->sb_n_free)) {\n\t\t\thpfs_error(s, \"free count underflow, allocating sector %08x\", sec);\n\t\t\tsbi->sb_n_free = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free--;\n\t}\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"free count underflow, allocating sector %08x\"",
            "sec"
          ],
          "line": 16
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!sbi->sb_n_free"
          ],
          "line": 15
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 13
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void hpfs_claim_alloc(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free != (unsigned)-1) {\n\t\tif (unlikely(!sbi->sb_n_free)) {\n\t\t\thpfs_error(s, \"free count underflow, allocating sector %08x\", sec);\n\t\t\tsbi->sb_n_free = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free--;\n\t}\n}"
  }
]