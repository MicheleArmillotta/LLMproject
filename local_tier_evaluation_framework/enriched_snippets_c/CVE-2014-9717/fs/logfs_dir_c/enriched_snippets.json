[
  {
    "function_name": "logfs_replay_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "729-777",
    "snippet": "int logfs_replay_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tu64 ino, pos;\n\tint err;\n\n\tif (super->s_victim_ino) {\n\t\t/* delete victim inode */\n\t\tino = super->s_victim_ino;\n\t\tprintk(KERN_INFO\"LogFS: delete unmapped inode #%llx\\n\", ino);\n\t\tinode = logfs_iget(sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\tgoto fail;\n\n\t\tLOGFS_BUG_ON(i_size_read(inode) > 0, sb);\n\t\tsuper->s_victim_ino = 0;\n\t\terr = logfs_remove_inode(inode);\n\t\tiput(inode);\n\t\tif (err) {\n\t\t\tsuper->s_victim_ino = ino;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (super->s_rename_dir) {\n\t\t/* delete old dd from rename */\n\t\tino = super->s_rename_dir;\n\t\tpos = super->s_rename_pos;\n\t\tprintk(KERN_INFO\"LogFS: delete unbacked dentry (%llx, %llx)\\n\",\n\t\t\t\tino, pos);\n\t\tinode = logfs_iget(sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\tgoto fail;\n\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\terr = logfs_delete_dd(inode, pos);\n\t\tiput(inode);\n\t\tif (err) {\n\t\t\tsuper->s_rename_dir = ino;\n\t\t\tsuper->s_rename_pos = pos;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn 0;\nfail:\n\tLOGFS_BUG(sb);\n\treturn -EIO;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOGFS_BUG",
          "args": [
            "sb"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_delete_dd",
          "args": [
            "inode",
            "pos"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_delete_dd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "567-578",
          "snippet": "static int logfs_delete_dd(struct inode *dir, loff_t pos)\n{\n\t/*\n\t * Getting called with pos somewhere beyond eof is either a goofup\n\t * within this file or means someone maliciously edited the\n\t * (crc-protected) journal.\n\t */\n\tBUG_ON(beyond_eof(dir, pos));\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tlog_dir(\" Delete dentry (%lx, %llx)\\n\", dir->i_ino, pos);\n\treturn logfs_delete(dir, pos, NULL);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_delete_dd(struct inode *dir, loff_t pos)\n{\n\t/*\n\t * Getting called with pos somewhere beyond eof is either a goofup\n\t * within this file or means someone maliciously edited the\n\t * (crc-protected) journal.\n\t */\n\tBUG_ON(beyond_eof(dir, pos));\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tlog_dir(\" Delete dentry (%lx, %llx)\\n\", dir->i_ino, pos);\n\treturn logfs_delete(dir, pos, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_iget",
          "args": [
            "sb",
            "ino"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "109-114",
          "snippet": "struct inode *logfs_iget(struct super_block *sb, ino_t ino)\n{\n\tBUG_ON(ino == LOGFS_INO_MASTER);\n\tBUG_ON(ino == LOGFS_INO_SEGFILE);\n\treturn __logfs_iget(sb, ino);\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstruct inode *logfs_iget(struct super_block *sb, ino_t ino)\n{\n\tBUG_ON(ino == LOGFS_INO_MASTER);\n\tBUG_ON(ino == LOGFS_INO_SEGFILE);\n\treturn __logfs_iget(sb, ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\"LogFS: delete unbacked dentry (%llx, %llx)\\n\"",
            "ino",
            "pos"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_remove_inode",
          "args": [
            "inode"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_remove_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "196-204",
          "snippet": "static int logfs_remove_inode(struct inode *inode)\n{\n\tint ret;\n\n\tdrop_nlink(inode);\n\tret = write_inode(inode);\n\tLOGFS_BUG_ON(ret, inode->i_sb);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_remove_inode(struct inode *inode)\n{\n\tint ret;\n\n\tdrop_nlink(inode);\n\tret = write_inode(inode);\n\tLOGFS_BUG_ON(ret, inode->i_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGFS_BUG_ON",
          "args": [
            "i_size_read(inode) > 0",
            "sb"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_replay_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tu64 ino, pos;\n\tint err;\n\n\tif (super->s_victim_ino) {\n\t\t/* delete victim inode */\n\t\tino = super->s_victim_ino;\n\t\tprintk(KERN_INFO\"LogFS: delete unmapped inode #%llx\\n\", ino);\n\t\tinode = logfs_iget(sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\tgoto fail;\n\n\t\tLOGFS_BUG_ON(i_size_read(inode) > 0, sb);\n\t\tsuper->s_victim_ino = 0;\n\t\terr = logfs_remove_inode(inode);\n\t\tiput(inode);\n\t\tif (err) {\n\t\t\tsuper->s_victim_ino = ino;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (super->s_rename_dir) {\n\t\t/* delete old dd from rename */\n\t\tino = super->s_rename_dir;\n\t\tpos = super->s_rename_pos;\n\t\tprintk(KERN_INFO\"LogFS: delete unbacked dentry (%llx, %llx)\\n\",\n\t\t\t\tino, pos);\n\t\tinode = logfs_iget(sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\tgoto fail;\n\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\terr = logfs_delete_dd(inode, pos);\n\t\tiput(inode);\n\t\tif (err) {\n\t\t\tsuper->s_rename_dir = ino;\n\t\t\tsuper->s_rename_pos = pos;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn 0;\nfail:\n\tLOGFS_BUG(sb);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "logfs_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "719-726",
    "snippet": "static int logfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tif (new_dentry->d_inode)\n\t\treturn logfs_rename_target(old_dir, old_dentry,\n\t\t\t\t\t   new_dir, new_dentry);\n\treturn logfs_rename_cross(old_dir, old_dentry, new_dir, new_dentry);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_rename_cross",
          "args": [
            "old_dir",
            "old_dentry",
            "new_dir",
            "new_dentry"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_rename_cross",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "585-631",
          "snippet": "static int logfs_rename_cross(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t      struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct logfs_super *super = logfs_super(old_dir->i_sb);\n\tstruct logfs_disk_dentry dd;\n\tstruct logfs_transaction *ta;\n\tloff_t pos;\n\tint err;\n\n\t/* 1. locate source dd */\n\terr = logfs_get_dd(old_dir, old_dentry, &dd, &pos);\n\tif (err)\n\t\treturn err;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta)\n\t\treturn -ENOMEM;\n\n\tta->state = CROSS_RENAME_1;\n\tta->dir = old_dir->i_ino;\n\tta->pos = pos;\n\n\t/* 2. write target dd */\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(new_dir, ta);\n\terr = logfs_write_dir(new_dir, new_dentry, old_dentry->d_inode);\n\tif (!err)\n\t\terr = write_inode(new_dir);\n\n\tif (err) {\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\tabort_transaction(new_dir, ta);\n\t\tgoto out;\n\t}\n\n\t/* 3. remove source dd */\n\tta->state = CROSS_RENAME_2;\n\tlogfs_add_transaction(old_dir, ta);\n\terr = logfs_delete_dd(old_dir, pos);\n\tif (!err)\n\t\terr = write_inode(old_dir);\n\tLOGFS_BUG_ON(err, old_dir->i_sb);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_rename_cross(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t      struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct logfs_super *super = logfs_super(old_dir->i_sb);\n\tstruct logfs_disk_dentry dd;\n\tstruct logfs_transaction *ta;\n\tloff_t pos;\n\tint err;\n\n\t/* 1. locate source dd */\n\terr = logfs_get_dd(old_dir, old_dentry, &dd, &pos);\n\tif (err)\n\t\treturn err;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta)\n\t\treturn -ENOMEM;\n\n\tta->state = CROSS_RENAME_1;\n\tta->dir = old_dir->i_ino;\n\tta->pos = pos;\n\n\t/* 2. write target dd */\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(new_dir, ta);\n\terr = logfs_write_dir(new_dir, new_dentry, old_dentry->d_inode);\n\tif (!err)\n\t\terr = write_inode(new_dir);\n\n\tif (err) {\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\tabort_transaction(new_dir, ta);\n\t\tgoto out;\n\t}\n\n\t/* 3. remove source dd */\n\tta->state = CROSS_RENAME_2;\n\tlogfs_add_transaction(old_dir, ta);\n\terr = logfs_delete_dd(old_dir, pos);\n\tif (!err)\n\t\terr = write_inode(old_dir);\n\tLOGFS_BUG_ON(err, old_dir->i_sb);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_rename_target",
          "args": [
            "old_dir",
            "old_dentry",
            "new_dir",
            "new_dentry"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_rename_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "657-717",
          "snippet": "static int logfs_rename_target(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t       struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct logfs_super *super = logfs_super(old_dir->i_sb);\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tint isdir = S_ISDIR(old_inode->i_mode);\n\tstruct logfs_disk_dentry dd;\n\tstruct logfs_transaction *ta;\n\tloff_t pos;\n\tint err;\n\n\tBUG_ON(isdir != S_ISDIR(new_inode->i_mode));\n\tif (isdir) {\n\t\tif (!logfs_empty_dir(new_inode))\n\t\t\treturn -ENOTEMPTY;\n\t}\n\n\t/* 1. locate source dd */\n\terr = logfs_get_dd(old_dir, old_dentry, &dd, &pos);\n\tif (err)\n\t\treturn err;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta)\n\t\treturn -ENOMEM;\n\n\tta->state = TARGET_RENAME_1;\n\tta->dir = old_dir->i_ino;\n\tta->pos = pos;\n\tta->ino = new_inode->i_ino;\n\n\t/* 2. attach source inode to target dd */\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(new_dir, ta);\n\terr = logfs_replace_inode(new_dir, new_dentry, &dd, old_inode);\n\tif (err) {\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\tsuper->s_victim_ino = 0;\n\t\tabort_transaction(new_dir, ta);\n\t\tgoto out;\n\t}\n\n\t/* 3. remove source dd */\n\tta->state = TARGET_RENAME_2;\n\tlogfs_add_transaction(old_dir, ta);\n\terr = logfs_delete_dd(old_dir, pos);\n\tif (!err)\n\t\terr = write_inode(old_dir);\n\tLOGFS_BUG_ON(err, old_dir->i_sb);\n\n\t/* 4. remove target inode */\n\tta->state = TARGET_RENAME_3;\n\tlogfs_add_transaction(new_inode, ta);\n\terr = logfs_remove_inode(new_inode);\n\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_rename_target(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t       struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct logfs_super *super = logfs_super(old_dir->i_sb);\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tint isdir = S_ISDIR(old_inode->i_mode);\n\tstruct logfs_disk_dentry dd;\n\tstruct logfs_transaction *ta;\n\tloff_t pos;\n\tint err;\n\n\tBUG_ON(isdir != S_ISDIR(new_inode->i_mode));\n\tif (isdir) {\n\t\tif (!logfs_empty_dir(new_inode))\n\t\t\treturn -ENOTEMPTY;\n\t}\n\n\t/* 1. locate source dd */\n\terr = logfs_get_dd(old_dir, old_dentry, &dd, &pos);\n\tif (err)\n\t\treturn err;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta)\n\t\treturn -ENOMEM;\n\n\tta->state = TARGET_RENAME_1;\n\tta->dir = old_dir->i_ino;\n\tta->pos = pos;\n\tta->ino = new_inode->i_ino;\n\n\t/* 2. attach source inode to target dd */\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(new_dir, ta);\n\terr = logfs_replace_inode(new_dir, new_dentry, &dd, old_inode);\n\tif (err) {\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\tsuper->s_victim_ino = 0;\n\t\tabort_transaction(new_dir, ta);\n\t\tgoto out;\n\t}\n\n\t/* 3. remove source dd */\n\tta->state = TARGET_RENAME_2;\n\tlogfs_add_transaction(old_dir, ta);\n\terr = logfs_delete_dd(old_dir, pos);\n\tif (!err)\n\t\terr = write_inode(old_dir);\n\tLOGFS_BUG_ON(err, old_dir->i_sb);\n\n\t/* 4. remove target inode */\n\tta->state = TARGET_RENAME_3;\n\tlogfs_add_transaction(new_inode, ta);\n\terr = logfs_remove_inode(new_inode);\n\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tif (new_dentry->d_inode)\n\t\treturn logfs_rename_target(old_dir, old_dentry,\n\t\t\t\t\t   new_dir, new_dentry);\n\treturn logfs_rename_cross(old_dir, old_dentry, new_dir, new_dentry);\n}"
  },
  {
    "function_name": "logfs_rename_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "657-717",
    "snippet": "static int logfs_rename_target(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t       struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct logfs_super *super = logfs_super(old_dir->i_sb);\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tint isdir = S_ISDIR(old_inode->i_mode);\n\tstruct logfs_disk_dentry dd;\n\tstruct logfs_transaction *ta;\n\tloff_t pos;\n\tint err;\n\n\tBUG_ON(isdir != S_ISDIR(new_inode->i_mode));\n\tif (isdir) {\n\t\tif (!logfs_empty_dir(new_inode))\n\t\t\treturn -ENOTEMPTY;\n\t}\n\n\t/* 1. locate source dd */\n\terr = logfs_get_dd(old_dir, old_dentry, &dd, &pos);\n\tif (err)\n\t\treturn err;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta)\n\t\treturn -ENOMEM;\n\n\tta->state = TARGET_RENAME_1;\n\tta->dir = old_dir->i_ino;\n\tta->pos = pos;\n\tta->ino = new_inode->i_ino;\n\n\t/* 2. attach source inode to target dd */\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(new_dir, ta);\n\terr = logfs_replace_inode(new_dir, new_dentry, &dd, old_inode);\n\tif (err) {\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\tsuper->s_victim_ino = 0;\n\t\tabort_transaction(new_dir, ta);\n\t\tgoto out;\n\t}\n\n\t/* 3. remove source dd */\n\tta->state = TARGET_RENAME_2;\n\tlogfs_add_transaction(old_dir, ta);\n\terr = logfs_delete_dd(old_dir, pos);\n\tif (!err)\n\t\terr = write_inode(old_dir);\n\tLOGFS_BUG_ON(err, old_dir->i_sb);\n\n\t/* 4. remove target inode */\n\tta->state = TARGET_RENAME_3;\n\tlogfs_add_transaction(new_inode, ta);\n\terr = logfs_remove_inode(new_inode);\n\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&super->s_dirop_mutex"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_remove_inode",
          "args": [
            "new_inode"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_remove_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "196-204",
          "snippet": "static int logfs_remove_inode(struct inode *inode)\n{\n\tint ret;\n\n\tdrop_nlink(inode);\n\tret = write_inode(inode);\n\tLOGFS_BUG_ON(ret, inode->i_sb);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_remove_inode(struct inode *inode)\n{\n\tint ret;\n\n\tdrop_nlink(inode);\n\tret = write_inode(inode);\n\tLOGFS_BUG_ON(ret, inode->i_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_add_transaction",
          "args": [
            "new_inode",
            "ta"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_add_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1495-1499",
          "snippet": "void logfs_add_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\talloc_inode_block(inode);\n\tlogfs_inode(inode)->li_block->ta = ta;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_add_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\talloc_inode_block(inode);\n\tlogfs_inode(inode)->li_block->ta = ta;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGFS_BUG_ON",
          "args": [
            "err",
            "old_dir->i_sb"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_inode",
          "args": [
            "old_dir"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "72-75",
          "snippet": "static int write_inode(struct inode *inode)\n{\n\treturn __logfs_write_inode(inode, NULL, WF_LOCK);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int write_inode(struct inode *inode)\n{\n\treturn __logfs_write_inode(inode, NULL, WF_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_delete_dd",
          "args": [
            "old_dir",
            "pos"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_delete_dd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "567-578",
          "snippet": "static int logfs_delete_dd(struct inode *dir, loff_t pos)\n{\n\t/*\n\t * Getting called with pos somewhere beyond eof is either a goofup\n\t * within this file or means someone maliciously edited the\n\t * (crc-protected) journal.\n\t */\n\tBUG_ON(beyond_eof(dir, pos));\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tlog_dir(\" Delete dentry (%lx, %llx)\\n\", dir->i_ino, pos);\n\treturn logfs_delete(dir, pos, NULL);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_delete_dd(struct inode *dir, loff_t pos)\n{\n\t/*\n\t * Getting called with pos somewhere beyond eof is either a goofup\n\t * within this file or means someone maliciously edited the\n\t * (crc-protected) journal.\n\t */\n\tBUG_ON(beyond_eof(dir, pos));\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tlog_dir(\" Delete dentry (%lx, %llx)\\n\", dir->i_ino, pos);\n\treturn logfs_delete(dir, pos, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "abort_transaction",
          "args": [
            "new_dir",
            "ta"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "abort_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "206-211",
          "snippet": "static void abort_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\tif (logfs_inode(inode)->li_block)\n\t\tlogfs_inode(inode)->li_block->ta = NULL;\n\tkfree(ta);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void abort_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\tif (logfs_inode(inode)->li_block)\n\t\tlogfs_inode(inode)->li_block->ta = NULL;\n\tkfree(ta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_replace_inode",
          "args": [
            "new_dir",
            "new_dentry",
            "&dd",
            "old_inode"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_replace_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "633-651",
          "snippet": "static int logfs_replace_inode(struct inode *dir, struct dentry *dentry,\n\t\tstruct logfs_disk_dentry *dd, struct inode *inode)\n{\n\tloff_t pos;\n\tint err;\n\n\terr = logfs_get_dd(dir, dentry, dd, &pos);\n\tif (err)\n\t\treturn err;\n\tdd->ino = cpu_to_be64(inode->i_ino);\n\tdd->type = logfs_type(inode);\n\n\terr = write_dir(dir, dd, pos);\n\tif (err)\n\t\treturn err;\n\tlog_dir(\"Replace dentry (%lx, %llx) %s -> %llx\\n\", dir->i_ino, pos,\n\t\t\tdd->name, be64_to_cpu(dd->ino));\n\treturn write_inode(dir);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_replace_inode(struct inode *dir, struct dentry *dentry,\n\t\tstruct logfs_disk_dentry *dd, struct inode *inode)\n{\n\tloff_t pos;\n\tint err;\n\n\terr = logfs_get_dd(dir, dentry, dd, &pos);\n\tif (err)\n\t\treturn err;\n\tdd->ino = cpu_to_be64(inode->i_ino);\n\tdd->type = logfs_type(inode);\n\n\terr = write_dir(dir, dd, pos);\n\tif (err)\n\t\treturn err;\n\tlog_dir(\"Replace dentry (%lx, %llx) %s -> %llx\\n\", dir->i_ino, pos,\n\t\t\tdd->name, be64_to_cpu(dd->ino));\n\treturn write_inode(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&super->s_dirop_mutex"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ta)",
            "GFP_KERNEL"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_dd",
          "args": [
            "old_dir",
            "old_dentry",
            "&dd",
            "&pos"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_dd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "550-565",
          "snippet": "static int logfs_get_dd(struct inode *dir, struct dentry *dentry,\n\t\tstruct logfs_disk_dentry *dd, loff_t *pos)\n{\n\tstruct page *page;\n\tvoid *map;\n\n\tpage = logfs_get_dd_page(dir, dentry);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\t*pos = page->index;\n\tmap = kmap_atomic(page);\n\tmemcpy(dd, map, sizeof(*dd));\n\tkunmap_atomic(map);\n\tpage_cache_release(page);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_get_dd(struct inode *dir, struct dentry *dentry,\n\t\tstruct logfs_disk_dentry *dd, loff_t *pos)\n{\n\tstruct page *page;\n\tvoid *map;\n\n\tpage = logfs_get_dd_page(dir, dentry);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\t*pos = page->index;\n\tmap = kmap_atomic(page);\n\tmemcpy(dd, map, sizeof(*dd));\n\tkunmap_atomic(map);\n\tpage_cache_release(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_empty_dir",
          "args": [
            "new_inode"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "264-270",
          "snippet": "static inline int logfs_empty_dir(struct inode *dir)\n{\n\tu64 data;\n\n\tdata = logfs_seek_data(dir, 0) << dir->i_sb->s_blocksize_bits;\n\treturn data >= i_size_read(dir);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic inline int logfs_empty_dir(struct inode *dir)\n{\n\tu64 data;\n\n\tdata = logfs_seek_data(dir, 0) << dir->i_sb->s_blocksize_bits;\n\treturn data >= i_size_read(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "isdir != S_ISDIR(new_inode->i_mode)"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "new_inode->i_mode"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode->i_mode"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "old_dir->i_sb"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_rename_target(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t       struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct logfs_super *super = logfs_super(old_dir->i_sb);\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tint isdir = S_ISDIR(old_inode->i_mode);\n\tstruct logfs_disk_dentry dd;\n\tstruct logfs_transaction *ta;\n\tloff_t pos;\n\tint err;\n\n\tBUG_ON(isdir != S_ISDIR(new_inode->i_mode));\n\tif (isdir) {\n\t\tif (!logfs_empty_dir(new_inode))\n\t\t\treturn -ENOTEMPTY;\n\t}\n\n\t/* 1. locate source dd */\n\terr = logfs_get_dd(old_dir, old_dentry, &dd, &pos);\n\tif (err)\n\t\treturn err;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta)\n\t\treturn -ENOMEM;\n\n\tta->state = TARGET_RENAME_1;\n\tta->dir = old_dir->i_ino;\n\tta->pos = pos;\n\tta->ino = new_inode->i_ino;\n\n\t/* 2. attach source inode to target dd */\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(new_dir, ta);\n\terr = logfs_replace_inode(new_dir, new_dentry, &dd, old_inode);\n\tif (err) {\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\tsuper->s_victim_ino = 0;\n\t\tabort_transaction(new_dir, ta);\n\t\tgoto out;\n\t}\n\n\t/* 3. remove source dd */\n\tta->state = TARGET_RENAME_2;\n\tlogfs_add_transaction(old_dir, ta);\n\terr = logfs_delete_dd(old_dir, pos);\n\tif (!err)\n\t\terr = write_inode(old_dir);\n\tLOGFS_BUG_ON(err, old_dir->i_sb);\n\n\t/* 4. remove target inode */\n\tta->state = TARGET_RENAME_3;\n\tlogfs_add_transaction(new_inode, ta);\n\terr = logfs_remove_inode(new_inode);\n\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "logfs_replace_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "633-651",
    "snippet": "static int logfs_replace_inode(struct inode *dir, struct dentry *dentry,\n\t\tstruct logfs_disk_dentry *dd, struct inode *inode)\n{\n\tloff_t pos;\n\tint err;\n\n\terr = logfs_get_dd(dir, dentry, dd, &pos);\n\tif (err)\n\t\treturn err;\n\tdd->ino = cpu_to_be64(inode->i_ino);\n\tdd->type = logfs_type(inode);\n\n\terr = write_dir(dir, dd, pos);\n\tif (err)\n\t\treturn err;\n\tlog_dir(\"Replace dentry (%lx, %llx) %s -> %llx\\n\", dir->i_ino, pos,\n\t\t\tdd->name, be64_to_cpu(dd->ino));\n\treturn write_inode(dir);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_inode",
          "args": [
            "dir"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "72-75",
          "snippet": "static int write_inode(struct inode *inode)\n{\n\treturn __logfs_write_inode(inode, NULL, WF_LOCK);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int write_inode(struct inode *inode)\n{\n\treturn __logfs_write_inode(inode, NULL, WF_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_dir",
          "args": [
            "\"Replace dentry (%lx, %llx) %s -> %llx\\n\"",
            "dir->i_ino",
            "pos",
            "dd->name",
            "be64_to_cpu(dd->ino)"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "log_directory_changes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "3175-3204",
          "snippet": "static noinline int log_directory_changes(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct inode *inode,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_path *dst_path)\n{\n\tu64 min_key;\n\tu64 max_key;\n\tint ret;\n\tint key_type = BTRFS_DIR_ITEM_KEY;\n\nagain:\n\tmin_key = 0;\n\tmax_key = 0;\n\twhile (1) {\n\t\tret = log_dir_items(trans, root, inode, path,\n\t\t\t\t    dst_path, key_type, min_key,\n\t\t\t\t    &max_key);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (max_key == (u64)-1)\n\t\t\tbreak;\n\t\tmin_key = max_key + 1;\n\t}\n\n\tif (key_type == BTRFS_DIR_ITEM_KEY) {\n\t\tkey_type = BTRFS_DIR_INDEX_KEY;\n\t\tgoto again;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int log_directory_changes(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct inode *inode,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_path *dst_path)\n{\n\tu64 min_key;\n\tu64 max_key;\n\tint ret;\n\tint key_type = BTRFS_DIR_ITEM_KEY;\n\nagain:\n\tmin_key = 0;\n\tmax_key = 0;\n\twhile (1) {\n\t\tret = log_dir_items(trans, root, inode, path,\n\t\t\t\t    dst_path, key_type, min_key,\n\t\t\t\t    &max_key);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (max_key == (u64)-1)\n\t\t\tbreak;\n\t\tmin_key = max_key + 1;\n\t}\n\n\tif (key_type == BTRFS_DIR_ITEM_KEY) {\n\t\tkey_type = BTRFS_DIR_INDEX_KEY;\n\t\tgoto again;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dd->ino"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_dir",
          "args": [
            "dir",
            "dd",
            "pos"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "368-405",
          "snippet": "static int logfs_write_dir(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode)\n{\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\tu32 hash = hash_32(dentry->d_name.name, dentry->d_name.len, 0);\n\tpgoff_t index;\n\tint round, err;\n\n\tfor (round = 0; round < 20; round++) {\n\t\tindex = hash_index(hash, round);\n\n\t\tif (logfs_exist_block(dir, index))\n\t\t\tcontinue;\n\t\tpage = find_or_create_page(dir->i_mapping, index, GFP_KERNEL);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tdd = kmap_atomic(page);\n\t\tmemset(dd, 0, sizeof(*dd));\n\t\tdd->ino = cpu_to_be64(inode->i_ino);\n\t\tdd->type = logfs_type(inode);\n\t\tlogfs_set_name(dd, &dentry->d_name);\n\t\tkunmap_atomic(dd);\n\n\t\terr = logfs_write_buf(dir, page, WF_LOCK);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (!err)\n\t\t\tgrow_dir(dir, index);\n\t\treturn err;\n\t}\n\t/* FIXME: Is there a better return value?  In most cases neither\n\t * the filesystem nor the directory are full.  But we have had\n\t * too many collisions for this particular hash and no fallback.\n\t */\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_dir(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode)\n{\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\tu32 hash = hash_32(dentry->d_name.name, dentry->d_name.len, 0);\n\tpgoff_t index;\n\tint round, err;\n\n\tfor (round = 0; round < 20; round++) {\n\t\tindex = hash_index(hash, round);\n\n\t\tif (logfs_exist_block(dir, index))\n\t\t\tcontinue;\n\t\tpage = find_or_create_page(dir->i_mapping, index, GFP_KERNEL);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tdd = kmap_atomic(page);\n\t\tmemset(dd, 0, sizeof(*dd));\n\t\tdd->ino = cpu_to_be64(inode->i_ino);\n\t\tdd->type = logfs_type(inode);\n\t\tlogfs_set_name(dd, &dentry->d_name);\n\t\tkunmap_atomic(dd);\n\n\t\terr = logfs_write_buf(dir, page, WF_LOCK);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (!err)\n\t\t\tgrow_dir(dir, index);\n\t\treturn err;\n\t}\n\t/* FIXME: Is there a better return value?  In most cases neither\n\t * the filesystem nor the directory are full.  But we have had\n\t * too many collisions for this particular hash and no fallback.\n\t */\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_type",
          "args": [
            "inode"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "658-661",
          "snippet": "static inline u8 logfs_type(struct inode *inode)\n{\n\treturn (inode->i_mode >> 12) & 15;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u8 logfs_type(struct inode *inode)\n{\n\treturn (inode->i_mode >> 12) & 15;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "inode->i_ino"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_dd",
          "args": [
            "dir",
            "dentry",
            "dd",
            "&pos"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_dd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "550-565",
          "snippet": "static int logfs_get_dd(struct inode *dir, struct dentry *dentry,\n\t\tstruct logfs_disk_dentry *dd, loff_t *pos)\n{\n\tstruct page *page;\n\tvoid *map;\n\n\tpage = logfs_get_dd_page(dir, dentry);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\t*pos = page->index;\n\tmap = kmap_atomic(page);\n\tmemcpy(dd, map, sizeof(*dd));\n\tkunmap_atomic(map);\n\tpage_cache_release(page);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_get_dd(struct inode *dir, struct dentry *dentry,\n\t\tstruct logfs_disk_dentry *dd, loff_t *pos)\n{\n\tstruct page *page;\n\tvoid *map;\n\n\tpage = logfs_get_dd_page(dir, dentry);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\t*pos = page->index;\n\tmap = kmap_atomic(page);\n\tmemcpy(dd, map, sizeof(*dd));\n\tkunmap_atomic(map);\n\tpage_cache_release(page);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_replace_inode(struct inode *dir, struct dentry *dentry,\n\t\tstruct logfs_disk_dentry *dd, struct inode *inode)\n{\n\tloff_t pos;\n\tint err;\n\n\terr = logfs_get_dd(dir, dentry, dd, &pos);\n\tif (err)\n\t\treturn err;\n\tdd->ino = cpu_to_be64(inode->i_ino);\n\tdd->type = logfs_type(inode);\n\n\terr = write_dir(dir, dd, pos);\n\tif (err)\n\t\treturn err;\n\tlog_dir(\"Replace dentry (%lx, %llx) %s -> %llx\\n\", dir->i_ino, pos,\n\t\t\tdd->name, be64_to_cpu(dd->ino));\n\treturn write_inode(dir);\n}"
  },
  {
    "function_name": "logfs_rename_cross",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "585-631",
    "snippet": "static int logfs_rename_cross(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t      struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct logfs_super *super = logfs_super(old_dir->i_sb);\n\tstruct logfs_disk_dentry dd;\n\tstruct logfs_transaction *ta;\n\tloff_t pos;\n\tint err;\n\n\t/* 1. locate source dd */\n\terr = logfs_get_dd(old_dir, old_dentry, &dd, &pos);\n\tif (err)\n\t\treturn err;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta)\n\t\treturn -ENOMEM;\n\n\tta->state = CROSS_RENAME_1;\n\tta->dir = old_dir->i_ino;\n\tta->pos = pos;\n\n\t/* 2. write target dd */\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(new_dir, ta);\n\terr = logfs_write_dir(new_dir, new_dentry, old_dentry->d_inode);\n\tif (!err)\n\t\terr = write_inode(new_dir);\n\n\tif (err) {\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\tabort_transaction(new_dir, ta);\n\t\tgoto out;\n\t}\n\n\t/* 3. remove source dd */\n\tta->state = CROSS_RENAME_2;\n\tlogfs_add_transaction(old_dir, ta);\n\terr = logfs_delete_dd(old_dir, pos);\n\tif (!err)\n\t\terr = write_inode(old_dir);\n\tLOGFS_BUG_ON(err, old_dir->i_sb);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&super->s_dirop_mutex"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGFS_BUG_ON",
          "args": [
            "err",
            "old_dir->i_sb"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_inode",
          "args": [
            "old_dir"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "72-75",
          "snippet": "static int write_inode(struct inode *inode)\n{\n\treturn __logfs_write_inode(inode, NULL, WF_LOCK);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int write_inode(struct inode *inode)\n{\n\treturn __logfs_write_inode(inode, NULL, WF_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_delete_dd",
          "args": [
            "old_dir",
            "pos"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_delete_dd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "567-578",
          "snippet": "static int logfs_delete_dd(struct inode *dir, loff_t pos)\n{\n\t/*\n\t * Getting called with pos somewhere beyond eof is either a goofup\n\t * within this file or means someone maliciously edited the\n\t * (crc-protected) journal.\n\t */\n\tBUG_ON(beyond_eof(dir, pos));\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tlog_dir(\" Delete dentry (%lx, %llx)\\n\", dir->i_ino, pos);\n\treturn logfs_delete(dir, pos, NULL);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_delete_dd(struct inode *dir, loff_t pos)\n{\n\t/*\n\t * Getting called with pos somewhere beyond eof is either a goofup\n\t * within this file or means someone maliciously edited the\n\t * (crc-protected) journal.\n\t */\n\tBUG_ON(beyond_eof(dir, pos));\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tlog_dir(\" Delete dentry (%lx, %llx)\\n\", dir->i_ino, pos);\n\treturn logfs_delete(dir, pos, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_add_transaction",
          "args": [
            "old_dir",
            "ta"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_add_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1495-1499",
          "snippet": "void logfs_add_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\talloc_inode_block(inode);\n\tlogfs_inode(inode)->li_block->ta = ta;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_add_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\talloc_inode_block(inode);\n\tlogfs_inode(inode)->li_block->ta = ta;\n}"
        }
      },
      {
        "call_info": {
          "callee": "abort_transaction",
          "args": [
            "new_dir",
            "ta"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "abort_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "206-211",
          "snippet": "static void abort_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\tif (logfs_inode(inode)->li_block)\n\t\tlogfs_inode(inode)->li_block->ta = NULL;\n\tkfree(ta);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void abort_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\tif (logfs_inode(inode)->li_block)\n\t\tlogfs_inode(inode)->li_block->ta = NULL;\n\tkfree(ta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_dir",
          "args": [
            "new_dir",
            "new_dentry",
            "old_dentry->d_inode"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "368-405",
          "snippet": "static int logfs_write_dir(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode)\n{\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\tu32 hash = hash_32(dentry->d_name.name, dentry->d_name.len, 0);\n\tpgoff_t index;\n\tint round, err;\n\n\tfor (round = 0; round < 20; round++) {\n\t\tindex = hash_index(hash, round);\n\n\t\tif (logfs_exist_block(dir, index))\n\t\t\tcontinue;\n\t\tpage = find_or_create_page(dir->i_mapping, index, GFP_KERNEL);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tdd = kmap_atomic(page);\n\t\tmemset(dd, 0, sizeof(*dd));\n\t\tdd->ino = cpu_to_be64(inode->i_ino);\n\t\tdd->type = logfs_type(inode);\n\t\tlogfs_set_name(dd, &dentry->d_name);\n\t\tkunmap_atomic(dd);\n\n\t\terr = logfs_write_buf(dir, page, WF_LOCK);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (!err)\n\t\t\tgrow_dir(dir, index);\n\t\treturn err;\n\t}\n\t/* FIXME: Is there a better return value?  In most cases neither\n\t * the filesystem nor the directory are full.  But we have had\n\t * too many collisions for this particular hash and no fallback.\n\t */\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_dir(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode)\n{\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\tu32 hash = hash_32(dentry->d_name.name, dentry->d_name.len, 0);\n\tpgoff_t index;\n\tint round, err;\n\n\tfor (round = 0; round < 20; round++) {\n\t\tindex = hash_index(hash, round);\n\n\t\tif (logfs_exist_block(dir, index))\n\t\t\tcontinue;\n\t\tpage = find_or_create_page(dir->i_mapping, index, GFP_KERNEL);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tdd = kmap_atomic(page);\n\t\tmemset(dd, 0, sizeof(*dd));\n\t\tdd->ino = cpu_to_be64(inode->i_ino);\n\t\tdd->type = logfs_type(inode);\n\t\tlogfs_set_name(dd, &dentry->d_name);\n\t\tkunmap_atomic(dd);\n\n\t\terr = logfs_write_buf(dir, page, WF_LOCK);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (!err)\n\t\t\tgrow_dir(dir, index);\n\t\treturn err;\n\t}\n\t/* FIXME: Is there a better return value?  In most cases neither\n\t * the filesystem nor the directory are full.  But we have had\n\t * too many collisions for this particular hash and no fallback.\n\t */\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&super->s_dirop_mutex"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ta)",
            "GFP_KERNEL"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_dd",
          "args": [
            "old_dir",
            "old_dentry",
            "&dd",
            "&pos"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_dd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "550-565",
          "snippet": "static int logfs_get_dd(struct inode *dir, struct dentry *dentry,\n\t\tstruct logfs_disk_dentry *dd, loff_t *pos)\n{\n\tstruct page *page;\n\tvoid *map;\n\n\tpage = logfs_get_dd_page(dir, dentry);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\t*pos = page->index;\n\tmap = kmap_atomic(page);\n\tmemcpy(dd, map, sizeof(*dd));\n\tkunmap_atomic(map);\n\tpage_cache_release(page);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_get_dd(struct inode *dir, struct dentry *dentry,\n\t\tstruct logfs_disk_dentry *dd, loff_t *pos)\n{\n\tstruct page *page;\n\tvoid *map;\n\n\tpage = logfs_get_dd_page(dir, dentry);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\t*pos = page->index;\n\tmap = kmap_atomic(page);\n\tmemcpy(dd, map, sizeof(*dd));\n\tkunmap_atomic(map);\n\tpage_cache_release(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "old_dir->i_sb"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_rename_cross(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t      struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct logfs_super *super = logfs_super(old_dir->i_sb);\n\tstruct logfs_disk_dentry dd;\n\tstruct logfs_transaction *ta;\n\tloff_t pos;\n\tint err;\n\n\t/* 1. locate source dd */\n\terr = logfs_get_dd(old_dir, old_dentry, &dd, &pos);\n\tif (err)\n\t\treturn err;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta)\n\t\treturn -ENOMEM;\n\n\tta->state = CROSS_RENAME_1;\n\tta->dir = old_dir->i_ino;\n\tta->pos = pos;\n\n\t/* 2. write target dd */\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(new_dir, ta);\n\terr = logfs_write_dir(new_dir, new_dentry, old_dentry->d_inode);\n\tif (!err)\n\t\terr = write_inode(new_dir);\n\n\tif (err) {\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\tabort_transaction(new_dir, ta);\n\t\tgoto out;\n\t}\n\n\t/* 3. remove source dd */\n\tta->state = CROSS_RENAME_2;\n\tlogfs_add_transaction(old_dir, ta);\n\terr = logfs_delete_dd(old_dir, pos);\n\tif (!err)\n\t\terr = write_inode(old_dir);\n\tLOGFS_BUG_ON(err, old_dir->i_sb);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "logfs_delete_dd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "567-578",
    "snippet": "static int logfs_delete_dd(struct inode *dir, loff_t pos)\n{\n\t/*\n\t * Getting called with pos somewhere beyond eof is either a goofup\n\t * within this file or means someone maliciously edited the\n\t * (crc-protected) journal.\n\t */\n\tBUG_ON(beyond_eof(dir, pos));\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tlog_dir(\" Delete dentry (%lx, %llx)\\n\", dir->i_ino, pos);\n\treturn logfs_delete(dir, pos, NULL);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_delete",
          "args": [
            "dir",
            "pos",
            "NULL"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1591-1609",
          "snippet": "int logfs_delete(struct inode *inode, pgoff_t index,\n\t\tstruct shadow_tree *shadow_tree)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct page *page;\n\tint ret;\n\n\tpage = logfs_get_read_page(inode, index, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tlogfs_get_wblocks(sb, page, 1);\n\tret = __logfs_delete(inode, page);\n\tlogfs_put_wblocks(sb, page, 1);\n\n\tlogfs_put_read_page(page);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_delete(struct inode *inode, pgoff_t index,\n\t\tstruct shadow_tree *shadow_tree)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct page *page;\n\tint ret;\n\n\tpage = logfs_get_read_page(inode, index, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tlogfs_get_wblocks(sb, page, 1);\n\tret = __logfs_delete(inode, page);\n\tlogfs_put_wblocks(sb, page, 1);\n\n\tlogfs_put_read_page(page);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_dir",
          "args": [
            "\" Delete dentry (%lx, %llx)\\n\"",
            "dir->i_ino",
            "pos"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "beyond_eof(dir, pos)"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "beyond_eof",
          "args": [
            "dir",
            "pos"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "beyond_eof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "84-88",
          "snippet": "static int beyond_eof(struct inode *inode, loff_t bix)\n{\n\tloff_t pos = bix << inode->i_sb->s_blocksize_bits;\n\treturn pos >= i_size_read(inode);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int beyond_eof(struct inode *inode, loff_t bix)\n{\n\tloff_t pos = bix << inode->i_sb->s_blocksize_bits;\n\treturn pos >= i_size_read(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_delete_dd(struct inode *dir, loff_t pos)\n{\n\t/*\n\t * Getting called with pos somewhere beyond eof is either a goofup\n\t * within this file or means someone maliciously edited the\n\t * (crc-protected) journal.\n\t */\n\tBUG_ON(beyond_eof(dir, pos));\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tlog_dir(\" Delete dentry (%lx, %llx)\\n\", dir->i_ino, pos);\n\treturn logfs_delete(dir, pos, NULL);\n}"
  },
  {
    "function_name": "logfs_get_dd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "550-565",
    "snippet": "static int logfs_get_dd(struct inode *dir, struct dentry *dentry,\n\t\tstruct logfs_disk_dentry *dd, loff_t *pos)\n{\n\tstruct page *page;\n\tvoid *map;\n\n\tpage = logfs_get_dd_page(dir, dentry);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\t*pos = page->index;\n\tmap = kmap_atomic(page);\n\tmemcpy(dd, map, sizeof(*dd));\n\tkunmap_atomic(map);\n\tpage_cache_release(page);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "map"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dd",
            "map",
            "sizeof(*dd)"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_dd_page",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_dd_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "157-194",
          "snippet": "static struct page *logfs_get_dd_page(struct inode *dir, struct dentry *dentry)\n{\n\tstruct qstr *name = &dentry->d_name;\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\tu32 hash = hash_32(name->name, name->len, 0);\n\tpgoff_t index;\n\tint round;\n\n\tif (name->len > LOGFS_MAX_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tfor (round = 0; round < 20; round++) {\n\t\tindex = hash_index(hash, round);\n\n\t\tif (beyond_eof(dir, index))\n\t\t\treturn NULL;\n\t\tif (!logfs_exist_block(dir, index))\n\t\t\tcontinue;\n\t\tpage = read_cache_page(dir->i_mapping, index,\n\t\t\t\t(filler_t *)logfs_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\t\tdd = kmap_atomic(page);\n\t\tBUG_ON(dd->namelen == 0);\n\n\t\tif (name->len != be16_to_cpu(dd->namelen) ||\n\t\t\t\tmemcmp(name->name, dd->name, name->len)) {\n\t\t\tkunmap_atomic(dd);\n\t\t\tpage_cache_release(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkunmap_atomic(dd);\n\t\treturn page;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_dd_page(struct inode *dir, struct dentry *dentry)\n{\n\tstruct qstr *name = &dentry->d_name;\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\tu32 hash = hash_32(name->name, name->len, 0);\n\tpgoff_t index;\n\tint round;\n\n\tif (name->len > LOGFS_MAX_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tfor (round = 0; round < 20; round++) {\n\t\tindex = hash_index(hash, round);\n\n\t\tif (beyond_eof(dir, index))\n\t\t\treturn NULL;\n\t\tif (!logfs_exist_block(dir, index))\n\t\t\tcontinue;\n\t\tpage = read_cache_page(dir->i_mapping, index,\n\t\t\t\t(filler_t *)logfs_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\t\tdd = kmap_atomic(page);\n\t\tBUG_ON(dd->namelen == 0);\n\n\t\tif (name->len != be16_to_cpu(dd->namelen) ||\n\t\t\t\tmemcmp(name->name, dd->name, name->len)) {\n\t\t\tkunmap_atomic(dd);\n\t\t\tpage_cache_release(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkunmap_atomic(dd);\n\t\treturn page;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_get_dd(struct inode *dir, struct dentry *dentry,\n\t\tstruct logfs_disk_dentry *dd, loff_t *pos)\n{\n\tstruct page *page;\n\tvoid *map;\n\n\tpage = logfs_get_dd_page(dir, dentry);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\t*pos = page->index;\n\tmap = kmap_atomic(page);\n\tmemcpy(dd, map, sizeof(*dd));\n\tkunmap_atomic(map);\n\tpage_cache_release(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "537-548",
    "snippet": "static int logfs_link(struct dentry *old_dentry, struct inode *dir,\n\t\tstruct dentry *dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tihold(inode);\n\tinc_nlink(inode);\n\tmark_inode_dirty_sync(inode);\n\n\treturn __logfs_create(dir, dentry, inode, NULL, 0);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__logfs_create",
          "args": [
            "dir",
            "dentry",
            "inode",
            "NULL",
            "0"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "407-464",
          "snippet": "static int __logfs_create(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode, const char *dest, long destlen)\n{\n\tstruct logfs_super *super = logfs_super(dir->i_sb);\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_transaction *ta;\n\tint ret;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta) {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\treturn -ENOMEM;\n\t}\n\n\tta->state = CREATE_1;\n\tta->ino = inode->i_ino;\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(inode, ta);\n\n\tif (dest) {\n\t\t/* symlink */\n\t\tret = logfs_inode_write(inode, dest, destlen, 0, WF_LOCK, NULL);\n\t\tif (!ret)\n\t\t\tret = write_inode(inode);\n\t} else {\n\t\t/* creat/mkdir/mknod */\n\t\tret = write_inode(inode);\n\t}\n\tif (ret) {\n\t\tabort_transaction(inode, ta);\n\t\tli->li_flags |= LOGFS_IF_STILLBORN;\n\t\t/* FIXME: truncate symlink */\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\n\tta->state = CREATE_2;\n\tlogfs_add_transaction(dir, ta);\n\tret = logfs_write_dir(dir, dentry, inode);\n\t/* sync directory */\n\tif (!ret)\n\t\tret = write_inode(dir);\n\n\tif (ret) {\n\t\tlogfs_del_transaction(dir, ta);\n\t\tta->state = CREATE_2;\n\t\tlogfs_add_transaction(inode, ta);\n\t\tlogfs_remove_inode(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __logfs_create(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode, const char *dest, long destlen)\n{\n\tstruct logfs_super *super = logfs_super(dir->i_sb);\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_transaction *ta;\n\tint ret;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta) {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\treturn -ENOMEM;\n\t}\n\n\tta->state = CREATE_1;\n\tta->ino = inode->i_ino;\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(inode, ta);\n\n\tif (dest) {\n\t\t/* symlink */\n\t\tret = logfs_inode_write(inode, dest, destlen, 0, WF_LOCK, NULL);\n\t\tif (!ret)\n\t\t\tret = write_inode(inode);\n\t} else {\n\t\t/* creat/mkdir/mknod */\n\t\tret = write_inode(inode);\n\t}\n\tif (ret) {\n\t\tabort_transaction(inode, ta);\n\t\tli->li_flags |= LOGFS_IF_STILLBORN;\n\t\t/* FIXME: truncate symlink */\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\n\tta->state = CREATE_2;\n\tlogfs_add_transaction(dir, ta);\n\tret = logfs_write_dir(dir, dentry, inode);\n\t/* sync directory */\n\tif (!ret)\n\t\tret = write_inode(dir);\n\n\tif (ret) {\n\t\tlogfs_del_transaction(dir, ta);\n\t\tta->state = CREATE_2;\n\t\tlogfs_add_transaction(inode, ta);\n\t\tlogfs_remove_inode(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty_sync",
          "args": [
            "inode"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "291-294",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "121-125",
          "snippet": "static inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_link(struct dentry *old_dentry, struct inode *dir,\n\t\tstruct dentry *dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tihold(inode);\n\tinc_nlink(inode);\n\tmark_inode_dirty_sync(inode);\n\n\treturn __logfs_create(dir, dentry, inode, NULL, 0);\n}"
  },
  {
    "function_name": "logfs_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "518-535",
    "snippet": "static int logfs_symlink(struct inode *dir, struct dentry *dentry,\n\t\tconst char *target)\n{\n\tstruct inode *inode;\n\tsize_t destlen = strlen(target) + 1;\n\n\tif (destlen > dir->i_sb->s_blocksize)\n\t\treturn -ENAMETOOLONG;\n\n\tinode = logfs_new_inode(dir, S_IFLNK | 0777);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &logfs_symlink_iops;\n\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\n\treturn __logfs_create(dir, dentry, inode, target, destlen);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations logfs_symlink_iops = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__logfs_create",
          "args": [
            "dir",
            "dentry",
            "inode",
            "target",
            "destlen"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "407-464",
          "snippet": "static int __logfs_create(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode, const char *dest, long destlen)\n{\n\tstruct logfs_super *super = logfs_super(dir->i_sb);\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_transaction *ta;\n\tint ret;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta) {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\treturn -ENOMEM;\n\t}\n\n\tta->state = CREATE_1;\n\tta->ino = inode->i_ino;\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(inode, ta);\n\n\tif (dest) {\n\t\t/* symlink */\n\t\tret = logfs_inode_write(inode, dest, destlen, 0, WF_LOCK, NULL);\n\t\tif (!ret)\n\t\t\tret = write_inode(inode);\n\t} else {\n\t\t/* creat/mkdir/mknod */\n\t\tret = write_inode(inode);\n\t}\n\tif (ret) {\n\t\tabort_transaction(inode, ta);\n\t\tli->li_flags |= LOGFS_IF_STILLBORN;\n\t\t/* FIXME: truncate symlink */\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\n\tta->state = CREATE_2;\n\tlogfs_add_transaction(dir, ta);\n\tret = logfs_write_dir(dir, dentry, inode);\n\t/* sync directory */\n\tif (!ret)\n\t\tret = write_inode(dir);\n\n\tif (ret) {\n\t\tlogfs_del_transaction(dir, ta);\n\t\tta->state = CREATE_2;\n\t\tlogfs_add_transaction(inode, ta);\n\t\tlogfs_remove_inode(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __logfs_create(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode, const char *dest, long destlen)\n{\n\tstruct logfs_super *super = logfs_super(dir->i_sb);\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_transaction *ta;\n\tint ret;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta) {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\treturn -ENOMEM;\n\t}\n\n\tta->state = CREATE_1;\n\tta->ino = inode->i_ino;\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(inode, ta);\n\n\tif (dest) {\n\t\t/* symlink */\n\t\tret = logfs_inode_write(inode, dest, destlen, 0, WF_LOCK, NULL);\n\t\tif (!ret)\n\t\t\tret = write_inode(inode);\n\t} else {\n\t\t/* creat/mkdir/mknod */\n\t\tret = write_inode(inode);\n\t}\n\tif (ret) {\n\t\tabort_transaction(inode, ta);\n\t\tli->li_flags |= LOGFS_IF_STILLBORN;\n\t\t/* FIXME: truncate symlink */\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\n\tta->state = CREATE_2;\n\tlogfs_add_transaction(dir, ta);\n\tret = logfs_write_dir(dir, dentry, inode);\n\t/* sync directory */\n\tif (!ret)\n\t\tret = write_inode(dir);\n\n\tif (ret) {\n\t\tlogfs_del_transaction(dir, ta);\n\t\tta->state = CREATE_2;\n\t\tlogfs_add_transaction(inode, ta);\n\t\tlogfs_remove_inode(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_new_inode",
          "args": [
            "dir",
            "S_IFLNK | 0777"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "342-365",
          "snippet": "struct inode *logfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlogfs_init_inode(sb, inode);\n\n\t/* inherit parent flags */\n\tlogfs_inode(inode)->li_flags |=\n\t\tlogfs_inode(dir)->li_flags & LOGFS_FL_INHERITED;\n\n\tinode->i_mode = mode;\n\tlogfs_set_ino_generation(sb, inode);\n\n\tinode_init_owner(inode, dir, mode);\n\tlogfs_inode_setops(inode);\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstruct inode *logfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlogfs_init_inode(sb, inode);\n\n\t/* inherit parent flags */\n\tlogfs_inode(inode)->li_flags |=\n\t\tlogfs_inode(dir)->li_flags & LOGFS_FL_INHERITED;\n\n\tinode->i_mode = mode;\n\tlogfs_set_ino_generation(sb, inode);\n\n\tinode_init_owner(inode, dir, mode);\n\tlogfs_inode_setops(inode);\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "target"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nconst struct inode_operations logfs_symlink_iops = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n};\n\nstatic int logfs_symlink(struct inode *dir, struct dentry *dentry,\n\t\tconst char *target)\n{\n\tstruct inode *inode;\n\tsize_t destlen = strlen(target) + 1;\n\n\tif (destlen > dir->i_sb->s_blocksize)\n\t\treturn -ENAMETOOLONG;\n\n\tinode = logfs_new_inode(dir, S_IFLNK | 0777);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &logfs_symlink_iops;\n\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\n\treturn __logfs_create(dir, dentry, inode, target, destlen);\n}"
  },
  {
    "function_name": "logfs_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "501-516",
    "snippet": "static int logfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tdev_t rdev)\n{\n\tstruct inode *inode;\n\n\tif (dentry->d_name.len > LOGFS_MAX_NAMELEN)\n\t\treturn -ENAMETOOLONG;\n\n\tinode = logfs_new_inode(dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinit_special_inode(inode, mode, rdev);\n\n\treturn __logfs_create(dir, dentry, inode, NULL, 0);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__logfs_create",
          "args": [
            "dir",
            "dentry",
            "inode",
            "NULL",
            "0"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "407-464",
          "snippet": "static int __logfs_create(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode, const char *dest, long destlen)\n{\n\tstruct logfs_super *super = logfs_super(dir->i_sb);\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_transaction *ta;\n\tint ret;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta) {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\treturn -ENOMEM;\n\t}\n\n\tta->state = CREATE_1;\n\tta->ino = inode->i_ino;\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(inode, ta);\n\n\tif (dest) {\n\t\t/* symlink */\n\t\tret = logfs_inode_write(inode, dest, destlen, 0, WF_LOCK, NULL);\n\t\tif (!ret)\n\t\t\tret = write_inode(inode);\n\t} else {\n\t\t/* creat/mkdir/mknod */\n\t\tret = write_inode(inode);\n\t}\n\tif (ret) {\n\t\tabort_transaction(inode, ta);\n\t\tli->li_flags |= LOGFS_IF_STILLBORN;\n\t\t/* FIXME: truncate symlink */\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\n\tta->state = CREATE_2;\n\tlogfs_add_transaction(dir, ta);\n\tret = logfs_write_dir(dir, dentry, inode);\n\t/* sync directory */\n\tif (!ret)\n\t\tret = write_inode(dir);\n\n\tif (ret) {\n\t\tlogfs_del_transaction(dir, ta);\n\t\tta->state = CREATE_2;\n\t\tlogfs_add_transaction(inode, ta);\n\t\tlogfs_remove_inode(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __logfs_create(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode, const char *dest, long destlen)\n{\n\tstruct logfs_super *super = logfs_super(dir->i_sb);\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_transaction *ta;\n\tint ret;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta) {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\treturn -ENOMEM;\n\t}\n\n\tta->state = CREATE_1;\n\tta->ino = inode->i_ino;\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(inode, ta);\n\n\tif (dest) {\n\t\t/* symlink */\n\t\tret = logfs_inode_write(inode, dest, destlen, 0, WF_LOCK, NULL);\n\t\tif (!ret)\n\t\t\tret = write_inode(inode);\n\t} else {\n\t\t/* creat/mkdir/mknod */\n\t\tret = write_inode(inode);\n\t}\n\tif (ret) {\n\t\tabort_transaction(inode, ta);\n\t\tli->li_flags |= LOGFS_IF_STILLBORN;\n\t\t/* FIXME: truncate symlink */\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\n\tta->state = CREATE_2;\n\tlogfs_add_transaction(dir, ta);\n\tret = logfs_write_dir(dir, dentry, inode);\n\t/* sync directory */\n\tif (!ret)\n\t\tret = write_inode(dir);\n\n\tif (ret) {\n\t\tlogfs_del_transaction(dir, ta);\n\t\tta->state = CREATE_2;\n\t\tlogfs_add_transaction(inode, ta);\n\t\tlogfs_remove_inode(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "mode",
            "rdev"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_new_inode",
          "args": [
            "dir",
            "mode"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "342-365",
          "snippet": "struct inode *logfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlogfs_init_inode(sb, inode);\n\n\t/* inherit parent flags */\n\tlogfs_inode(inode)->li_flags |=\n\t\tlogfs_inode(dir)->li_flags & LOGFS_FL_INHERITED;\n\n\tinode->i_mode = mode;\n\tlogfs_set_ino_generation(sb, inode);\n\n\tinode_init_owner(inode, dir, mode);\n\tlogfs_inode_setops(inode);\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstruct inode *logfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlogfs_init_inode(sb, inode);\n\n\t/* inherit parent flags */\n\tlogfs_inode(inode)->li_flags |=\n\t\tlogfs_inode(dir)->li_flags & LOGFS_FL_INHERITED;\n\n\tinode->i_mode = mode;\n\tlogfs_set_ino_generation(sb, inode);\n\n\tinode_init_owner(inode, dir, mode);\n\tlogfs_inode_setops(inode);\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tdev_t rdev)\n{\n\tstruct inode *inode;\n\n\tif (dentry->d_name.len > LOGFS_MAX_NAMELEN)\n\t\treturn -ENAMETOOLONG;\n\n\tinode = logfs_new_inode(dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinit_special_inode(inode, mode, rdev);\n\n\treturn __logfs_create(dir, dentry, inode, NULL, 0);\n}"
  },
  {
    "function_name": "logfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "485-499",
    "snippet": "static int logfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool excl)\n{\n\tstruct inode *inode;\n\n\tinode = logfs_new_inode(dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &logfs_reg_iops;\n\tinode->i_fop = &logfs_reg_fops;\n\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\n\treturn __logfs_create(dir, dentry, inode, NULL, 0);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__logfs_create",
          "args": [
            "dir",
            "dentry",
            "inode",
            "NULL",
            "0"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "407-464",
          "snippet": "static int __logfs_create(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode, const char *dest, long destlen)\n{\n\tstruct logfs_super *super = logfs_super(dir->i_sb);\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_transaction *ta;\n\tint ret;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta) {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\treturn -ENOMEM;\n\t}\n\n\tta->state = CREATE_1;\n\tta->ino = inode->i_ino;\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(inode, ta);\n\n\tif (dest) {\n\t\t/* symlink */\n\t\tret = logfs_inode_write(inode, dest, destlen, 0, WF_LOCK, NULL);\n\t\tif (!ret)\n\t\t\tret = write_inode(inode);\n\t} else {\n\t\t/* creat/mkdir/mknod */\n\t\tret = write_inode(inode);\n\t}\n\tif (ret) {\n\t\tabort_transaction(inode, ta);\n\t\tli->li_flags |= LOGFS_IF_STILLBORN;\n\t\t/* FIXME: truncate symlink */\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\n\tta->state = CREATE_2;\n\tlogfs_add_transaction(dir, ta);\n\tret = logfs_write_dir(dir, dentry, inode);\n\t/* sync directory */\n\tif (!ret)\n\t\tret = write_inode(dir);\n\n\tif (ret) {\n\t\tlogfs_del_transaction(dir, ta);\n\t\tta->state = CREATE_2;\n\t\tlogfs_add_transaction(inode, ta);\n\t\tlogfs_remove_inode(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __logfs_create(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode, const char *dest, long destlen)\n{\n\tstruct logfs_super *super = logfs_super(dir->i_sb);\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_transaction *ta;\n\tint ret;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta) {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\treturn -ENOMEM;\n\t}\n\n\tta->state = CREATE_1;\n\tta->ino = inode->i_ino;\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(inode, ta);\n\n\tif (dest) {\n\t\t/* symlink */\n\t\tret = logfs_inode_write(inode, dest, destlen, 0, WF_LOCK, NULL);\n\t\tif (!ret)\n\t\t\tret = write_inode(inode);\n\t} else {\n\t\t/* creat/mkdir/mknod */\n\t\tret = write_inode(inode);\n\t}\n\tif (ret) {\n\t\tabort_transaction(inode, ta);\n\t\tli->li_flags |= LOGFS_IF_STILLBORN;\n\t\t/* FIXME: truncate symlink */\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\n\tta->state = CREATE_2;\n\tlogfs_add_transaction(dir, ta);\n\tret = logfs_write_dir(dir, dentry, inode);\n\t/* sync directory */\n\tif (!ret)\n\t\tret = write_inode(dir);\n\n\tif (ret) {\n\t\tlogfs_del_transaction(dir, ta);\n\t\tta->state = CREATE_2;\n\t\tlogfs_add_transaction(inode, ta);\n\t\tlogfs_remove_inode(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_new_inode",
          "args": [
            "dir",
            "mode"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "342-365",
          "snippet": "struct inode *logfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlogfs_init_inode(sb, inode);\n\n\t/* inherit parent flags */\n\tlogfs_inode(inode)->li_flags |=\n\t\tlogfs_inode(dir)->li_flags & LOGFS_FL_INHERITED;\n\n\tinode->i_mode = mode;\n\tlogfs_set_ino_generation(sb, inode);\n\n\tinode_init_owner(inode, dir, mode);\n\tlogfs_inode_setops(inode);\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstruct inode *logfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlogfs_init_inode(sb, inode);\n\n\t/* inherit parent flags */\n\tlogfs_inode(inode)->li_flags |=\n\t\tlogfs_inode(dir)->li_flags & LOGFS_FL_INHERITED;\n\n\tinode->i_mode = mode;\n\tlogfs_set_ino_generation(sb, inode);\n\n\tinode_init_owner(inode, dir, mode);\n\tlogfs_inode_setops(inode);\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool excl)\n{\n\tstruct inode *inode;\n\n\tinode = logfs_new_inode(dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &logfs_reg_iops;\n\tinode->i_fop = &logfs_reg_fops;\n\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\n\treturn __logfs_create(dir, dentry, inode, NULL, 0);\n}"
  },
  {
    "function_name": "logfs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "466-483",
    "snippet": "static int logfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode;\n\n\t/*\n\t * FIXME: why do we have to fill in S_IFDIR, while the mode is\n\t * correct for mknod, creat, etc.?  Smells like the vfs *should*\n\t * do it for us but for some reason fails to do so.\n\t */\n\tinode = logfs_new_inode(dir, S_IFDIR | mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &logfs_dir_iops;\n\tinode->i_fop = &logfs_dir_fops;\n\n\treturn __logfs_create(dir, dentry, inode, NULL, 0);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations logfs_dir_iops = {\n\t.create\t\t= logfs_create,\n\t.link\t\t= logfs_link,\n\t.lookup\t\t= logfs_lookup,\n\t.mkdir\t\t= logfs_mkdir,\n\t.mknod\t\t= logfs_mknod,\n\t.rename\t\t= logfs_rename,\n\t.rmdir\t\t= logfs_rmdir,\n\t.symlink\t= logfs_symlink,\n\t.unlink\t\t= logfs_unlink,\n};",
      "const struct file_operations logfs_dir_fops = {\n\t.fsync\t\t= logfs_fsync,\n\t.unlocked_ioctl\t= logfs_ioctl,\n\t.iterate\t= logfs_readdir,\n\t.read\t\t= generic_read_dir,\n\t.llseek\t\t= default_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__logfs_create",
          "args": [
            "dir",
            "dentry",
            "inode",
            "NULL",
            "0"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "407-464",
          "snippet": "static int __logfs_create(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode, const char *dest, long destlen)\n{\n\tstruct logfs_super *super = logfs_super(dir->i_sb);\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_transaction *ta;\n\tint ret;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta) {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\treturn -ENOMEM;\n\t}\n\n\tta->state = CREATE_1;\n\tta->ino = inode->i_ino;\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(inode, ta);\n\n\tif (dest) {\n\t\t/* symlink */\n\t\tret = logfs_inode_write(inode, dest, destlen, 0, WF_LOCK, NULL);\n\t\tif (!ret)\n\t\t\tret = write_inode(inode);\n\t} else {\n\t\t/* creat/mkdir/mknod */\n\t\tret = write_inode(inode);\n\t}\n\tif (ret) {\n\t\tabort_transaction(inode, ta);\n\t\tli->li_flags |= LOGFS_IF_STILLBORN;\n\t\t/* FIXME: truncate symlink */\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\n\tta->state = CREATE_2;\n\tlogfs_add_transaction(dir, ta);\n\tret = logfs_write_dir(dir, dentry, inode);\n\t/* sync directory */\n\tif (!ret)\n\t\tret = write_inode(dir);\n\n\tif (ret) {\n\t\tlogfs_del_transaction(dir, ta);\n\t\tta->state = CREATE_2;\n\t\tlogfs_add_transaction(inode, ta);\n\t\tlogfs_remove_inode(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __logfs_create(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode, const char *dest, long destlen)\n{\n\tstruct logfs_super *super = logfs_super(dir->i_sb);\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_transaction *ta;\n\tint ret;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta) {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\treturn -ENOMEM;\n\t}\n\n\tta->state = CREATE_1;\n\tta->ino = inode->i_ino;\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(inode, ta);\n\n\tif (dest) {\n\t\t/* symlink */\n\t\tret = logfs_inode_write(inode, dest, destlen, 0, WF_LOCK, NULL);\n\t\tif (!ret)\n\t\t\tret = write_inode(inode);\n\t} else {\n\t\t/* creat/mkdir/mknod */\n\t\tret = write_inode(inode);\n\t}\n\tif (ret) {\n\t\tabort_transaction(inode, ta);\n\t\tli->li_flags |= LOGFS_IF_STILLBORN;\n\t\t/* FIXME: truncate symlink */\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\n\tta->state = CREATE_2;\n\tlogfs_add_transaction(dir, ta);\n\tret = logfs_write_dir(dir, dentry, inode);\n\t/* sync directory */\n\tif (!ret)\n\t\tret = write_inode(dir);\n\n\tif (ret) {\n\t\tlogfs_del_transaction(dir, ta);\n\t\tta->state = CREATE_2;\n\t\tlogfs_add_transaction(inode, ta);\n\t\tlogfs_remove_inode(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_new_inode",
          "args": [
            "dir",
            "S_IFDIR | mode"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "342-365",
          "snippet": "struct inode *logfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlogfs_init_inode(sb, inode);\n\n\t/* inherit parent flags */\n\tlogfs_inode(inode)->li_flags |=\n\t\tlogfs_inode(dir)->li_flags & LOGFS_FL_INHERITED;\n\n\tinode->i_mode = mode;\n\tlogfs_set_ino_generation(sb, inode);\n\n\tinode_init_owner(inode, dir, mode);\n\tlogfs_inode_setops(inode);\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstruct inode *logfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlogfs_init_inode(sb, inode);\n\n\t/* inherit parent flags */\n\tlogfs_inode(inode)->li_flags |=\n\t\tlogfs_inode(dir)->li_flags & LOGFS_FL_INHERITED;\n\n\tinode->i_mode = mode;\n\tlogfs_set_ino_generation(sb, inode);\n\n\tinode_init_owner(inode, dir, mode);\n\tlogfs_inode_setops(inode);\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nconst struct inode_operations logfs_dir_iops = {\n\t.create\t\t= logfs_create,\n\t.link\t\t= logfs_link,\n\t.lookup\t\t= logfs_lookup,\n\t.mkdir\t\t= logfs_mkdir,\n\t.mknod\t\t= logfs_mknod,\n\t.rename\t\t= logfs_rename,\n\t.rmdir\t\t= logfs_rmdir,\n\t.symlink\t= logfs_symlink,\n\t.unlink\t\t= logfs_unlink,\n};\nconst struct file_operations logfs_dir_fops = {\n\t.fsync\t\t= logfs_fsync,\n\t.unlocked_ioctl\t= logfs_ioctl,\n\t.iterate\t= logfs_readdir,\n\t.read\t\t= generic_read_dir,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic int logfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode;\n\n\t/*\n\t * FIXME: why do we have to fill in S_IFDIR, while the mode is\n\t * correct for mknod, creat, etc.?  Smells like the vfs *should*\n\t * do it for us but for some reason fails to do so.\n\t */\n\tinode = logfs_new_inode(dir, S_IFDIR | mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &logfs_dir_iops;\n\tinode->i_fop = &logfs_dir_fops;\n\n\treturn __logfs_create(dir, dentry, inode, NULL, 0);\n}"
  },
  {
    "function_name": "__logfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "407-464",
    "snippet": "static int __logfs_create(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode, const char *dest, long destlen)\n{\n\tstruct logfs_super *super = logfs_super(dir->i_sb);\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_transaction *ta;\n\tint ret;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta) {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\treturn -ENOMEM;\n\t}\n\n\tta->state = CREATE_1;\n\tta->ino = inode->i_ino;\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(inode, ta);\n\n\tif (dest) {\n\t\t/* symlink */\n\t\tret = logfs_inode_write(inode, dest, destlen, 0, WF_LOCK, NULL);\n\t\tif (!ret)\n\t\t\tret = write_inode(inode);\n\t} else {\n\t\t/* creat/mkdir/mknod */\n\t\tret = write_inode(inode);\n\t}\n\tif (ret) {\n\t\tabort_transaction(inode, ta);\n\t\tli->li_flags |= LOGFS_IF_STILLBORN;\n\t\t/* FIXME: truncate symlink */\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\n\tta->state = CREATE_2;\n\tlogfs_add_transaction(dir, ta);\n\tret = logfs_write_dir(dir, dentry, inode);\n\t/* sync directory */\n\tif (!ret)\n\t\tret = write_inode(dir);\n\n\tif (ret) {\n\t\tlogfs_del_transaction(dir, ta);\n\t\tta->state = CREATE_2;\n\t\tlogfs_add_transaction(inode, ta);\n\t\tlogfs_remove_inode(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&super->s_dirop_mutex"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_remove_inode",
          "args": [
            "inode"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_remove_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "196-204",
          "snippet": "static int logfs_remove_inode(struct inode *inode)\n{\n\tint ret;\n\n\tdrop_nlink(inode);\n\tret = write_inode(inode);\n\tLOGFS_BUG_ON(ret, inode->i_sb);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_remove_inode(struct inode *inode)\n{\n\tint ret;\n\n\tdrop_nlink(inode);\n\tret = write_inode(inode);\n\tLOGFS_BUG_ON(ret, inode->i_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_add_transaction",
          "args": [
            "inode",
            "ta"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_add_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1495-1499",
          "snippet": "void logfs_add_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\talloc_inode_block(inode);\n\tlogfs_inode(inode)->li_block->ta = ta;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_add_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\talloc_inode_block(inode);\n\tlogfs_inode(inode)->li_block->ta = ta;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_del_transaction",
          "args": [
            "dir",
            "ta"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_del_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1501-1507",
          "snippet": "void logfs_del_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\tstruct logfs_block *block = logfs_inode(inode)->li_block;\n\n\tif (block && block->ta)\n\t\tblock->ta = NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_del_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\tstruct logfs_block *block = logfs_inode(inode)->li_block;\n\n\tif (block && block->ta)\n\t\tblock->ta = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_inode",
          "args": [
            "dir"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "72-75",
          "snippet": "static int write_inode(struct inode *inode)\n{\n\treturn __logfs_write_inode(inode, NULL, WF_LOCK);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int write_inode(struct inode *inode)\n{\n\treturn __logfs_write_inode(inode, NULL, WF_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_dir",
          "args": [
            "dir",
            "dentry",
            "inode"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "368-405",
          "snippet": "static int logfs_write_dir(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode)\n{\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\tu32 hash = hash_32(dentry->d_name.name, dentry->d_name.len, 0);\n\tpgoff_t index;\n\tint round, err;\n\n\tfor (round = 0; round < 20; round++) {\n\t\tindex = hash_index(hash, round);\n\n\t\tif (logfs_exist_block(dir, index))\n\t\t\tcontinue;\n\t\tpage = find_or_create_page(dir->i_mapping, index, GFP_KERNEL);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tdd = kmap_atomic(page);\n\t\tmemset(dd, 0, sizeof(*dd));\n\t\tdd->ino = cpu_to_be64(inode->i_ino);\n\t\tdd->type = logfs_type(inode);\n\t\tlogfs_set_name(dd, &dentry->d_name);\n\t\tkunmap_atomic(dd);\n\n\t\terr = logfs_write_buf(dir, page, WF_LOCK);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (!err)\n\t\t\tgrow_dir(dir, index);\n\t\treturn err;\n\t}\n\t/* FIXME: Is there a better return value?  In most cases neither\n\t * the filesystem nor the directory are full.  But we have had\n\t * too many collisions for this particular hash and no fallback.\n\t */\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_dir(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode)\n{\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\tu32 hash = hash_32(dentry->d_name.name, dentry->d_name.len, 0);\n\tpgoff_t index;\n\tint round, err;\n\n\tfor (round = 0; round < 20; round++) {\n\t\tindex = hash_index(hash, round);\n\n\t\tif (logfs_exist_block(dir, index))\n\t\t\tcontinue;\n\t\tpage = find_or_create_page(dir->i_mapping, index, GFP_KERNEL);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tdd = kmap_atomic(page);\n\t\tmemset(dd, 0, sizeof(*dd));\n\t\tdd->ino = cpu_to_be64(inode->i_ino);\n\t\tdd->type = logfs_type(inode);\n\t\tlogfs_set_name(dd, &dentry->d_name);\n\t\tkunmap_atomic(dd);\n\n\t\terr = logfs_write_buf(dir, page, WF_LOCK);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (!err)\n\t\t\tgrow_dir(dir, index);\n\t\treturn err;\n\t}\n\t/* FIXME: Is there a better return value?  In most cases neither\n\t * the filesystem nor the directory are full.  But we have had\n\t * too many collisions for this particular hash and no fallback.\n\t */\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "127-131",
          "snippet": "static inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "abort_transaction",
          "args": [
            "inode",
            "ta"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "abort_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "206-211",
          "snippet": "static void abort_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\tif (logfs_inode(inode)->li_block)\n\t\tlogfs_inode(inode)->li_block->ta = NULL;\n\tkfree(ta);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void abort_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\tif (logfs_inode(inode)->li_block)\n\t\tlogfs_inode(inode)->li_block->ta = NULL;\n\tkfree(ta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode_write",
          "args": [
            "inode",
            "dest",
            "destlen",
            "0",
            "WF_LOCK",
            "NULL"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2238-2263",
          "snippet": "int logfs_inode_write(struct inode *inode, const void *buf, size_t count,\n\t\tloff_t bix, long flags, struct shadow_tree *shadow_tree)\n{\n\tloff_t pos = bix << inode->i_sb->s_blocksize_bits;\n\tint err;\n\tstruct page *page;\n\tvoid *pagebuf;\n\n\tBUG_ON(pos & (LOGFS_BLOCKSIZE-1));\n\tBUG_ON(count > LOGFS_BLOCKSIZE);\n\tpage = logfs_get_write_page(inode, bix, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tpagebuf = kmap_atomic(page);\n\tmemcpy(pagebuf, buf, count);\n\tflush_dcache_page(page);\n\tkunmap_atomic(pagebuf);\n\n\tif (i_size_read(inode) < pos + LOGFS_BLOCKSIZE)\n\t\ti_size_write(inode, pos + LOGFS_BLOCKSIZE);\n\n\terr = logfs_write_buf(inode, page, flags);\n\tlogfs_put_write_page(page);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_inode_write(struct inode *inode, const void *buf, size_t count,\n\t\tloff_t bix, long flags, struct shadow_tree *shadow_tree)\n{\n\tloff_t pos = bix << inode->i_sb->s_blocksize_bits;\n\tint err;\n\tstruct page *page;\n\tvoid *pagebuf;\n\n\tBUG_ON(pos & (LOGFS_BLOCKSIZE-1));\n\tBUG_ON(count > LOGFS_BLOCKSIZE);\n\tpage = logfs_get_write_page(inode, bix, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tpagebuf = kmap_atomic(page);\n\tmemcpy(pagebuf, buf, count);\n\tflush_dcache_page(page);\n\tkunmap_atomic(pagebuf);\n\n\tif (i_size_read(inode) < pos + LOGFS_BLOCKSIZE)\n\t\ti_size_write(inode, pos + LOGFS_BLOCKSIZE);\n\n\terr = logfs_write_buf(inode, page, flags);\n\tlogfs_put_write_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&super->s_dirop_mutex"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ta)",
            "GFP_KERNEL"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "dir->i_sb"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __logfs_create(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode, const char *dest, long destlen)\n{\n\tstruct logfs_super *super = logfs_super(dir->i_sb);\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_transaction *ta;\n\tint ret;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta) {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\treturn -ENOMEM;\n\t}\n\n\tta->state = CREATE_1;\n\tta->ino = inode->i_ino;\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(inode, ta);\n\n\tif (dest) {\n\t\t/* symlink */\n\t\tret = logfs_inode_write(inode, dest, destlen, 0, WF_LOCK, NULL);\n\t\tif (!ret)\n\t\t\tret = write_inode(inode);\n\t} else {\n\t\t/* creat/mkdir/mknod */\n\t\tret = write_inode(inode);\n\t}\n\tif (ret) {\n\t\tabort_transaction(inode, ta);\n\t\tli->li_flags |= LOGFS_IF_STILLBORN;\n\t\t/* FIXME: truncate symlink */\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\n\tta->state = CREATE_2;\n\tlogfs_add_transaction(dir, ta);\n\tret = logfs_write_dir(dir, dentry, inode);\n\t/* sync directory */\n\tif (!ret)\n\t\tret = write_inode(dir);\n\n\tif (ret) {\n\t\tlogfs_del_transaction(dir, ta);\n\t\tta->state = CREATE_2;\n\t\tlogfs_add_transaction(inode, ta);\n\t\tlogfs_remove_inode(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "logfs_write_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "368-405",
    "snippet": "static int logfs_write_dir(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode)\n{\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\tu32 hash = hash_32(dentry->d_name.name, dentry->d_name.len, 0);\n\tpgoff_t index;\n\tint round, err;\n\n\tfor (round = 0; round < 20; round++) {\n\t\tindex = hash_index(hash, round);\n\n\t\tif (logfs_exist_block(dir, index))\n\t\t\tcontinue;\n\t\tpage = find_or_create_page(dir->i_mapping, index, GFP_KERNEL);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tdd = kmap_atomic(page);\n\t\tmemset(dd, 0, sizeof(*dd));\n\t\tdd->ino = cpu_to_be64(inode->i_ino);\n\t\tdd->type = logfs_type(inode);\n\t\tlogfs_set_name(dd, &dentry->d_name);\n\t\tkunmap_atomic(dd);\n\n\t\terr = logfs_write_buf(dir, page, WF_LOCK);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (!err)\n\t\t\tgrow_dir(dir, index);\n\t\treturn err;\n\t}\n\t/* FIXME: Is there a better return value?  In most cases neither\n\t * the filesystem nor the directory are full.  But we have had\n\t * too many collisions for this particular hash and no fallback.\n\t */\n\treturn -ENOSPC;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "grow_dir",
          "args": [
            "dir",
            "index"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "grow_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "361-366",
          "snippet": "static void grow_dir(struct inode *dir, loff_t index)\n{\n\tindex = (index + 1) << dir->i_sb->s_blocksize_bits;\n\tif (i_size_read(dir) < index)\n\t\ti_size_write(dir, index);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void grow_dir(struct inode *dir, loff_t index)\n{\n\tindex = (index + 1) << dir->i_sb->s_blocksize_bits;\n\tif (i_size_read(dir) < index)\n\t\ti_size_write(dir, index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_buf",
          "args": [
            "dir",
            "page",
            "WF_LOCK"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1565-1574",
          "snippet": "int logfs_write_buf(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = __logfs_write_buf(inode, page, flags);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_write_buf(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = __logfs_write_buf(inode, page, flags);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "dd"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_set_name",
          "args": [
            "dd",
            "&dentry->d_name"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_set_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "326-330",
          "snippet": "static void logfs_set_name(struct logfs_disk_dentry *dd, struct qstr *name)\n{\n\tdd->namelen = cpu_to_be16(name->len);\n\tmemcpy(dd->name, name->name, name->len);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_set_name(struct logfs_disk_dentry *dd, struct qstr *name)\n{\n\tdd->namelen = cpu_to_be16(name->len);\n\tmemcpy(dd->name, name->name, name->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_type",
          "args": [
            "inode"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "658-661",
          "snippet": "static inline u8 logfs_type(struct inode *inode)\n{\n\treturn (inode->i_mode >> 12) & 15;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u8 logfs_type(struct inode *inode)\n{\n\treturn (inode->i_mode >> 12) & 15;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "inode->i_ino"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dd",
            "0",
            "sizeof(*dd)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "dir->i_mapping",
            "index",
            "GFP_KERNEL"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_exist_block",
          "args": [
            "dir",
            "index"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_exist_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "810-817",
          "snippet": "int logfs_exist_block(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (bix < I0_BLOCKS)\n\t\treturn !!li->li_data[bix];\n\treturn logfs_exist_loop(inode, bix);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_exist_block(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (bix < I0_BLOCKS)\n\t\treturn !!li->li_data[bix];\n\treturn logfs_exist_loop(inode, bix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_index",
          "args": [
            "hash",
            "round"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "hash_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "134-155",
          "snippet": "static pgoff_t hash_index(u32 hash, int round)\n{\n\tu32 i0_blocks = I0_BLOCKS;\n\tu32 i1_blocks = I1_BLOCKS;\n\tu32 i2_blocks = I2_BLOCKS;\n\tu32 i3_blocks = I3_BLOCKS;\n\n\tswitch (round) {\n\tcase 0:\n\t\treturn hash % i0_blocks;\n\tcase 1:\n\t\treturn i0_blocks + hash % (i1_blocks - i0_blocks);\n\tcase 2:\n\t\treturn i1_blocks + hash % (i2_blocks - i1_blocks);\n\tcase 3:\n\t\treturn i2_blocks + hash % (i3_blocks - i2_blocks);\n\tcase 4 ... 19:\n\t\treturn i3_blocks + 16 * (hash % (((1<<31) - i3_blocks) / 16))\n\t\t\t+ round - 4;\n\t}\n\tBUG();\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic pgoff_t hash_index(u32 hash, int round)\n{\n\tu32 i0_blocks = I0_BLOCKS;\n\tu32 i1_blocks = I1_BLOCKS;\n\tu32 i2_blocks = I2_BLOCKS;\n\tu32 i3_blocks = I3_BLOCKS;\n\n\tswitch (round) {\n\tcase 0:\n\t\treturn hash % i0_blocks;\n\tcase 1:\n\t\treturn i0_blocks + hash % (i1_blocks - i0_blocks);\n\tcase 2:\n\t\treturn i1_blocks + hash % (i2_blocks - i1_blocks);\n\tcase 3:\n\t\treturn i2_blocks + hash % (i3_blocks - i2_blocks);\n\tcase 4 ... 19:\n\t\treturn i3_blocks + 16 * (hash % (((1<<31) - i3_blocks) / 16))\n\t\t\t+ round - 4;\n\t}\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_32",
          "args": [
            "dentry->d_name.name",
            "dentry->d_name.len",
            "0"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "hash_32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "98-106",
          "snippet": "static u32 hash_32(const char *s, int len, u32 seed)\n{\n\tu32 hash = seed;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\thash = hash * 293 + s[i];\n\treturn hash;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic u32 hash_32(const char *s, int len, u32 seed)\n{\n\tu32 hash = seed;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\thash = hash * 293 + s[i];\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_dir(struct inode *dir, struct dentry *dentry,\n\t\tstruct inode *inode)\n{\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\tu32 hash = hash_32(dentry->d_name.name, dentry->d_name.len, 0);\n\tpgoff_t index;\n\tint round, err;\n\n\tfor (round = 0; round < 20; round++) {\n\t\tindex = hash_index(hash, round);\n\n\t\tif (logfs_exist_block(dir, index))\n\t\t\tcontinue;\n\t\tpage = find_or_create_page(dir->i_mapping, index, GFP_KERNEL);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tdd = kmap_atomic(page);\n\t\tmemset(dd, 0, sizeof(*dd));\n\t\tdd->ino = cpu_to_be64(inode->i_ino);\n\t\tdd->type = logfs_type(inode);\n\t\tlogfs_set_name(dd, &dentry->d_name);\n\t\tkunmap_atomic(dd);\n\n\t\terr = logfs_write_buf(dir, page, WF_LOCK);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (!err)\n\t\t\tgrow_dir(dir, index);\n\t\treturn err;\n\t}\n\t/* FIXME: Is there a better return value?  In most cases neither\n\t * the filesystem nor the directory are full.  But we have had\n\t * too many collisions for this particular hash and no fallback.\n\t */\n\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "grow_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "361-366",
    "snippet": "static void grow_dir(struct inode *dir, loff_t index)\n{\n\tindex = (index + 1) << dir->i_sb->s_blocksize_bits;\n\tif (i_size_read(dir) < index)\n\t\ti_size_write(dir, index);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "dir",
            "index"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void grow_dir(struct inode *dir, loff_t index)\n{\n\tindex = (index + 1) << dir->i_sb->s_blocksize_bits;\n\tif (i_size_read(dir) < index)\n\t\ti_size_write(dir, index);\n}"
  },
  {
    "function_name": "logfs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "332-359",
    "snippet": "static struct dentry *logfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\tunsigned int flags)\n{\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\tpgoff_t index;\n\tu64 ino = 0;\n\tstruct inode *inode;\n\n\tpage = logfs_get_dd_page(dir, dentry);\n\tif (IS_ERR(page))\n\t\treturn ERR_CAST(page);\n\tif (!page) {\n\t\td_add(dentry, NULL);\n\t\treturn NULL;\n\t}\n\tindex = page->index;\n\tdd = kmap_atomic(page);\n\tino = be64_to_cpu(dd->ino);\n\tkunmap_atomic(dd);\n\tpage_cache_release(page);\n\n\tinode = logfs_iget(dir->i_sb, ino);\n\tif (IS_ERR(inode))\n\t\tprintk(KERN_ERR\"LogFS: Cannot read inode #%llx for dentry (%lx, %lx)n\",\n\t\t\t\tino, dir->i_ino, index);\n\treturn d_splice_alias(inode, dentry);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\"LogFS: Cannot read inode #%llx for dentry (%lx, %lx)n\"",
            "ino",
            "dir->i_ino",
            "index"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_iget",
          "args": [
            "dir->i_sb",
            "ino"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "109-114",
          "snippet": "struct inode *logfs_iget(struct super_block *sb, ino_t ino)\n{\n\tBUG_ON(ino == LOGFS_INO_MASTER);\n\tBUG_ON(ino == LOGFS_INO_SEGFILE);\n\treturn __logfs_iget(sb, ino);\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstruct inode *logfs_iget(struct super_block *sb, ino_t ino)\n{\n\tBUG_ON(ino == LOGFS_INO_MASTER);\n\tBUG_ON(ino == LOGFS_INO_SEGFILE);\n\treturn __logfs_iget(sb, ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "dd"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dd->ino"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "NULL"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "page"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_dd_page",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_dd_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "157-194",
          "snippet": "static struct page *logfs_get_dd_page(struct inode *dir, struct dentry *dentry)\n{\n\tstruct qstr *name = &dentry->d_name;\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\tu32 hash = hash_32(name->name, name->len, 0);\n\tpgoff_t index;\n\tint round;\n\n\tif (name->len > LOGFS_MAX_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tfor (round = 0; round < 20; round++) {\n\t\tindex = hash_index(hash, round);\n\n\t\tif (beyond_eof(dir, index))\n\t\t\treturn NULL;\n\t\tif (!logfs_exist_block(dir, index))\n\t\t\tcontinue;\n\t\tpage = read_cache_page(dir->i_mapping, index,\n\t\t\t\t(filler_t *)logfs_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\t\tdd = kmap_atomic(page);\n\t\tBUG_ON(dd->namelen == 0);\n\n\t\tif (name->len != be16_to_cpu(dd->namelen) ||\n\t\t\t\tmemcmp(name->name, dd->name, name->len)) {\n\t\t\tkunmap_atomic(dd);\n\t\t\tpage_cache_release(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkunmap_atomic(dd);\n\t\treturn page;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_dd_page(struct inode *dir, struct dentry *dentry)\n{\n\tstruct qstr *name = &dentry->d_name;\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\tu32 hash = hash_32(name->name, name->len, 0);\n\tpgoff_t index;\n\tint round;\n\n\tif (name->len > LOGFS_MAX_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tfor (round = 0; round < 20; round++) {\n\t\tindex = hash_index(hash, round);\n\n\t\tif (beyond_eof(dir, index))\n\t\t\treturn NULL;\n\t\tif (!logfs_exist_block(dir, index))\n\t\t\tcontinue;\n\t\tpage = read_cache_page(dir->i_mapping, index,\n\t\t\t\t(filler_t *)logfs_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\t\tdd = kmap_atomic(page);\n\t\tBUG_ON(dd->namelen == 0);\n\n\t\tif (name->len != be16_to_cpu(dd->namelen) ||\n\t\t\t\tmemcmp(name->name, dd->name, name->len)) {\n\t\t\tkunmap_atomic(dd);\n\t\t\tpage_cache_release(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkunmap_atomic(dd);\n\t\treturn page;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct dentry *logfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\tunsigned int flags)\n{\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\tpgoff_t index;\n\tu64 ino = 0;\n\tstruct inode *inode;\n\n\tpage = logfs_get_dd_page(dir, dentry);\n\tif (IS_ERR(page))\n\t\treturn ERR_CAST(page);\n\tif (!page) {\n\t\td_add(dentry, NULL);\n\t\treturn NULL;\n\t}\n\tindex = page->index;\n\tdd = kmap_atomic(page);\n\tino = be64_to_cpu(dd->ino);\n\tkunmap_atomic(dd);\n\tpage_cache_release(page);\n\n\tinode = logfs_iget(dir->i_sb, ino);\n\tif (IS_ERR(inode))\n\t\tprintk(KERN_ERR\"LogFS: Cannot read inode #%llx for dentry (%lx, %lx)n\",\n\t\t\t\tino, dir->i_ino, index);\n\treturn d_splice_alias(inode, dentry);\n}"
  },
  {
    "function_name": "logfs_set_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "326-330",
    "snippet": "static void logfs_set_name(struct logfs_disk_dentry *dd, struct qstr *name)\n{\n\tdd->namelen = cpu_to_be16(name->len);\n\tmemcpy(dd->name, name->name, name->len);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dd->name",
            "name->name",
            "name->len"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "name->len"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_set_name(struct logfs_disk_dentry *dd, struct qstr *name)\n{\n\tdd->namelen = cpu_to_be16(name->len);\n\tmemcpy(dd->name, name->name, name->len);\n}"
  },
  {
    "function_name": "logfs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "284-324",
    "snippet": "static int logfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *dir = file_inode(file);\n\tloff_t pos;\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\n\tif (ctx->pos < 0)\n\t\treturn -EINVAL;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\tpos = ctx->pos - 2;\n\tBUG_ON(pos < 0);\n\tfor (;; pos++, ctx->pos++) {\n\t\tbool full;\n\t\tif (beyond_eof(dir, pos))\n\t\t\tbreak;\n\t\tif (!logfs_exist_block(dir, pos)) {\n\t\t\t/* deleted dentry */\n\t\t\tpos = dir_seek_data(dir, pos);\n\t\t\tcontinue;\n\t\t}\n\t\tpage = read_cache_page(dir->i_mapping, pos,\n\t\t\t\t(filler_t *)logfs_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tdd = kmap(page);\n\t\tBUG_ON(dd->namelen == 0);\n\n\t\tfull = !dir_emit(ctx, (char *)dd->name,\n\t\t\t\tbe16_to_cpu(dd->namelen),\n\t\t\t\tbe64_to_cpu(dd->ino), dd->type);\n\t\tkunmap(page);\n\t\tpage_cache_release(page);\n\t\tif (full)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "(char *)dd->name",
            "be16_to_cpu(dd->namelen)",
            "be64_to_cpu(dd->ino)",
            "dd->type"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dd->ino"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dd->namelen"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dd->namelen == 0"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cache_page",
          "args": [
            "dir->i_mapping",
            "pos",
            "(filler_t *)logfs_readpage",
            "NULL"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_seek_data",
          "args": [
            "dir",
            "pos"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "dir_seek_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "77-82",
          "snippet": "static s64 dir_seek_data(struct inode *inode, s64 pos)\n{\n\ts64 new_pos = logfs_seek_data(inode, pos);\n\n\treturn max(pos, new_pos - 1);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic s64 dir_seek_data(struct inode *inode, s64 pos)\n{\n\ts64 new_pos = logfs_seek_data(inode, pos);\n\n\treturn max(pos, new_pos - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_exist_block",
          "args": [
            "dir",
            "pos"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_exist_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "810-817",
          "snippet": "int logfs_exist_block(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (bix < I0_BLOCKS)\n\t\treturn !!li->li_data[bix];\n\treturn logfs_exist_loop(inode, bix);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_exist_block(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (bix < I0_BLOCKS)\n\t\treturn !!li->li_data[bix];\n\treturn logfs_exist_loop(inode, bix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "beyond_eof",
          "args": [
            "dir",
            "pos"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "beyond_eof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "84-88",
          "snippet": "static int beyond_eof(struct inode *inode, loff_t bix)\n{\n\tloff_t pos = bix << inode->i_sb->s_blocksize_bits;\n\treturn pos >= i_size_read(inode);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int beyond_eof(struct inode *inode, loff_t bix)\n{\n\tloff_t pos = bix << inode->i_sb->s_blocksize_bits;\n\treturn pos >= i_size_read(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pos < 0"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit_dots",
          "args": [
            "file",
            "ctx"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *dir = file_inode(file);\n\tloff_t pos;\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\n\tif (ctx->pos < 0)\n\t\treturn -EINVAL;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\tpos = ctx->pos - 2;\n\tBUG_ON(pos < 0);\n\tfor (;; pos++, ctx->pos++) {\n\t\tbool full;\n\t\tif (beyond_eof(dir, pos))\n\t\t\tbreak;\n\t\tif (!logfs_exist_block(dir, pos)) {\n\t\t\t/* deleted dentry */\n\t\t\tpos = dir_seek_data(dir, pos);\n\t\t\tcontinue;\n\t\t}\n\t\tpage = read_cache_page(dir->i_mapping, pos,\n\t\t\t\t(filler_t *)logfs_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tdd = kmap(page);\n\t\tBUG_ON(dd->namelen == 0);\n\n\t\tfull = !dir_emit(ctx, (char *)dd->name,\n\t\t\t\tbe16_to_cpu(dd->namelen),\n\t\t\t\tbe64_to_cpu(dd->ino), dd->type);\n\t\tkunmap(page);\n\t\tpage_cache_release(page);\n\t\tif (full)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "272-280",
    "snippet": "static int logfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (!logfs_empty_dir(inode))\n\t\treturn -ENOTEMPTY;\n\n\treturn logfs_unlink(dir, dentry);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_unlink",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "213-262",
          "snippet": "static int logfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct logfs_super *super = logfs_super(dir->i_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tstruct logfs_transaction *ta;\n\tstruct page *page;\n\tpgoff_t index;\n\tint ret;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta)\n\t\treturn -ENOMEM;\n\n\tta->state = UNLINK_1;\n\tta->ino = inode->i_ino;\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\tpage = logfs_get_dd_page(dir, dentry);\n\tif (!page) {\n\t\tkfree(ta);\n\t\treturn -ENOENT;\n\t}\n\tif (IS_ERR(page)) {\n\t\tkfree(ta);\n\t\treturn PTR_ERR(page);\n\t}\n\tindex = page->index;\n\tpage_cache_release(page);\n\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(dir, ta);\n\n\tret = logfs_delete(dir, index, NULL);\n\tif (!ret)\n\t\tret = write_inode(dir);\n\n\tif (ret) {\n\t\tabort_transaction(dir, ta);\n\t\tprintk(KERN_ERR\"LOGFS: unable to delete inode\\n\");\n\t\tgoto out;\n\t}\n\n\tta->state = UNLINK_2;\n\tlogfs_add_transaction(inode, ta);\n\tret = logfs_remove_inode(inode);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct logfs_super *super = logfs_super(dir->i_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tstruct logfs_transaction *ta;\n\tstruct page *page;\n\tpgoff_t index;\n\tint ret;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta)\n\t\treturn -ENOMEM;\n\n\tta->state = UNLINK_1;\n\tta->ino = inode->i_ino;\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\tpage = logfs_get_dd_page(dir, dentry);\n\tif (!page) {\n\t\tkfree(ta);\n\t\treturn -ENOENT;\n\t}\n\tif (IS_ERR(page)) {\n\t\tkfree(ta);\n\t\treturn PTR_ERR(page);\n\t}\n\tindex = page->index;\n\tpage_cache_release(page);\n\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(dir, ta);\n\n\tret = logfs_delete(dir, index, NULL);\n\tif (!ret)\n\t\tret = write_inode(dir);\n\n\tif (ret) {\n\t\tabort_transaction(dir, ta);\n\t\tprintk(KERN_ERR\"LOGFS: unable to delete inode\\n\");\n\t\tgoto out;\n\t}\n\n\tta->state = UNLINK_2;\n\tlogfs_add_transaction(inode, ta);\n\tret = logfs_remove_inode(inode);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_empty_dir",
          "args": [
            "inode"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "264-270",
          "snippet": "static inline int logfs_empty_dir(struct inode *dir)\n{\n\tu64 data;\n\n\tdata = logfs_seek_data(dir, 0) << dir->i_sb->s_blocksize_bits;\n\treturn data >= i_size_read(dir);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic inline int logfs_empty_dir(struct inode *dir)\n{\n\tu64 data;\n\n\tdata = logfs_seek_data(dir, 0) << dir->i_sb->s_blocksize_bits;\n\treturn data >= i_size_read(dir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (!logfs_empty_dir(inode))\n\t\treturn -ENOTEMPTY;\n\n\treturn logfs_unlink(dir, dentry);\n}"
  },
  {
    "function_name": "logfs_empty_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "264-270",
    "snippet": "static inline int logfs_empty_dir(struct inode *dir)\n{\n\tu64 data;\n\n\tdata = logfs_seek_data(dir, 0) << dir->i_sb->s_blocksize_bits;\n\treturn data >= i_size_read(dir);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_seek_data",
          "args": [
            "dir",
            "0"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_seek_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "944-954",
          "snippet": "u64 logfs_seek_data(struct inode *inode, u64 bix)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu64 ret, end;\n\n\tret = __logfs_seek_data(inode, bix);\n\tend = i_size_read(inode) >> sb->s_blocksize_bits;\n\tif (ret >= end)\n\t\tret = max(bix, end);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nu64 logfs_seek_data(struct inode *inode, u64 bix)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu64 ret, end;\n\n\tret = __logfs_seek_data(inode, bix);\n\tend = i_size_read(inode) >> sb->s_blocksize_bits;\n\tif (ret >= end)\n\t\tret = max(bix, end);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic inline int logfs_empty_dir(struct inode *dir)\n{\n\tu64 data;\n\n\tdata = logfs_seek_data(dir, 0) << dir->i_sb->s_blocksize_bits;\n\treturn data >= i_size_read(dir);\n}"
  },
  {
    "function_name": "logfs_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "213-262",
    "snippet": "static int logfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct logfs_super *super = logfs_super(dir->i_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tstruct logfs_transaction *ta;\n\tstruct page *page;\n\tpgoff_t index;\n\tint ret;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta)\n\t\treturn -ENOMEM;\n\n\tta->state = UNLINK_1;\n\tta->ino = inode->i_ino;\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\tpage = logfs_get_dd_page(dir, dentry);\n\tif (!page) {\n\t\tkfree(ta);\n\t\treturn -ENOENT;\n\t}\n\tif (IS_ERR(page)) {\n\t\tkfree(ta);\n\t\treturn PTR_ERR(page);\n\t}\n\tindex = page->index;\n\tpage_cache_release(page);\n\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(dir, ta);\n\n\tret = logfs_delete(dir, index, NULL);\n\tif (!ret)\n\t\tret = write_inode(dir);\n\n\tif (ret) {\n\t\tabort_transaction(dir, ta);\n\t\tprintk(KERN_ERR\"LOGFS: unable to delete inode\\n\");\n\t\tgoto out;\n\t}\n\n\tta->state = UNLINK_2;\n\tlogfs_add_transaction(inode, ta);\n\tret = logfs_remove_inode(inode);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&super->s_dirop_mutex"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_remove_inode",
          "args": [
            "inode"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_remove_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "196-204",
          "snippet": "static int logfs_remove_inode(struct inode *inode)\n{\n\tint ret;\n\n\tdrop_nlink(inode);\n\tret = write_inode(inode);\n\tLOGFS_BUG_ON(ret, inode->i_sb);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_remove_inode(struct inode *inode)\n{\n\tint ret;\n\n\tdrop_nlink(inode);\n\tret = write_inode(inode);\n\tLOGFS_BUG_ON(ret, inode->i_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_add_transaction",
          "args": [
            "inode",
            "ta"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_add_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1495-1499",
          "snippet": "void logfs_add_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\talloc_inode_block(inode);\n\tlogfs_inode(inode)->li_block->ta = ta;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_add_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\talloc_inode_block(inode);\n\tlogfs_inode(inode)->li_block->ta = ta;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\"LOGFS: unable to delete inode\\n\""
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "abort_transaction",
          "args": [
            "dir",
            "ta"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "abort_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "206-211",
          "snippet": "static void abort_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\tif (logfs_inode(inode)->li_block)\n\t\tlogfs_inode(inode)->li_block->ta = NULL;\n\tkfree(ta);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void abort_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\tif (logfs_inode(inode)->li_block)\n\t\tlogfs_inode(inode)->li_block->ta = NULL;\n\tkfree(ta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_inode",
          "args": [
            "dir"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "72-75",
          "snippet": "static int write_inode(struct inode *inode)\n{\n\treturn __logfs_write_inode(inode, NULL, WF_LOCK);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int write_inode(struct inode *inode)\n{\n\treturn __logfs_write_inode(inode, NULL, WF_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_delete",
          "args": [
            "dir",
            "index",
            "NULL"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1591-1609",
          "snippet": "int logfs_delete(struct inode *inode, pgoff_t index,\n\t\tstruct shadow_tree *shadow_tree)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct page *page;\n\tint ret;\n\n\tpage = logfs_get_read_page(inode, index, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tlogfs_get_wblocks(sb, page, 1);\n\tret = __logfs_delete(inode, page);\n\tlogfs_put_wblocks(sb, page, 1);\n\n\tlogfs_put_read_page(page);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_delete(struct inode *inode, pgoff_t index,\n\t\tstruct shadow_tree *shadow_tree)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct page *page;\n\tint ret;\n\n\tpage = logfs_get_read_page(inode, index, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tlogfs_get_wblocks(sb, page, 1);\n\tret = __logfs_delete(inode, page);\n\tlogfs_put_wblocks(sb, page, 1);\n\n\tlogfs_put_read_page(page);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&super->s_dirop_mutex"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ta"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ta"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_dd_page",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_dd_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "157-194",
          "snippet": "static struct page *logfs_get_dd_page(struct inode *dir, struct dentry *dentry)\n{\n\tstruct qstr *name = &dentry->d_name;\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\tu32 hash = hash_32(name->name, name->len, 0);\n\tpgoff_t index;\n\tint round;\n\n\tif (name->len > LOGFS_MAX_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tfor (round = 0; round < 20; round++) {\n\t\tindex = hash_index(hash, round);\n\n\t\tif (beyond_eof(dir, index))\n\t\t\treturn NULL;\n\t\tif (!logfs_exist_block(dir, index))\n\t\t\tcontinue;\n\t\tpage = read_cache_page(dir->i_mapping, index,\n\t\t\t\t(filler_t *)logfs_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\t\tdd = kmap_atomic(page);\n\t\tBUG_ON(dd->namelen == 0);\n\n\t\tif (name->len != be16_to_cpu(dd->namelen) ||\n\t\t\t\tmemcmp(name->name, dd->name, name->len)) {\n\t\t\tkunmap_atomic(dd);\n\t\t\tpage_cache_release(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkunmap_atomic(dd);\n\t\treturn page;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_dd_page(struct inode *dir, struct dentry *dentry)\n{\n\tstruct qstr *name = &dentry->d_name;\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\tu32 hash = hash_32(name->name, name->len, 0);\n\tpgoff_t index;\n\tint round;\n\n\tif (name->len > LOGFS_MAX_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tfor (round = 0; round < 20; round++) {\n\t\tindex = hash_index(hash, round);\n\n\t\tif (beyond_eof(dir, index))\n\t\t\treturn NULL;\n\t\tif (!logfs_exist_block(dir, index))\n\t\t\tcontinue;\n\t\tpage = read_cache_page(dir->i_mapping, index,\n\t\t\t\t(filler_t *)logfs_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\t\tdd = kmap_atomic(page);\n\t\tBUG_ON(dd->namelen == 0);\n\n\t\tif (name->len != be16_to_cpu(dd->namelen) ||\n\t\t\t\tmemcmp(name->name, dd->name, name->len)) {\n\t\t\tkunmap_atomic(dd);\n\t\t\tpage_cache_release(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkunmap_atomic(dd);\n\t\treturn page;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ta)",
            "GFP_KERNEL"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "dir->i_sb"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct logfs_super *super = logfs_super(dir->i_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tstruct logfs_transaction *ta;\n\tstruct page *page;\n\tpgoff_t index;\n\tint ret;\n\n\tta = kzalloc(sizeof(*ta), GFP_KERNEL);\n\tif (!ta)\n\t\treturn -ENOMEM;\n\n\tta->state = UNLINK_1;\n\tta->ino = inode->i_ino;\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\tpage = logfs_get_dd_page(dir, dentry);\n\tif (!page) {\n\t\tkfree(ta);\n\t\treturn -ENOENT;\n\t}\n\tif (IS_ERR(page)) {\n\t\tkfree(ta);\n\t\treturn PTR_ERR(page);\n\t}\n\tindex = page->index;\n\tpage_cache_release(page);\n\n\tmutex_lock(&super->s_dirop_mutex);\n\tlogfs_add_transaction(dir, ta);\n\n\tret = logfs_delete(dir, index, NULL);\n\tif (!ret)\n\t\tret = write_inode(dir);\n\n\tif (ret) {\n\t\tabort_transaction(dir, ta);\n\t\tprintk(KERN_ERR\"LOGFS: unable to delete inode\\n\");\n\t\tgoto out;\n\t}\n\n\tta->state = UNLINK_2;\n\tlogfs_add_transaction(inode, ta);\n\tret = logfs_remove_inode(inode);\nout:\n\tmutex_unlock(&super->s_dirop_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "abort_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "206-211",
    "snippet": "static void abort_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\tif (logfs_inode(inode)->li_block)\n\t\tlogfs_inode(inode)->li_block->ta = NULL;\n\tkfree(ta);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ta"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void abort_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\tif (logfs_inode(inode)->li_block)\n\t\tlogfs_inode(inode)->li_block->ta = NULL;\n\tkfree(ta);\n}"
  },
  {
    "function_name": "logfs_remove_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "196-204",
    "snippet": "static int logfs_remove_inode(struct inode *inode)\n{\n\tint ret;\n\n\tdrop_nlink(inode);\n\tret = write_inode(inode);\n\tLOGFS_BUG_ON(ret, inode->i_sb);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOGFS_BUG_ON",
          "args": [
            "ret",
            "inode->i_sb"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_inode",
          "args": [
            "inode"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "72-75",
          "snippet": "static int write_inode(struct inode *inode)\n{\n\treturn __logfs_write_inode(inode, NULL, WF_LOCK);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int write_inode(struct inode *inode)\n{\n\treturn __logfs_write_inode(inode, NULL, WF_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "127-131",
          "snippet": "static inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_remove_inode(struct inode *inode)\n{\n\tint ret;\n\n\tdrop_nlink(inode);\n\tret = write_inode(inode);\n\tLOGFS_BUG_ON(ret, inode->i_sb);\n\treturn ret;\n}"
  },
  {
    "function_name": "logfs_get_dd_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "157-194",
    "snippet": "static struct page *logfs_get_dd_page(struct inode *dir, struct dentry *dentry)\n{\n\tstruct qstr *name = &dentry->d_name;\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\tu32 hash = hash_32(name->name, name->len, 0);\n\tpgoff_t index;\n\tint round;\n\n\tif (name->len > LOGFS_MAX_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tfor (round = 0; round < 20; round++) {\n\t\tindex = hash_index(hash, round);\n\n\t\tif (beyond_eof(dir, index))\n\t\t\treturn NULL;\n\t\tif (!logfs_exist_block(dir, index))\n\t\t\tcontinue;\n\t\tpage = read_cache_page(dir->i_mapping, index,\n\t\t\t\t(filler_t *)logfs_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\t\tdd = kmap_atomic(page);\n\t\tBUG_ON(dd->namelen == 0);\n\n\t\tif (name->len != be16_to_cpu(dd->namelen) ||\n\t\t\t\tmemcmp(name->name, dd->name, name->len)) {\n\t\t\tkunmap_atomic(dd);\n\t\t\tpage_cache_release(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkunmap_atomic(dd);\n\t\treturn page;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "dd"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "dd"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name->name",
            "dd->name",
            "name->len"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dd->namelen"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dd->namelen == 0"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cache_page",
          "args": [
            "dir->i_mapping",
            "index",
            "(filler_t *)logfs_readpage",
            "NULL"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_exist_block",
          "args": [
            "dir",
            "index"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_exist_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "810-817",
          "snippet": "int logfs_exist_block(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (bix < I0_BLOCKS)\n\t\treturn !!li->li_data[bix];\n\treturn logfs_exist_loop(inode, bix);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_exist_block(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (bix < I0_BLOCKS)\n\t\treturn !!li->li_data[bix];\n\treturn logfs_exist_loop(inode, bix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "beyond_eof",
          "args": [
            "dir",
            "index"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "beyond_eof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "84-88",
          "snippet": "static int beyond_eof(struct inode *inode, loff_t bix)\n{\n\tloff_t pos = bix << inode->i_sb->s_blocksize_bits;\n\treturn pos >= i_size_read(inode);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int beyond_eof(struct inode *inode, loff_t bix)\n{\n\tloff_t pos = bix << inode->i_sb->s_blocksize_bits;\n\treturn pos >= i_size_read(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_index",
          "args": [
            "hash",
            "round"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "hash_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "134-155",
          "snippet": "static pgoff_t hash_index(u32 hash, int round)\n{\n\tu32 i0_blocks = I0_BLOCKS;\n\tu32 i1_blocks = I1_BLOCKS;\n\tu32 i2_blocks = I2_BLOCKS;\n\tu32 i3_blocks = I3_BLOCKS;\n\n\tswitch (round) {\n\tcase 0:\n\t\treturn hash % i0_blocks;\n\tcase 1:\n\t\treturn i0_blocks + hash % (i1_blocks - i0_blocks);\n\tcase 2:\n\t\treturn i1_blocks + hash % (i2_blocks - i1_blocks);\n\tcase 3:\n\t\treturn i2_blocks + hash % (i3_blocks - i2_blocks);\n\tcase 4 ... 19:\n\t\treturn i3_blocks + 16 * (hash % (((1<<31) - i3_blocks) / 16))\n\t\t\t+ round - 4;\n\t}\n\tBUG();\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic pgoff_t hash_index(u32 hash, int round)\n{\n\tu32 i0_blocks = I0_BLOCKS;\n\tu32 i1_blocks = I1_BLOCKS;\n\tu32 i2_blocks = I2_BLOCKS;\n\tu32 i3_blocks = I3_BLOCKS;\n\n\tswitch (round) {\n\tcase 0:\n\t\treturn hash % i0_blocks;\n\tcase 1:\n\t\treturn i0_blocks + hash % (i1_blocks - i0_blocks);\n\tcase 2:\n\t\treturn i1_blocks + hash % (i2_blocks - i1_blocks);\n\tcase 3:\n\t\treturn i2_blocks + hash % (i3_blocks - i2_blocks);\n\tcase 4 ... 19:\n\t\treturn i3_blocks + 16 * (hash % (((1<<31) - i3_blocks) / 16))\n\t\t\t+ round - 4;\n\t}\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_32",
          "args": [
            "name->name",
            "name->len",
            "0"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "hash_32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "98-106",
          "snippet": "static u32 hash_32(const char *s, int len, u32 seed)\n{\n\tu32 hash = seed;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\thash = hash * 293 + s[i];\n\treturn hash;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic u32 hash_32(const char *s, int len, u32 seed)\n{\n\tu32 hash = seed;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\thash = hash * 293 + s[i];\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_dd_page(struct inode *dir, struct dentry *dentry)\n{\n\tstruct qstr *name = &dentry->d_name;\n\tstruct page *page;\n\tstruct logfs_disk_dentry *dd;\n\tu32 hash = hash_32(name->name, name->len, 0);\n\tpgoff_t index;\n\tint round;\n\n\tif (name->len > LOGFS_MAX_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tfor (round = 0; round < 20; round++) {\n\t\tindex = hash_index(hash, round);\n\n\t\tif (beyond_eof(dir, index))\n\t\t\treturn NULL;\n\t\tif (!logfs_exist_block(dir, index))\n\t\t\tcontinue;\n\t\tpage = read_cache_page(dir->i_mapping, index,\n\t\t\t\t(filler_t *)logfs_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\t\tdd = kmap_atomic(page);\n\t\tBUG_ON(dd->namelen == 0);\n\n\t\tif (name->len != be16_to_cpu(dd->namelen) ||\n\t\t\t\tmemcmp(name->name, dd->name, name->len)) {\n\t\t\tkunmap_atomic(dd);\n\t\t\tpage_cache_release(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkunmap_atomic(dd);\n\t\treturn page;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "hash_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "134-155",
    "snippet": "static pgoff_t hash_index(u32 hash, int round)\n{\n\tu32 i0_blocks = I0_BLOCKS;\n\tu32 i1_blocks = I1_BLOCKS;\n\tu32 i2_blocks = I2_BLOCKS;\n\tu32 i3_blocks = I3_BLOCKS;\n\n\tswitch (round) {\n\tcase 0:\n\t\treturn hash % i0_blocks;\n\tcase 1:\n\t\treturn i0_blocks + hash % (i1_blocks - i0_blocks);\n\tcase 2:\n\t\treturn i1_blocks + hash % (i2_blocks - i1_blocks);\n\tcase 3:\n\t\treturn i2_blocks + hash % (i3_blocks - i2_blocks);\n\tcase 4 ... 19:\n\t\treturn i3_blocks + 16 * (hash % (((1<<31) - i3_blocks) / 16))\n\t\t\t+ round - 4;\n\t}\n\tBUG();\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic pgoff_t hash_index(u32 hash, int round)\n{\n\tu32 i0_blocks = I0_BLOCKS;\n\tu32 i1_blocks = I1_BLOCKS;\n\tu32 i2_blocks = I2_BLOCKS;\n\tu32 i3_blocks = I3_BLOCKS;\n\n\tswitch (round) {\n\tcase 0:\n\t\treturn hash % i0_blocks;\n\tcase 1:\n\t\treturn i0_blocks + hash % (i1_blocks - i0_blocks);\n\tcase 2:\n\t\treturn i1_blocks + hash % (i2_blocks - i1_blocks);\n\tcase 3:\n\t\treturn i2_blocks + hash % (i3_blocks - i2_blocks);\n\tcase 4 ... 19:\n\t\treturn i3_blocks + 16 * (hash % (((1<<31) - i3_blocks) / 16))\n\t\t\t+ round - 4;\n\t}\n\tBUG();\n}"
  },
  {
    "function_name": "hash_32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "98-106",
    "snippet": "static u32 hash_32(const char *s, int len, u32 seed)\n{\n\tu32 hash = seed;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\thash = hash * 293 + s[i];\n\treturn hash;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic u32 hash_32(const char *s, int len, u32 seed)\n{\n\tu32 hash = seed;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\thash = hash * 293 + s[i];\n\treturn hash;\n}"
  },
  {
    "function_name": "beyond_eof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "84-88",
    "snippet": "static int beyond_eof(struct inode *inode, loff_t bix)\n{\n\tloff_t pos = bix << inode->i_sb->s_blocksize_bits;\n\treturn pos >= i_size_read(inode);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int beyond_eof(struct inode *inode, loff_t bix)\n{\n\tloff_t pos = bix << inode->i_sb->s_blocksize_bits;\n\treturn pos >= i_size_read(inode);\n}"
  },
  {
    "function_name": "dir_seek_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "77-82",
    "snippet": "static s64 dir_seek_data(struct inode *inode, s64 pos)\n{\n\ts64 new_pos = logfs_seek_data(inode, pos);\n\n\treturn max(pos, new_pos - 1);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "pos",
            "new_pos - 1"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_max_rec_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1212-1238",
          "snippet": "static int ocfs2_find_max_rec_len(struct super_block *sb,\n\t\t\t\t  struct buffer_head *dirblock_bh)\n{\n\tint size, this_hole, largest_hole = 0;\n\tchar *trailer, *de_buf, *limit, *start = dirblock_bh->b_data;\n\tstruct ocfs2_dir_entry *de;\n\n\ttrailer = (char *)ocfs2_trailer_from_bh(dirblock_bh, sb);\n\tsize = ocfs2_dir_trailer_blk_off(sb);\n\tlimit = start + size;\n\tde_buf = start;\n\tde = (struct ocfs2_dir_entry *)de_buf;\n\tdo {\n\t\tif (de_buf != trailer) {\n\t\t\tthis_hole = ocfs2_figure_dirent_hole(de);\n\t\t\tif (this_hole > largest_hole)\n\t\t\t\tlargest_hole = this_hole;\n\t\t}\n\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\t} while (de_buf < limit);\n\n\tif (largest_hole >= OCFS2_DIR_MIN_REC_LEN)\n\t\treturn largest_hole;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_find_max_rec_len(struct super_block *sb,\n\t\t\t\t  struct buffer_head *dirblock_bh)\n{\n\tint size, this_hole, largest_hole = 0;\n\tchar *trailer, *de_buf, *limit, *start = dirblock_bh->b_data;\n\tstruct ocfs2_dir_entry *de;\n\n\ttrailer = (char *)ocfs2_trailer_from_bh(dirblock_bh, sb);\n\tsize = ocfs2_dir_trailer_blk_off(sb);\n\tlimit = start + size;\n\tde_buf = start;\n\tde = (struct ocfs2_dir_entry *)de_buf;\n\tdo {\n\t\tif (de_buf != trailer) {\n\t\t\tthis_hole = ocfs2_figure_dirent_hole(de);\n\t\t\tif (this_hole > largest_hole)\n\t\t\t\tlargest_hole = this_hole;\n\t\t}\n\n\t\tde_buf += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *)de_buf;\n\t} while (de_buf < limit);\n\n\tif (largest_hole >= OCFS2_DIR_MIN_REC_LEN)\n\t\treturn largest_hole;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_seek_data",
          "args": [
            "inode",
            "pos"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_seek_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "944-954",
          "snippet": "u64 logfs_seek_data(struct inode *inode, u64 bix)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu64 ret, end;\n\n\tret = __logfs_seek_data(inode, bix);\n\tend = i_size_read(inode) >> sb->s_blocksize_bits;\n\tif (ret >= end)\n\t\tret = max(bix, end);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nu64 logfs_seek_data(struct inode *inode, u64 bix)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu64 ret, end;\n\n\tret = __logfs_seek_data(inode, bix);\n\tend = i_size_read(inode) >> sb->s_blocksize_bits;\n\tif (ret >= end)\n\t\tret = max(bix, end);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic s64 dir_seek_data(struct inode *inode, s64 pos)\n{\n\ts64 new_pos = logfs_seek_data(inode, pos);\n\n\treturn max(pos, new_pos - 1);\n}"
  },
  {
    "function_name": "write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "72-75",
    "snippet": "static int write_inode(struct inode *inode)\n{\n\treturn __logfs_write_inode(inode, NULL, WF_LOCK);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__logfs_write_inode",
          "args": [
            "inode",
            "NULL",
            "WF_LOCK"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2132-2141",
          "snippet": "int __logfs_write_inode(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = do_write_inode(inode);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint __logfs_write_inode(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = do_write_inode(inode);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int write_inode(struct inode *inode)\n{\n\treturn __logfs_write_inode(inode, NULL, WF_LOCK);\n}"
  },
  {
    "function_name": "write_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
    "lines": "66-70",
    "snippet": "static int write_dir(struct inode *dir, struct logfs_disk_dentry *dd,\n\t\tloff_t pos)\n{\n\treturn logfs_inode_write(dir, dd, sizeof(*dd), pos, WF_LOCK, NULL);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_inode_write",
          "args": [
            "dir",
            "dd",
            "sizeof(*dd)",
            "pos",
            "WF_LOCK",
            "NULL"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2238-2263",
          "snippet": "int logfs_inode_write(struct inode *inode, const void *buf, size_t count,\n\t\tloff_t bix, long flags, struct shadow_tree *shadow_tree)\n{\n\tloff_t pos = bix << inode->i_sb->s_blocksize_bits;\n\tint err;\n\tstruct page *page;\n\tvoid *pagebuf;\n\n\tBUG_ON(pos & (LOGFS_BLOCKSIZE-1));\n\tBUG_ON(count > LOGFS_BLOCKSIZE);\n\tpage = logfs_get_write_page(inode, bix, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tpagebuf = kmap_atomic(page);\n\tmemcpy(pagebuf, buf, count);\n\tflush_dcache_page(page);\n\tkunmap_atomic(pagebuf);\n\n\tif (i_size_read(inode) < pos + LOGFS_BLOCKSIZE)\n\t\ti_size_write(inode, pos + LOGFS_BLOCKSIZE);\n\n\terr = logfs_write_buf(inode, page, flags);\n\tlogfs_put_write_page(page);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_inode_write(struct inode *inode, const void *buf, size_t count,\n\t\tloff_t bix, long flags, struct shadow_tree *shadow_tree)\n{\n\tloff_t pos = bix << inode->i_sb->s_blocksize_bits;\n\tint err;\n\tstruct page *page;\n\tvoid *pagebuf;\n\n\tBUG_ON(pos & (LOGFS_BLOCKSIZE-1));\n\tBUG_ON(count > LOGFS_BLOCKSIZE);\n\tpage = logfs_get_write_page(inode, bix, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tpagebuf = kmap_atomic(page);\n\tmemcpy(pagebuf, buf, count);\n\tflush_dcache_page(page);\n\tkunmap_atomic(pagebuf);\n\n\tif (i_size_read(inode) < pos + LOGFS_BLOCKSIZE)\n\t\ti_size_write(inode, pos + LOGFS_BLOCKSIZE);\n\n\terr = logfs_write_buf(inode, page, flags);\n\tlogfs_put_write_page(page);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int write_dir(struct inode *dir, struct logfs_disk_dentry *dd,\n\t\tloff_t pos)\n{\n\treturn logfs_inode_write(dir, dd, sizeof(*dd), pos, WF_LOCK, NULL);\n}"
  }
]