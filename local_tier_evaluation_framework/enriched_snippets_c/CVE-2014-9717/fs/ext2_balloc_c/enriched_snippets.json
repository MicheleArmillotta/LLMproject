[
  {
    "function_name": "ext2_bg_num_gdb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "1532-1535",
    "snippet": "unsigned long ext2_bg_num_gdb(struct super_block *sb, int group)\n{\n\treturn ext2_bg_has_super(sb, group) ? EXT2_SB(sb)->s_gdb_count : 0;\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_bg_has_super",
          "args": [
            "sb",
            "group"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "1515-1521",
          "snippet": "int ext2_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT2_HAS_RO_COMPAT_FEATURE(sb,EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER)&&\n\t    !ext2_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nint ext2_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT2_HAS_RO_COMPAT_FEATURE(sb,EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER)&&\n\t    !ext2_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nunsigned long ext2_bg_num_gdb(struct super_block *sb, int group)\n{\n\treturn ext2_bg_has_super(sb, group) ? EXT2_SB(sb)->s_gdb_count : 0;\n}"
  },
  {
    "function_name": "ext2_bg_has_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "1515-1521",
    "snippet": "int ext2_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT2_HAS_RO_COMPAT_FEATURE(sb,EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER)&&\n\t    !ext2_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_group_sparse",
          "args": [
            "group"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_group_sparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "1499-1505",
          "snippet": "static int ext2_group_sparse(int group)\n{\n\tif (group <= 1)\n\t\treturn 1;\n\treturn (test_root(group, 3) || test_root(group, 5) ||\n\t\ttest_root(group, 7));\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic int ext2_group_sparse(int group)\n{\n\tif (group <= 1)\n\t\treturn 1;\n\treturn (test_root(group, 3) || test_root(group, 5) ||\n\t\ttest_root(group, 7));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nint ext2_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT2_HAS_RO_COMPAT_FEATURE(sb,EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER)&&\n\t    !ext2_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "ext2_group_sparse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "1499-1505",
    "snippet": "static int ext2_group_sparse(int group)\n{\n\tif (group <= 1)\n\t\treturn 1;\n\treturn (test_root(group, 3) || test_root(group, 5) ||\n\t\ttest_root(group, 7));\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_root",
          "args": [
            "group",
            "7"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "test_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "1490-1497",
          "snippet": "static inline int test_root(int a, int b)\n{\n\tint num = b;\n\n\twhile (a > num)\n\t\tnum *= b;\n\treturn num == a;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic inline int test_root(int a, int b)\n{\n\tint num = b;\n\n\twhile (a > num)\n\t\tnum *= b;\n\treturn num == a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic int ext2_group_sparse(int group)\n{\n\tif (group <= 1)\n\t\treturn 1;\n\treturn (test_root(group, 3) || test_root(group, 5) ||\n\t\ttest_root(group, 7));\n}"
  },
  {
    "function_name": "test_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "1490-1497",
    "snippet": "static inline int test_root(int a, int b)\n{\n\tint num = b;\n\n\twhile (a > num)\n\t\tnum *= b;\n\treturn num == a;\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic inline int test_root(int a, int b)\n{\n\tint num = b;\n\n\twhile (a > num)\n\t\tnum *= b;\n\treturn num == a;\n}"
  },
  {
    "function_name": "ext2_count_free_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "1446-1488",
    "snippet": "unsigned long ext2_count_free_blocks (struct super_block * sb)\n{\n\tstruct ext2_group_desc * desc;\n\tunsigned long desc_count = 0;\n\tint i;\n#ifdef EXT2FS_DEBUG\n\tunsigned long bitmap_count, x;\n\tstruct ext2_super_block *es;\n\n\tes = EXT2_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tdesc = NULL;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tstruct buffer_head *bitmap_bh;\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_blocks_count);\n\t\tbitmap_bh = read_block_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\t\t\n\t\tx = ext2_count_free(bitmap_bh, sb->s_blocksize);\n\t\tprintk (\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_blocks_count), x);\n\t\tbitmap_count += x;\n\t\tbrelse(bitmap_bh);\n\t}\n\tprintk(\"ext2_count_free_blocks: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(long)le32_to_cpu(es->s_free_blocks_count),\n\t\tdesc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n        for (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n                desc = ext2_get_group_desc (sb, i, NULL);\n                if (!desc)\n                        continue;\n                desc_count += le16_to_cpu(desc->bg_free_blocks_count);\n\t}\n\treturn desc_count;\n#endif\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "desc->bg_free_blocks_count"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_get_group_desc",
          "args": [
            "sb",
            "i",
            "NULL"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "39-71",
          "snippet": "struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstruct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"ext2_count_free_blocks: stored = %lu, computed = %lu, %lu\\n\"",
            "(long)le32_to_cpu(es->s_free_blocks_count)",
            "desc_count",
            "bitmap_count"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_free_blocks_count"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap_bh"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_count_free",
          "args": [
            "bitmap_bh",
            "sb->s_blocksize"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_count_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "1439-1442",
          "snippet": "unsigned long ext2_count_free(struct buffer_head *map, unsigned int numchars)\n{\n\treturn numchars * BITS_PER_BYTE - memweight(map->b_data, numchars);\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nunsigned long ext2_count_free(struct buffer_head *map, unsigned int numchars)\n{\n\treturn numchars * BITS_PER_BYTE - memweight(map->b_data, numchars);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_block_bitmap",
          "args": [
            "sb",
            "i"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "read_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "123-160",
          "snippet": "static struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext2_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text2_fsblk_t bitmap_blk;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text2_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tif (likely(bh_uptodate_or_lock(bh)))\n\t\treturn bh;\n\n\tif (bh_submit_read(bh) < 0) {\n\t\tbrelse(bh);\n\t\text2_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\n\text2_valid_block_bitmap(sb, desc, block_group, bh);\n\t/*\n\t * file system mounted not to panic on error, continue with corrupt\n\t * bitmap\n\t */\n\treturn bh;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext2_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text2_fsblk_t bitmap_blk;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text2_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tif (likely(bh_uptodate_or_lock(bh)))\n\t\treturn bh;\n\n\tif (bh_submit_read(bh) < 0) {\n\t\tbrelse(bh);\n\t\text2_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\n\text2_valid_block_bitmap(sb, desc, block_group, bh);\n\t/*\n\t * file system mounted not to panic on error, continue with corrupt\n\t * bitmap\n\t */\n\treturn bh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nunsigned long ext2_count_free_blocks (struct super_block * sb)\n{\n\tstruct ext2_group_desc * desc;\n\tunsigned long desc_count = 0;\n\tint i;\n#ifdef EXT2FS_DEBUG\n\tunsigned long bitmap_count, x;\n\tstruct ext2_super_block *es;\n\n\tes = EXT2_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tdesc = NULL;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tstruct buffer_head *bitmap_bh;\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_blocks_count);\n\t\tbitmap_bh = read_block_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\t\t\n\t\tx = ext2_count_free(bitmap_bh, sb->s_blocksize);\n\t\tprintk (\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_blocks_count), x);\n\t\tbitmap_count += x;\n\t\tbrelse(bitmap_bh);\n\t}\n\tprintk(\"ext2_count_free_blocks: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(long)le32_to_cpu(es->s_free_blocks_count),\n\t\tdesc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n        for (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n                desc = ext2_get_group_desc (sb, i, NULL);\n                if (!desc)\n                        continue;\n                desc_count += le16_to_cpu(desc->bg_free_blocks_count);\n\t}\n\treturn desc_count;\n#endif\n}"
  },
  {
    "function_name": "ext2_count_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "1439-1442",
    "snippet": "unsigned long ext2_count_free(struct buffer_head *map, unsigned int numchars)\n{\n\treturn numchars * BITS_PER_BYTE - memweight(map->b_data, numchars);\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memweight",
          "args": [
            "map->b_data",
            "numchars"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nunsigned long ext2_count_free(struct buffer_head *map, unsigned int numchars)\n{\n\treturn numchars * BITS_PER_BYTE - memweight(map->b_data, numchars);\n}"
  },
  {
    "function_name": "ext2_new_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "1430-1435",
    "snippet": "ext2_fsblk_t ext2_new_block(struct inode *inode, unsigned long goal, int *errp)\n{\n\tunsigned long count = 1;\n\n\treturn ext2_new_blocks(inode, goal, &count, errp);\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_new_blocks",
          "args": [
            "inode",
            "goal",
            "&count",
            "errp"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_new_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "1210-1428",
          "snippet": "ext2_fsblk_t ext2_new_blocks(struct inode *inode, ext2_fsblk_t goal,\n\t\t    unsigned long *count, int *errp)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gdp_bh;\n\tint group_no;\n\tint goal_group;\n\text2_grpblk_t grp_target_blk;\t/* blockgroup relative goal block */\n\text2_grpblk_t grp_alloc_blk;\t/* blockgroup-relative allocated block*/\n\text2_fsblk_t ret_block;\t\t/* filesyetem-wide allocated block */\n\tint bgi;\t\t\t/* blockgroup iteration index */\n\tint performed_allocation = 0;\n\text2_grpblk_t free_blocks;\t/* number of free blocks in a group */\n\tstruct super_block *sb;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_sb_info *sbi;\n\tstruct ext2_reserve_window_node *my_rsv = NULL;\n\tstruct ext2_block_alloc_info *block_i;\n\tunsigned short windowsz = 0;\n\tunsigned long ngroups;\n\tunsigned long num = *count;\n\tint ret;\n\n\t*errp = -ENOSPC;\n\tsb = inode->i_sb;\n\n\t/*\n\t * Check quota for allocation of this block.\n\t */\n\tret = dquot_alloc_block(inode, num);\n\tif (ret) {\n\t\t*errp = ret;\n\t\treturn 0;\n\t}\n\n\tsbi = EXT2_SB(sb);\n\tes = EXT2_SB(sb)->s_es;\n\text2_debug(\"goal=%lu.\\n\", goal);\n\t/*\n\t * Allocate a block from reservation only when\n\t * filesystem is mounted with reservation(default,-o reservation), and\n\t * it's a regular file, and\n\t * the desired window size is greater than 0 (One could use ioctl\n\t * command EXT2_IOC_SETRSVSZ to set the window size to 0 to turn off\n\t * reservation on that particular file)\n\t */\n\tblock_i = EXT2_I(inode)->i_block_alloc_info;\n\tif (block_i) {\n\t\twindowsz = block_i->rsv_window_node.rsv_goal_size;\n\t\tif (windowsz > 0)\n\t\t\tmy_rsv = &block_i->rsv_window_node;\n\t}\n\n\tif (!ext2_has_free_blocks(sbi)) {\n\t\t*errp = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, test whether the goal block is free.\n\t */\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t    goal >= le32_to_cpu(es->s_blocks_count))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\tgroup_no = (goal - le32_to_cpu(es->s_first_data_block)) /\n\t\t\tEXT2_BLOCKS_PER_GROUP(sb);\n\tgoal_group = group_no;\nretry_alloc:\n\tgdp = ext2_get_group_desc(sb, group_no, &gdp_bh);\n\tif (!gdp)\n\t\tgoto io_error;\n\n\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t/*\n\t * if there is not enough free blocks to make a new resevation\n\t * turn off reservation for this allocation\n\t */\n\tif (my_rsv && (free_blocks < windowsz)\n\t\t&& (free_blocks > 0)\n\t\t&& (rsv_is_empty(&my_rsv->rsv_window)))\n\t\tmy_rsv = NULL;\n\n\tif (free_blocks > 0) {\n\t\tgrp_target_blk = ((goal - le32_to_cpu(es->s_first_data_block)) %\n\t\t\t\tEXT2_BLOCKS_PER_GROUP(sb));\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\tgrp_alloc_blk = ext2_try_to_allocate_with_rsv(sb, group_no,\n\t\t\t\t\tbitmap_bh, grp_target_blk,\n\t\t\t\t\tmy_rsv, &num);\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\n\tngroups = EXT2_SB(sb)->s_groups_count;\n\tsmp_rmb();\n\n\t/*\n\t * Now search the rest of the groups.  We assume that\n\t * group_no and gdp correctly point to the last group visited.\n\t */\n\tfor (bgi = 0; bgi < ngroups; bgi++) {\n\t\tgroup_no++;\n\t\tif (group_no >= ngroups)\n\t\t\tgroup_no = 0;\n\t\tgdp = ext2_get_group_desc(sb, group_no, &gdp_bh);\n\t\tif (!gdp)\n\t\t\tgoto io_error;\n\n\t\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t\t/*\n\t\t * skip this group (and avoid loading bitmap) if there\n\t\t * are no free blocks\n\t\t */\n\t\tif (!free_blocks)\n\t\t\tcontinue;\n\t\t/*\n\t\t * skip this group if the number of\n\t\t * free blocks is less than half of the reservation\n\t\t * window size.\n\t\t */\n\t\tif (my_rsv && (free_blocks <= (windowsz/2)))\n\t\t\tcontinue;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\t/*\n\t\t * try to allocate block(s) from this group, without a goal(-1).\n\t\t */\n\t\tgrp_alloc_blk = ext2_try_to_allocate_with_rsv(sb, group_no,\n\t\t\t\t\tbitmap_bh, -1, my_rsv, &num);\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\t/*\n\t * We may end up a bogus earlier ENOSPC error due to\n\t * filesystem is \"full\" of reservations, but\n\t * there maybe indeed free blocks available on disk\n\t * In this case, we just forget about the reservations\n\t * just do block allocation as without reservations.\n\t */\n\tif (my_rsv) {\n\t\tmy_rsv = NULL;\n\t\twindowsz = 0;\n\t\tgroup_no = goal_group;\n\t\tgoto retry_alloc;\n\t}\n\t/* No space left on the device */\n\t*errp = -ENOSPC;\n\tgoto out;\n\nallocated:\n\n\text2_debug(\"using block group %d(%d)\\n\",\n\t\t\tgroup_no, gdp->bg_free_blocks_count);\n\n\tret_block = grp_alloc_blk + ext2_group_first_block_no(sb, group_no);\n\n\tif (in_range(le32_to_cpu(gdp->bg_block_bitmap), ret_block, num) ||\n\t    in_range(le32_to_cpu(gdp->bg_inode_bitmap), ret_block, num) ||\n\t    in_range(ret_block, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT2_SB(sb)->s_itb_per_group) ||\n\t    in_range(ret_block + num - 1, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT2_SB(sb)->s_itb_per_group)) {\n\t\text2_error(sb, \"ext2_new_blocks\",\n\t\t\t    \"Allocating block in system zone - \"\n\t\t\t    \"blocks from \"E2FSBLK\", length %lu\",\n\t\t\t    ret_block, num);\n\t\t/*\n\t\t * ext2_try_to_allocate marked the blocks we allocated as in\n\t\t * use.  So we may want to selectively mark some of the blocks\n\t\t * as free\n\t\t */\n\t\tgoto retry_alloc;\n\t}\n\n\tperformed_allocation = 1;\n\n\tif (ret_block + num - 1 >= le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error(sb, \"ext2_new_blocks\",\n\t\t\t    \"block(\"E2FSBLK\") >= blocks count(%d) - \"\n\t\t\t    \"block_group = %d, es == %p \", ret_block,\n\t\t\tle32_to_cpu(es->s_blocks_count), group_no, es);\n\t\tgoto out;\n\t}\n\n\tgroup_adjust_blocks(sb, group_no, gdp, gdp_bh, -num);\n\tpercpu_counter_sub(&sbi->s_freeblocks_counter, num);\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\t*errp = 0;\n\tbrelse(bitmap_bh);\n\tif (num < *count) {\n\t\tdquot_free_block_nodirty(inode, *count-num);\n\t\tmark_inode_dirty(inode);\n\t\t*count = num;\n\t}\n\treturn ret_block;\n\nio_error:\n\t*errp = -EIO;\nout:\n\t/*\n\t * Undo the block allocation\n\t */\n\tif (!performed_allocation) {\n\t\tdquot_free_block_nodirty(inode, *count);\n\t\tmark_inode_dirty(inode);\n\t}\n\tbrelse(bitmap_bh);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\next2_fsblk_t ext2_new_blocks(struct inode *inode, ext2_fsblk_t goal,\n\t\t    unsigned long *count, int *errp)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gdp_bh;\n\tint group_no;\n\tint goal_group;\n\text2_grpblk_t grp_target_blk;\t/* blockgroup relative goal block */\n\text2_grpblk_t grp_alloc_blk;\t/* blockgroup-relative allocated block*/\n\text2_fsblk_t ret_block;\t\t/* filesyetem-wide allocated block */\n\tint bgi;\t\t\t/* blockgroup iteration index */\n\tint performed_allocation = 0;\n\text2_grpblk_t free_blocks;\t/* number of free blocks in a group */\n\tstruct super_block *sb;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_sb_info *sbi;\n\tstruct ext2_reserve_window_node *my_rsv = NULL;\n\tstruct ext2_block_alloc_info *block_i;\n\tunsigned short windowsz = 0;\n\tunsigned long ngroups;\n\tunsigned long num = *count;\n\tint ret;\n\n\t*errp = -ENOSPC;\n\tsb = inode->i_sb;\n\n\t/*\n\t * Check quota for allocation of this block.\n\t */\n\tret = dquot_alloc_block(inode, num);\n\tif (ret) {\n\t\t*errp = ret;\n\t\treturn 0;\n\t}\n\n\tsbi = EXT2_SB(sb);\n\tes = EXT2_SB(sb)->s_es;\n\text2_debug(\"goal=%lu.\\n\", goal);\n\t/*\n\t * Allocate a block from reservation only when\n\t * filesystem is mounted with reservation(default,-o reservation), and\n\t * it's a regular file, and\n\t * the desired window size is greater than 0 (One could use ioctl\n\t * command EXT2_IOC_SETRSVSZ to set the window size to 0 to turn off\n\t * reservation on that particular file)\n\t */\n\tblock_i = EXT2_I(inode)->i_block_alloc_info;\n\tif (block_i) {\n\t\twindowsz = block_i->rsv_window_node.rsv_goal_size;\n\t\tif (windowsz > 0)\n\t\t\tmy_rsv = &block_i->rsv_window_node;\n\t}\n\n\tif (!ext2_has_free_blocks(sbi)) {\n\t\t*errp = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, test whether the goal block is free.\n\t */\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t    goal >= le32_to_cpu(es->s_blocks_count))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\tgroup_no = (goal - le32_to_cpu(es->s_first_data_block)) /\n\t\t\tEXT2_BLOCKS_PER_GROUP(sb);\n\tgoal_group = group_no;\nretry_alloc:\n\tgdp = ext2_get_group_desc(sb, group_no, &gdp_bh);\n\tif (!gdp)\n\t\tgoto io_error;\n\n\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t/*\n\t * if there is not enough free blocks to make a new resevation\n\t * turn off reservation for this allocation\n\t */\n\tif (my_rsv && (free_blocks < windowsz)\n\t\t&& (free_blocks > 0)\n\t\t&& (rsv_is_empty(&my_rsv->rsv_window)))\n\t\tmy_rsv = NULL;\n\n\tif (free_blocks > 0) {\n\t\tgrp_target_blk = ((goal - le32_to_cpu(es->s_first_data_block)) %\n\t\t\t\tEXT2_BLOCKS_PER_GROUP(sb));\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\tgrp_alloc_blk = ext2_try_to_allocate_with_rsv(sb, group_no,\n\t\t\t\t\tbitmap_bh, grp_target_blk,\n\t\t\t\t\tmy_rsv, &num);\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\n\tngroups = EXT2_SB(sb)->s_groups_count;\n\tsmp_rmb();\n\n\t/*\n\t * Now search the rest of the groups.  We assume that\n\t * group_no and gdp correctly point to the last group visited.\n\t */\n\tfor (bgi = 0; bgi < ngroups; bgi++) {\n\t\tgroup_no++;\n\t\tif (group_no >= ngroups)\n\t\t\tgroup_no = 0;\n\t\tgdp = ext2_get_group_desc(sb, group_no, &gdp_bh);\n\t\tif (!gdp)\n\t\t\tgoto io_error;\n\n\t\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t\t/*\n\t\t * skip this group (and avoid loading bitmap) if there\n\t\t * are no free blocks\n\t\t */\n\t\tif (!free_blocks)\n\t\t\tcontinue;\n\t\t/*\n\t\t * skip this group if the number of\n\t\t * free blocks is less than half of the reservation\n\t\t * window size.\n\t\t */\n\t\tif (my_rsv && (free_blocks <= (windowsz/2)))\n\t\t\tcontinue;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\t/*\n\t\t * try to allocate block(s) from this group, without a goal(-1).\n\t\t */\n\t\tgrp_alloc_blk = ext2_try_to_allocate_with_rsv(sb, group_no,\n\t\t\t\t\tbitmap_bh, -1, my_rsv, &num);\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\t/*\n\t * We may end up a bogus earlier ENOSPC error due to\n\t * filesystem is \"full\" of reservations, but\n\t * there maybe indeed free blocks available on disk\n\t * In this case, we just forget about the reservations\n\t * just do block allocation as without reservations.\n\t */\n\tif (my_rsv) {\n\t\tmy_rsv = NULL;\n\t\twindowsz = 0;\n\t\tgroup_no = goal_group;\n\t\tgoto retry_alloc;\n\t}\n\t/* No space left on the device */\n\t*errp = -ENOSPC;\n\tgoto out;\n\nallocated:\n\n\text2_debug(\"using block group %d(%d)\\n\",\n\t\t\tgroup_no, gdp->bg_free_blocks_count);\n\n\tret_block = grp_alloc_blk + ext2_group_first_block_no(sb, group_no);\n\n\tif (in_range(le32_to_cpu(gdp->bg_block_bitmap), ret_block, num) ||\n\t    in_range(le32_to_cpu(gdp->bg_inode_bitmap), ret_block, num) ||\n\t    in_range(ret_block, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT2_SB(sb)->s_itb_per_group) ||\n\t    in_range(ret_block + num - 1, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT2_SB(sb)->s_itb_per_group)) {\n\t\text2_error(sb, \"ext2_new_blocks\",\n\t\t\t    \"Allocating block in system zone - \"\n\t\t\t    \"blocks from \"E2FSBLK\", length %lu\",\n\t\t\t    ret_block, num);\n\t\t/*\n\t\t * ext2_try_to_allocate marked the blocks we allocated as in\n\t\t * use.  So we may want to selectively mark some of the blocks\n\t\t * as free\n\t\t */\n\t\tgoto retry_alloc;\n\t}\n\n\tperformed_allocation = 1;\n\n\tif (ret_block + num - 1 >= le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error(sb, \"ext2_new_blocks\",\n\t\t\t    \"block(\"E2FSBLK\") >= blocks count(%d) - \"\n\t\t\t    \"block_group = %d, es == %p \", ret_block,\n\t\t\tle32_to_cpu(es->s_blocks_count), group_no, es);\n\t\tgoto out;\n\t}\n\n\tgroup_adjust_blocks(sb, group_no, gdp, gdp_bh, -num);\n\tpercpu_counter_sub(&sbi->s_freeblocks_counter, num);\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\t*errp = 0;\n\tbrelse(bitmap_bh);\n\tif (num < *count) {\n\t\tdquot_free_block_nodirty(inode, *count-num);\n\t\tmark_inode_dirty(inode);\n\t\t*count = num;\n\t}\n\treturn ret_block;\n\nio_error:\n\t*errp = -EIO;\nout:\n\t/*\n\t * Undo the block allocation\n\t */\n\tif (!performed_allocation) {\n\t\tdquot_free_block_nodirty(inode, *count);\n\t\tmark_inode_dirty(inode);\n\t}\n\tbrelse(bitmap_bh);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\next2_fsblk_t ext2_new_block(struct inode *inode, unsigned long goal, int *errp)\n{\n\tunsigned long count = 1;\n\n\treturn ext2_new_blocks(inode, goal, &count, errp);\n}"
  },
  {
    "function_name": "ext2_new_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "1210-1428",
    "snippet": "ext2_fsblk_t ext2_new_blocks(struct inode *inode, ext2_fsblk_t goal,\n\t\t    unsigned long *count, int *errp)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gdp_bh;\n\tint group_no;\n\tint goal_group;\n\text2_grpblk_t grp_target_blk;\t/* blockgroup relative goal block */\n\text2_grpblk_t grp_alloc_blk;\t/* blockgroup-relative allocated block*/\n\text2_fsblk_t ret_block;\t\t/* filesyetem-wide allocated block */\n\tint bgi;\t\t\t/* blockgroup iteration index */\n\tint performed_allocation = 0;\n\text2_grpblk_t free_blocks;\t/* number of free blocks in a group */\n\tstruct super_block *sb;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_sb_info *sbi;\n\tstruct ext2_reserve_window_node *my_rsv = NULL;\n\tstruct ext2_block_alloc_info *block_i;\n\tunsigned short windowsz = 0;\n\tunsigned long ngroups;\n\tunsigned long num = *count;\n\tint ret;\n\n\t*errp = -ENOSPC;\n\tsb = inode->i_sb;\n\n\t/*\n\t * Check quota for allocation of this block.\n\t */\n\tret = dquot_alloc_block(inode, num);\n\tif (ret) {\n\t\t*errp = ret;\n\t\treturn 0;\n\t}\n\n\tsbi = EXT2_SB(sb);\n\tes = EXT2_SB(sb)->s_es;\n\text2_debug(\"goal=%lu.\\n\", goal);\n\t/*\n\t * Allocate a block from reservation only when\n\t * filesystem is mounted with reservation(default,-o reservation), and\n\t * it's a regular file, and\n\t * the desired window size is greater than 0 (One could use ioctl\n\t * command EXT2_IOC_SETRSVSZ to set the window size to 0 to turn off\n\t * reservation on that particular file)\n\t */\n\tblock_i = EXT2_I(inode)->i_block_alloc_info;\n\tif (block_i) {\n\t\twindowsz = block_i->rsv_window_node.rsv_goal_size;\n\t\tif (windowsz > 0)\n\t\t\tmy_rsv = &block_i->rsv_window_node;\n\t}\n\n\tif (!ext2_has_free_blocks(sbi)) {\n\t\t*errp = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, test whether the goal block is free.\n\t */\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t    goal >= le32_to_cpu(es->s_blocks_count))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\tgroup_no = (goal - le32_to_cpu(es->s_first_data_block)) /\n\t\t\tEXT2_BLOCKS_PER_GROUP(sb);\n\tgoal_group = group_no;\nretry_alloc:\n\tgdp = ext2_get_group_desc(sb, group_no, &gdp_bh);\n\tif (!gdp)\n\t\tgoto io_error;\n\n\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t/*\n\t * if there is not enough free blocks to make a new resevation\n\t * turn off reservation for this allocation\n\t */\n\tif (my_rsv && (free_blocks < windowsz)\n\t\t&& (free_blocks > 0)\n\t\t&& (rsv_is_empty(&my_rsv->rsv_window)))\n\t\tmy_rsv = NULL;\n\n\tif (free_blocks > 0) {\n\t\tgrp_target_blk = ((goal - le32_to_cpu(es->s_first_data_block)) %\n\t\t\t\tEXT2_BLOCKS_PER_GROUP(sb));\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\tgrp_alloc_blk = ext2_try_to_allocate_with_rsv(sb, group_no,\n\t\t\t\t\tbitmap_bh, grp_target_blk,\n\t\t\t\t\tmy_rsv, &num);\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\n\tngroups = EXT2_SB(sb)->s_groups_count;\n\tsmp_rmb();\n\n\t/*\n\t * Now search the rest of the groups.  We assume that\n\t * group_no and gdp correctly point to the last group visited.\n\t */\n\tfor (bgi = 0; bgi < ngroups; bgi++) {\n\t\tgroup_no++;\n\t\tif (group_no >= ngroups)\n\t\t\tgroup_no = 0;\n\t\tgdp = ext2_get_group_desc(sb, group_no, &gdp_bh);\n\t\tif (!gdp)\n\t\t\tgoto io_error;\n\n\t\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t\t/*\n\t\t * skip this group (and avoid loading bitmap) if there\n\t\t * are no free blocks\n\t\t */\n\t\tif (!free_blocks)\n\t\t\tcontinue;\n\t\t/*\n\t\t * skip this group if the number of\n\t\t * free blocks is less than half of the reservation\n\t\t * window size.\n\t\t */\n\t\tif (my_rsv && (free_blocks <= (windowsz/2)))\n\t\t\tcontinue;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\t/*\n\t\t * try to allocate block(s) from this group, without a goal(-1).\n\t\t */\n\t\tgrp_alloc_blk = ext2_try_to_allocate_with_rsv(sb, group_no,\n\t\t\t\t\tbitmap_bh, -1, my_rsv, &num);\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\t/*\n\t * We may end up a bogus earlier ENOSPC error due to\n\t * filesystem is \"full\" of reservations, but\n\t * there maybe indeed free blocks available on disk\n\t * In this case, we just forget about the reservations\n\t * just do block allocation as without reservations.\n\t */\n\tif (my_rsv) {\n\t\tmy_rsv = NULL;\n\t\twindowsz = 0;\n\t\tgroup_no = goal_group;\n\t\tgoto retry_alloc;\n\t}\n\t/* No space left on the device */\n\t*errp = -ENOSPC;\n\tgoto out;\n\nallocated:\n\n\text2_debug(\"using block group %d(%d)\\n\",\n\t\t\tgroup_no, gdp->bg_free_blocks_count);\n\n\tret_block = grp_alloc_blk + ext2_group_first_block_no(sb, group_no);\n\n\tif (in_range(le32_to_cpu(gdp->bg_block_bitmap), ret_block, num) ||\n\t    in_range(le32_to_cpu(gdp->bg_inode_bitmap), ret_block, num) ||\n\t    in_range(ret_block, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT2_SB(sb)->s_itb_per_group) ||\n\t    in_range(ret_block + num - 1, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT2_SB(sb)->s_itb_per_group)) {\n\t\text2_error(sb, \"ext2_new_blocks\",\n\t\t\t    \"Allocating block in system zone - \"\n\t\t\t    \"blocks from \"E2FSBLK\", length %lu\",\n\t\t\t    ret_block, num);\n\t\t/*\n\t\t * ext2_try_to_allocate marked the blocks we allocated as in\n\t\t * use.  So we may want to selectively mark some of the blocks\n\t\t * as free\n\t\t */\n\t\tgoto retry_alloc;\n\t}\n\n\tperformed_allocation = 1;\n\n\tif (ret_block + num - 1 >= le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error(sb, \"ext2_new_blocks\",\n\t\t\t    \"block(\"E2FSBLK\") >= blocks count(%d) - \"\n\t\t\t    \"block_group = %d, es == %p \", ret_block,\n\t\t\tle32_to_cpu(es->s_blocks_count), group_no, es);\n\t\tgoto out;\n\t}\n\n\tgroup_adjust_blocks(sb, group_no, gdp, gdp_bh, -num);\n\tpercpu_counter_sub(&sbi->s_freeblocks_counter, num);\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\t*errp = 0;\n\tbrelse(bitmap_bh);\n\tif (num < *count) {\n\t\tdquot_free_block_nodirty(inode, *count-num);\n\t\tmark_inode_dirty(inode);\n\t\t*count = num;\n\t}\n\treturn ret_block;\n\nio_error:\n\t*errp = -EIO;\nout:\n\t/*\n\t * Undo the block allocation\n\t */\n\tif (!performed_allocation) {\n\t\tdquot_free_block_nodirty(inode, *count);\n\t\tmark_inode_dirty(inode);\n\t}\n\tbrelse(bitmap_bh);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap_bh"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_block_nodirty",
          "args": [
            "inode",
            "*count"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_free_block_nodirty",
          "args": [
            "inode",
            "*count-num"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bitmap_bh"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bitmap_bh"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_sub",
          "args": [
            "&sbi->s_freeblocks_counter",
            "num"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group_adjust_blocks",
          "args": [
            "sb",
            "group_no",
            "gdp",
            "gdp_bh",
            "-num"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "group_adjust_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "162-175",
          "snippet": "static void group_adjust_blocks(struct super_block *sb, int group_no,\n\tstruct ext2_group_desc *desc, struct buffer_head *bh, int count)\n{\n\tif (count) {\n\t\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\t\tunsigned free_blocks;\n\n\t\tspin_lock(sb_bgl_lock(sbi, group_no));\n\t\tfree_blocks = le16_to_cpu(desc->bg_free_blocks_count);\n\t\tdesc->bg_free_blocks_count = cpu_to_le16(free_blocks + count);\n\t\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\t\tmark_buffer_dirty(bh);\n\t}\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic void group_adjust_blocks(struct super_block *sb, int group_no,\n\tstruct ext2_group_desc *desc, struct buffer_head *bh, int count)\n{\n\tif (count) {\n\t\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\t\tunsigned free_blocks;\n\n\t\tspin_lock(sb_bgl_lock(sbi, group_no));\n\t\tfree_blocks = le16_to_cpu(desc->bg_free_blocks_count);\n\t\tdesc->bg_free_blocks_count = cpu_to_le16(free_blocks + count);\n\t\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\t\tmark_buffer_dirty(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_error",
          "args": [
            "sb",
            "\"ext2_new_blocks\"",
            "\"block(\"E2FSBLK\") >= blocks count(%d) - \"\n\t\t\t    \"block_group = %d, es == %p \"",
            "ret_block",
            "le32_to_cpu(es->s_blocks_count)",
            "group_no",
            "es"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "47-80",
          "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_blocks_count"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_range",
          "args": [
            "ret_block + num - 1",
            "le32_to_cpu(gdp->bg_inode_table)",
            "EXT2_SB(sb)->s_itb_per_group"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_page_exists_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "7049-7117",
          "snippet": "bool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nbool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_group_first_block_no",
          "args": [
            "sb",
            "group_no"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_debug",
          "args": [
            "\"using block group %d(%d)\\n\"",
            "group_no",
            "gdp->bg_free_blocks_count"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_try_to_allocate_with_rsv",
          "args": [
            "sb",
            "group_no",
            "bitmap_bh",
            "-1",
            "my_rsv",
            "&num"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_try_to_allocate_with_rsv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "1091-1173",
          "snippet": "static ext2_grpblk_t\next2_try_to_allocate_with_rsv(struct super_block *sb, unsigned int group,\n\t\t\tstruct buffer_head *bitmap_bh, ext2_grpblk_t grp_goal,\n\t\t\tstruct ext2_reserve_window_node * my_rsv,\n\t\t\tunsigned long *count)\n{\n\text2_fsblk_t group_first_block, group_last_block;\n\text2_grpblk_t ret = 0;\n\tunsigned long num = *count;\n\n\t/*\n\t * we don't deal with reservation when\n\t * filesystem is mounted without reservation\n\t * or the file is not a regular file\n\t * or last attempt to allocate a block with reservation turned on failed\n\t */\n\tif (my_rsv == NULL) {\n\t\treturn ext2_try_to_allocate(sb, group, bitmap_bh,\n\t\t\t\t\t\tgrp_goal, count, NULL);\n\t}\n\t/*\n\t * grp_goal is a group relative block number (if there is a goal)\n\t * 0 <= grp_goal < EXT2_BLOCKS_PER_GROUP(sb)\n\t * first block is a filesystem wide block number\n\t * first block is the block number of the first block in this group\n\t */\n\tgroup_first_block = ext2_group_first_block_no(sb, group);\n\tgroup_last_block = group_first_block + (EXT2_BLOCKS_PER_GROUP(sb) - 1);\n\n\t/*\n\t * Basically we will allocate a new block from inode's reservation\n\t * window.\n\t *\n\t * We need to allocate a new reservation window, if:\n\t * a) inode does not have a reservation window; or\n\t * b) last attempt to allocate a block from existing reservation\n\t *    failed; or\n\t * c) we come here with a goal and with a reservation window\n\t *\n\t * We do not need to allocate a new reservation window if we come here\n\t * at the beginning with a goal and the goal is inside the window, or\n\t * we don't have a goal but already have a reservation window.\n\t * then we could go to allocate from the reservation window directly.\n\t */\n\twhile (1) {\n\t\tif (rsv_is_empty(&my_rsv->rsv_window) || (ret < 0) ||\n\t\t\t!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\tgrp_goal, group, sb)) {\n\t\t\tif (my_rsv->rsv_goal_size < *count)\n\t\t\t\tmy_rsv->rsv_goal_size = *count;\n\t\t\tret = alloc_new_reservation(my_rsv, grp_goal, sb,\n\t\t\t\t\t\t\tgroup, bitmap_bh);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\t\t\t/* failed */\n\n\t\t\tif (!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\t\tgrp_goal, group, sb))\n\t\t\t\tgrp_goal = -1;\n\t\t} else if (grp_goal >= 0) {\n\t\t\tint curr = my_rsv->rsv_end -\n\t\t\t\t\t(grp_goal + group_first_block) + 1;\n\n\t\t\tif (curr < *count)\n\t\t\t\ttry_to_extend_reservation(my_rsv, sb,\n\t\t\t\t\t\t\t*count - curr);\n\t\t}\n\n\t\tif ((my_rsv->rsv_start > group_last_block) ||\n\t\t\t\t(my_rsv->rsv_end < group_first_block)) {\n\t\t\trsv_window_dump(&EXT2_SB(sb)->s_rsv_window_root, 1);\n\t\t\tBUG();\n\t\t}\n\t\tret = ext2_try_to_allocate(sb, group, bitmap_bh, grp_goal,\n\t\t\t\t\t   &num, &my_rsv->rsv_window);\n\t\tif (ret >= 0) {\n\t\t\tmy_rsv->rsv_alloc_hit += num;\n\t\t\t*count = num;\n\t\t\tbreak;\t\t\t\t/* succeed */\n\t\t}\n\t\tnum = *count;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic ext2_grpblk_t\next2_try_to_allocate_with_rsv(struct super_block *sb, unsigned int group,\n\t\t\tstruct buffer_head *bitmap_bh, ext2_grpblk_t grp_goal,\n\t\t\tstruct ext2_reserve_window_node * my_rsv,\n\t\t\tunsigned long *count)\n{\n\text2_fsblk_t group_first_block, group_last_block;\n\text2_grpblk_t ret = 0;\n\tunsigned long num = *count;\n\n\t/*\n\t * we don't deal with reservation when\n\t * filesystem is mounted without reservation\n\t * or the file is not a regular file\n\t * or last attempt to allocate a block with reservation turned on failed\n\t */\n\tif (my_rsv == NULL) {\n\t\treturn ext2_try_to_allocate(sb, group, bitmap_bh,\n\t\t\t\t\t\tgrp_goal, count, NULL);\n\t}\n\t/*\n\t * grp_goal is a group relative block number (if there is a goal)\n\t * 0 <= grp_goal < EXT2_BLOCKS_PER_GROUP(sb)\n\t * first block is a filesystem wide block number\n\t * first block is the block number of the first block in this group\n\t */\n\tgroup_first_block = ext2_group_first_block_no(sb, group);\n\tgroup_last_block = group_first_block + (EXT2_BLOCKS_PER_GROUP(sb) - 1);\n\n\t/*\n\t * Basically we will allocate a new block from inode's reservation\n\t * window.\n\t *\n\t * We need to allocate a new reservation window, if:\n\t * a) inode does not have a reservation window; or\n\t * b) last attempt to allocate a block from existing reservation\n\t *    failed; or\n\t * c) we come here with a goal and with a reservation window\n\t *\n\t * We do not need to allocate a new reservation window if we come here\n\t * at the beginning with a goal and the goal is inside the window, or\n\t * we don't have a goal but already have a reservation window.\n\t * then we could go to allocate from the reservation window directly.\n\t */\n\twhile (1) {\n\t\tif (rsv_is_empty(&my_rsv->rsv_window) || (ret < 0) ||\n\t\t\t!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\tgrp_goal, group, sb)) {\n\t\t\tif (my_rsv->rsv_goal_size < *count)\n\t\t\t\tmy_rsv->rsv_goal_size = *count;\n\t\t\tret = alloc_new_reservation(my_rsv, grp_goal, sb,\n\t\t\t\t\t\t\tgroup, bitmap_bh);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\t\t\t/* failed */\n\n\t\t\tif (!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\t\tgrp_goal, group, sb))\n\t\t\t\tgrp_goal = -1;\n\t\t} else if (grp_goal >= 0) {\n\t\t\tint curr = my_rsv->rsv_end -\n\t\t\t\t\t(grp_goal + group_first_block) + 1;\n\n\t\t\tif (curr < *count)\n\t\t\t\ttry_to_extend_reservation(my_rsv, sb,\n\t\t\t\t\t\t\t*count - curr);\n\t\t}\n\n\t\tif ((my_rsv->rsv_start > group_last_block) ||\n\t\t\t\t(my_rsv->rsv_end < group_first_block)) {\n\t\t\trsv_window_dump(&EXT2_SB(sb)->s_rsv_window_root, 1);\n\t\t\tBUG();\n\t\t}\n\t\tret = ext2_try_to_allocate(sb, group, bitmap_bh, grp_goal,\n\t\t\t\t\t   &num, &my_rsv->rsv_window);\n\t\tif (ret >= 0) {\n\t\t\tmy_rsv->rsv_alloc_hit += num;\n\t\t\t*count = num;\n\t\t\tbreak;\t\t\t\t/* succeed */\n\t\t}\n\t\tnum = *count;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_block_bitmap",
          "args": [
            "sb",
            "group_no"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "read_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "123-160",
          "snippet": "static struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext2_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text2_fsblk_t bitmap_blk;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text2_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tif (likely(bh_uptodate_or_lock(bh)))\n\t\treturn bh;\n\n\tif (bh_submit_read(bh) < 0) {\n\t\tbrelse(bh);\n\t\text2_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\n\text2_valid_block_bitmap(sb, desc, block_group, bh);\n\t/*\n\t * file system mounted not to panic on error, continue with corrupt\n\t * bitmap\n\t */\n\treturn bh;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext2_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text2_fsblk_t bitmap_blk;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text2_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tif (likely(bh_uptodate_or_lock(bh)))\n\t\treturn bh;\n\n\tif (bh_submit_read(bh) < 0) {\n\t\tbrelse(bh);\n\t\text2_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\n\text2_valid_block_bitmap(sb, desc, block_group, bh);\n\t/*\n\t * file system mounted not to panic on error, continue with corrupt\n\t * bitmap\n\t */\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "gdp->bg_free_blocks_count"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_get_group_desc",
          "args": [
            "sb",
            "group_no",
            "&gdp_bh"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "39-71",
          "snippet": "struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstruct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsv_is_empty",
          "args": [
            "&my_rsv->rsv_window"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "rsv_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "383-387",
          "snippet": "static inline int rsv_is_empty(struct ext2_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn (rsv->_rsv_end == EXT2_RESERVE_WINDOW_NOT_ALLOCATED);\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic inline int rsv_is_empty(struct ext2_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn (rsv->_rsv_end == EXT2_RESERVE_WINDOW_NOT_ALLOCATED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_has_free_blocks",
          "args": [
            "sbi"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_has_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "1181-1194",
          "snippet": "static int ext2_has_free_blocks(struct ext2_sb_info *sbi)\n{\n\text2_fsblk_t free_blocks, root_blocks;\n\n\tfree_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\troot_blocks = le32_to_cpu(sbi->s_es->s_r_blocks_count);\n\tif (free_blocks < root_blocks + 1 && !capable(CAP_SYS_RESOURCE) &&\n\t\t!uid_eq(sbi->s_resuid, current_fsuid()) &&\n\t\t(gid_eq(sbi->s_resgid, GLOBAL_ROOT_GID) ||\n\t\t !in_group_p (sbi->s_resgid))) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic int ext2_has_free_blocks(struct ext2_sb_info *sbi)\n{\n\text2_fsblk_t free_blocks, root_blocks;\n\n\tfree_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\troot_blocks = le32_to_cpu(sbi->s_es->s_r_blocks_count);\n\tif (free_blocks < root_blocks + 1 && !capable(CAP_SYS_RESOURCE) &&\n\t\t!uid_eq(sbi->s_resuid, current_fsuid()) &&\n\t\t(gid_eq(sbi->s_resgid, GLOBAL_ROOT_GID) ||\n\t\t !in_group_p (sbi->s_resgid))) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_debug",
          "args": [
            "\"goal=%lu.\\n\"",
            "goal"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block",
          "args": [
            "inode",
            "num"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\next2_fsblk_t ext2_new_blocks(struct inode *inode, ext2_fsblk_t goal,\n\t\t    unsigned long *count, int *errp)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gdp_bh;\n\tint group_no;\n\tint goal_group;\n\text2_grpblk_t grp_target_blk;\t/* blockgroup relative goal block */\n\text2_grpblk_t grp_alloc_blk;\t/* blockgroup-relative allocated block*/\n\text2_fsblk_t ret_block;\t\t/* filesyetem-wide allocated block */\n\tint bgi;\t\t\t/* blockgroup iteration index */\n\tint performed_allocation = 0;\n\text2_grpblk_t free_blocks;\t/* number of free blocks in a group */\n\tstruct super_block *sb;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_sb_info *sbi;\n\tstruct ext2_reserve_window_node *my_rsv = NULL;\n\tstruct ext2_block_alloc_info *block_i;\n\tunsigned short windowsz = 0;\n\tunsigned long ngroups;\n\tunsigned long num = *count;\n\tint ret;\n\n\t*errp = -ENOSPC;\n\tsb = inode->i_sb;\n\n\t/*\n\t * Check quota for allocation of this block.\n\t */\n\tret = dquot_alloc_block(inode, num);\n\tif (ret) {\n\t\t*errp = ret;\n\t\treturn 0;\n\t}\n\n\tsbi = EXT2_SB(sb);\n\tes = EXT2_SB(sb)->s_es;\n\text2_debug(\"goal=%lu.\\n\", goal);\n\t/*\n\t * Allocate a block from reservation only when\n\t * filesystem is mounted with reservation(default,-o reservation), and\n\t * it's a regular file, and\n\t * the desired window size is greater than 0 (One could use ioctl\n\t * command EXT2_IOC_SETRSVSZ to set the window size to 0 to turn off\n\t * reservation on that particular file)\n\t */\n\tblock_i = EXT2_I(inode)->i_block_alloc_info;\n\tif (block_i) {\n\t\twindowsz = block_i->rsv_window_node.rsv_goal_size;\n\t\tif (windowsz > 0)\n\t\t\tmy_rsv = &block_i->rsv_window_node;\n\t}\n\n\tif (!ext2_has_free_blocks(sbi)) {\n\t\t*errp = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, test whether the goal block is free.\n\t */\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t    goal >= le32_to_cpu(es->s_blocks_count))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\tgroup_no = (goal - le32_to_cpu(es->s_first_data_block)) /\n\t\t\tEXT2_BLOCKS_PER_GROUP(sb);\n\tgoal_group = group_no;\nretry_alloc:\n\tgdp = ext2_get_group_desc(sb, group_no, &gdp_bh);\n\tif (!gdp)\n\t\tgoto io_error;\n\n\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t/*\n\t * if there is not enough free blocks to make a new resevation\n\t * turn off reservation for this allocation\n\t */\n\tif (my_rsv && (free_blocks < windowsz)\n\t\t&& (free_blocks > 0)\n\t\t&& (rsv_is_empty(&my_rsv->rsv_window)))\n\t\tmy_rsv = NULL;\n\n\tif (free_blocks > 0) {\n\t\tgrp_target_blk = ((goal - le32_to_cpu(es->s_first_data_block)) %\n\t\t\t\tEXT2_BLOCKS_PER_GROUP(sb));\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\tgrp_alloc_blk = ext2_try_to_allocate_with_rsv(sb, group_no,\n\t\t\t\t\tbitmap_bh, grp_target_blk,\n\t\t\t\t\tmy_rsv, &num);\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\n\tngroups = EXT2_SB(sb)->s_groups_count;\n\tsmp_rmb();\n\n\t/*\n\t * Now search the rest of the groups.  We assume that\n\t * group_no and gdp correctly point to the last group visited.\n\t */\n\tfor (bgi = 0; bgi < ngroups; bgi++) {\n\t\tgroup_no++;\n\t\tif (group_no >= ngroups)\n\t\t\tgroup_no = 0;\n\t\tgdp = ext2_get_group_desc(sb, group_no, &gdp_bh);\n\t\tif (!gdp)\n\t\t\tgoto io_error;\n\n\t\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t\t/*\n\t\t * skip this group (and avoid loading bitmap) if there\n\t\t * are no free blocks\n\t\t */\n\t\tif (!free_blocks)\n\t\t\tcontinue;\n\t\t/*\n\t\t * skip this group if the number of\n\t\t * free blocks is less than half of the reservation\n\t\t * window size.\n\t\t */\n\t\tif (my_rsv && (free_blocks <= (windowsz/2)))\n\t\t\tcontinue;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\t/*\n\t\t * try to allocate block(s) from this group, without a goal(-1).\n\t\t */\n\t\tgrp_alloc_blk = ext2_try_to_allocate_with_rsv(sb, group_no,\n\t\t\t\t\tbitmap_bh, -1, my_rsv, &num);\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\t/*\n\t * We may end up a bogus earlier ENOSPC error due to\n\t * filesystem is \"full\" of reservations, but\n\t * there maybe indeed free blocks available on disk\n\t * In this case, we just forget about the reservations\n\t * just do block allocation as without reservations.\n\t */\n\tif (my_rsv) {\n\t\tmy_rsv = NULL;\n\t\twindowsz = 0;\n\t\tgroup_no = goal_group;\n\t\tgoto retry_alloc;\n\t}\n\t/* No space left on the device */\n\t*errp = -ENOSPC;\n\tgoto out;\n\nallocated:\n\n\text2_debug(\"using block group %d(%d)\\n\",\n\t\t\tgroup_no, gdp->bg_free_blocks_count);\n\n\tret_block = grp_alloc_blk + ext2_group_first_block_no(sb, group_no);\n\n\tif (in_range(le32_to_cpu(gdp->bg_block_bitmap), ret_block, num) ||\n\t    in_range(le32_to_cpu(gdp->bg_inode_bitmap), ret_block, num) ||\n\t    in_range(ret_block, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT2_SB(sb)->s_itb_per_group) ||\n\t    in_range(ret_block + num - 1, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT2_SB(sb)->s_itb_per_group)) {\n\t\text2_error(sb, \"ext2_new_blocks\",\n\t\t\t    \"Allocating block in system zone - \"\n\t\t\t    \"blocks from \"E2FSBLK\", length %lu\",\n\t\t\t    ret_block, num);\n\t\t/*\n\t\t * ext2_try_to_allocate marked the blocks we allocated as in\n\t\t * use.  So we may want to selectively mark some of the blocks\n\t\t * as free\n\t\t */\n\t\tgoto retry_alloc;\n\t}\n\n\tperformed_allocation = 1;\n\n\tif (ret_block + num - 1 >= le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error(sb, \"ext2_new_blocks\",\n\t\t\t    \"block(\"E2FSBLK\") >= blocks count(%d) - \"\n\t\t\t    \"block_group = %d, es == %p \", ret_block,\n\t\t\tle32_to_cpu(es->s_blocks_count), group_no, es);\n\t\tgoto out;\n\t}\n\n\tgroup_adjust_blocks(sb, group_no, gdp, gdp_bh, -num);\n\tpercpu_counter_sub(&sbi->s_freeblocks_counter, num);\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\t*errp = 0;\n\tbrelse(bitmap_bh);\n\tif (num < *count) {\n\t\tdquot_free_block_nodirty(inode, *count-num);\n\t\tmark_inode_dirty(inode);\n\t\t*count = num;\n\t}\n\treturn ret_block;\n\nio_error:\n\t*errp = -EIO;\nout:\n\t/*\n\t * Undo the block allocation\n\t */\n\tif (!performed_allocation) {\n\t\tdquot_free_block_nodirty(inode, *count);\n\t\tmark_inode_dirty(inode);\n\t}\n\tbrelse(bitmap_bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext2_has_free_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "1181-1194",
    "snippet": "static int ext2_has_free_blocks(struct ext2_sb_info *sbi)\n{\n\text2_fsblk_t free_blocks, root_blocks;\n\n\tfree_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\troot_blocks = le32_to_cpu(sbi->s_es->s_r_blocks_count);\n\tif (free_blocks < root_blocks + 1 && !capable(CAP_SYS_RESOURCE) &&\n\t\t!uid_eq(sbi->s_resuid, current_fsuid()) &&\n\t\t(gid_eq(sbi->s_resgid, GLOBAL_ROOT_GID) ||\n\t\t !in_group_p (sbi->s_resgid))) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "sbi->s_resgid"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "sbi->s_resgid",
            "GLOBAL_ROOT_GID"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "sbi->s_resuid",
            "current_fsuid()"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_RESOURCE"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbi->s_es->s_r_blocks_count"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "&sbi->s_freeblocks_counter"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic int ext2_has_free_blocks(struct ext2_sb_info *sbi)\n{\n\text2_fsblk_t free_blocks, root_blocks;\n\n\tfree_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\troot_blocks = le32_to_cpu(sbi->s_es->s_r_blocks_count);\n\tif (free_blocks < root_blocks + 1 && !capable(CAP_SYS_RESOURCE) &&\n\t\t!uid_eq(sbi->s_resuid, current_fsuid()) &&\n\t\t(gid_eq(sbi->s_resgid, GLOBAL_ROOT_GID) ||\n\t\t !in_group_p (sbi->s_resgid))) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "ext2_try_to_allocate_with_rsv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "1091-1173",
    "snippet": "static ext2_grpblk_t\next2_try_to_allocate_with_rsv(struct super_block *sb, unsigned int group,\n\t\t\tstruct buffer_head *bitmap_bh, ext2_grpblk_t grp_goal,\n\t\t\tstruct ext2_reserve_window_node * my_rsv,\n\t\t\tunsigned long *count)\n{\n\text2_fsblk_t group_first_block, group_last_block;\n\text2_grpblk_t ret = 0;\n\tunsigned long num = *count;\n\n\t/*\n\t * we don't deal with reservation when\n\t * filesystem is mounted without reservation\n\t * or the file is not a regular file\n\t * or last attempt to allocate a block with reservation turned on failed\n\t */\n\tif (my_rsv == NULL) {\n\t\treturn ext2_try_to_allocate(sb, group, bitmap_bh,\n\t\t\t\t\t\tgrp_goal, count, NULL);\n\t}\n\t/*\n\t * grp_goal is a group relative block number (if there is a goal)\n\t * 0 <= grp_goal < EXT2_BLOCKS_PER_GROUP(sb)\n\t * first block is a filesystem wide block number\n\t * first block is the block number of the first block in this group\n\t */\n\tgroup_first_block = ext2_group_first_block_no(sb, group);\n\tgroup_last_block = group_first_block + (EXT2_BLOCKS_PER_GROUP(sb) - 1);\n\n\t/*\n\t * Basically we will allocate a new block from inode's reservation\n\t * window.\n\t *\n\t * We need to allocate a new reservation window, if:\n\t * a) inode does not have a reservation window; or\n\t * b) last attempt to allocate a block from existing reservation\n\t *    failed; or\n\t * c) we come here with a goal and with a reservation window\n\t *\n\t * We do not need to allocate a new reservation window if we come here\n\t * at the beginning with a goal and the goal is inside the window, or\n\t * we don't have a goal but already have a reservation window.\n\t * then we could go to allocate from the reservation window directly.\n\t */\n\twhile (1) {\n\t\tif (rsv_is_empty(&my_rsv->rsv_window) || (ret < 0) ||\n\t\t\t!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\tgrp_goal, group, sb)) {\n\t\t\tif (my_rsv->rsv_goal_size < *count)\n\t\t\t\tmy_rsv->rsv_goal_size = *count;\n\t\t\tret = alloc_new_reservation(my_rsv, grp_goal, sb,\n\t\t\t\t\t\t\tgroup, bitmap_bh);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\t\t\t/* failed */\n\n\t\t\tif (!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\t\tgrp_goal, group, sb))\n\t\t\t\tgrp_goal = -1;\n\t\t} else if (grp_goal >= 0) {\n\t\t\tint curr = my_rsv->rsv_end -\n\t\t\t\t\t(grp_goal + group_first_block) + 1;\n\n\t\t\tif (curr < *count)\n\t\t\t\ttry_to_extend_reservation(my_rsv, sb,\n\t\t\t\t\t\t\t*count - curr);\n\t\t}\n\n\t\tif ((my_rsv->rsv_start > group_last_block) ||\n\t\t\t\t(my_rsv->rsv_end < group_first_block)) {\n\t\t\trsv_window_dump(&EXT2_SB(sb)->s_rsv_window_root, 1);\n\t\t\tBUG();\n\t\t}\n\t\tret = ext2_try_to_allocate(sb, group, bitmap_bh, grp_goal,\n\t\t\t\t\t   &num, &my_rsv->rsv_window);\n\t\tif (ret >= 0) {\n\t\t\tmy_rsv->rsv_alloc_hit += num;\n\t\t\t*count = num;\n\t\t\tbreak;\t\t\t\t/* succeed */\n\t\t}\n\t\tnum = *count;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_try_to_allocate",
          "args": [
            "sb",
            "group",
            "bitmap_bh",
            "grp_goal",
            "&num",
            "&my_rsv->rsv_window"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_try_to_allocate_with_rsv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "1091-1173",
          "snippet": "static ext2_grpblk_t\next2_try_to_allocate_with_rsv(struct super_block *sb, unsigned int group,\n\t\t\tstruct buffer_head *bitmap_bh, ext2_grpblk_t grp_goal,\n\t\t\tstruct ext2_reserve_window_node * my_rsv,\n\t\t\tunsigned long *count)\n{\n\text2_fsblk_t group_first_block, group_last_block;\n\text2_grpblk_t ret = 0;\n\tunsigned long num = *count;\n\n\t/*\n\t * we don't deal with reservation when\n\t * filesystem is mounted without reservation\n\t * or the file is not a regular file\n\t * or last attempt to allocate a block with reservation turned on failed\n\t */\n\tif (my_rsv == NULL) {\n\t\treturn ext2_try_to_allocate(sb, group, bitmap_bh,\n\t\t\t\t\t\tgrp_goal, count, NULL);\n\t}\n\t/*\n\t * grp_goal is a group relative block number (if there is a goal)\n\t * 0 <= grp_goal < EXT2_BLOCKS_PER_GROUP(sb)\n\t * first block is a filesystem wide block number\n\t * first block is the block number of the first block in this group\n\t */\n\tgroup_first_block = ext2_group_first_block_no(sb, group);\n\tgroup_last_block = group_first_block + (EXT2_BLOCKS_PER_GROUP(sb) - 1);\n\n\t/*\n\t * Basically we will allocate a new block from inode's reservation\n\t * window.\n\t *\n\t * We need to allocate a new reservation window, if:\n\t * a) inode does not have a reservation window; or\n\t * b) last attempt to allocate a block from existing reservation\n\t *    failed; or\n\t * c) we come here with a goal and with a reservation window\n\t *\n\t * We do not need to allocate a new reservation window if we come here\n\t * at the beginning with a goal and the goal is inside the window, or\n\t * we don't have a goal but already have a reservation window.\n\t * then we could go to allocate from the reservation window directly.\n\t */\n\twhile (1) {\n\t\tif (rsv_is_empty(&my_rsv->rsv_window) || (ret < 0) ||\n\t\t\t!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\tgrp_goal, group, sb)) {\n\t\t\tif (my_rsv->rsv_goal_size < *count)\n\t\t\t\tmy_rsv->rsv_goal_size = *count;\n\t\t\tret = alloc_new_reservation(my_rsv, grp_goal, sb,\n\t\t\t\t\t\t\tgroup, bitmap_bh);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\t\t\t/* failed */\n\n\t\t\tif (!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\t\tgrp_goal, group, sb))\n\t\t\t\tgrp_goal = -1;\n\t\t} else if (grp_goal >= 0) {\n\t\t\tint curr = my_rsv->rsv_end -\n\t\t\t\t\t(grp_goal + group_first_block) + 1;\n\n\t\t\tif (curr < *count)\n\t\t\t\ttry_to_extend_reservation(my_rsv, sb,\n\t\t\t\t\t\t\t*count - curr);\n\t\t}\n\n\t\tif ((my_rsv->rsv_start > group_last_block) ||\n\t\t\t\t(my_rsv->rsv_end < group_first_block)) {\n\t\t\trsv_window_dump(&EXT2_SB(sb)->s_rsv_window_root, 1);\n\t\t\tBUG();\n\t\t}\n\t\tret = ext2_try_to_allocate(sb, group, bitmap_bh, grp_goal,\n\t\t\t\t\t   &num, &my_rsv->rsv_window);\n\t\tif (ret >= 0) {\n\t\t\tmy_rsv->rsv_alloc_hit += num;\n\t\t\t*count = num;\n\t\t\tbreak;\t\t\t\t/* succeed */\n\t\t}\n\t\tnum = *count;\n\t}\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsv_window_dump",
          "args": [
            "&EXT2_SB(sb)->s_rsv_window_root",
            "1"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_extend_reservation",
          "args": [
            "my_rsv",
            "sb",
            "*count - curr"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_extend_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "1040-1063",
          "snippet": "static void try_to_extend_reservation(struct ext2_reserve_window_node *my_rsv,\n\t\t\tstruct super_block *sb, int size)\n{\n\tstruct ext2_reserve_window_node *next_rsv;\n\tstruct rb_node *next;\n\tspinlock_t *rsv_lock = &EXT2_SB(sb)->s_rsv_window_lock;\n\n\tif (!spin_trylock(rsv_lock))\n\t\treturn;\n\n\tnext = rb_next(&my_rsv->rsv_node);\n\n\tif (!next)\n\t\tmy_rsv->rsv_end += size;\n\telse {\n\t\tnext_rsv = rb_entry(next, struct ext2_reserve_window_node, rsv_node);\n\n\t\tif ((next_rsv->rsv_start - my_rsv->rsv_end - 1) >= size)\n\t\t\tmy_rsv->rsv_end += size;\n\t\telse\n\t\t\tmy_rsv->rsv_end = next_rsv->rsv_start - 1;\n\t}\n\tspin_unlock(rsv_lock);\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic void try_to_extend_reservation(struct ext2_reserve_window_node *my_rsv,\n\t\t\tstruct super_block *sb, int size)\n{\n\tstruct ext2_reserve_window_node *next_rsv;\n\tstruct rb_node *next;\n\tspinlock_t *rsv_lock = &EXT2_SB(sb)->s_rsv_window_lock;\n\n\tif (!spin_trylock(rsv_lock))\n\t\treturn;\n\n\tnext = rb_next(&my_rsv->rsv_node);\n\n\tif (!next)\n\t\tmy_rsv->rsv_end += size;\n\telse {\n\t\tnext_rsv = rb_entry(next, struct ext2_reserve_window_node, rsv_node);\n\n\t\tif ((next_rsv->rsv_start - my_rsv->rsv_end - 1) >= size)\n\t\t\tmy_rsv->rsv_end += size;\n\t\telse\n\t\t\tmy_rsv->rsv_end = next_rsv->rsv_start - 1;\n\t}\n\tspin_unlock(rsv_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "goal_in_my_reservation",
          "args": [
            "&my_rsv->rsv_window",
            "grp_goal",
            "group",
            "sb"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "goal_in_my_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "263-279",
          "snippet": "static int\ngoal_in_my_reservation(struct ext2_reserve_window *rsv, ext2_grpblk_t grp_goal,\n\t\t\tunsigned int group, struct super_block * sb)\n{\n\text2_fsblk_t group_first_block, group_last_block;\n\n\tgroup_first_block = ext2_group_first_block_no(sb, group);\n\tgroup_last_block = group_first_block + EXT2_BLOCKS_PER_GROUP(sb) - 1;\n\n\tif ((rsv->_rsv_start > group_last_block) ||\n\t    (rsv->_rsv_end < group_first_block))\n\t\treturn 0;\n\tif ((grp_goal >= 0) && ((grp_goal + group_first_block < rsv->_rsv_start)\n\t\t|| (grp_goal + group_first_block > rsv->_rsv_end)))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic int\ngoal_in_my_reservation(struct ext2_reserve_window *rsv, ext2_grpblk_t grp_goal,\n\t\t\tunsigned int group, struct super_block * sb)\n{\n\text2_fsblk_t group_first_block, group_last_block;\n\n\tgroup_first_block = ext2_group_first_block_no(sb, group);\n\tgroup_last_block = group_first_block + EXT2_BLOCKS_PER_GROUP(sb) - 1;\n\n\tif ((rsv->_rsv_start > group_last_block) ||\n\t    (rsv->_rsv_end < group_first_block))\n\t\treturn 0;\n\tif ((grp_goal >= 0) && ((grp_goal + group_first_block < rsv->_rsv_start)\n\t\t|| (grp_goal + group_first_block > rsv->_rsv_end)))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_new_reservation",
          "args": [
            "my_rsv",
            "grp_goal",
            "sb",
            "group",
            "bitmap_bh"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_new_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "898-1021",
          "snippet": "static int alloc_new_reservation(struct ext2_reserve_window_node *my_rsv,\n\t\text2_grpblk_t grp_goal, struct super_block *sb,\n\t\tunsigned int group, struct buffer_head *bitmap_bh)\n{\n\tstruct ext2_reserve_window_node *search_head;\n\text2_fsblk_t group_first_block, group_end_block, start_block;\n\text2_grpblk_t first_free_block;\n\tstruct rb_root *fs_rsv_root = &EXT2_SB(sb)->s_rsv_window_root;\n\tunsigned long size;\n\tint ret;\n\tspinlock_t *rsv_lock = &EXT2_SB(sb)->s_rsv_window_lock;\n\n\tgroup_first_block = ext2_group_first_block_no(sb, group);\n\tgroup_end_block = group_first_block + (EXT2_BLOCKS_PER_GROUP(sb) - 1);\n\n\tif (grp_goal < 0)\n\t\tstart_block = group_first_block;\n\telse\n\t\tstart_block = grp_goal + group_first_block;\n\n\tsize = my_rsv->rsv_goal_size;\n\n\tif (!rsv_is_empty(&my_rsv->rsv_window)) {\n\t\t/*\n\t\t * if the old reservation is cross group boundary\n\t\t * and if the goal is inside the old reservation window,\n\t\t * we will come here when we just failed to allocate from\n\t\t * the first part of the window. We still have another part\n\t\t * that belongs to the next group. In this case, there is no\n\t\t * point to discard our window and try to allocate a new one\n\t\t * in this group(which will fail). we should\n\t\t * keep the reservation window, just simply move on.\n\t\t *\n\t\t * Maybe we could shift the start block of the reservation\n\t\t * window to the first block of next group.\n\t\t */\n\n\t\tif ((my_rsv->rsv_start <= group_end_block) &&\n\t\t\t\t(my_rsv->rsv_end > group_end_block) &&\n\t\t\t\t(start_block >= my_rsv->rsv_start))\n\t\t\treturn -1;\n\n\t\tif ((my_rsv->rsv_alloc_hit >\n\t\t     (my_rsv->rsv_end - my_rsv->rsv_start + 1) / 2)) {\n\t\t\t/*\n\t\t\t * if the previously allocation hit ratio is\n\t\t\t * greater than 1/2, then we double the size of\n\t\t\t * the reservation window the next time,\n\t\t\t * otherwise we keep the same size window\n\t\t\t */\n\t\t\tsize = size * 2;\n\t\t\tif (size > EXT2_MAX_RESERVE_BLOCKS)\n\t\t\t\tsize = EXT2_MAX_RESERVE_BLOCKS;\n\t\t\tmy_rsv->rsv_goal_size= size;\n\t\t}\n\t}\n\n\tspin_lock(rsv_lock);\n\t/*\n\t * shift the search start to the window near the goal block\n\t */\n\tsearch_head = search_reserve_window(fs_rsv_root, start_block);\n\n\t/*\n\t * find_next_reservable_window() simply finds a reservable window\n\t * inside the given range(start_block, group_end_block).\n\t *\n\t * To make sure the reservation window has a free bit inside it, we\n\t * need to check the bitmap after we found a reservable window.\n\t */\nretry:\n\tret = find_next_reservable_window(search_head, my_rsv, sb,\n\t\t\t\t\t\tstart_block, group_end_block);\n\n\tif (ret == -1) {\n\t\tif (!rsv_is_empty(&my_rsv->rsv_window))\n\t\t\trsv_window_remove(sb, my_rsv);\n\t\tspin_unlock(rsv_lock);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * On success, find_next_reservable_window() returns the\n\t * reservation window where there is a reservable space after it.\n\t * Before we reserve this reservable space, we need\n\t * to make sure there is at least a free block inside this region.\n\t *\n\t * Search the first free bit on the block bitmap.  Search starts from\n\t * the start block of the reservable space we just found.\n\t */\n\tspin_unlock(rsv_lock);\n\tfirst_free_block = bitmap_search_next_usable_block(\n\t\t\tmy_rsv->rsv_start - group_first_block,\n\t\t\tbitmap_bh, group_end_block - group_first_block + 1);\n\n\tif (first_free_block < 0) {\n\t\t/*\n\t\t * no free block left on the bitmap, no point\n\t\t * to reserve the space. return failed.\n\t\t */\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&my_rsv->rsv_window))\n\t\t\trsv_window_remove(sb, my_rsv);\n\t\tspin_unlock(rsv_lock);\n\t\treturn -1;\t\t/* failed */\n\t}\n\n\tstart_block = first_free_block + group_first_block;\n\t/*\n\t * check if the first free block is within the\n\t * free space we just reserved\n\t */\n\tif (start_block >= my_rsv->rsv_start && start_block <= my_rsv->rsv_end)\n\t\treturn 0;\t\t/* success */\n\t/*\n\t * if the first free bit we found is out of the reservable space\n\t * continue search for next reservable space,\n\t * start from where the free block is,\n\t * we also shift the list head to where we stopped last time\n\t */\n\tsearch_head = my_rsv;\n\tspin_lock(rsv_lock);\n\tgoto retry;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic int alloc_new_reservation(struct ext2_reserve_window_node *my_rsv,\n\t\text2_grpblk_t grp_goal, struct super_block *sb,\n\t\tunsigned int group, struct buffer_head *bitmap_bh)\n{\n\tstruct ext2_reserve_window_node *search_head;\n\text2_fsblk_t group_first_block, group_end_block, start_block;\n\text2_grpblk_t first_free_block;\n\tstruct rb_root *fs_rsv_root = &EXT2_SB(sb)->s_rsv_window_root;\n\tunsigned long size;\n\tint ret;\n\tspinlock_t *rsv_lock = &EXT2_SB(sb)->s_rsv_window_lock;\n\n\tgroup_first_block = ext2_group_first_block_no(sb, group);\n\tgroup_end_block = group_first_block + (EXT2_BLOCKS_PER_GROUP(sb) - 1);\n\n\tif (grp_goal < 0)\n\t\tstart_block = group_first_block;\n\telse\n\t\tstart_block = grp_goal + group_first_block;\n\n\tsize = my_rsv->rsv_goal_size;\n\n\tif (!rsv_is_empty(&my_rsv->rsv_window)) {\n\t\t/*\n\t\t * if the old reservation is cross group boundary\n\t\t * and if the goal is inside the old reservation window,\n\t\t * we will come here when we just failed to allocate from\n\t\t * the first part of the window. We still have another part\n\t\t * that belongs to the next group. In this case, there is no\n\t\t * point to discard our window and try to allocate a new one\n\t\t * in this group(which will fail). we should\n\t\t * keep the reservation window, just simply move on.\n\t\t *\n\t\t * Maybe we could shift the start block of the reservation\n\t\t * window to the first block of next group.\n\t\t */\n\n\t\tif ((my_rsv->rsv_start <= group_end_block) &&\n\t\t\t\t(my_rsv->rsv_end > group_end_block) &&\n\t\t\t\t(start_block >= my_rsv->rsv_start))\n\t\t\treturn -1;\n\n\t\tif ((my_rsv->rsv_alloc_hit >\n\t\t     (my_rsv->rsv_end - my_rsv->rsv_start + 1) / 2)) {\n\t\t\t/*\n\t\t\t * if the previously allocation hit ratio is\n\t\t\t * greater than 1/2, then we double the size of\n\t\t\t * the reservation window the next time,\n\t\t\t * otherwise we keep the same size window\n\t\t\t */\n\t\t\tsize = size * 2;\n\t\t\tif (size > EXT2_MAX_RESERVE_BLOCKS)\n\t\t\t\tsize = EXT2_MAX_RESERVE_BLOCKS;\n\t\t\tmy_rsv->rsv_goal_size= size;\n\t\t}\n\t}\n\n\tspin_lock(rsv_lock);\n\t/*\n\t * shift the search start to the window near the goal block\n\t */\n\tsearch_head = search_reserve_window(fs_rsv_root, start_block);\n\n\t/*\n\t * find_next_reservable_window() simply finds a reservable window\n\t * inside the given range(start_block, group_end_block).\n\t *\n\t * To make sure the reservation window has a free bit inside it, we\n\t * need to check the bitmap after we found a reservable window.\n\t */\nretry:\n\tret = find_next_reservable_window(search_head, my_rsv, sb,\n\t\t\t\t\t\tstart_block, group_end_block);\n\n\tif (ret == -1) {\n\t\tif (!rsv_is_empty(&my_rsv->rsv_window))\n\t\t\trsv_window_remove(sb, my_rsv);\n\t\tspin_unlock(rsv_lock);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * On success, find_next_reservable_window() returns the\n\t * reservation window where there is a reservable space after it.\n\t * Before we reserve this reservable space, we need\n\t * to make sure there is at least a free block inside this region.\n\t *\n\t * Search the first free bit on the block bitmap.  Search starts from\n\t * the start block of the reservable space we just found.\n\t */\n\tspin_unlock(rsv_lock);\n\tfirst_free_block = bitmap_search_next_usable_block(\n\t\t\tmy_rsv->rsv_start - group_first_block,\n\t\t\tbitmap_bh, group_end_block - group_first_block + 1);\n\n\tif (first_free_block < 0) {\n\t\t/*\n\t\t * no free block left on the bitmap, no point\n\t\t * to reserve the space. return failed.\n\t\t */\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&my_rsv->rsv_window))\n\t\t\trsv_window_remove(sb, my_rsv);\n\t\tspin_unlock(rsv_lock);\n\t\treturn -1;\t\t/* failed */\n\t}\n\n\tstart_block = first_free_block + group_first_block;\n\t/*\n\t * check if the first free block is within the\n\t * free space we just reserved\n\t */\n\tif (start_block >= my_rsv->rsv_start && start_block <= my_rsv->rsv_end)\n\t\treturn 0;\t\t/* success */\n\t/*\n\t * if the first free bit we found is out of the reservable space\n\t * continue search for next reservable space,\n\t * start from where the free block is,\n\t * we also shift the list head to where we stopped last time\n\t */\n\tsearch_head = my_rsv;\n\tspin_lock(rsv_lock);\n\tgoto retry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsv_is_empty",
          "args": [
            "&my_rsv->rsv_window"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "rsv_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "383-387",
          "snippet": "static inline int rsv_is_empty(struct ext2_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn (rsv->_rsv_end == EXT2_RESERVE_WINDOW_NOT_ALLOCATED);\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic inline int rsv_is_empty(struct ext2_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn (rsv->_rsv_end == EXT2_RESERVE_WINDOW_NOT_ALLOCATED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_group_first_block_no",
          "args": [
            "sb",
            "group"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic ext2_grpblk_t\next2_try_to_allocate_with_rsv(struct super_block *sb, unsigned int group,\n\t\t\tstruct buffer_head *bitmap_bh, ext2_grpblk_t grp_goal,\n\t\t\tstruct ext2_reserve_window_node * my_rsv,\n\t\t\tunsigned long *count)\n{\n\text2_fsblk_t group_first_block, group_last_block;\n\text2_grpblk_t ret = 0;\n\tunsigned long num = *count;\n\n\t/*\n\t * we don't deal with reservation when\n\t * filesystem is mounted without reservation\n\t * or the file is not a regular file\n\t * or last attempt to allocate a block with reservation turned on failed\n\t */\n\tif (my_rsv == NULL) {\n\t\treturn ext2_try_to_allocate(sb, group, bitmap_bh,\n\t\t\t\t\t\tgrp_goal, count, NULL);\n\t}\n\t/*\n\t * grp_goal is a group relative block number (if there is a goal)\n\t * 0 <= grp_goal < EXT2_BLOCKS_PER_GROUP(sb)\n\t * first block is a filesystem wide block number\n\t * first block is the block number of the first block in this group\n\t */\n\tgroup_first_block = ext2_group_first_block_no(sb, group);\n\tgroup_last_block = group_first_block + (EXT2_BLOCKS_PER_GROUP(sb) - 1);\n\n\t/*\n\t * Basically we will allocate a new block from inode's reservation\n\t * window.\n\t *\n\t * We need to allocate a new reservation window, if:\n\t * a) inode does not have a reservation window; or\n\t * b) last attempt to allocate a block from existing reservation\n\t *    failed; or\n\t * c) we come here with a goal and with a reservation window\n\t *\n\t * We do not need to allocate a new reservation window if we come here\n\t * at the beginning with a goal and the goal is inside the window, or\n\t * we don't have a goal but already have a reservation window.\n\t * then we could go to allocate from the reservation window directly.\n\t */\n\twhile (1) {\n\t\tif (rsv_is_empty(&my_rsv->rsv_window) || (ret < 0) ||\n\t\t\t!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\tgrp_goal, group, sb)) {\n\t\t\tif (my_rsv->rsv_goal_size < *count)\n\t\t\t\tmy_rsv->rsv_goal_size = *count;\n\t\t\tret = alloc_new_reservation(my_rsv, grp_goal, sb,\n\t\t\t\t\t\t\tgroup, bitmap_bh);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\t\t\t/* failed */\n\n\t\t\tif (!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\t\tgrp_goal, group, sb))\n\t\t\t\tgrp_goal = -1;\n\t\t} else if (grp_goal >= 0) {\n\t\t\tint curr = my_rsv->rsv_end -\n\t\t\t\t\t(grp_goal + group_first_block) + 1;\n\n\t\t\tif (curr < *count)\n\t\t\t\ttry_to_extend_reservation(my_rsv, sb,\n\t\t\t\t\t\t\t*count - curr);\n\t\t}\n\n\t\tif ((my_rsv->rsv_start > group_last_block) ||\n\t\t\t\t(my_rsv->rsv_end < group_first_block)) {\n\t\t\trsv_window_dump(&EXT2_SB(sb)->s_rsv_window_root, 1);\n\t\t\tBUG();\n\t\t}\n\t\tret = ext2_try_to_allocate(sb, group, bitmap_bh, grp_goal,\n\t\t\t\t\t   &num, &my_rsv->rsv_window);\n\t\tif (ret >= 0) {\n\t\t\tmy_rsv->rsv_alloc_hit += num;\n\t\t\t*count = num;\n\t\t\tbreak;\t\t\t\t/* succeed */\n\t\t}\n\t\tnum = *count;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "try_to_extend_reservation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "1040-1063",
    "snippet": "static void try_to_extend_reservation(struct ext2_reserve_window_node *my_rsv,\n\t\t\tstruct super_block *sb, int size)\n{\n\tstruct ext2_reserve_window_node *next_rsv;\n\tstruct rb_node *next;\n\tspinlock_t *rsv_lock = &EXT2_SB(sb)->s_rsv_window_lock;\n\n\tif (!spin_trylock(rsv_lock))\n\t\treturn;\n\n\tnext = rb_next(&my_rsv->rsv_node);\n\n\tif (!next)\n\t\tmy_rsv->rsv_end += size;\n\telse {\n\t\tnext_rsv = rb_entry(next, struct ext2_reserve_window_node, rsv_node);\n\n\t\tif ((next_rsv->rsv_start - my_rsv->rsv_end - 1) >= size)\n\t\t\tmy_rsv->rsv_end += size;\n\t\telse\n\t\t\tmy_rsv->rsv_end = next_rsv->rsv_start - 1;\n\t}\n\tspin_unlock(rsv_lock);\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "rsv_lock"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "next",
            "structext2_reserve_window_node",
            "rsv_node"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&my_rsv->rsv_node"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "rsv_lock"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic void try_to_extend_reservation(struct ext2_reserve_window_node *my_rsv,\n\t\t\tstruct super_block *sb, int size)\n{\n\tstruct ext2_reserve_window_node *next_rsv;\n\tstruct rb_node *next;\n\tspinlock_t *rsv_lock = &EXT2_SB(sb)->s_rsv_window_lock;\n\n\tif (!spin_trylock(rsv_lock))\n\t\treturn;\n\n\tnext = rb_next(&my_rsv->rsv_node);\n\n\tif (!next)\n\t\tmy_rsv->rsv_end += size;\n\telse {\n\t\tnext_rsv = rb_entry(next, struct ext2_reserve_window_node, rsv_node);\n\n\t\tif ((next_rsv->rsv_start - my_rsv->rsv_end - 1) >= size)\n\t\t\tmy_rsv->rsv_end += size;\n\t\telse\n\t\t\tmy_rsv->rsv_end = next_rsv->rsv_start - 1;\n\t}\n\tspin_unlock(rsv_lock);\n}"
  },
  {
    "function_name": "alloc_new_reservation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "898-1021",
    "snippet": "static int alloc_new_reservation(struct ext2_reserve_window_node *my_rsv,\n\t\text2_grpblk_t grp_goal, struct super_block *sb,\n\t\tunsigned int group, struct buffer_head *bitmap_bh)\n{\n\tstruct ext2_reserve_window_node *search_head;\n\text2_fsblk_t group_first_block, group_end_block, start_block;\n\text2_grpblk_t first_free_block;\n\tstruct rb_root *fs_rsv_root = &EXT2_SB(sb)->s_rsv_window_root;\n\tunsigned long size;\n\tint ret;\n\tspinlock_t *rsv_lock = &EXT2_SB(sb)->s_rsv_window_lock;\n\n\tgroup_first_block = ext2_group_first_block_no(sb, group);\n\tgroup_end_block = group_first_block + (EXT2_BLOCKS_PER_GROUP(sb) - 1);\n\n\tif (grp_goal < 0)\n\t\tstart_block = group_first_block;\n\telse\n\t\tstart_block = grp_goal + group_first_block;\n\n\tsize = my_rsv->rsv_goal_size;\n\n\tif (!rsv_is_empty(&my_rsv->rsv_window)) {\n\t\t/*\n\t\t * if the old reservation is cross group boundary\n\t\t * and if the goal is inside the old reservation window,\n\t\t * we will come here when we just failed to allocate from\n\t\t * the first part of the window. We still have another part\n\t\t * that belongs to the next group. In this case, there is no\n\t\t * point to discard our window and try to allocate a new one\n\t\t * in this group(which will fail). we should\n\t\t * keep the reservation window, just simply move on.\n\t\t *\n\t\t * Maybe we could shift the start block of the reservation\n\t\t * window to the first block of next group.\n\t\t */\n\n\t\tif ((my_rsv->rsv_start <= group_end_block) &&\n\t\t\t\t(my_rsv->rsv_end > group_end_block) &&\n\t\t\t\t(start_block >= my_rsv->rsv_start))\n\t\t\treturn -1;\n\n\t\tif ((my_rsv->rsv_alloc_hit >\n\t\t     (my_rsv->rsv_end - my_rsv->rsv_start + 1) / 2)) {\n\t\t\t/*\n\t\t\t * if the previously allocation hit ratio is\n\t\t\t * greater than 1/2, then we double the size of\n\t\t\t * the reservation window the next time,\n\t\t\t * otherwise we keep the same size window\n\t\t\t */\n\t\t\tsize = size * 2;\n\t\t\tif (size > EXT2_MAX_RESERVE_BLOCKS)\n\t\t\t\tsize = EXT2_MAX_RESERVE_BLOCKS;\n\t\t\tmy_rsv->rsv_goal_size= size;\n\t\t}\n\t}\n\n\tspin_lock(rsv_lock);\n\t/*\n\t * shift the search start to the window near the goal block\n\t */\n\tsearch_head = search_reserve_window(fs_rsv_root, start_block);\n\n\t/*\n\t * find_next_reservable_window() simply finds a reservable window\n\t * inside the given range(start_block, group_end_block).\n\t *\n\t * To make sure the reservation window has a free bit inside it, we\n\t * need to check the bitmap after we found a reservable window.\n\t */\nretry:\n\tret = find_next_reservable_window(search_head, my_rsv, sb,\n\t\t\t\t\t\tstart_block, group_end_block);\n\n\tif (ret == -1) {\n\t\tif (!rsv_is_empty(&my_rsv->rsv_window))\n\t\t\trsv_window_remove(sb, my_rsv);\n\t\tspin_unlock(rsv_lock);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * On success, find_next_reservable_window() returns the\n\t * reservation window where there is a reservable space after it.\n\t * Before we reserve this reservable space, we need\n\t * to make sure there is at least a free block inside this region.\n\t *\n\t * Search the first free bit on the block bitmap.  Search starts from\n\t * the start block of the reservable space we just found.\n\t */\n\tspin_unlock(rsv_lock);\n\tfirst_free_block = bitmap_search_next_usable_block(\n\t\t\tmy_rsv->rsv_start - group_first_block,\n\t\t\tbitmap_bh, group_end_block - group_first_block + 1);\n\n\tif (first_free_block < 0) {\n\t\t/*\n\t\t * no free block left on the bitmap, no point\n\t\t * to reserve the space. return failed.\n\t\t */\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&my_rsv->rsv_window))\n\t\t\trsv_window_remove(sb, my_rsv);\n\t\tspin_unlock(rsv_lock);\n\t\treturn -1;\t\t/* failed */\n\t}\n\n\tstart_block = first_free_block + group_first_block;\n\t/*\n\t * check if the first free block is within the\n\t * free space we just reserved\n\t */\n\tif (start_block >= my_rsv->rsv_start && start_block <= my_rsv->rsv_end)\n\t\treturn 0;\t\t/* success */\n\t/*\n\t * if the first free bit we found is out of the reservable space\n\t * continue search for next reservable space,\n\t * start from where the free block is,\n\t * we also shift the list head to where we stopped last time\n\t */\n\tsearch_head = my_rsv;\n\tspin_lock(rsv_lock);\n\tgoto retry;\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "rsv_lock"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "rsv_lock"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsv_window_remove",
          "args": [
            "sb",
            "my_rsv"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "rsv_window_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "368-375",
          "snippet": "static void rsv_window_remove(struct super_block *sb,\n\t\t\t      struct ext2_reserve_window_node *rsv)\n{\n\trsv->rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_alloc_hit = 0;\n\trb_erase(&rsv->rsv_node, &EXT2_SB(sb)->s_rsv_window_root);\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic void rsv_window_remove(struct super_block *sb,\n\t\t\t      struct ext2_reserve_window_node *rsv)\n{\n\trsv->rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_alloc_hit = 0;\n\trb_erase(&rsv->rsv_node, &EXT2_SB(sb)->s_rsv_window_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsv_is_empty",
          "args": [
            "&my_rsv->rsv_window"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "rsv_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "383-387",
          "snippet": "static inline int rsv_is_empty(struct ext2_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn (rsv->_rsv_end == EXT2_RESERVE_WINDOW_NOT_ALLOCATED);\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic inline int rsv_is_empty(struct ext2_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn (rsv->_rsv_end == EXT2_RESERVE_WINDOW_NOT_ALLOCATED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_search_next_usable_block",
          "args": [
            "my_rsv->rsv_start - group_first_block",
            "bitmap_bh",
            "group_end_block - group_first_block + 1"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_search_next_usable_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "578-588",
          "snippet": "static ext2_grpblk_t\nbitmap_search_next_usable_block(ext2_grpblk_t start, struct buffer_head *bh,\n\t\t\t\t\text2_grpblk_t maxblocks)\n{\n\text2_grpblk_t next;\n\n\tnext = ext2_find_next_zero_bit(bh->b_data, maxblocks, start);\n\tif (next >= maxblocks)\n\t\treturn -1;\n\treturn next;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic ext2_grpblk_t\nbitmap_search_next_usable_block(ext2_grpblk_t start, struct buffer_head *bh,\n\t\t\t\t\text2_grpblk_t maxblocks)\n{\n\text2_grpblk_t next;\n\n\tnext = ext2_find_next_zero_bit(bh->b_data, maxblocks, start);\n\tif (next >= maxblocks)\n\t\treturn -1;\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_reservable_window",
          "args": [
            "search_head",
            "my_rsv",
            "sb",
            "start_block",
            "group_end_block"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_reservable_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "776-859",
          "snippet": "static int find_next_reservable_window(\n\t\t\t\tstruct ext2_reserve_window_node *search_head,\n\t\t\t\tstruct ext2_reserve_window_node *my_rsv,\n\t\t\t\tstruct super_block * sb,\n\t\t\t\text2_fsblk_t start_block,\n\t\t\t\text2_fsblk_t last_block)\n{\n\tstruct rb_node *next;\n\tstruct ext2_reserve_window_node *rsv, *prev;\n\text2_fsblk_t cur;\n\tint size = my_rsv->rsv_goal_size;\n\n\t/* TODO: make the start of the reservation window byte-aligned */\n\t/* cur = *start_block & ~7;*/\n\tcur = start_block;\n\trsv = search_head;\n\tif (!rsv)\n\t\treturn -1;\n\n\twhile (1) {\n\t\tif (cur <= rsv->rsv_end)\n\t\t\tcur = rsv->rsv_end + 1;\n\n\t\t/* TODO?\n\t\t * in the case we could not find a reservable space\n\t\t * that is what is expected, during the re-search, we could\n\t\t * remember what's the largest reservable space we could have\n\t\t * and return that one.\n\t\t *\n\t\t * For now it will fail if we could not find the reservable\n\t\t * space with expected-size (or more)...\n\t\t */\n\t\tif (cur > last_block)\n\t\t\treturn -1;\t\t/* fail */\n\n\t\tprev = rsv;\n\t\tnext = rb_next(&rsv->rsv_node);\n\t\trsv = rb_entry(next,struct ext2_reserve_window_node,rsv_node);\n\n\t\t/*\n\t\t * Reached the last reservation, we can just append to the\n\t\t * previous one.\n\t\t */\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (cur + size <= rsv->rsv_start) {\n\t\t\t/*\n\t\t\t * Found a reserveable space big enough.  We could\n\t\t\t * have a reservation across the group boundary here\n\t\t \t */\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * we come here either :\n\t * when we reach the end of the whole list,\n\t * and there is empty reservable space after last entry in the list.\n\t * append it to the end of the list.\n\t *\n\t * or we found one reservable space in the middle of the list,\n\t * return the reservation window that we could append to.\n\t * succeed.\n\t */\n\n\tif ((prev != my_rsv) && (!rsv_is_empty(&my_rsv->rsv_window)))\n\t\trsv_window_remove(sb, my_rsv);\n\n\t/*\n\t * Let's book the whole available window for now.  We will check the\n\t * disk bitmap later and then, if there are free blocks then we adjust\n\t * the window size if it's larger than requested.\n\t * Otherwise, we will remove this node from the tree next time\n\t * call find_next_reservable_window.\n\t */\n\tmy_rsv->rsv_start = cur;\n\tmy_rsv->rsv_end = cur + size - 1;\n\tmy_rsv->rsv_alloc_hit = 0;\n\n\tif (prev != my_rsv)\n\t\text2_rsv_window_add(sb, my_rsv);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic int find_next_reservable_window(\n\t\t\t\tstruct ext2_reserve_window_node *search_head,\n\t\t\t\tstruct ext2_reserve_window_node *my_rsv,\n\t\t\t\tstruct super_block * sb,\n\t\t\t\text2_fsblk_t start_block,\n\t\t\t\text2_fsblk_t last_block)\n{\n\tstruct rb_node *next;\n\tstruct ext2_reserve_window_node *rsv, *prev;\n\text2_fsblk_t cur;\n\tint size = my_rsv->rsv_goal_size;\n\n\t/* TODO: make the start of the reservation window byte-aligned */\n\t/* cur = *start_block & ~7;*/\n\tcur = start_block;\n\trsv = search_head;\n\tif (!rsv)\n\t\treturn -1;\n\n\twhile (1) {\n\t\tif (cur <= rsv->rsv_end)\n\t\t\tcur = rsv->rsv_end + 1;\n\n\t\t/* TODO?\n\t\t * in the case we could not find a reservable space\n\t\t * that is what is expected, during the re-search, we could\n\t\t * remember what's the largest reservable space we could have\n\t\t * and return that one.\n\t\t *\n\t\t * For now it will fail if we could not find the reservable\n\t\t * space with expected-size (or more)...\n\t\t */\n\t\tif (cur > last_block)\n\t\t\treturn -1;\t\t/* fail */\n\n\t\tprev = rsv;\n\t\tnext = rb_next(&rsv->rsv_node);\n\t\trsv = rb_entry(next,struct ext2_reserve_window_node,rsv_node);\n\n\t\t/*\n\t\t * Reached the last reservation, we can just append to the\n\t\t * previous one.\n\t\t */\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (cur + size <= rsv->rsv_start) {\n\t\t\t/*\n\t\t\t * Found a reserveable space big enough.  We could\n\t\t\t * have a reservation across the group boundary here\n\t\t \t */\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * we come here either :\n\t * when we reach the end of the whole list,\n\t * and there is empty reservable space after last entry in the list.\n\t * append it to the end of the list.\n\t *\n\t * or we found one reservable space in the middle of the list,\n\t * return the reservation window that we could append to.\n\t * succeed.\n\t */\n\n\tif ((prev != my_rsv) && (!rsv_is_empty(&my_rsv->rsv_window)))\n\t\trsv_window_remove(sb, my_rsv);\n\n\t/*\n\t * Let's book the whole available window for now.  We will check the\n\t * disk bitmap later and then, if there are free blocks then we adjust\n\t * the window size if it's larger than requested.\n\t * Otherwise, we will remove this node from the tree next time\n\t * call find_next_reservable_window.\n\t */\n\tmy_rsv->rsv_start = cur;\n\tmy_rsv->rsv_end = cur + size - 1;\n\tmy_rsv->rsv_alloc_hit = 0;\n\n\tif (prev != my_rsv)\n\t\text2_rsv_window_add(sb, my_rsv);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_reserve_window",
          "args": [
            "fs_rsv_root",
            "start_block"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "search_reserve_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "290-320",
          "snippet": "static struct ext2_reserve_window_node *\nsearch_reserve_window(struct rb_root *root, ext2_fsblk_t goal)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct ext2_reserve_window_node *rsv;\n\n\tif (!n)\n\t\treturn NULL;\n\n\tdo {\n\t\trsv = rb_entry(n, struct ext2_reserve_window_node, rsv_node);\n\n\t\tif (goal < rsv->rsv_start)\n\t\t\tn = n->rb_left;\n\t\telse if (goal > rsv->rsv_end)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn rsv;\n\t} while (n);\n\t/*\n\t * We've fallen off the end of the tree: the goal wasn't inside\n\t * any particular node.  OK, the previous node must be to one\n\t * side of the interval containing the goal.  If it's the RHS,\n\t * we need to back up one.\n\t */\n\tif (rsv->rsv_start > goal) {\n\t\tn = rb_prev(&rsv->rsv_node);\n\t\trsv = rb_entry(n, struct ext2_reserve_window_node, rsv_node);\n\t}\n\treturn rsv;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic struct ext2_reserve_window_node *\nsearch_reserve_window(struct rb_root *root, ext2_fsblk_t goal)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct ext2_reserve_window_node *rsv;\n\n\tif (!n)\n\t\treturn NULL;\n\n\tdo {\n\t\trsv = rb_entry(n, struct ext2_reserve_window_node, rsv_node);\n\n\t\tif (goal < rsv->rsv_start)\n\t\t\tn = n->rb_left;\n\t\telse if (goal > rsv->rsv_end)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn rsv;\n\t} while (n);\n\t/*\n\t * We've fallen off the end of the tree: the goal wasn't inside\n\t * any particular node.  OK, the previous node must be to one\n\t * side of the interval containing the goal.  If it's the RHS,\n\t * we need to back up one.\n\t */\n\tif (rsv->rsv_start > goal) {\n\t\tn = rb_prev(&rsv->rsv_node);\n\t\trsv = rb_entry(n, struct ext2_reserve_window_node, rsv_node);\n\t}\n\treturn rsv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_group_first_block_no",
          "args": [
            "sb",
            "group"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic int alloc_new_reservation(struct ext2_reserve_window_node *my_rsv,\n\t\text2_grpblk_t grp_goal, struct super_block *sb,\n\t\tunsigned int group, struct buffer_head *bitmap_bh)\n{\n\tstruct ext2_reserve_window_node *search_head;\n\text2_fsblk_t group_first_block, group_end_block, start_block;\n\text2_grpblk_t first_free_block;\n\tstruct rb_root *fs_rsv_root = &EXT2_SB(sb)->s_rsv_window_root;\n\tunsigned long size;\n\tint ret;\n\tspinlock_t *rsv_lock = &EXT2_SB(sb)->s_rsv_window_lock;\n\n\tgroup_first_block = ext2_group_first_block_no(sb, group);\n\tgroup_end_block = group_first_block + (EXT2_BLOCKS_PER_GROUP(sb) - 1);\n\n\tif (grp_goal < 0)\n\t\tstart_block = group_first_block;\n\telse\n\t\tstart_block = grp_goal + group_first_block;\n\n\tsize = my_rsv->rsv_goal_size;\n\n\tif (!rsv_is_empty(&my_rsv->rsv_window)) {\n\t\t/*\n\t\t * if the old reservation is cross group boundary\n\t\t * and if the goal is inside the old reservation window,\n\t\t * we will come here when we just failed to allocate from\n\t\t * the first part of the window. We still have another part\n\t\t * that belongs to the next group. In this case, there is no\n\t\t * point to discard our window and try to allocate a new one\n\t\t * in this group(which will fail). we should\n\t\t * keep the reservation window, just simply move on.\n\t\t *\n\t\t * Maybe we could shift the start block of the reservation\n\t\t * window to the first block of next group.\n\t\t */\n\n\t\tif ((my_rsv->rsv_start <= group_end_block) &&\n\t\t\t\t(my_rsv->rsv_end > group_end_block) &&\n\t\t\t\t(start_block >= my_rsv->rsv_start))\n\t\t\treturn -1;\n\n\t\tif ((my_rsv->rsv_alloc_hit >\n\t\t     (my_rsv->rsv_end - my_rsv->rsv_start + 1) / 2)) {\n\t\t\t/*\n\t\t\t * if the previously allocation hit ratio is\n\t\t\t * greater than 1/2, then we double the size of\n\t\t\t * the reservation window the next time,\n\t\t\t * otherwise we keep the same size window\n\t\t\t */\n\t\t\tsize = size * 2;\n\t\t\tif (size > EXT2_MAX_RESERVE_BLOCKS)\n\t\t\t\tsize = EXT2_MAX_RESERVE_BLOCKS;\n\t\t\tmy_rsv->rsv_goal_size= size;\n\t\t}\n\t}\n\n\tspin_lock(rsv_lock);\n\t/*\n\t * shift the search start to the window near the goal block\n\t */\n\tsearch_head = search_reserve_window(fs_rsv_root, start_block);\n\n\t/*\n\t * find_next_reservable_window() simply finds a reservable window\n\t * inside the given range(start_block, group_end_block).\n\t *\n\t * To make sure the reservation window has a free bit inside it, we\n\t * need to check the bitmap after we found a reservable window.\n\t */\nretry:\n\tret = find_next_reservable_window(search_head, my_rsv, sb,\n\t\t\t\t\t\tstart_block, group_end_block);\n\n\tif (ret == -1) {\n\t\tif (!rsv_is_empty(&my_rsv->rsv_window))\n\t\t\trsv_window_remove(sb, my_rsv);\n\t\tspin_unlock(rsv_lock);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * On success, find_next_reservable_window() returns the\n\t * reservation window where there is a reservable space after it.\n\t * Before we reserve this reservable space, we need\n\t * to make sure there is at least a free block inside this region.\n\t *\n\t * Search the first free bit on the block bitmap.  Search starts from\n\t * the start block of the reservable space we just found.\n\t */\n\tspin_unlock(rsv_lock);\n\tfirst_free_block = bitmap_search_next_usable_block(\n\t\t\tmy_rsv->rsv_start - group_first_block,\n\t\t\tbitmap_bh, group_end_block - group_first_block + 1);\n\n\tif (first_free_block < 0) {\n\t\t/*\n\t\t * no free block left on the bitmap, no point\n\t\t * to reserve the space. return failed.\n\t\t */\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&my_rsv->rsv_window))\n\t\t\trsv_window_remove(sb, my_rsv);\n\t\tspin_unlock(rsv_lock);\n\t\treturn -1;\t\t/* failed */\n\t}\n\n\tstart_block = first_free_block + group_first_block;\n\t/*\n\t * check if the first free block is within the\n\t * free space we just reserved\n\t */\n\tif (start_block >= my_rsv->rsv_start && start_block <= my_rsv->rsv_end)\n\t\treturn 0;\t\t/* success */\n\t/*\n\t * if the first free bit we found is out of the reservable space\n\t * continue search for next reservable space,\n\t * start from where the free block is,\n\t * we also shift the list head to where we stopped last time\n\t */\n\tsearch_head = my_rsv;\n\tspin_lock(rsv_lock);\n\tgoto retry;\n}"
  },
  {
    "function_name": "find_next_reservable_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "776-859",
    "snippet": "static int find_next_reservable_window(\n\t\t\t\tstruct ext2_reserve_window_node *search_head,\n\t\t\t\tstruct ext2_reserve_window_node *my_rsv,\n\t\t\t\tstruct super_block * sb,\n\t\t\t\text2_fsblk_t start_block,\n\t\t\t\text2_fsblk_t last_block)\n{\n\tstruct rb_node *next;\n\tstruct ext2_reserve_window_node *rsv, *prev;\n\text2_fsblk_t cur;\n\tint size = my_rsv->rsv_goal_size;\n\n\t/* TODO: make the start of the reservation window byte-aligned */\n\t/* cur = *start_block & ~7;*/\n\tcur = start_block;\n\trsv = search_head;\n\tif (!rsv)\n\t\treturn -1;\n\n\twhile (1) {\n\t\tif (cur <= rsv->rsv_end)\n\t\t\tcur = rsv->rsv_end + 1;\n\n\t\t/* TODO?\n\t\t * in the case we could not find a reservable space\n\t\t * that is what is expected, during the re-search, we could\n\t\t * remember what's the largest reservable space we could have\n\t\t * and return that one.\n\t\t *\n\t\t * For now it will fail if we could not find the reservable\n\t\t * space with expected-size (or more)...\n\t\t */\n\t\tif (cur > last_block)\n\t\t\treturn -1;\t\t/* fail */\n\n\t\tprev = rsv;\n\t\tnext = rb_next(&rsv->rsv_node);\n\t\trsv = rb_entry(next,struct ext2_reserve_window_node,rsv_node);\n\n\t\t/*\n\t\t * Reached the last reservation, we can just append to the\n\t\t * previous one.\n\t\t */\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (cur + size <= rsv->rsv_start) {\n\t\t\t/*\n\t\t\t * Found a reserveable space big enough.  We could\n\t\t\t * have a reservation across the group boundary here\n\t\t \t */\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * we come here either :\n\t * when we reach the end of the whole list,\n\t * and there is empty reservable space after last entry in the list.\n\t * append it to the end of the list.\n\t *\n\t * or we found one reservable space in the middle of the list,\n\t * return the reservation window that we could append to.\n\t * succeed.\n\t */\n\n\tif ((prev != my_rsv) && (!rsv_is_empty(&my_rsv->rsv_window)))\n\t\trsv_window_remove(sb, my_rsv);\n\n\t/*\n\t * Let's book the whole available window for now.  We will check the\n\t * disk bitmap later and then, if there are free blocks then we adjust\n\t * the window size if it's larger than requested.\n\t * Otherwise, we will remove this node from the tree next time\n\t * call find_next_reservable_window.\n\t */\n\tmy_rsv->rsv_start = cur;\n\tmy_rsv->rsv_end = cur + size - 1;\n\tmy_rsv->rsv_alloc_hit = 0;\n\n\tif (prev != my_rsv)\n\t\text2_rsv_window_add(sb, my_rsv);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_rsv_window_add",
          "args": [
            "sb",
            "my_rsv"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_rsv_window_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "329-357",
          "snippet": "void ext2_rsv_window_add(struct super_block *sb,\n\t\t    struct ext2_reserve_window_node *rsv)\n{\n\tstruct rb_root *root = &EXT2_SB(sb)->s_rsv_window_root;\n\tstruct rb_node *node = &rsv->rsv_node;\n\text2_fsblk_t start = rsv->rsv_start;\n\n\tstruct rb_node ** p = &root->rb_node;\n\tstruct rb_node * parent = NULL;\n\tstruct ext2_reserve_window_node *this;\n\n\twhile (*p)\n\t{\n\t\tparent = *p;\n\t\tthis = rb_entry(parent, struct ext2_reserve_window_node, rsv_node);\n\n\t\tif (start < this->rsv_start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (start > this->rsv_end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\trsv_window_dump(root, 1);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nvoid ext2_rsv_window_add(struct super_block *sb,\n\t\t    struct ext2_reserve_window_node *rsv)\n{\n\tstruct rb_root *root = &EXT2_SB(sb)->s_rsv_window_root;\n\tstruct rb_node *node = &rsv->rsv_node;\n\text2_fsblk_t start = rsv->rsv_start;\n\n\tstruct rb_node ** p = &root->rb_node;\n\tstruct rb_node * parent = NULL;\n\tstruct ext2_reserve_window_node *this;\n\n\twhile (*p)\n\t{\n\t\tparent = *p;\n\t\tthis = rb_entry(parent, struct ext2_reserve_window_node, rsv_node);\n\n\t\tif (start < this->rsv_start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (start > this->rsv_end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\trsv_window_dump(root, 1);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsv_window_remove",
          "args": [
            "sb",
            "my_rsv"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "rsv_window_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "368-375",
          "snippet": "static void rsv_window_remove(struct super_block *sb,\n\t\t\t      struct ext2_reserve_window_node *rsv)\n{\n\trsv->rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_alloc_hit = 0;\n\trb_erase(&rsv->rsv_node, &EXT2_SB(sb)->s_rsv_window_root);\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic void rsv_window_remove(struct super_block *sb,\n\t\t\t      struct ext2_reserve_window_node *rsv)\n{\n\trsv->rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_alloc_hit = 0;\n\trb_erase(&rsv->rsv_node, &EXT2_SB(sb)->s_rsv_window_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsv_is_empty",
          "args": [
            "&my_rsv->rsv_window"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "rsv_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "383-387",
          "snippet": "static inline int rsv_is_empty(struct ext2_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn (rsv->_rsv_end == EXT2_RESERVE_WINDOW_NOT_ALLOCATED);\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic inline int rsv_is_empty(struct ext2_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn (rsv->_rsv_end == EXT2_RESERVE_WINDOW_NOT_ALLOCATED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "next",
            "structext2_reserve_window_node",
            "rsv_node"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&rsv->rsv_node"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic int find_next_reservable_window(\n\t\t\t\tstruct ext2_reserve_window_node *search_head,\n\t\t\t\tstruct ext2_reserve_window_node *my_rsv,\n\t\t\t\tstruct super_block * sb,\n\t\t\t\text2_fsblk_t start_block,\n\t\t\t\text2_fsblk_t last_block)\n{\n\tstruct rb_node *next;\n\tstruct ext2_reserve_window_node *rsv, *prev;\n\text2_fsblk_t cur;\n\tint size = my_rsv->rsv_goal_size;\n\n\t/* TODO: make the start of the reservation window byte-aligned */\n\t/* cur = *start_block & ~7;*/\n\tcur = start_block;\n\trsv = search_head;\n\tif (!rsv)\n\t\treturn -1;\n\n\twhile (1) {\n\t\tif (cur <= rsv->rsv_end)\n\t\t\tcur = rsv->rsv_end + 1;\n\n\t\t/* TODO?\n\t\t * in the case we could not find a reservable space\n\t\t * that is what is expected, during the re-search, we could\n\t\t * remember what's the largest reservable space we could have\n\t\t * and return that one.\n\t\t *\n\t\t * For now it will fail if we could not find the reservable\n\t\t * space with expected-size (or more)...\n\t\t */\n\t\tif (cur > last_block)\n\t\t\treturn -1;\t\t/* fail */\n\n\t\tprev = rsv;\n\t\tnext = rb_next(&rsv->rsv_node);\n\t\trsv = rb_entry(next,struct ext2_reserve_window_node,rsv_node);\n\n\t\t/*\n\t\t * Reached the last reservation, we can just append to the\n\t\t * previous one.\n\t\t */\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (cur + size <= rsv->rsv_start) {\n\t\t\t/*\n\t\t\t * Found a reserveable space big enough.  We could\n\t\t\t * have a reservation across the group boundary here\n\t\t \t */\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * we come here either :\n\t * when we reach the end of the whole list,\n\t * and there is empty reservable space after last entry in the list.\n\t * append it to the end of the list.\n\t *\n\t * or we found one reservable space in the middle of the list,\n\t * return the reservation window that we could append to.\n\t * succeed.\n\t */\n\n\tif ((prev != my_rsv) && (!rsv_is_empty(&my_rsv->rsv_window)))\n\t\trsv_window_remove(sb, my_rsv);\n\n\t/*\n\t * Let's book the whole available window for now.  We will check the\n\t * disk bitmap later and then, if there are free blocks then we adjust\n\t * the window size if it's larger than requested.\n\t * Otherwise, we will remove this node from the tree next time\n\t * call find_next_reservable_window.\n\t */\n\tmy_rsv->rsv_start = cur;\n\tmy_rsv->rsv_end = cur + size - 1;\n\tmy_rsv->rsv_alloc_hit = 0;\n\n\tif (prev != my_rsv)\n\t\text2_rsv_window_add(sb, my_rsv);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext2_try_to_allocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "663-741",
    "snippet": "static int\next2_try_to_allocate(struct super_block *sb, int group,\n\t\t\tstruct buffer_head *bitmap_bh, ext2_grpblk_t grp_goal,\n\t\t\tunsigned long *count,\n\t\t\tstruct ext2_reserve_window *my_rsv)\n{\n\text2_fsblk_t group_first_block;\n       \text2_grpblk_t start, end;\n\tunsigned long num = 0;\n\n\t/* we do allocation within the reservation window if we have a window */\n\tif (my_rsv) {\n\t\tgroup_first_block = ext2_group_first_block_no(sb, group);\n\t\tif (my_rsv->_rsv_start >= group_first_block)\n\t\t\tstart = my_rsv->_rsv_start - group_first_block;\n\t\telse\n\t\t\t/* reservation window cross group boundary */\n\t\t\tstart = 0;\n\t\tend = my_rsv->_rsv_end - group_first_block + 1;\n\t\tif (end > EXT2_BLOCKS_PER_GROUP(sb))\n\t\t\t/* reservation window crosses group boundary */\n\t\t\tend = EXT2_BLOCKS_PER_GROUP(sb);\n\t\tif ((start <= grp_goal) && (grp_goal < end))\n\t\t\tstart = grp_goal;\n\t\telse\n\t\t\tgrp_goal = -1;\n\t} else {\n\t\tif (grp_goal > 0)\n\t\t\tstart = grp_goal;\n\t\telse\n\t\t\tstart = 0;\n\t\tend = EXT2_BLOCKS_PER_GROUP(sb);\n\t}\n\n\tBUG_ON(start > EXT2_BLOCKS_PER_GROUP(sb));\n\nrepeat:\n\tif (grp_goal < 0) {\n\t\tgrp_goal = find_next_usable_block(start, bitmap_bh, end);\n\t\tif (grp_goal < 0)\n\t\t\tgoto fail_access;\n\t\tif (!my_rsv) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < 7 && grp_goal > start &&\n\t\t\t\t\t!ext2_test_bit(grp_goal - 1,\n\t\t\t\t\t     \t\tbitmap_bh->b_data);\n\t\t\t     \t\ti++, grp_goal--)\n\t\t\t\t;\n\t\t}\n\t}\n\tstart = grp_goal;\n\n\tif (ext2_set_bit_atomic(sb_bgl_lock(EXT2_SB(sb), group), grp_goal,\n\t\t\t       \t\t\t\tbitmap_bh->b_data)) {\n\t\t/*\n\t\t * The block was allocated by another thread, or it was\n\t\t * allocated and then freed by another thread\n\t\t */\n\t\tstart++;\n\t\tgrp_goal++;\n\t\tif (start >= end)\n\t\t\tgoto fail_access;\n\t\tgoto repeat;\n\t}\n\tnum++;\n\tgrp_goal++;\n\twhile (num < *count && grp_goal < end\n\t\t&& !ext2_set_bit_atomic(sb_bgl_lock(EXT2_SB(sb), group),\n\t\t\t\t\tgrp_goal, bitmap_bh->b_data)) {\n\t\tnum++;\n\t\tgrp_goal++;\n\t}\n\t*count = num;\n\treturn grp_goal - num;\nfail_access:\n\t*count = num;\n\treturn -1;\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_set_bit_atomic",
          "args": [
            "sb_bgl_lock(EXT2_SB(sb), group)",
            "grp_goal",
            "bitmap_bh->b_data"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bgl_lock",
          "args": [
            "EXT2_SB(sb)",
            "group"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "sb_bgl_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "116-120",
          "snippet": "static inline spinlock_t *\nsb_bgl_lock(struct ext2_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nstatic inline spinlock_t *\nsb_bgl_lock(struct ext2_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_set_bit_atomic",
          "args": [
            "sb_bgl_lock(EXT2_SB(sb), group)",
            "grp_goal",
            "bitmap_bh->b_data"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_test_bit",
          "args": [
            "grp_goal - 1",
            "bitmap_bh->b_data"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_usable_block",
          "args": [
            "start",
            "bitmap_bh",
            "end"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_usable_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "602-639",
          "snippet": "static ext2_grpblk_t\nfind_next_usable_block(int start, struct buffer_head *bh, int maxblocks)\n{\n\text2_grpblk_t here, next;\n\tchar *p, *r;\n\n\tif (start > 0) {\n\t\t/*\n\t\t * The goal was occupied; search forward for a free \n\t\t * block within the next XX blocks.\n\t\t *\n\t\t * end_goal is more or less random, but it has to be\n\t\t * less than EXT2_BLOCKS_PER_GROUP. Aligning up to the\n\t\t * next 64-bit boundary is simple..\n\t\t */\n\t\text2_grpblk_t end_goal = (start + 63) & ~63;\n\t\tif (end_goal > maxblocks)\n\t\t\tend_goal = maxblocks;\n\t\there = ext2_find_next_zero_bit(bh->b_data, end_goal, start);\n\t\tif (here < end_goal)\n\t\t\treturn here;\n\t\text2_debug(\"Bit not found near goal\\n\");\n\t}\n\n\there = start;\n\tif (here < 0)\n\t\there = 0;\n\n\tp = ((char *)bh->b_data) + (here >> 3);\n\tr = memscan(p, 0, ((maxblocks + 7) >> 3) - (here >> 3));\n\tnext = (r - ((char *)bh->b_data)) << 3;\n\n\tif (next < maxblocks && next >= here)\n\t\treturn next;\n\n\there = bitmap_search_next_usable_block(here, bh, maxblocks);\n\treturn here;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic ext2_grpblk_t\nfind_next_usable_block(int start, struct buffer_head *bh, int maxblocks)\n{\n\text2_grpblk_t here, next;\n\tchar *p, *r;\n\n\tif (start > 0) {\n\t\t/*\n\t\t * The goal was occupied; search forward for a free \n\t\t * block within the next XX blocks.\n\t\t *\n\t\t * end_goal is more or less random, but it has to be\n\t\t * less than EXT2_BLOCKS_PER_GROUP. Aligning up to the\n\t\t * next 64-bit boundary is simple..\n\t\t */\n\t\text2_grpblk_t end_goal = (start + 63) & ~63;\n\t\tif (end_goal > maxblocks)\n\t\t\tend_goal = maxblocks;\n\t\there = ext2_find_next_zero_bit(bh->b_data, end_goal, start);\n\t\tif (here < end_goal)\n\t\t\treturn here;\n\t\text2_debug(\"Bit not found near goal\\n\");\n\t}\n\n\there = start;\n\tif (here < 0)\n\t\there = 0;\n\n\tp = ((char *)bh->b_data) + (here >> 3);\n\tr = memscan(p, 0, ((maxblocks + 7) >> 3) - (here >> 3));\n\tnext = (r - ((char *)bh->b_data)) << 3;\n\n\tif (next < maxblocks && next >= here)\n\t\treturn next;\n\n\there = bitmap_search_next_usable_block(here, bh, maxblocks);\n\treturn here;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start > EXT2_BLOCKS_PER_GROUP(sb)"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_group_first_block_no",
          "args": [
            "sb",
            "group"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic int\next2_try_to_allocate(struct super_block *sb, int group,\n\t\t\tstruct buffer_head *bitmap_bh, ext2_grpblk_t grp_goal,\n\t\t\tunsigned long *count,\n\t\t\tstruct ext2_reserve_window *my_rsv)\n{\n\text2_fsblk_t group_first_block;\n       \text2_grpblk_t start, end;\n\tunsigned long num = 0;\n\n\t/* we do allocation within the reservation window if we have a window */\n\tif (my_rsv) {\n\t\tgroup_first_block = ext2_group_first_block_no(sb, group);\n\t\tif (my_rsv->_rsv_start >= group_first_block)\n\t\t\tstart = my_rsv->_rsv_start - group_first_block;\n\t\telse\n\t\t\t/* reservation window cross group boundary */\n\t\t\tstart = 0;\n\t\tend = my_rsv->_rsv_end - group_first_block + 1;\n\t\tif (end > EXT2_BLOCKS_PER_GROUP(sb))\n\t\t\t/* reservation window crosses group boundary */\n\t\t\tend = EXT2_BLOCKS_PER_GROUP(sb);\n\t\tif ((start <= grp_goal) && (grp_goal < end))\n\t\t\tstart = grp_goal;\n\t\telse\n\t\t\tgrp_goal = -1;\n\t} else {\n\t\tif (grp_goal > 0)\n\t\t\tstart = grp_goal;\n\t\telse\n\t\t\tstart = 0;\n\t\tend = EXT2_BLOCKS_PER_GROUP(sb);\n\t}\n\n\tBUG_ON(start > EXT2_BLOCKS_PER_GROUP(sb));\n\nrepeat:\n\tif (grp_goal < 0) {\n\t\tgrp_goal = find_next_usable_block(start, bitmap_bh, end);\n\t\tif (grp_goal < 0)\n\t\t\tgoto fail_access;\n\t\tif (!my_rsv) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < 7 && grp_goal > start &&\n\t\t\t\t\t!ext2_test_bit(grp_goal - 1,\n\t\t\t\t\t     \t\tbitmap_bh->b_data);\n\t\t\t     \t\ti++, grp_goal--)\n\t\t\t\t;\n\t\t}\n\t}\n\tstart = grp_goal;\n\n\tif (ext2_set_bit_atomic(sb_bgl_lock(EXT2_SB(sb), group), grp_goal,\n\t\t\t       \t\t\t\tbitmap_bh->b_data)) {\n\t\t/*\n\t\t * The block was allocated by another thread, or it was\n\t\t * allocated and then freed by another thread\n\t\t */\n\t\tstart++;\n\t\tgrp_goal++;\n\t\tif (start >= end)\n\t\t\tgoto fail_access;\n\t\tgoto repeat;\n\t}\n\tnum++;\n\tgrp_goal++;\n\twhile (num < *count && grp_goal < end\n\t\t&& !ext2_set_bit_atomic(sb_bgl_lock(EXT2_SB(sb), group),\n\t\t\t\t\tgrp_goal, bitmap_bh->b_data)) {\n\t\tnum++;\n\t\tgrp_goal++;\n\t}\n\t*count = num;\n\treturn grp_goal - num;\nfail_access:\n\t*count = num;\n\treturn -1;\n}"
  },
  {
    "function_name": "find_next_usable_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "602-639",
    "snippet": "static ext2_grpblk_t\nfind_next_usable_block(int start, struct buffer_head *bh, int maxblocks)\n{\n\text2_grpblk_t here, next;\n\tchar *p, *r;\n\n\tif (start > 0) {\n\t\t/*\n\t\t * The goal was occupied; search forward for a free \n\t\t * block within the next XX blocks.\n\t\t *\n\t\t * end_goal is more or less random, but it has to be\n\t\t * less than EXT2_BLOCKS_PER_GROUP. Aligning up to the\n\t\t * next 64-bit boundary is simple..\n\t\t */\n\t\text2_grpblk_t end_goal = (start + 63) & ~63;\n\t\tif (end_goal > maxblocks)\n\t\t\tend_goal = maxblocks;\n\t\there = ext2_find_next_zero_bit(bh->b_data, end_goal, start);\n\t\tif (here < end_goal)\n\t\t\treturn here;\n\t\text2_debug(\"Bit not found near goal\\n\");\n\t}\n\n\there = start;\n\tif (here < 0)\n\t\there = 0;\n\n\tp = ((char *)bh->b_data) + (here >> 3);\n\tr = memscan(p, 0, ((maxblocks + 7) >> 3) - (here >> 3));\n\tnext = (r - ((char *)bh->b_data)) << 3;\n\n\tif (next < maxblocks && next >= here)\n\t\treturn next;\n\n\there = bitmap_search_next_usable_block(here, bh, maxblocks);\n\treturn here;\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_search_next_usable_block",
          "args": [
            "here",
            "bh",
            "maxblocks"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_search_next_usable_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "578-588",
          "snippet": "static ext2_grpblk_t\nbitmap_search_next_usable_block(ext2_grpblk_t start, struct buffer_head *bh,\n\t\t\t\t\text2_grpblk_t maxblocks)\n{\n\text2_grpblk_t next;\n\n\tnext = ext2_find_next_zero_bit(bh->b_data, maxblocks, start);\n\tif (next >= maxblocks)\n\t\treturn -1;\n\treturn next;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic ext2_grpblk_t\nbitmap_search_next_usable_block(ext2_grpblk_t start, struct buffer_head *bh,\n\t\t\t\t\text2_grpblk_t maxblocks)\n{\n\text2_grpblk_t next;\n\n\tnext = ext2_find_next_zero_bit(bh->b_data, maxblocks, start);\n\tif (next >= maxblocks)\n\t\treturn -1;\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memscan",
          "args": [
            "p",
            "0",
            "((maxblocks + 7) >> 3) - (here >> 3)"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_debug",
          "args": [
            "\"Bit not found near goal\\n\""
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_find_next_zero_bit",
          "args": [
            "bh->b_data",
            "end_goal",
            "start"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic ext2_grpblk_t\nfind_next_usable_block(int start, struct buffer_head *bh, int maxblocks)\n{\n\text2_grpblk_t here, next;\n\tchar *p, *r;\n\n\tif (start > 0) {\n\t\t/*\n\t\t * The goal was occupied; search forward for a free \n\t\t * block within the next XX blocks.\n\t\t *\n\t\t * end_goal is more or less random, but it has to be\n\t\t * less than EXT2_BLOCKS_PER_GROUP. Aligning up to the\n\t\t * next 64-bit boundary is simple..\n\t\t */\n\t\text2_grpblk_t end_goal = (start + 63) & ~63;\n\t\tif (end_goal > maxblocks)\n\t\t\tend_goal = maxblocks;\n\t\there = ext2_find_next_zero_bit(bh->b_data, end_goal, start);\n\t\tif (here < end_goal)\n\t\t\treturn here;\n\t\text2_debug(\"Bit not found near goal\\n\");\n\t}\n\n\there = start;\n\tif (here < 0)\n\t\there = 0;\n\n\tp = ((char *)bh->b_data) + (here >> 3);\n\tr = memscan(p, 0, ((maxblocks + 7) >> 3) - (here >> 3));\n\tnext = (r - ((char *)bh->b_data)) << 3;\n\n\tif (next < maxblocks && next >= here)\n\t\treturn next;\n\n\there = bitmap_search_next_usable_block(here, bh, maxblocks);\n\treturn here;\n}"
  },
  {
    "function_name": "bitmap_search_next_usable_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "578-588",
    "snippet": "static ext2_grpblk_t\nbitmap_search_next_usable_block(ext2_grpblk_t start, struct buffer_head *bh,\n\t\t\t\t\text2_grpblk_t maxblocks)\n{\n\text2_grpblk_t next;\n\n\tnext = ext2_find_next_zero_bit(bh->b_data, maxblocks, start);\n\tif (next >= maxblocks)\n\t\treturn -1;\n\treturn next;\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_find_next_zero_bit",
          "args": [
            "bh->b_data",
            "maxblocks",
            "start"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic ext2_grpblk_t\nbitmap_search_next_usable_block(ext2_grpblk_t start, struct buffer_head *bh,\n\t\t\t\t\text2_grpblk_t maxblocks)\n{\n\text2_grpblk_t next;\n\n\tnext = ext2_find_next_zero_bit(bh->b_data, maxblocks, start);\n\tif (next >= maxblocks)\n\t\treturn -1;\n\treturn next;\n}"
  },
  {
    "function_name": "ext2_free_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "476-567",
    "snippet": "void ext2_free_blocks (struct inode * inode, unsigned long block,\n\t\t       unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head * bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_super_block * es = sbi->s_es;\n\tunsigned freed = 0, group_freed;\n\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = %lu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text2_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT2_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT2_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tdesc = ext2_get_group_desc (sb, block_group, &bh2);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = %lu, count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\tif (!ext2_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\text2_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block %lu\", block + i);\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tgroup_adjust_blocks(sb, block_group, desc, bh2, group_freed);\n\tfreed += group_freed;\n\n\tif (overflow) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\tif (freed) {\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\t\tdquot_free_block_nodirty(inode, freed);\n\t\tmark_inode_dirty(inode);\n\t}\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_block_nodirty",
          "args": [
            "inode",
            "freed"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_add",
          "args": [
            "&sbi->s_freeblocks_counter",
            "freed"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap_bh"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "group_adjust_blocks",
          "args": [
            "sb",
            "block_group",
            "desc",
            "bh2",
            "group_freed"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "group_adjust_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "162-175",
          "snippet": "static void group_adjust_blocks(struct super_block *sb, int group_no,\n\tstruct ext2_group_desc *desc, struct buffer_head *bh, int count)\n{\n\tif (count) {\n\t\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\t\tunsigned free_blocks;\n\n\t\tspin_lock(sb_bgl_lock(sbi, group_no));\n\t\tfree_blocks = le16_to_cpu(desc->bg_free_blocks_count);\n\t\tdesc->bg_free_blocks_count = cpu_to_le16(free_blocks + count);\n\t\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\t\tmark_buffer_dirty(bh);\n\t}\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic void group_adjust_blocks(struct super_block *sb, int group_no,\n\tstruct ext2_group_desc *desc, struct buffer_head *bh, int count)\n{\n\tif (count) {\n\t\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\t\tunsigned free_blocks;\n\n\t\tspin_lock(sb_bgl_lock(sbi, group_no));\n\t\tfree_blocks = le16_to_cpu(desc->bg_free_blocks_count);\n\t\tdesc->bg_free_blocks_count = cpu_to_le16(free_blocks + count);\n\t\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\t\tmark_buffer_dirty(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bitmap_bh"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bitmap_bh"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_error",
          "args": [
            "sb",
            "__func__",
            "\"bit already cleared for block %lu\"",
            "block + i"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "47-80",
          "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_clear_bit_atomic",
          "args": [
            "sb_bgl_lock(sbi, block_group)",
            "bit + i",
            "bitmap_bh->b_data"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bgl_lock",
          "args": [
            "sbi",
            "block_group"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "sb_bgl_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "116-120",
          "snippet": "static inline spinlock_t *\nsb_bgl_lock(struct ext2_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nstatic inline spinlock_t *\nsb_bgl_lock(struct ext2_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_range",
          "args": [
            "block + count - 1",
            "le32_to_cpu(desc->bg_inode_table)",
            "sbi->s_itb_per_group"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_page_exists_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "7049-7117",
          "snippet": "bool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nbool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "desc->bg_inode_table"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_get_group_desc",
          "args": [
            "sb",
            "block_group",
            "&bh2"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "39-71",
          "snippet": "struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstruct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_block_bitmap",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "read_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "123-160",
          "snippet": "static struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext2_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text2_fsblk_t bitmap_blk;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text2_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tif (likely(bh_uptodate_or_lock(bh)))\n\t\treturn bh;\n\n\tif (bh_submit_read(bh) < 0) {\n\t\tbrelse(bh);\n\t\text2_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\n\text2_valid_block_bitmap(sb, desc, block_group, bh);\n\t/*\n\t * file system mounted not to panic on error, continue with corrupt\n\t * bitmap\n\t */\n\treturn bh;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext2_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text2_fsblk_t bitmap_blk;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text2_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tif (likely(bh_uptodate_or_lock(bh)))\n\t\treturn bh;\n\n\tif (bh_submit_read(bh) < 0) {\n\t\tbrelse(bh);\n\t\text2_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\n\text2_valid_block_bitmap(sb, desc, block_group, bh);\n\t/*\n\t * file system mounted not to panic on error, continue with corrupt\n\t * bitmap\n\t */\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_debug",
          "args": [
            "\"freeing block(s) %lu-%lu\\n\"",
            "block",
            "block + count - 1"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nvoid ext2_free_blocks (struct inode * inode, unsigned long block,\n\t\t       unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head * bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_super_block * es = sbi->s_es;\n\tunsigned freed = 0, group_freed;\n\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = %lu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text2_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT2_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT2_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tdesc = ext2_get_group_desc (sb, block_group, &bh2);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = %lu, count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\tif (!ext2_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\text2_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block %lu\", block + i);\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tgroup_adjust_blocks(sb, block_group, desc, bh2, group_freed);\n\tfreed += group_freed;\n\n\tif (overflow) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\tif (freed) {\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\t\tdquot_free_block_nodirty(inode, freed);\n\t\tmark_inode_dirty(inode);\n\t}\n}"
  },
  {
    "function_name": "ext2_discard_reservation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "451-468",
    "snippet": "void ext2_discard_reservation(struct inode *inode)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct ext2_block_alloc_info *block_i = ei->i_block_alloc_info;\n\tstruct ext2_reserve_window_node *rsv;\n\tspinlock_t *rsv_lock = &EXT2_SB(inode->i_sb)->s_rsv_window_lock;\n\n\tif (!block_i)\n\t\treturn;\n\n\trsv = &block_i->rsv_window_node;\n\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&rsv->rsv_window))\n\t\t\trsv_window_remove(inode->i_sb, rsv);\n\t\tspin_unlock(rsv_lock);\n\t}\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "rsv_lock"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsv_window_remove",
          "args": [
            "inode->i_sb",
            "rsv"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "rsv_window_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "368-375",
          "snippet": "static void rsv_window_remove(struct super_block *sb,\n\t\t\t      struct ext2_reserve_window_node *rsv)\n{\n\trsv->rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_alloc_hit = 0;\n\trb_erase(&rsv->rsv_node, &EXT2_SB(sb)->s_rsv_window_root);\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic void rsv_window_remove(struct super_block *sb,\n\t\t\t      struct ext2_reserve_window_node *rsv)\n{\n\trsv->rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_alloc_hit = 0;\n\trb_erase(&rsv->rsv_node, &EXT2_SB(sb)->s_rsv_window_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsv_is_empty",
          "args": [
            "&rsv->rsv_window"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "rsv_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "383-387",
          "snippet": "static inline int rsv_is_empty(struct ext2_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn (rsv->_rsv_end == EXT2_RESERVE_WINDOW_NOT_ALLOCATED);\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic inline int rsv_is_empty(struct ext2_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn (rsv->_rsv_end == EXT2_RESERVE_WINDOW_NOT_ALLOCATED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "rsv_lock"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nvoid ext2_discard_reservation(struct inode *inode)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct ext2_block_alloc_info *block_i = ei->i_block_alloc_info;\n\tstruct ext2_reserve_window_node *rsv;\n\tspinlock_t *rsv_lock = &EXT2_SB(inode->i_sb)->s_rsv_window_lock;\n\n\tif (!block_i)\n\t\treturn;\n\n\trsv = &block_i->rsv_window_node;\n\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&rsv->rsv_window))\n\t\t\trsv_window_remove(inode->i_sb, rsv);\n\t\tspin_unlock(rsv_lock);\n\t}\n}"
  },
  {
    "function_name": "ext2_init_block_alloc_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "410-437",
    "snippet": "void ext2_init_block_alloc_info(struct inode *inode)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct ext2_block_alloc_info *block_i;\n\tstruct super_block *sb = inode->i_sb;\n\n\tblock_i = kmalloc(sizeof(*block_i), GFP_NOFS);\n\tif (block_i) {\n\t\tstruct ext2_reserve_window_node *rsv = &block_i->rsv_window_node;\n\n\t\trsv->rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\t\trsv->rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\n\t \t/*\n\t\t * if filesystem is mounted with NORESERVATION, the goal\n\t\t * reservation window size is set to zero to indicate\n\t\t * block reservation is off\n\t\t */\n\t\tif (!test_opt(sb, RESERVATION))\n\t\t\trsv->rsv_goal_size = 0;\n\t\telse\n\t\t\trsv->rsv_goal_size = EXT2_DEFAULT_RESERVE_BLOCKS;\n\t\trsv->rsv_alloc_hit = 0;\n\t\tblock_i->last_alloc_logical_block = 0;\n\t\tblock_i->last_alloc_physical_block = 0;\n\t}\n\tei->i_block_alloc_info = block_i;\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "RESERVATION"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*block_i)",
            "GFP_NOFS"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nvoid ext2_init_block_alloc_info(struct inode *inode)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct ext2_block_alloc_info *block_i;\n\tstruct super_block *sb = inode->i_sb;\n\n\tblock_i = kmalloc(sizeof(*block_i), GFP_NOFS);\n\tif (block_i) {\n\t\tstruct ext2_reserve_window_node *rsv = &block_i->rsv_window_node;\n\n\t\trsv->rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\t\trsv->rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\n\t \t/*\n\t\t * if filesystem is mounted with NORESERVATION, the goal\n\t\t * reservation window size is set to zero to indicate\n\t\t * block reservation is off\n\t\t */\n\t\tif (!test_opt(sb, RESERVATION))\n\t\t\trsv->rsv_goal_size = 0;\n\t\telse\n\t\t\trsv->rsv_goal_size = EXT2_DEFAULT_RESERVE_BLOCKS;\n\t\trsv->rsv_alloc_hit = 0;\n\t\tblock_i->last_alloc_logical_block = 0;\n\t\tblock_i->last_alloc_physical_block = 0;\n\t}\n\tei->i_block_alloc_info = block_i;\n}"
  },
  {
    "function_name": "rsv_is_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "383-387",
    "snippet": "static inline int rsv_is_empty(struct ext2_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn (rsv->_rsv_end == EXT2_RESERVE_WINDOW_NOT_ALLOCATED);\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic inline int rsv_is_empty(struct ext2_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn (rsv->_rsv_end == EXT2_RESERVE_WINDOW_NOT_ALLOCATED);\n}"
  },
  {
    "function_name": "rsv_window_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "368-375",
    "snippet": "static void rsv_window_remove(struct super_block *sb,\n\t\t\t      struct ext2_reserve_window_node *rsv)\n{\n\trsv->rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_alloc_hit = 0;\n\trb_erase(&rsv->rsv_node, &EXT2_SB(sb)->s_rsv_window_root);\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&rsv->rsv_node",
            "&EXT2_SB(sb)->s_rsv_window_root"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic void rsv_window_remove(struct super_block *sb,\n\t\t\t      struct ext2_reserve_window_node *rsv)\n{\n\trsv->rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_alloc_hit = 0;\n\trb_erase(&rsv->rsv_node, &EXT2_SB(sb)->s_rsv_window_root);\n}"
  },
  {
    "function_name": "ext2_rsv_window_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "329-357",
    "snippet": "void ext2_rsv_window_add(struct super_block *sb,\n\t\t    struct ext2_reserve_window_node *rsv)\n{\n\tstruct rb_root *root = &EXT2_SB(sb)->s_rsv_window_root;\n\tstruct rb_node *node = &rsv->rsv_node;\n\text2_fsblk_t start = rsv->rsv_start;\n\n\tstruct rb_node ** p = &root->rb_node;\n\tstruct rb_node * parent = NULL;\n\tstruct ext2_reserve_window_node *this;\n\n\twhile (*p)\n\t{\n\t\tparent = *p;\n\t\tthis = rb_entry(parent, struct ext2_reserve_window_node, rsv_node);\n\n\t\tif (start < this->rsv_start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (start > this->rsv_end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\trsv_window_dump(root, 1);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "node",
            "root"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "node",
            "parent",
            "p"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsv_window_dump",
          "args": [
            "root",
            "1"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structext2_reserve_window_node",
            "rsv_node"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nvoid ext2_rsv_window_add(struct super_block *sb,\n\t\t    struct ext2_reserve_window_node *rsv)\n{\n\tstruct rb_root *root = &EXT2_SB(sb)->s_rsv_window_root;\n\tstruct rb_node *node = &rsv->rsv_node;\n\text2_fsblk_t start = rsv->rsv_start;\n\n\tstruct rb_node ** p = &root->rb_node;\n\tstruct rb_node * parent = NULL;\n\tstruct ext2_reserve_window_node *this;\n\n\twhile (*p)\n\t{\n\t\tparent = *p;\n\t\tthis = rb_entry(parent, struct ext2_reserve_window_node, rsv_node);\n\n\t\tif (start < this->rsv_start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (start > this->rsv_end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\trsv_window_dump(root, 1);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n}"
  },
  {
    "function_name": "search_reserve_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "290-320",
    "snippet": "static struct ext2_reserve_window_node *\nsearch_reserve_window(struct rb_root *root, ext2_fsblk_t goal)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct ext2_reserve_window_node *rsv;\n\n\tif (!n)\n\t\treturn NULL;\n\n\tdo {\n\t\trsv = rb_entry(n, struct ext2_reserve_window_node, rsv_node);\n\n\t\tif (goal < rsv->rsv_start)\n\t\t\tn = n->rb_left;\n\t\telse if (goal > rsv->rsv_end)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn rsv;\n\t} while (n);\n\t/*\n\t * We've fallen off the end of the tree: the goal wasn't inside\n\t * any particular node.  OK, the previous node must be to one\n\t * side of the interval containing the goal.  If it's the RHS,\n\t * we need to back up one.\n\t */\n\tif (rsv->rsv_start > goal) {\n\t\tn = rb_prev(&rsv->rsv_node);\n\t\trsv = rb_entry(n, struct ext2_reserve_window_node, rsv_node);\n\t}\n\treturn rsv;\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structext2_reserve_window_node",
            "rsv_node"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&rsv->rsv_node"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structext2_reserve_window_node",
            "rsv_node"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic struct ext2_reserve_window_node *\nsearch_reserve_window(struct rb_root *root, ext2_fsblk_t goal)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct ext2_reserve_window_node *rsv;\n\n\tif (!n)\n\t\treturn NULL;\n\n\tdo {\n\t\trsv = rb_entry(n, struct ext2_reserve_window_node, rsv_node);\n\n\t\tif (goal < rsv->rsv_start)\n\t\t\tn = n->rb_left;\n\t\telse if (goal > rsv->rsv_end)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn rsv;\n\t} while (n);\n\t/*\n\t * We've fallen off the end of the tree: the goal wasn't inside\n\t * any particular node.  OK, the previous node must be to one\n\t * side of the interval containing the goal.  If it's the RHS,\n\t * we need to back up one.\n\t */\n\tif (rsv->rsv_start > goal) {\n\t\tn = rb_prev(&rsv->rsv_node);\n\t\trsv = rb_entry(n, struct ext2_reserve_window_node, rsv_node);\n\t}\n\treturn rsv;\n}"
  },
  {
    "function_name": "goal_in_my_reservation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "263-279",
    "snippet": "static int\ngoal_in_my_reservation(struct ext2_reserve_window *rsv, ext2_grpblk_t grp_goal,\n\t\t\tunsigned int group, struct super_block * sb)\n{\n\text2_fsblk_t group_first_block, group_last_block;\n\n\tgroup_first_block = ext2_group_first_block_no(sb, group);\n\tgroup_last_block = group_first_block + EXT2_BLOCKS_PER_GROUP(sb) - 1;\n\n\tif ((rsv->_rsv_start > group_last_block) ||\n\t    (rsv->_rsv_end < group_first_block))\n\t\treturn 0;\n\tif ((grp_goal >= 0) && ((grp_goal + group_first_block < rsv->_rsv_start)\n\t\t|| (grp_goal + group_first_block > rsv->_rsv_end)))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_group_first_block_no",
          "args": [
            "sb",
            "group"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic int\ngoal_in_my_reservation(struct ext2_reserve_window *rsv, ext2_grpblk_t grp_goal,\n\t\t\tunsigned int group, struct super_block * sb)\n{\n\text2_fsblk_t group_first_block, group_last_block;\n\n\tgroup_first_block = ext2_group_first_block_no(sb, group);\n\tgroup_last_block = group_first_block + EXT2_BLOCKS_PER_GROUP(sb) - 1;\n\n\tif ((rsv->_rsv_start > group_last_block) ||\n\t    (rsv->_rsv_end < group_first_block))\n\t\treturn 0;\n\tif ((grp_goal >= 0) && ((grp_goal + group_first_block < rsv->_rsv_start)\n\t\t|| (grp_goal + group_first_block > rsv->_rsv_end)))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "__rsv_window_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "199-240",
    "snippet": "static void __rsv_window_dump(struct rb_root *root, int verbose,\n\t\t\t      const char *fn)\n{\n\tstruct rb_node *n;\n\tstruct ext2_reserve_window_node *rsv, *prev;\n\tint bad;\n\nrestart:\n\tn = rb_first(root);\n\tbad = 0;\n\tprev = NULL;\n\n\tprintk(\"Block Allocation Reservation Windows Map (%s):\\n\", fn);\n\twhile (n) {\n\t\trsv = rb_entry(n, struct ext2_reserve_window_node, rsv_node);\n\t\tif (verbose)\n\t\t\tprintk(\"reservation window 0x%p \"\n\t\t\t\t\"start: %lu, end: %lu\\n\",\n\t\t\t\trsv, rsv->rsv_start, rsv->rsv_end);\n\t\tif (rsv->rsv_start && rsv->rsv_start >= rsv->rsv_end) {\n\t\t\tprintk(\"Bad reservation %p (start >= end)\\n\",\n\t\t\t       rsv);\n\t\t\tbad = 1;\n\t\t}\n\t\tif (prev && prev->rsv_end >= rsv->rsv_start) {\n\t\t\tprintk(\"Bad reservation %p (prev->end >= start)\\n\",\n\t\t\t       rsv);\n\t\t\tbad = 1;\n\t\t}\n\t\tif (bad) {\n\t\t\tif (!verbose) {\n\t\t\t\tprintk(\"Restarting reservation walk in verbose mode\\n\");\n\t\t\t\tverbose = 1;\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t\tn = rb_next(n);\n\t\tprev = rsv;\n\t}\n\tprintk(\"Window map complete.\\n\");\n\tBUG_ON(bad);\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bad"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Window map complete.\\n\""
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structext2_reserve_window_node",
            "rsv_node"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "root"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic void __rsv_window_dump(struct rb_root *root, int verbose,\n\t\t\t      const char *fn)\n{\n\tstruct rb_node *n;\n\tstruct ext2_reserve_window_node *rsv, *prev;\n\tint bad;\n\nrestart:\n\tn = rb_first(root);\n\tbad = 0;\n\tprev = NULL;\n\n\tprintk(\"Block Allocation Reservation Windows Map (%s):\\n\", fn);\n\twhile (n) {\n\t\trsv = rb_entry(n, struct ext2_reserve_window_node, rsv_node);\n\t\tif (verbose)\n\t\t\tprintk(\"reservation window 0x%p \"\n\t\t\t\t\"start: %lu, end: %lu\\n\",\n\t\t\t\trsv, rsv->rsv_start, rsv->rsv_end);\n\t\tif (rsv->rsv_start && rsv->rsv_start >= rsv->rsv_end) {\n\t\t\tprintk(\"Bad reservation %p (start >= end)\\n\",\n\t\t\t       rsv);\n\t\t\tbad = 1;\n\t\t}\n\t\tif (prev && prev->rsv_end >= rsv->rsv_start) {\n\t\t\tprintk(\"Bad reservation %p (prev->end >= start)\\n\",\n\t\t\t       rsv);\n\t\t\tbad = 1;\n\t\t}\n\t\tif (bad) {\n\t\t\tif (!verbose) {\n\t\t\t\tprintk(\"Restarting reservation walk in verbose mode\\n\");\n\t\t\t\tverbose = 1;\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t\tn = rb_next(n);\n\t\tprev = rsv;\n\t}\n\tprintk(\"Window map complete.\\n\");\n\tBUG_ON(bad);\n}"
  },
  {
    "function_name": "group_adjust_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "162-175",
    "snippet": "static void group_adjust_blocks(struct super_block *sb, int group_no,\n\tstruct ext2_group_desc *desc, struct buffer_head *bh, int count)\n{\n\tif (count) {\n\t\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\t\tunsigned free_blocks;\n\n\t\tspin_lock(sb_bgl_lock(sbi, group_no));\n\t\tfree_blocks = le16_to_cpu(desc->bg_free_blocks_count);\n\t\tdesc->bg_free_blocks_count = cpu_to_le16(free_blocks + count);\n\t\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\t\tmark_buffer_dirty(bh);\n\t}\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "sb_bgl_lock(sbi, group_no)"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bgl_lock",
          "args": [
            "sbi",
            "group_no"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "sb_bgl_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "116-120",
          "snippet": "static inline spinlock_t *\nsb_bgl_lock(struct ext2_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nstatic inline spinlock_t *\nsb_bgl_lock(struct ext2_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "free_blocks + count"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "desc->bg_free_blocks_count"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "sb_bgl_lock(sbi, group_no)"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic void group_adjust_blocks(struct super_block *sb, int group_no,\n\tstruct ext2_group_desc *desc, struct buffer_head *bh, int count)\n{\n\tif (count) {\n\t\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\t\tunsigned free_blocks;\n\n\t\tspin_lock(sb_bgl_lock(sbi, group_no));\n\t\tfree_blocks = le16_to_cpu(desc->bg_free_blocks_count);\n\t\tdesc->bg_free_blocks_count = cpu_to_le16(free_blocks + count);\n\t\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\t\tmark_buffer_dirty(bh);\n\t}\n}"
  },
  {
    "function_name": "read_block_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "123-160",
    "snippet": "static struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext2_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text2_fsblk_t bitmap_blk;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text2_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tif (likely(bh_uptodate_or_lock(bh)))\n\t\treturn bh;\n\n\tif (bh_submit_read(bh) < 0) {\n\t\tbrelse(bh);\n\t\text2_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\n\text2_valid_block_bitmap(sb, desc, block_group, bh);\n\t/*\n\t * file system mounted not to panic on error, continue with corrupt\n\t * bitmap\n\t */\n\treturn bh;\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_valid_block_bitmap",
          "args": [
            "sb",
            "desc",
            "block_group",
            "bh"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_valid_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "73-115",
          "snippet": "static int ext2_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\tstruct ext2_group_desc *desc,\n\t\t\t\t\tunsigned int block_group,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\text2_grpblk_t offset;\n\text2_grpblk_t next_zero_bit;\n\text2_fsblk_t bitmap_blk;\n\text2_fsblk_t group_first_block;\n\n\tgroup_first_block = ext2_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\toffset = bitmap_blk - group_first_block;\n\tif (!ext2_test_bit(offset, bh->b_data))\n\t\t/* bad block bitmap */\n\t\tgoto err_out;\n\n\t/* check whether the inode bitmap block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_inode_bitmap);\n\toffset = bitmap_blk - group_first_block;\n\tif (!ext2_test_bit(offset, bh->b_data))\n\t\t/* bad block bitmap */\n\t\tgoto err_out;\n\n\t/* check whether the inode table block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_inode_table);\n\toffset = bitmap_blk - group_first_block;\n\tnext_zero_bit = ext2_find_next_zero_bit(bh->b_data,\n\t\t\t\toffset + EXT2_SB(sb)->s_itb_per_group,\n\t\t\t\toffset);\n\tif (next_zero_bit >= offset + EXT2_SB(sb)->s_itb_per_group)\n\t\t/* good bitmap for inode tables */\n\t\treturn 1;\n\nerr_out:\n\text2_error(sb, __func__,\n\t\t\t\"Invalid block bitmap - \"\n\t\t\t\"block_group = %d, block = %lu\",\n\t\t\tblock_group, bitmap_blk);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic int ext2_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\tstruct ext2_group_desc *desc,\n\t\t\t\t\tunsigned int block_group,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\text2_grpblk_t offset;\n\text2_grpblk_t next_zero_bit;\n\text2_fsblk_t bitmap_blk;\n\text2_fsblk_t group_first_block;\n\n\tgroup_first_block = ext2_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\toffset = bitmap_blk - group_first_block;\n\tif (!ext2_test_bit(offset, bh->b_data))\n\t\t/* bad block bitmap */\n\t\tgoto err_out;\n\n\t/* check whether the inode bitmap block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_inode_bitmap);\n\toffset = bitmap_blk - group_first_block;\n\tif (!ext2_test_bit(offset, bh->b_data))\n\t\t/* bad block bitmap */\n\t\tgoto err_out;\n\n\t/* check whether the inode table block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_inode_table);\n\toffset = bitmap_blk - group_first_block;\n\tnext_zero_bit = ext2_find_next_zero_bit(bh->b_data,\n\t\t\t\toffset + EXT2_SB(sb)->s_itb_per_group,\n\t\t\t\toffset);\n\tif (next_zero_bit >= offset + EXT2_SB(sb)->s_itb_per_group)\n\t\t/* good bitmap for inode tables */\n\t\treturn 1;\n\nerr_out:\n\text2_error(sb, __func__,\n\t\t\t\"Invalid block bitmap - \"\n\t\t\t\"block_group = %d, block = %lu\",\n\t\t\tblock_group, bitmap_blk);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_error",
          "args": [
            "sb",
            "__func__",
            "\"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\"",
            "block_group",
            "le32_to_cpu(desc->bg_block_bitmap)"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "47-80",
          "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "desc->bg_block_bitmap"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_submit_read",
          "args": [
            "bh"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "bh_uptodate_or_lock(bh)"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_uptodate_or_lock",
          "args": [
            "bh"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "bitmap_blk"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_get_group_desc",
          "args": [
            "sb",
            "block_group",
            "NULL"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "39-71",
          "snippet": "struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstruct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext2_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text2_fsblk_t bitmap_blk;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text2_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tif (likely(bh_uptodate_or_lock(bh)))\n\t\treturn bh;\n\n\tif (bh_submit_read(bh) < 0) {\n\t\tbrelse(bh);\n\t\text2_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\n\text2_valid_block_bitmap(sb, desc, block_group, bh);\n\t/*\n\t * file system mounted not to panic on error, continue with corrupt\n\t * bitmap\n\t */\n\treturn bh;\n}"
  },
  {
    "function_name": "ext2_valid_block_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "73-115",
    "snippet": "static int ext2_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\tstruct ext2_group_desc *desc,\n\t\t\t\t\tunsigned int block_group,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\text2_grpblk_t offset;\n\text2_grpblk_t next_zero_bit;\n\text2_fsblk_t bitmap_blk;\n\text2_fsblk_t group_first_block;\n\n\tgroup_first_block = ext2_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\toffset = bitmap_blk - group_first_block;\n\tif (!ext2_test_bit(offset, bh->b_data))\n\t\t/* bad block bitmap */\n\t\tgoto err_out;\n\n\t/* check whether the inode bitmap block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_inode_bitmap);\n\toffset = bitmap_blk - group_first_block;\n\tif (!ext2_test_bit(offset, bh->b_data))\n\t\t/* bad block bitmap */\n\t\tgoto err_out;\n\n\t/* check whether the inode table block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_inode_table);\n\toffset = bitmap_blk - group_first_block;\n\tnext_zero_bit = ext2_find_next_zero_bit(bh->b_data,\n\t\t\t\toffset + EXT2_SB(sb)->s_itb_per_group,\n\t\t\t\toffset);\n\tif (next_zero_bit >= offset + EXT2_SB(sb)->s_itb_per_group)\n\t\t/* good bitmap for inode tables */\n\t\treturn 1;\n\nerr_out:\n\text2_error(sb, __func__,\n\t\t\t\"Invalid block bitmap - \"\n\t\t\t\"block_group = %d, block = %lu\",\n\t\t\tblock_group, bitmap_blk);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_error",
          "args": [
            "sb",
            "__func__",
            "\"Invalid block bitmap - \"\n\t\t\t\"block_group = %d, block = %lu\"",
            "block_group",
            "bitmap_blk"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "47-80",
          "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_find_next_zero_bit",
          "args": [
            "bh->b_data",
            "offset + EXT2_SB(sb)->s_itb_per_group",
            "offset"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "desc->bg_inode_table"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_test_bit",
          "args": [
            "offset",
            "bh->b_data"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_test_bit",
          "args": [
            "offset",
            "bh->b_data"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_group_first_block_no",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstatic int ext2_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\tstruct ext2_group_desc *desc,\n\t\t\t\t\tunsigned int block_group,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\text2_grpblk_t offset;\n\text2_grpblk_t next_zero_bit;\n\text2_fsblk_t bitmap_blk;\n\text2_fsblk_t group_first_block;\n\n\tgroup_first_block = ext2_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\toffset = bitmap_blk - group_first_block;\n\tif (!ext2_test_bit(offset, bh->b_data))\n\t\t/* bad block bitmap */\n\t\tgoto err_out;\n\n\t/* check whether the inode bitmap block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_inode_bitmap);\n\toffset = bitmap_blk - group_first_block;\n\tif (!ext2_test_bit(offset, bh->b_data))\n\t\t/* bad block bitmap */\n\t\tgoto err_out;\n\n\t/* check whether the inode table block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_inode_table);\n\toffset = bitmap_blk - group_first_block;\n\tnext_zero_bit = ext2_find_next_zero_bit(bh->b_data,\n\t\t\t\toffset + EXT2_SB(sb)->s_itb_per_group,\n\t\t\t\toffset);\n\tif (next_zero_bit >= offset + EXT2_SB(sb)->s_itb_per_group)\n\t\t/* good bitmap for inode tables */\n\t\treturn 1;\n\nerr_out:\n\text2_error(sb, __func__,\n\t\t\t\"Invalid block bitmap - \"\n\t\t\t\"block_group = %d, block = %lu\",\n\t\t\tblock_group, bitmap_blk);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext2_get_group_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
    "lines": "39-71",
    "snippet": "struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
    "includes": [
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_error",
          "args": [
            "sb",
            "\"ext2_get_group_desc\"",
            "\"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\"",
            "block_group",
            "group_desc",
            "offset"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "47-80",
          "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_DESC_PER_BLOCK_BITS",
          "args": [
            "sb"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstruct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
  }
]