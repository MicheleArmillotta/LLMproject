[
  {
    "function_name": "xfs_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_acl.c",
    "lines": "274-304",
    "snippet": "int\nxfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\n\tif (!acl)\n\t\tgoto set_acl;\n\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\n\t\tif (error <= 0) {\n\t\t\tacl = NULL;\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__xfs_set_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_acl.c",
          "lines": "177-231",
          "snippet": "STATIC int\n__xfs_set_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tunsigned char *ea_name;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = SGI_ACL_FILE;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tea_name = SGI_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tstruct xfs_acl *xfs_acl;\n\t\tint len = XFS_ACL_MAX_SIZE(ip->i_mount);\n\n\t\txfs_acl = kmem_zalloc_large(len, KM_SLEEP);\n\t\tif (!xfs_acl)\n\t\t\treturn -ENOMEM;\n\n\t\txfs_acl_to_disk(xfs_acl, acl);\n\n\t\t/* subtract away the unused acl entries */\n\t\tlen -= sizeof(struct xfs_acl_entry) *\n\t\t\t (XFS_ACL_MAX_ENTRIES(ip->i_mount) - acl->a_count);\n\n\t\terror = xfs_attr_set(ip, ea_name, (unsigned char *)xfs_acl,\n\t\t\t\tlen, ATTR_ROOT);\n\n\t\tkmem_free(xfs_acl);\n\t} else {\n\t\t/*\n\t\t * A NULL ACL argument means we want to remove the ACL.\n\t\t */\n\t\terror = xfs_attr_remove(ip, ea_name, ATTR_ROOT);\n\n\t\t/*\n\t\t * If the attribute didn't exist to start with that's fine.\n\t\t */\n\t\tif (error == -ENOATTR)\n\t\t\terror = 0;\n\t}\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xfs_trace.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\n__xfs_set_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tunsigned char *ea_name;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = SGI_ACL_FILE;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tea_name = SGI_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tstruct xfs_acl *xfs_acl;\n\t\tint len = XFS_ACL_MAX_SIZE(ip->i_mount);\n\n\t\txfs_acl = kmem_zalloc_large(len, KM_SLEEP);\n\t\tif (!xfs_acl)\n\t\t\treturn -ENOMEM;\n\n\t\txfs_acl_to_disk(xfs_acl, acl);\n\n\t\t/* subtract away the unused acl entries */\n\t\tlen -= sizeof(struct xfs_acl_entry) *\n\t\t\t (XFS_ACL_MAX_ENTRIES(ip->i_mount) - acl->a_count);\n\n\t\terror = xfs_attr_set(ip, ea_name, (unsigned char *)xfs_acl,\n\t\t\t\tlen, ATTR_ROOT);\n\n\t\tkmem_free(xfs_acl);\n\t} else {\n\t\t/*\n\t\t * A NULL ACL argument means we want to remove the ACL.\n\t\t */\n\t\terror = xfs_attr_remove(ip, ea_name, ATTR_ROOT);\n\n\t\t/*\n\t\t * If the attribute didn't exist to start with that's fine.\n\t\t */\n\t\tif (error == -ENOATTR)\n\t\t\terror = 0;\n\t}\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_set_mode",
          "args": [
            "inode",
            "mode"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_set_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_acl.c",
          "lines": "233-249",
          "snippet": "static int\nxfs_set_mode(struct inode *inode, umode_t mode)\n{\n\tint error = 0;\n\n\tif (mode != inode->i_mode) {\n\t\tstruct iattr iattr;\n\n\t\tiattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\tiattr.ia_mode = mode;\n\t\tiattr.ia_ctime = current_fs_time(inode->i_sb);\n\n\t\terror = xfs_setattr_nonsize(XFS_I(inode), &iattr, XFS_ATTR_NOACL);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xfs_trace.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic int\nxfs_set_mode(struct inode *inode, umode_t mode)\n{\n\tint error = 0;\n\n\tif (mode != inode->i_mode) {\n\t\tstruct iattr iattr;\n\n\t\tiattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\tiattr.ia_mode = mode;\n\t\tiattr.ia_ctime = current_fs_time(inode->i_sb);\n\n\t\terror = xfs_setattr_nonsize(XFS_I(inode), &iattr, XFS_ATTR_NOACL);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_equiv_mode",
          "args": [
            "acl",
            "&mode"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_equiv_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "242-282",
          "snippet": "int\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ACL_MAX_ENTRIES",
          "args": [
            "XFS_M(inode->i_sb)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "inode->i_sb"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xfs_trace.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\n\tif (!acl)\n\t\tgoto set_acl;\n\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\n\t\tif (error <= 0) {\n\t\t\tacl = NULL;\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}"
  },
  {
    "function_name": "posix_acl_default_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_acl.c",
    "lines": "266-272",
    "snippet": "int\nposix_acl_default_exists(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn 0;\n\treturn xfs_acl_exists(inode, SGI_ACL_DEFAULT);\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_acl_exists",
          "args": [
            "inode",
            "SGI_ACL_DEFAULT"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_acl_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_acl.c",
          "lines": "251-258",
          "snippet": "static int\nxfs_acl_exists(struct inode *inode, unsigned char *name)\n{\n\tint len = XFS_ACL_MAX_SIZE(XFS_M(inode->i_sb));\n\n\treturn (xfs_attr_get(XFS_I(inode), name, NULL, &len,\n\t\t\t    ATTR_ROOT|ATTR_KERNOVAL) == 0);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xfs_trace.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic int\nxfs_acl_exists(struct inode *inode, unsigned char *name)\n{\n\tint len = XFS_ACL_MAX_SIZE(XFS_M(inode->i_sb));\n\n\treturn (xfs_attr_get(XFS_I(inode), name, NULL, &len,\n\t\t\t    ATTR_ROOT|ATTR_KERNOVAL) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xfs_trace.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nposix_acl_default_exists(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn 0;\n\treturn xfs_acl_exists(inode, SGI_ACL_DEFAULT);\n}"
  },
  {
    "function_name": "posix_acl_access_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_acl.c",
    "lines": "260-264",
    "snippet": "int\nposix_acl_access_exists(struct inode *inode)\n{\n\treturn xfs_acl_exists(inode, SGI_ACL_FILE);\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_acl_exists",
          "args": [
            "inode",
            "SGI_ACL_FILE"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_acl_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_acl.c",
          "lines": "251-258",
          "snippet": "static int\nxfs_acl_exists(struct inode *inode, unsigned char *name)\n{\n\tint len = XFS_ACL_MAX_SIZE(XFS_M(inode->i_sb));\n\n\treturn (xfs_attr_get(XFS_I(inode), name, NULL, &len,\n\t\t\t    ATTR_ROOT|ATTR_KERNOVAL) == 0);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xfs_trace.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic int\nxfs_acl_exists(struct inode *inode, unsigned char *name)\n{\n\tint len = XFS_ACL_MAX_SIZE(XFS_M(inode->i_sb));\n\n\treturn (xfs_attr_get(XFS_I(inode), name, NULL, &len,\n\t\t\t    ATTR_ROOT|ATTR_KERNOVAL) == 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xfs_trace.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nposix_acl_access_exists(struct inode *inode)\n{\n\treturn xfs_acl_exists(inode, SGI_ACL_FILE);\n}"
  },
  {
    "function_name": "xfs_acl_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_acl.c",
    "lines": "251-258",
    "snippet": "static int\nxfs_acl_exists(struct inode *inode, unsigned char *name)\n{\n\tint len = XFS_ACL_MAX_SIZE(XFS_M(inode->i_sb));\n\n\treturn (xfs_attr_get(XFS_I(inode), name, NULL, &len,\n\t\t\t    ATTR_ROOT|ATTR_KERNOVAL) == 0);\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_attr_get",
          "args": [
            "XFS_I(inode)",
            "name",
            "NULL",
            "&len",
            "ATTR_ROOT|ATTR_KERNOVAL"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "116-156",
          "snippet": "int\nxfs_attr_get(\n\tstruct xfs_inode\t*ip,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\t*valuelenp,\n\tint\t\t\tflags)\n{\n\tstruct xfs_da_args\targs;\n\tuint\t\t\tlock_mode;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_attr_get);\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\n\tif (!xfs_inode_hasattr(ip))\n\t\treturn -ENOATTR;\n\n\terror = xfs_attr_args_init(&args, ip, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = *valuelenp;\n\n\tlock_mode = xfs_ilock_attr_map_shared(ip);\n\tif (!xfs_inode_hasattr(ip))\n\t\terror = -ENOATTR;\n\telse if (ip->i_d.di_aformat == XFS_DINODE_FMT_LOCAL)\n\t\terror = xfs_attr_shortform_getvalue(&args);\n\telse if (xfs_bmap_one_block(ip, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_get(&args);\n\telse\n\t\terror = xfs_attr_node_get(&args);\n\txfs_iunlock(ip, lock_mode);\n\n\t*valuelenp = args.valuelen;\n\treturn error == -EEXIST ? 0 : error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nint\nxfs_attr_get(\n\tstruct xfs_inode\t*ip,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\t*valuelenp,\n\tint\t\t\tflags)\n{\n\tstruct xfs_da_args\targs;\n\tuint\t\t\tlock_mode;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_attr_get);\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\n\tif (!xfs_inode_hasattr(ip))\n\t\treturn -ENOATTR;\n\n\terror = xfs_attr_args_init(&args, ip, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = *valuelenp;\n\n\tlock_mode = xfs_ilock_attr_map_shared(ip);\n\tif (!xfs_inode_hasattr(ip))\n\t\terror = -ENOATTR;\n\telse if (ip->i_d.di_aformat == XFS_DINODE_FMT_LOCAL)\n\t\terror = xfs_attr_shortform_getvalue(&args);\n\telse if (xfs_bmap_one_block(ip, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_get(&args);\n\telse\n\t\terror = xfs_attr_node_get(&args);\n\txfs_iunlock(ip, lock_mode);\n\n\t*valuelenp = args.valuelen;\n\treturn error == -EEXIST ? 0 : error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ACL_MAX_SIZE",
          "args": [
            "XFS_M(inode->i_sb)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "inode->i_sb"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xfs_trace.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic int\nxfs_acl_exists(struct inode *inode, unsigned char *name)\n{\n\tint len = XFS_ACL_MAX_SIZE(XFS_M(inode->i_sb));\n\n\treturn (xfs_attr_get(XFS_I(inode), name, NULL, &len,\n\t\t\t    ATTR_ROOT|ATTR_KERNOVAL) == 0);\n}"
  },
  {
    "function_name": "xfs_set_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_acl.c",
    "lines": "233-249",
    "snippet": "static int\nxfs_set_mode(struct inode *inode, umode_t mode)\n{\n\tint error = 0;\n\n\tif (mode != inode->i_mode) {\n\t\tstruct iattr iattr;\n\n\t\tiattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\tiattr.ia_mode = mode;\n\t\tiattr.ia_ctime = current_fs_time(inode->i_sb);\n\n\t\terror = xfs_setattr_nonsize(XFS_I(inode), &iattr, XFS_ATTR_NOACL);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_setattr_nonsize",
          "args": [
            "XFS_I(inode)",
            "&iattr",
            "XFS_ATTR_NOACL"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setattr_nonsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "535-737",
          "snippet": "int\nxfs_setattr_nonsize(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr,\n\tint\t\t\tflags)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tint\t\t\tmask = iattr->ia_valid;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\tkuid_t\t\t\tuid = GLOBAL_ROOT_UID, iuid = GLOBAL_ROOT_UID;\n\tkgid_t\t\t\tgid = GLOBAL_ROOT_GID, igid = GLOBAL_ROOT_GID;\n\tstruct xfs_dquot\t*udqp = NULL, *gdqp = NULL;\n\tstruct xfs_dquot\t*olddquot1 = NULL, *olddquot2 = NULL;\n\n\ttrace_xfs_setattr(ip);\n\n\t/* If acls are being inherited, we already have this checked */\n\tif (!(flags & XFS_ATTR_NOACL)) {\n\t\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\t\treturn -EROFS;\n\n\t\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\t\treturn -EIO;\n\n\t\terror = inode_change_ok(inode, iattr);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tASSERT((mask & ATTR_SIZE) == 0);\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {\n\t\tuint\tqflags = 0;\n\n\t\tif ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\tuid = iattr->ia_uid;\n\t\t\tqflags |= XFS_QMOPT_UQUOTA;\n\t\t} else {\n\t\t\tuid = inode->i_uid;\n\t\t}\n\t\tif ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\tgid = iattr->ia_gid;\n\t\t\tqflags |= XFS_QMOPT_GQUOTA;\n\t\t}  else {\n\t\t\tgid = inode->i_gid;\n\t\t}\n\n\t\t/*\n\t\t * We take a reference when we initialize udqp and gdqp,\n\t\t * so it is important that we never blindly double trip on\n\t\t * the same variable. See xfs_create() for an example.\n\t\t */\n\t\tASSERT(udqp == NULL);\n\t\tASSERT(gdqp == NULL);\n\t\terror = xfs_qm_vop_dqalloc(ip, xfs_kuid_to_uid(uid),\n\t\t\t\t\t   xfs_kgid_to_gid(gid),\n\t\t\t\t\t   xfs_get_projid(ip),\n\t\t\t\t\t   qflags, &udqp, &gdqp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error)\n\t\tgoto out_dqrele;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * These IDs could have changed since we last looked at them.\n\t\t * But, we're assured that if the ownership did change\n\t\t * while we didn't have the inode locked, inode's dquot(s)\n\t\t * would have changed also.\n\t\t */\n\t\tiuid = inode->i_uid;\n\t\tigid = inode->i_gid;\n\t\tgid = (mask & ATTR_GID) ? iattr->ia_gid : igid;\n\t\tuid = (mask & ATTR_UID) ? iattr->ia_uid : iuid;\n\n\t\t/*\n\t\t * Do a quota reservation only if uid/gid is actually\n\t\t * going to change.\n\t\t */\n\t\tif (XFS_IS_QUOTA_RUNNING(mp) &&\n\t\t    ((XFS_IS_UQUOTA_ON(mp) && !uid_eq(iuid, uid)) ||\n\t\t     (XFS_IS_GQUOTA_ON(mp) && !gid_eq(igid, gid)))) {\n\t\t\tASSERT(tp);\n\t\t\terror = xfs_qm_vop_chown_reserve(tp, ip, udqp, gdqp,\n\t\t\t\t\t\tNULL, capable(CAP_FOWNER) ?\n\t\t\t\t\t\tXFS_QMOPT_FORCE_RES : 0);\n\t\t\tif (error)\t/* out of quota */\n\t\t\t\tgoto out_trans_cancel;\n\t\t}\n\t}\n\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * CAP_FSETID overrides the following restrictions:\n\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t */\n\t\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !capable(CAP_FSETID))\n\t\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.\n\t\t */\n\t\tif (!uid_eq(iuid, uid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\t\tASSERT(mask & ATTR_UID);\n\t\t\t\tASSERT(udqp);\n\t\t\t\tolddquot1 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_udquot, udqp);\n\t\t\t}\n\t\t\tip->i_d.di_uid = xfs_kuid_to_uid(uid);\n\t\t\tinode->i_uid = uid;\n\t\t}\n\t\tif (!gid_eq(igid, gid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\t\tASSERT(xfs_sb_version_has_pquotino(&mp->m_sb) ||\n\t\t\t\t       !XFS_IS_PQUOTA_ON(mp));\n\t\t\t\tASSERT(mask & ATTR_GID);\n\t\t\t\tASSERT(gdqp);\n\t\t\t\tolddquot2 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_gdquot, gdqp);\n\t\t\t}\n\t\t\tip->i_d.di_gid = xfs_kgid_to_gid(gid);\n\t\t\tinode->i_gid = gid;\n\t\t}\n\t}\n\n\tif (mask & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (mask & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Release any dquot(s) the inode had kept before chown.\n\t */\n\txfs_qm_dqrele(olddquot1);\n\txfs_qm_dqrele(olddquot2);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * XXX(hch): Updating the ACL entries is not atomic vs the i_mode\n\t * \t     update.  We could avoid this with linked transactions\n\t * \t     and passing down the transaction pointer all the way\n\t *\t     to attr_set.  No previous user of the generic\n\t * \t     Posix ACL code seems to care about this issue either.\n\t */\n\tif ((mask & ATTR_MODE) && !(flags & XFS_ATTR_NOACL)) {\n\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp, 0);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\nout_dqrele:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_setattr_nonsize(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr,\n\tint\t\t\tflags)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tint\t\t\tmask = iattr->ia_valid;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\tkuid_t\t\t\tuid = GLOBAL_ROOT_UID, iuid = GLOBAL_ROOT_UID;\n\tkgid_t\t\t\tgid = GLOBAL_ROOT_GID, igid = GLOBAL_ROOT_GID;\n\tstruct xfs_dquot\t*udqp = NULL, *gdqp = NULL;\n\tstruct xfs_dquot\t*olddquot1 = NULL, *olddquot2 = NULL;\n\n\ttrace_xfs_setattr(ip);\n\n\t/* If acls are being inherited, we already have this checked */\n\tif (!(flags & XFS_ATTR_NOACL)) {\n\t\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\t\treturn -EROFS;\n\n\t\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\t\treturn -EIO;\n\n\t\terror = inode_change_ok(inode, iattr);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tASSERT((mask & ATTR_SIZE) == 0);\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {\n\t\tuint\tqflags = 0;\n\n\t\tif ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\tuid = iattr->ia_uid;\n\t\t\tqflags |= XFS_QMOPT_UQUOTA;\n\t\t} else {\n\t\t\tuid = inode->i_uid;\n\t\t}\n\t\tif ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\tgid = iattr->ia_gid;\n\t\t\tqflags |= XFS_QMOPT_GQUOTA;\n\t\t}  else {\n\t\t\tgid = inode->i_gid;\n\t\t}\n\n\t\t/*\n\t\t * We take a reference when we initialize udqp and gdqp,\n\t\t * so it is important that we never blindly double trip on\n\t\t * the same variable. See xfs_create() for an example.\n\t\t */\n\t\tASSERT(udqp == NULL);\n\t\tASSERT(gdqp == NULL);\n\t\terror = xfs_qm_vop_dqalloc(ip, xfs_kuid_to_uid(uid),\n\t\t\t\t\t   xfs_kgid_to_gid(gid),\n\t\t\t\t\t   xfs_get_projid(ip),\n\t\t\t\t\t   qflags, &udqp, &gdqp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error)\n\t\tgoto out_dqrele;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * These IDs could have changed since we last looked at them.\n\t\t * But, we're assured that if the ownership did change\n\t\t * while we didn't have the inode locked, inode's dquot(s)\n\t\t * would have changed also.\n\t\t */\n\t\tiuid = inode->i_uid;\n\t\tigid = inode->i_gid;\n\t\tgid = (mask & ATTR_GID) ? iattr->ia_gid : igid;\n\t\tuid = (mask & ATTR_UID) ? iattr->ia_uid : iuid;\n\n\t\t/*\n\t\t * Do a quota reservation only if uid/gid is actually\n\t\t * going to change.\n\t\t */\n\t\tif (XFS_IS_QUOTA_RUNNING(mp) &&\n\t\t    ((XFS_IS_UQUOTA_ON(mp) && !uid_eq(iuid, uid)) ||\n\t\t     (XFS_IS_GQUOTA_ON(mp) && !gid_eq(igid, gid)))) {\n\t\t\tASSERT(tp);\n\t\t\terror = xfs_qm_vop_chown_reserve(tp, ip, udqp, gdqp,\n\t\t\t\t\t\tNULL, capable(CAP_FOWNER) ?\n\t\t\t\t\t\tXFS_QMOPT_FORCE_RES : 0);\n\t\t\tif (error)\t/* out of quota */\n\t\t\t\tgoto out_trans_cancel;\n\t\t}\n\t}\n\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * CAP_FSETID overrides the following restrictions:\n\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t */\n\t\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !capable(CAP_FSETID))\n\t\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.\n\t\t */\n\t\tif (!uid_eq(iuid, uid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\t\tASSERT(mask & ATTR_UID);\n\t\t\t\tASSERT(udqp);\n\t\t\t\tolddquot1 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_udquot, udqp);\n\t\t\t}\n\t\t\tip->i_d.di_uid = xfs_kuid_to_uid(uid);\n\t\t\tinode->i_uid = uid;\n\t\t}\n\t\tif (!gid_eq(igid, gid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\t\tASSERT(xfs_sb_version_has_pquotino(&mp->m_sb) ||\n\t\t\t\t       !XFS_IS_PQUOTA_ON(mp));\n\t\t\t\tASSERT(mask & ATTR_GID);\n\t\t\t\tASSERT(gdqp);\n\t\t\t\tolddquot2 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_gdquot, gdqp);\n\t\t\t}\n\t\t\tip->i_d.di_gid = xfs_kgid_to_gid(gid);\n\t\t\tinode->i_gid = gid;\n\t\t}\n\t}\n\n\tif (mask & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (mask & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Release any dquot(s) the inode had kept before chown.\n\t */\n\txfs_qm_dqrele(olddquot1);\n\txfs_qm_dqrele(olddquot2);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * XXX(hch): Updating the ACL entries is not atomic vs the i_mode\n\t * \t     update.  We could avoid this with linked transactions\n\t * \t     and passing down the transaction pointer all the way\n\t *\t     to attr_set.  No previous user of the generic\n\t * \t     Posix ACL code seems to care about this issue either.\n\t */\n\tif ((mask & ATTR_MODE) && !(flags & XFS_ATTR_NOACL)) {\n\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp, 0);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\nout_dqrele:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xfs_trace.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic int\nxfs_set_mode(struct inode *inode, umode_t mode)\n{\n\tint error = 0;\n\n\tif (mode != inode->i_mode) {\n\t\tstruct iattr iattr;\n\n\t\tiattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\tiattr.ia_mode = mode;\n\t\tiattr.ia_ctime = current_fs_time(inode->i_sb);\n\n\t\terror = xfs_setattr_nonsize(XFS_I(inode), &iattr, XFS_ATTR_NOACL);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "__xfs_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_acl.c",
    "lines": "177-231",
    "snippet": "STATIC int\n__xfs_set_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tunsigned char *ea_name;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = SGI_ACL_FILE;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tea_name = SGI_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tstruct xfs_acl *xfs_acl;\n\t\tint len = XFS_ACL_MAX_SIZE(ip->i_mount);\n\n\t\txfs_acl = kmem_zalloc_large(len, KM_SLEEP);\n\t\tif (!xfs_acl)\n\t\t\treturn -ENOMEM;\n\n\t\txfs_acl_to_disk(xfs_acl, acl);\n\n\t\t/* subtract away the unused acl entries */\n\t\tlen -= sizeof(struct xfs_acl_entry) *\n\t\t\t (XFS_ACL_MAX_ENTRIES(ip->i_mount) - acl->a_count);\n\n\t\terror = xfs_attr_set(ip, ea_name, (unsigned char *)xfs_acl,\n\t\t\t\tlen, ATTR_ROOT);\n\n\t\tkmem_free(xfs_acl);\n\t} else {\n\t\t/*\n\t\t * A NULL ACL argument means we want to remove the ACL.\n\t\t */\n\t\terror = xfs_attr_remove(ip, ea_name, ATTR_ROOT);\n\n\t\t/*\n\t\t * If the attribute didn't exist to start with that's fine.\n\t\t */\n\t\tif (error == -ENOATTR)\n\t\t\terror = 0;\n\t}\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "58-68",
          "snippet": "void set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\tspin_lock(&inode->i_lock);\n\told = *p;\n\trcu_assign_pointer(*p, posix_acl_dup(acl));\n\tspin_unlock(&inode->i_lock);\n\tif (old != ACL_NOT_CACHED)\n\t\tposix_acl_release(old);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\tspin_lock(&inode->i_lock);\n\told = *p;\n\trcu_assign_pointer(*p, posix_acl_dup(acl));\n\tspin_unlock(&inode->i_lock);\n\tif (old != ACL_NOT_CACHED)\n\t\tposix_acl_release(old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_remove",
          "args": [
            "ip",
            "ea_name",
            "ATTR_ROOT"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "404-516",
          "snippet": "int\nxfs_attr_remove(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_bmap_free\tflist;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_attr_remove);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tif (!xfs_inode_hasattr(dp))\n\t\treturn -ENOATTR;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.firstblock = &firstblock;\n\targs.flist = &flist;\n\n\t/*\n\t * we have no control over the attribute names that userspace passes us\n\t * to remove, so we have to allow the name lookup prior to attribute\n\t * removal to fail.\n\t */\n\targs.op_flags = XFS_DA_OP_OKNOENT;\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\targs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_RM);\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\n\tif (flags & ATTR_ROOT)\n\t\targs.trans->t_flags |= XFS_TRANS_RESERVE;\n\n\terror = xfs_trans_reserve(args.trans, &M_RES(mp)->tr_attrrm,\n\t\t\t\t  XFS_ATTRRM_SPACE_RES(mp), 0);\n\tif (error) {\n\t\txfs_trans_cancel(args.trans, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\t/*\n\t * No need to make quota reservations here. We expect to release some\n\t * blocks not allocate in the common case.\n\t */\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = -ENOATTR;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\tASSERT(dp->i_afp->if_flags & XFS_IFINLINE);\n\t\terror = xfs_attr_shortform_remove(&args);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_removename(&args);\n\t} else {\n\t\terror = xfs_attr_node_removename(&args);\n\t}\n\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans) {\n\t\txfs_trans_cancel(args.trans,\n\t\t\tXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nint\nxfs_attr_remove(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_bmap_free\tflist;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_attr_remove);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tif (!xfs_inode_hasattr(dp))\n\t\treturn -ENOATTR;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.firstblock = &firstblock;\n\targs.flist = &flist;\n\n\t/*\n\t * we have no control over the attribute names that userspace passes us\n\t * to remove, so we have to allow the name lookup prior to attribute\n\t * removal to fail.\n\t */\n\targs.op_flags = XFS_DA_OP_OKNOENT;\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\targs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_RM);\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\n\tif (flags & ATTR_ROOT)\n\t\targs.trans->t_flags |= XFS_TRANS_RESERVE;\n\n\terror = xfs_trans_reserve(args.trans, &M_RES(mp)->tr_attrrm,\n\t\t\t\t  XFS_ATTRRM_SPACE_RES(mp), 0);\n\tif (error) {\n\t\txfs_trans_cancel(args.trans, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\t/*\n\t * No need to make quota reservations here. We expect to release some\n\t * blocks not allocate in the common case.\n\t */\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = -ENOATTR;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\tASSERT(dp->i_afp->if_flags & XFS_IFINLINE);\n\t\terror = xfs_attr_shortform_remove(&args);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_removename(&args);\n\t} else {\n\t\terror = xfs_attr_node_removename(&args);\n\t}\n\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans) {\n\t\txfs_trans_cancel(args.trans,\n\t\t\tXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "xfs_acl"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_set",
          "args": [
            "ip",
            "ea_name",
            "(unsigned char *)xfs_acl",
            "len",
            "ATTR_ROOT"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "194-398",
          "snippet": "int\nxfs_attr_set(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\tvaluelen,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_bmap_free\tflist;\n\tstruct xfs_trans_res\ttres;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\trsvd = (flags & ATTR_ROOT) != 0;\n\tint\t\t\terror, err2, committed, local;\n\n\tXFS_STATS_INC(xs_attr_set);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = valuelen;\n\targs.firstblock = &firstblock;\n\targs.flist = &flist;\n\targs.op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\targs.total = xfs_attr_calc_size(&args, &local);\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the inode doesn't have an attribute fork, add one.\n\t * (inode must not be locked when we call this routine)\n\t */\n\tif (XFS_IFORK_Q(dp) == 0) {\n\t\tint sf_size = sizeof(xfs_attr_sf_hdr_t) +\n\t\t\tXFS_ATTR_SF_ENTSIZE_BYNAME(args.namelen, valuelen);\n\n\t\terror = xfs_bmap_add_attrfork(dp, sf_size, rsvd);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\targs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_SET);\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\n\tif (rsvd)\n\t\targs.trans->t_flags |= XFS_TRANS_RESERVE;\n\n\ttres.tr_logres = M_RES(mp)->tr_attrsetm.tr_logres +\n\t\t\t M_RES(mp)->tr_attrsetrt.tr_logres * args.total;\n\ttres.tr_logcount = XFS_ATTRSET_LOG_COUNT;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(args.trans, &tres, args.total, 0);\n\tif (error) {\n\t\txfs_trans_cancel(args.trans, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\n\terror = xfs_trans_reserve_quota_nblks(args.trans, dp, args.total, 0,\n\t\t\t\trsvd ? XFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\n\t\t\t\t       XFS_QMOPT_RES_REGBLKS);\n\tif (error) {\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\t\treturn error;\n\t}\n\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t/*\n\t * If the attribute list is non-existent or a shortform list,\n\t * upgrade it to a single-leaf-block attribute list.\n\t */\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL ||\n\t    (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     dp->i_d.di_anextents == 0)) {\n\n\t\t/*\n\t\t * Build initial attribute list (if required).\n\t\t */\n\t\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS)\n\t\t\txfs_attr_shortform_create(&args);\n\n\t\t/*\n\t\t * Try to add the attr to the attribute list in\n\t\t * the inode.\n\t\t */\n\t\terror = xfs_attr_shortform_addname(&args);\n\t\tif (error != -ENOSPC) {\n\t\t\t/*\n\t\t\t * Commit the shortform mods, and we're done.\n\t\t\t * NOTE: this is also the error path (EEXIST, etc).\n\t\t\t */\n\t\t\tASSERT(args.trans != NULL);\n\n\t\t\t/*\n\t\t\t * If this is a synchronous mount, make sure that\n\t\t\t * the transaction goes to disk before returning\n\t\t\t * to the user.\n\t\t\t */\n\t\t\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\t\t\txfs_trans_set_sync(args.trans);\n\n\t\t\tif (!error && (flags & ATTR_KERNOTIME) == 0) {\n\t\t\t\txfs_trans_ichgtime(args.trans, dp,\n\t\t\t\t\t\t\tXFS_ICHGTIME_CHG);\n\t\t\t}\n\t\t\terr2 = xfs_trans_commit(args.trans,\n\t\t\t\t\t\t XFS_TRANS_RELEASE_LOG_RES);\n\t\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\t\t\treturn error ? error : err2;\n\t\t}\n\n\t\t/*\n\t\t * It won't fit in the shortform, transform to a leaf block.\n\t\t * GROT: another possible req'mt for a double-split btree op.\n\t\t */\n\t\txfs_bmap_init(args.flist, args.firstblock);\n\t\terror = xfs_attr_shortform_to_leaf(&args);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args.trans, args.flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs.trans = NULL;\n\t\t\txfs_bmap_cancel(&flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the leaf transformation.  We'll need another (linked)\n\t\t * transaction to add the new attribute to the leaf.\n\t\t */\n\n\t\terror = xfs_trans_roll(&args.trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t}\n\n\tif (xfs_bmap_one_block(dp, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_addname(&args);\n\telse\n\t\terror = xfs_attr_node_addname(&args);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans) {\n\t\txfs_trans_cancel(args.trans,\n\t\t\tXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nint\nxfs_attr_set(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\tvaluelen,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_bmap_free\tflist;\n\tstruct xfs_trans_res\ttres;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\trsvd = (flags & ATTR_ROOT) != 0;\n\tint\t\t\terror, err2, committed, local;\n\n\tXFS_STATS_INC(xs_attr_set);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = valuelen;\n\targs.firstblock = &firstblock;\n\targs.flist = &flist;\n\targs.op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\targs.total = xfs_attr_calc_size(&args, &local);\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the inode doesn't have an attribute fork, add one.\n\t * (inode must not be locked when we call this routine)\n\t */\n\tif (XFS_IFORK_Q(dp) == 0) {\n\t\tint sf_size = sizeof(xfs_attr_sf_hdr_t) +\n\t\t\tXFS_ATTR_SF_ENTSIZE_BYNAME(args.namelen, valuelen);\n\n\t\terror = xfs_bmap_add_attrfork(dp, sf_size, rsvd);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\targs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_SET);\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\n\tif (rsvd)\n\t\targs.trans->t_flags |= XFS_TRANS_RESERVE;\n\n\ttres.tr_logres = M_RES(mp)->tr_attrsetm.tr_logres +\n\t\t\t M_RES(mp)->tr_attrsetrt.tr_logres * args.total;\n\ttres.tr_logcount = XFS_ATTRSET_LOG_COUNT;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(args.trans, &tres, args.total, 0);\n\tif (error) {\n\t\txfs_trans_cancel(args.trans, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\n\terror = xfs_trans_reserve_quota_nblks(args.trans, dp, args.total, 0,\n\t\t\t\trsvd ? XFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\n\t\t\t\t       XFS_QMOPT_RES_REGBLKS);\n\tif (error) {\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\t\treturn error;\n\t}\n\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t/*\n\t * If the attribute list is non-existent or a shortform list,\n\t * upgrade it to a single-leaf-block attribute list.\n\t */\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL ||\n\t    (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     dp->i_d.di_anextents == 0)) {\n\n\t\t/*\n\t\t * Build initial attribute list (if required).\n\t\t */\n\t\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS)\n\t\t\txfs_attr_shortform_create(&args);\n\n\t\t/*\n\t\t * Try to add the attr to the attribute list in\n\t\t * the inode.\n\t\t */\n\t\terror = xfs_attr_shortform_addname(&args);\n\t\tif (error != -ENOSPC) {\n\t\t\t/*\n\t\t\t * Commit the shortform mods, and we're done.\n\t\t\t * NOTE: this is also the error path (EEXIST, etc).\n\t\t\t */\n\t\t\tASSERT(args.trans != NULL);\n\n\t\t\t/*\n\t\t\t * If this is a synchronous mount, make sure that\n\t\t\t * the transaction goes to disk before returning\n\t\t\t * to the user.\n\t\t\t */\n\t\t\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\t\t\txfs_trans_set_sync(args.trans);\n\n\t\t\tif (!error && (flags & ATTR_KERNOTIME) == 0) {\n\t\t\t\txfs_trans_ichgtime(args.trans, dp,\n\t\t\t\t\t\t\tXFS_ICHGTIME_CHG);\n\t\t\t}\n\t\t\terr2 = xfs_trans_commit(args.trans,\n\t\t\t\t\t\t XFS_TRANS_RELEASE_LOG_RES);\n\t\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\t\t\treturn error ? error : err2;\n\t\t}\n\n\t\t/*\n\t\t * It won't fit in the shortform, transform to a leaf block.\n\t\t * GROT: another possible req'mt for a double-split btree op.\n\t\t */\n\t\txfs_bmap_init(args.flist, args.firstblock);\n\t\terror = xfs_attr_shortform_to_leaf(&args);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args.trans, args.flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs.trans = NULL;\n\t\t\txfs_bmap_cancel(&flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the leaf transformation.  We'll need another (linked)\n\t\t * transaction to add the new attribute to the leaf.\n\t\t */\n\n\t\terror = xfs_trans_roll(&args.trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t}\n\n\tif (xfs_bmap_one_block(dp, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_addname(&args);\n\telse\n\t\terror = xfs_attr_node_addname(&args);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans) {\n\t\txfs_trans_cancel(args.trans,\n\t\t\tXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ACL_MAX_ENTRIES",
          "args": [
            "ip->i_mount"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_acl_to_disk",
          "args": [
            "xfs_acl",
            "acl"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_acl_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_acl.c",
          "lines": "92-119",
          "snippet": "STATIC void\nxfs_acl_to_disk(struct xfs_acl *aclp, const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *acl_e;\n\tstruct xfs_acl_entry *ace;\n\tint i;\n\n\taclp->acl_cnt = cpu_to_be32(acl->a_count);\n\tfor (i = 0; i < acl->a_count; i++) {\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e = &acl->a_entries[i];\n\n\t\tace->ae_tag = cpu_to_be32(acl_e->e_tag);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tace->ae_id = cpu_to_be32(xfs_kuid_to_uid(acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tace->ae_id = cpu_to_be32(xfs_kgid_to_gid(acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tace->ae_id = cpu_to_be32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\n\t\tace->ae_perm = cpu_to_be16(acl_e->e_perm);\n\t}\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xfs_trace.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_acl_to_disk(struct xfs_acl *aclp, const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *acl_e;\n\tstruct xfs_acl_entry *ace;\n\tint i;\n\n\taclp->acl_cnt = cpu_to_be32(acl->a_count);\n\tfor (i = 0; i < acl->a_count; i++) {\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e = &acl->a_entries[i];\n\n\t\tace->ae_tag = cpu_to_be32(acl_e->e_tag);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tace->ae_id = cpu_to_be32(xfs_kuid_to_uid(acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tace->ae_id = cpu_to_be32(xfs_kgid_to_gid(acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tace->ae_id = cpu_to_be32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\n\t\tace->ae_perm = cpu_to_be16(acl_e->e_perm);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zalloc_large",
          "args": [
            "len",
            "KM_SLEEP"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ACL_MAX_SIZE",
          "args": [
            "ip->i_mount"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xfs_trace.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\n__xfs_set_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tunsigned char *ea_name;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = SGI_ACL_FILE;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tea_name = SGI_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tstruct xfs_acl *xfs_acl;\n\t\tint len = XFS_ACL_MAX_SIZE(ip->i_mount);\n\n\t\txfs_acl = kmem_zalloc_large(len, KM_SLEEP);\n\t\tif (!xfs_acl)\n\t\t\treturn -ENOMEM;\n\n\t\txfs_acl_to_disk(xfs_acl, acl);\n\n\t\t/* subtract away the unused acl entries */\n\t\tlen -= sizeof(struct xfs_acl_entry) *\n\t\t\t (XFS_ACL_MAX_ENTRIES(ip->i_mount) - acl->a_count);\n\n\t\terror = xfs_attr_set(ip, ea_name, (unsigned char *)xfs_acl,\n\t\t\t\tlen, ATTR_ROOT);\n\n\t\tkmem_free(xfs_acl);\n\t} else {\n\t\t/*\n\t\t * A NULL ACL argument means we want to remove the ACL.\n\t\t */\n\t\terror = xfs_attr_remove(ip, ea_name, ATTR_ROOT);\n\n\t\t/*\n\t\t * If the attribute didn't exist to start with that's fine.\n\t\t */\n\t\tif (error == -ENOATTR)\n\t\t\terror = 0;\n\t}\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_get_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_acl.c",
    "lines": "121-175",
    "snippet": "struct posix_acl *\nxfs_get_acl(struct inode *inode, int type)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tstruct posix_acl *acl = NULL;\n\tstruct xfs_acl *xfs_acl;\n\tunsigned char *ea_name;\n\tint error;\n\tint len;\n\n\ttrace_xfs_get_acl(ip);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = SGI_ACL_FILE;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = SGI_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/*\n\t * If we have a cached ACLs value just return it, not need to\n\t * go out to the disk.\n\t */\n\tlen = XFS_ACL_MAX_SIZE(ip->i_mount);\n\txfs_acl = kmem_zalloc_large(len, KM_SLEEP);\n\tif (!xfs_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terror = xfs_attr_get(ip, ea_name, (unsigned char *)xfs_acl,\n\t\t\t\t\t\t\t&len, ATTR_ROOT);\n\tif (error) {\n\t\t/*\n\t\t * If the attribute doesn't exist make sure we have a negative\n\t\t * cache entry, for any other error assume it is transient and\n\t\t * leave the cache entry as ACL_NOT_CACHED.\n\t\t */\n\t\tif (error == -ENOATTR)\n\t\t\tgoto out_update_cache;\n\t\tgoto out;\n\t}\n\n\tacl = xfs_acl_from_disk(xfs_acl, XFS_ACL_MAX_ENTRIES(ip->i_mount));\n\tif (IS_ERR(acl))\n\t\tgoto out;\n\nout_update_cache:\n\tset_cached_acl(inode, type, acl);\nout:\n\tkmem_free(xfs_acl);\n\treturn acl;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "xfs_acl"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "58-68",
          "snippet": "void set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\tspin_lock(&inode->i_lock);\n\told = *p;\n\trcu_assign_pointer(*p, posix_acl_dup(acl));\n\tspin_unlock(&inode->i_lock);\n\tif (old != ACL_NOT_CACHED)\n\t\tposix_acl_release(old);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\tspin_lock(&inode->i_lock);\n\told = *p;\n\trcu_assign_pointer(*p, posix_acl_dup(acl));\n\tspin_unlock(&inode->i_lock);\n\tif (old != ACL_NOT_CACHED)\n\t\tposix_acl_release(old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "acl"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_acl_from_disk",
          "args": [
            "xfs_acl",
            "XFS_ACL_MAX_ENTRIES(ip->i_mount)"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_acl_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_acl.c",
          "lines": "38-90",
          "snippet": "posix_acl *\nxfs_acl_from_disk(\n\tstruct xfs_acl\t*aclp,\n\tint\t\tmax_entries)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tunsigned int count, i;\n\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > max_entries)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\n\t\t/*\n\t\t * The tag is 32 bits on disk and 16 bits in core.\n\t\t *\n\t\t * Because every access to it goes through the core\n\t\t * format first this is not a problem.\n\t\t */\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tacl_e->e_uid = xfs_uid_to_kuid(be32_to_cpu(ace->ae_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_gid = xfs_gid_to_kgid(be32_to_cpu(ace->ae_id));\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xfs_trace.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nposix_acl *\nxfs_acl_from_disk(\n\tstruct xfs_acl\t*aclp,\n\tint\t\tmax_entries)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tunsigned int count, i;\n\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > max_entries)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\n\t\t/*\n\t\t * The tag is 32 bits on disk and 16 bits in core.\n\t\t *\n\t\t * Because every access to it goes through the core\n\t\t * format first this is not a problem.\n\t\t */\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tacl_e->e_uid = xfs_uid_to_kuid(be32_to_cpu(ace->ae_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_gid = xfs_gid_to_kgid(be32_to_cpu(ace->ae_id));\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ACL_MAX_ENTRIES",
          "args": [
            "ip->i_mount"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_get",
          "args": [
            "ip",
            "ea_name",
            "(unsigned char *)xfs_acl",
            "&len",
            "ATTR_ROOT"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "116-156",
          "snippet": "int\nxfs_attr_get(\n\tstruct xfs_inode\t*ip,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\t*valuelenp,\n\tint\t\t\tflags)\n{\n\tstruct xfs_da_args\targs;\n\tuint\t\t\tlock_mode;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_attr_get);\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\n\tif (!xfs_inode_hasattr(ip))\n\t\treturn -ENOATTR;\n\n\terror = xfs_attr_args_init(&args, ip, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = *valuelenp;\n\n\tlock_mode = xfs_ilock_attr_map_shared(ip);\n\tif (!xfs_inode_hasattr(ip))\n\t\terror = -ENOATTR;\n\telse if (ip->i_d.di_aformat == XFS_DINODE_FMT_LOCAL)\n\t\terror = xfs_attr_shortform_getvalue(&args);\n\telse if (xfs_bmap_one_block(ip, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_get(&args);\n\telse\n\t\terror = xfs_attr_node_get(&args);\n\txfs_iunlock(ip, lock_mode);\n\n\t*valuelenp = args.valuelen;\n\treturn error == -EEXIST ? 0 : error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nint\nxfs_attr_get(\n\tstruct xfs_inode\t*ip,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\t*valuelenp,\n\tint\t\t\tflags)\n{\n\tstruct xfs_da_args\targs;\n\tuint\t\t\tlock_mode;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_attr_get);\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\n\tif (!xfs_inode_hasattr(ip))\n\t\treturn -ENOATTR;\n\n\terror = xfs_attr_args_init(&args, ip, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = *valuelenp;\n\n\tlock_mode = xfs_ilock_attr_map_shared(ip);\n\tif (!xfs_inode_hasattr(ip))\n\t\terror = -ENOATTR;\n\telse if (ip->i_d.di_aformat == XFS_DINODE_FMT_LOCAL)\n\t\terror = xfs_attr_shortform_getvalue(&args);\n\telse if (xfs_bmap_one_block(ip, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_get(&args);\n\telse\n\t\terror = xfs_attr_node_get(&args);\n\txfs_iunlock(ip, lock_mode);\n\n\t*valuelenp = args.valuelen;\n\treturn error == -EEXIST ? 0 : error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc_large",
          "args": [
            "len",
            "KM_SLEEP"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ACL_MAX_SIZE",
          "args": [
            "ip->i_mount"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_get_acl",
          "args": [
            "ip"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xfs_trace.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstruct posix_acl *\nxfs_get_acl(struct inode *inode, int type)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tstruct posix_acl *acl = NULL;\n\tstruct xfs_acl *xfs_acl;\n\tunsigned char *ea_name;\n\tint error;\n\tint len;\n\n\ttrace_xfs_get_acl(ip);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = SGI_ACL_FILE;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = SGI_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/*\n\t * If we have a cached ACLs value just return it, not need to\n\t * go out to the disk.\n\t */\n\tlen = XFS_ACL_MAX_SIZE(ip->i_mount);\n\txfs_acl = kmem_zalloc_large(len, KM_SLEEP);\n\tif (!xfs_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terror = xfs_attr_get(ip, ea_name, (unsigned char *)xfs_acl,\n\t\t\t\t\t\t\t&len, ATTR_ROOT);\n\tif (error) {\n\t\t/*\n\t\t * If the attribute doesn't exist make sure we have a negative\n\t\t * cache entry, for any other error assume it is transient and\n\t\t * leave the cache entry as ACL_NOT_CACHED.\n\t\t */\n\t\tif (error == -ENOATTR)\n\t\t\tgoto out_update_cache;\n\t\tgoto out;\n\t}\n\n\tacl = xfs_acl_from_disk(xfs_acl, XFS_ACL_MAX_ENTRIES(ip->i_mount));\n\tif (IS_ERR(acl))\n\t\tgoto out;\n\nout_update_cache:\n\tset_cached_acl(inode, type, acl);\nout:\n\tkmem_free(xfs_acl);\n\treturn acl;\n}"
  },
  {
    "function_name": "xfs_acl_to_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_acl.c",
    "lines": "92-119",
    "snippet": "STATIC void\nxfs_acl_to_disk(struct xfs_acl *aclp, const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *acl_e;\n\tstruct xfs_acl_entry *ace;\n\tint i;\n\n\taclp->acl_cnt = cpu_to_be32(acl->a_count);\n\tfor (i = 0; i < acl->a_count; i++) {\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e = &acl->a_entries[i];\n\n\t\tace->ae_tag = cpu_to_be32(acl_e->e_tag);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tace->ae_id = cpu_to_be32(xfs_kuid_to_uid(acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tace->ae_id = cpu_to_be32(xfs_kgid_to_gid(acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tace->ae_id = cpu_to_be32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\n\t\tace->ae_perm = cpu_to_be16(acl_e->e_perm);\n\t}\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "acl_e->e_perm"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ACL_UNDEFINED_ID"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "xfs_kgid_to_gid(acl_e->e_gid)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_kgid_to_gid",
          "args": [
            "acl_e->e_gid"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_kgid_to_gid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "213-216",
          "snippet": "static inline __uint32_t xfs_kgid_to_gid(kgid_t gid)\n{\n\treturn from_kgid(&init_user_ns, gid);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint32_t xfs_kgid_to_gid(kgid_t gid)\n{\n\treturn from_kgid(&init_user_ns, gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "xfs_kuid_to_uid(acl_e->e_uid)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_kuid_to_uid",
          "args": [
            "acl_e->e_uid"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_kuid_to_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "203-206",
          "snippet": "static inline __uint32_t xfs_kuid_to_uid(kuid_t uid)\n{\n\treturn from_kuid(&init_user_ns, uid);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint32_t xfs_kuid_to_uid(kuid_t uid)\n{\n\treturn from_kuid(&init_user_ns, uid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "acl_e->e_tag"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "acl->a_count"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xfs_trace.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_acl_to_disk(struct xfs_acl *aclp, const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *acl_e;\n\tstruct xfs_acl_entry *ace;\n\tint i;\n\n\taclp->acl_cnt = cpu_to_be32(acl->a_count);\n\tfor (i = 0; i < acl->a_count; i++) {\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e = &acl->a_entries[i];\n\n\t\tace->ae_tag = cpu_to_be32(acl_e->e_tag);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tace->ae_id = cpu_to_be32(xfs_kuid_to_uid(acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tace->ae_id = cpu_to_be32(xfs_kgid_to_gid(acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tace->ae_id = cpu_to_be32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\n\t\tace->ae_perm = cpu_to_be16(acl_e->e_perm);\n\t}\n}"
  },
  {
    "function_name": "xfs_acl_from_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_acl.c",
    "lines": "38-90",
    "snippet": "posix_acl *\nxfs_acl_from_disk(\n\tstruct xfs_acl\t*aclp,\n\tint\t\tmax_entries)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tunsigned int count, i;\n\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > max_entries)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\n\t\t/*\n\t\t * The tag is 32 bits on disk and 16 bits in core.\n\t\t *\n\t\t * Because every access to it goes through the core\n\t\t * format first this is not a problem.\n\t\t */\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tacl_e->e_uid = xfs_uid_to_kuid(be32_to_cpu(ace->ae_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_gid = xfs_gid_to_kgid(be32_to_cpu(ace->ae_id));\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_gid_to_kgid",
          "args": [
            "be32_to_cpu(ace->ae_id)"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_gid_to_kgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "218-221",
          "snippet": "static inline kgid_t xfs_gid_to_kgid(__uint32_t gid)\n{\n\treturn make_kgid(&init_user_ns, gid);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline kgid_t xfs_gid_to_kgid(__uint32_t gid)\n{\n\treturn make_kgid(&init_user_ns, gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ace->ae_id"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_uid_to_kuid",
          "args": [
            "be32_to_cpu(ace->ae_id)"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_uid_to_kuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "208-211",
          "snippet": "static inline kuid_t xfs_uid_to_kuid(__uint32_t uid)\n{\n\treturn make_kuid(&init_user_ns, uid);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline kuid_t xfs_uid_to_kuid(__uint32_t uid)\n{\n\treturn make_kuid(&init_user_ns, uid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ace->ae_id"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "ace->ae_perm"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ace->ae_tag"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_alloc",
          "args": [
            "count",
            "GFP_KERNEL"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "140-149",
          "snippet": "struct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFSCORRUPTED"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "aclp->acl_cnt"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xfs_trace.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nposix_acl *\nxfs_acl_from_disk(\n\tstruct xfs_acl\t*aclp,\n\tint\t\tmax_entries)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tunsigned int count, i;\n\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > max_entries)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\n\t\t/*\n\t\t * The tag is 32 bits on disk and 16 bits in core.\n\t\t *\n\t\t * Because every access to it goes through the core\n\t\t * format first this is not a problem.\n\t\t */\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tacl_e->e_uid = xfs_uid_to_kuid(be32_to_cpu(ace->ae_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_gid = xfs_gid_to_kgid(be32_to_cpu(ace->ae_id));\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}"
  }
]