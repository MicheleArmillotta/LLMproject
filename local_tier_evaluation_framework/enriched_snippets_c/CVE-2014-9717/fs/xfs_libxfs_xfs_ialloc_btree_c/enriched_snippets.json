[
  {
    "function_name": "xfs_inobt_maxrecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "409-420",
    "snippet": "int\nxfs_inobt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_INOBT_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_inobt_rec_t);\n\treturn blocklen / (sizeof(xfs_inobt_key_t) + sizeof(xfs_inobt_ptr_t));\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_INOBT_BLOCK_LEN",
          "args": [
            "mp"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_inobt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_INOBT_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_inobt_rec_t);\n\treturn blocklen / (sizeof(xfs_inobt_key_t) + sizeof(xfs_inobt_ptr_t));\n}"
  },
  {
    "function_name": "xfs_inobt_init_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "371-404",
    "snippet": "struct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "static const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};",
      "static const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_free_level"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_level"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zone_zalloc",
          "args": [
            "xfs_btree_cur_zone",
            "KM_SLEEP"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_zalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "119-123",
          "snippet": "static inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache",
            "#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)\n\nstatic inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "agbp"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\nstatic const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}"
  },
  {
    "function_name": "xfs_inobt_recs_inorder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "313-321",
    "snippet": "STATIC int\nxfs_inobt_recs_inorder(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*r1,\n\tunion xfs_btree_rec\t*r2)\n{\n\treturn be32_to_cpu(r1->inobt.ir_startino) + XFS_INODES_PER_CHUNK <=\n\t\tbe32_to_cpu(r2->inobt.ir_startino);\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "r2->inobt.ir_startino"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "r1->inobt.ir_startino"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_inobt_recs_inorder(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*r1,\n\tunion xfs_btree_rec\t*r2)\n{\n\treturn be32_to_cpu(r1->inobt.ir_startino) + XFS_INODES_PER_CHUNK <=\n\t\tbe32_to_cpu(r2->inobt.ir_startino);\n}"
  },
  {
    "function_name": "xfs_inobt_keys_inorder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "303-311",
    "snippet": "STATIC int\nxfs_inobt_keys_inorder(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*k1,\n\tunion xfs_btree_key\t*k2)\n{\n\treturn be32_to_cpu(k1->inobt.ir_startino) <\n\t\tbe32_to_cpu(k2->inobt.ir_startino);\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k2->inobt.ir_startino"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k1->inobt.ir_startino"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_inobt_keys_inorder(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*k1,\n\tunion xfs_btree_key\t*k2)\n{\n\treturn be32_to_cpu(k1->inobt.ir_startino) <\n\t\tbe32_to_cpu(k2->inobt.ir_startino);\n}"
  },
  {
    "function_name": "xfs_inobt_write_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "283-295",
    "snippet": "static void\nxfs_inobt_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tif (!xfs_inobt_verify(bp)) {\n\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\txfs_btree_sblock_calc_crc(bp);\n\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_sblock_calc_crc",
          "args": [
            "bp"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_sblock_calc_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "258-270",
          "snippet": "void\nxfs_btree_sblock_calc_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn;\n\tif (bip)\n\t\tblock->bb_u.s.bb_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\txfs_buf_update_cksum(bp, XFS_BTREE_SBLOCK_CRC_OFF);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_sblock_calc_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn;\n\tif (bip)\n\t\tblock->bb_u.s.bb_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\txfs_buf_update_cksum(bp, XFS_BTREE_SBLOCK_CRC_OFF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_btree_corrupt",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_verify",
          "args": [
            "bp"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
          "lines": "209-266",
          "snippet": "static int\nxfs_inobt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\tunsigned int\t\tlevel;\n\n\t/*\n\t * During growfs operations, we can't verify the exact owner as the\n\t * perag is not fully initialised and hence not attached to the buffer.\n\t *\n\t * Similarly, during log recovery we will have a perag structure\n\t * attached, but the agi information will not yet have been initialised\n\t * from the on disk AGI. We don't currently use any of this information,\n\t * but beware of the landmine (i.e. need to check pag->pagi_init) if we\n\t * ever do.\n\t */\n\tswitch (block->bb_magic) {\n\tcase cpu_to_be32(XFS_IBT_CRC_MAGIC):\n\tcase cpu_to_be32(XFS_FIBT_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (block->bb_u.s.bb_blkno != cpu_to_be64(bp->b_bn))\n\t\t\treturn false;\n\t\tif (pag &&\n\t\t    be32_to_cpu(block->bb_u.s.bb_owner) != pag->pag_agno)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_IBT_MAGIC):\n\tcase cpu_to_be32(XFS_FIBT_MAGIC):\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t/* numrecs and level verification */\n\tlevel = be16_to_cpu(block->bb_level);\n\tif (level >= mp->m_in_maxlevels)\n\t\treturn false;\n\tif (be16_to_cpu(block->bb_numrecs) > mp->m_inobt_mxr[level != 0])\n\t\treturn false;\n\n\t/* sibling pointer verification */\n\tif (!block->bb_u.s.bb_leftsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_leftsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_leftsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\tif (!block->bb_u.s.bb_rightsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_rightsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_rightsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic int\nxfs_inobt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\tunsigned int\t\tlevel;\n\n\t/*\n\t * During growfs operations, we can't verify the exact owner as the\n\t * perag is not fully initialised and hence not attached to the buffer.\n\t *\n\t * Similarly, during log recovery we will have a perag structure\n\t * attached, but the agi information will not yet have been initialised\n\t * from the on disk AGI. We don't currently use any of this information,\n\t * but beware of the landmine (i.e. need to check pag->pagi_init) if we\n\t * ever do.\n\t */\n\tswitch (block->bb_magic) {\n\tcase cpu_to_be32(XFS_IBT_CRC_MAGIC):\n\tcase cpu_to_be32(XFS_FIBT_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (block->bb_u.s.bb_blkno != cpu_to_be64(bp->b_bn))\n\t\t\treturn false;\n\t\tif (pag &&\n\t\t    be32_to_cpu(block->bb_u.s.bb_owner) != pag->pag_agno)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_IBT_MAGIC):\n\tcase cpu_to_be32(XFS_FIBT_MAGIC):\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t/* numrecs and level verification */\n\tlevel = be16_to_cpu(block->bb_level);\n\tif (level >= mp->m_in_maxlevels)\n\t\treturn false;\n\tif (be16_to_cpu(block->bb_numrecs) > mp->m_inobt_mxr[level != 0])\n\t\treturn false;\n\n\t/* sibling pointer verification */\n\tif (!block->bb_u.s.bb_leftsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_leftsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_leftsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\tif (!block->bb_u.s.bb_rightsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_rightsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_rightsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic void\nxfs_inobt_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tif (!xfs_inobt_verify(bp)) {\n\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\txfs_btree_sblock_calc_crc(bp);\n\n}"
  },
  {
    "function_name": "xfs_inobt_read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "268-281",
    "snippet": "static void\nxfs_inobt_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tif (!xfs_btree_sblock_verify_crc(bp))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_inobt_verify(bp))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error) {\n\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\txfs_verifier_error(bp);\n\t}\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_btree_corrupt",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_verify",
          "args": [
            "bp"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
          "lines": "209-266",
          "snippet": "static int\nxfs_inobt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\tunsigned int\t\tlevel;\n\n\t/*\n\t * During growfs operations, we can't verify the exact owner as the\n\t * perag is not fully initialised and hence not attached to the buffer.\n\t *\n\t * Similarly, during log recovery we will have a perag structure\n\t * attached, but the agi information will not yet have been initialised\n\t * from the on disk AGI. We don't currently use any of this information,\n\t * but beware of the landmine (i.e. need to check pag->pagi_init) if we\n\t * ever do.\n\t */\n\tswitch (block->bb_magic) {\n\tcase cpu_to_be32(XFS_IBT_CRC_MAGIC):\n\tcase cpu_to_be32(XFS_FIBT_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (block->bb_u.s.bb_blkno != cpu_to_be64(bp->b_bn))\n\t\t\treturn false;\n\t\tif (pag &&\n\t\t    be32_to_cpu(block->bb_u.s.bb_owner) != pag->pag_agno)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_IBT_MAGIC):\n\tcase cpu_to_be32(XFS_FIBT_MAGIC):\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t/* numrecs and level verification */\n\tlevel = be16_to_cpu(block->bb_level);\n\tif (level >= mp->m_in_maxlevels)\n\t\treturn false;\n\tif (be16_to_cpu(block->bb_numrecs) > mp->m_inobt_mxr[level != 0])\n\t\treturn false;\n\n\t/* sibling pointer verification */\n\tif (!block->bb_u.s.bb_leftsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_leftsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_leftsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\tif (!block->bb_u.s.bb_rightsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_rightsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_rightsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic int\nxfs_inobt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\tunsigned int\t\tlevel;\n\n\t/*\n\t * During growfs operations, we can't verify the exact owner as the\n\t * perag is not fully initialised and hence not attached to the buffer.\n\t *\n\t * Similarly, during log recovery we will have a perag structure\n\t * attached, but the agi information will not yet have been initialised\n\t * from the on disk AGI. We don't currently use any of this information,\n\t * but beware of the landmine (i.e. need to check pag->pagi_init) if we\n\t * ever do.\n\t */\n\tswitch (block->bb_magic) {\n\tcase cpu_to_be32(XFS_IBT_CRC_MAGIC):\n\tcase cpu_to_be32(XFS_FIBT_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (block->bb_u.s.bb_blkno != cpu_to_be64(bp->b_bn))\n\t\t\treturn false;\n\t\tif (pag &&\n\t\t    be32_to_cpu(block->bb_u.s.bb_owner) != pag->pag_agno)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_IBT_MAGIC):\n\tcase cpu_to_be32(XFS_FIBT_MAGIC):\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t/* numrecs and level verification */\n\tlevel = be16_to_cpu(block->bb_level);\n\tif (level >= mp->m_in_maxlevels)\n\t\treturn false;\n\tif (be16_to_cpu(block->bb_numrecs) > mp->m_inobt_mxr[level != 0])\n\t\treturn false;\n\n\t/* sibling pointer verification */\n\tif (!block->bb_u.s.bb_leftsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_leftsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_leftsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\tif (!block->bb_u.s.bb_rightsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_rightsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_rightsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_sblock_verify_crc",
          "args": [
            "bp"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_sblock_verify_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "272-280",
          "snippet": "bool\nxfs_btree_sblock_verify_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tif (xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn xfs_buf_verify_cksum(bp, XFS_BTREE_SBLOCK_CRC_OFF);\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nbool\nxfs_btree_sblock_verify_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tif (xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn xfs_buf_verify_cksum(bp, XFS_BTREE_SBLOCK_CRC_OFF);\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic void\nxfs_inobt_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tif (!xfs_btree_sblock_verify_crc(bp))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_inobt_verify(bp))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error) {\n\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\txfs_verifier_error(bp);\n\t}\n}"
  },
  {
    "function_name": "xfs_inobt_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "209-266",
    "snippet": "static int\nxfs_inobt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\tunsigned int\t\tlevel;\n\n\t/*\n\t * During growfs operations, we can't verify the exact owner as the\n\t * perag is not fully initialised and hence not attached to the buffer.\n\t *\n\t * Similarly, during log recovery we will have a perag structure\n\t * attached, but the agi information will not yet have been initialised\n\t * from the on disk AGI. We don't currently use any of this information,\n\t * but beware of the landmine (i.e. need to check pag->pagi_init) if we\n\t * ever do.\n\t */\n\tswitch (block->bb_magic) {\n\tcase cpu_to_be32(XFS_IBT_CRC_MAGIC):\n\tcase cpu_to_be32(XFS_FIBT_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (block->bb_u.s.bb_blkno != cpu_to_be64(bp->b_bn))\n\t\t\treturn false;\n\t\tif (pag &&\n\t\t    be32_to_cpu(block->bb_u.s.bb_owner) != pag->pag_agno)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_IBT_MAGIC):\n\tcase cpu_to_be32(XFS_FIBT_MAGIC):\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t/* numrecs and level verification */\n\tlevel = be16_to_cpu(block->bb_level);\n\tif (level >= mp->m_in_maxlevels)\n\t\treturn false;\n\tif (be16_to_cpu(block->bb_numrecs) > mp->m_inobt_mxr[level != 0])\n\t\treturn false;\n\n\t/* sibling pointer verification */\n\tif (!block->bb_u.s.bb_leftsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_leftsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_leftsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\tif (!block->bb_u.s.bb_rightsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_rightsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_rightsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGBLOCK"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "block->bb_u.s.bb_rightsib"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGBLOCK"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "block->bb_u.s.bb_leftsib"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_numrecs"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_level"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_FIBT_MAGIC"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_IBT_MAGIC"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "block->bb_u.s.bb_owner"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bp->b_bn"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&block->bb_u.s.bb_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_FIBT_CRC_MAGIC"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_IBT_CRC_MAGIC"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic int\nxfs_inobt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\tunsigned int\t\tlevel;\n\n\t/*\n\t * During growfs operations, we can't verify the exact owner as the\n\t * perag is not fully initialised and hence not attached to the buffer.\n\t *\n\t * Similarly, during log recovery we will have a perag structure\n\t * attached, but the agi information will not yet have been initialised\n\t * from the on disk AGI. We don't currently use any of this information,\n\t * but beware of the landmine (i.e. need to check pag->pagi_init) if we\n\t * ever do.\n\t */\n\tswitch (block->bb_magic) {\n\tcase cpu_to_be32(XFS_IBT_CRC_MAGIC):\n\tcase cpu_to_be32(XFS_FIBT_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (block->bb_u.s.bb_blkno != cpu_to_be64(bp->b_bn))\n\t\t\treturn false;\n\t\tif (pag &&\n\t\t    be32_to_cpu(block->bb_u.s.bb_owner) != pag->pag_agno)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_IBT_MAGIC):\n\tcase cpu_to_be32(XFS_FIBT_MAGIC):\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t/* numrecs and level verification */\n\tlevel = be16_to_cpu(block->bb_level);\n\tif (level >= mp->m_in_maxlevels)\n\t\treturn false;\n\tif (be16_to_cpu(block->bb_numrecs) > mp->m_inobt_mxr[level != 0])\n\t\treturn false;\n\n\t/* sibling pointer verification */\n\tif (!block->bb_u.s.bb_leftsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_leftsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_leftsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\tif (!block->bb_u.s.bb_rightsib ||\n\t    (be32_to_cpu(block->bb_u.s.bb_rightsib) >= mp->m_sb.sb_agblocks &&\n\t     block->bb_u.s.bb_rightsib != cpu_to_be32(NULLAGBLOCK)))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_inobt_key_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "200-207",
    "snippet": "STATIC __int64_t\nxfs_inobt_key_diff(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*key)\n{\n\treturn (__int64_t)be32_to_cpu(key->inobt.ir_startino) -\n\t\t\t  cur->bc_rec.i.ir_startino;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "key->inobt.ir_startino"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC __int64_t\nxfs_inobt_key_diff(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*key)\n{\n\treturn (__int64_t)be32_to_cpu(key->inobt.ir_startino) -\n\t\t\t  cur->bc_rec.i.ir_startino;\n}"
  },
  {
    "function_name": "xfs_finobt_init_ptr_from_cur",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "189-198",
    "snippet": "STATIC void\nxfs_finobt_init_ptr_from_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(cur->bc_private.a.agbp);\n\n\tASSERT(cur->bc_private.a.agno == be32_to_cpu(agi->agi_seqno));\n\tptr->s = agi->agi_free_root;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_private.a.agno == be32_to_cpu(agi->agi_seqno)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_seqno"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "cur->bc_private.a.agbp"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_finobt_init_ptr_from_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(cur->bc_private.a.agbp);\n\n\tASSERT(cur->bc_private.a.agno == be32_to_cpu(agi->agi_seqno));\n\tptr->s = agi->agi_free_root;\n}"
  },
  {
    "function_name": "xfs_inobt_init_ptr_from_cur",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "177-187",
    "snippet": "STATIC void\nxfs_inobt_init_ptr_from_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(cur->bc_private.a.agbp);\n\n\tASSERT(cur->bc_private.a.agno == be32_to_cpu(agi->agi_seqno));\n\n\tptr->s = agi->agi_root;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_private.a.agno == be32_to_cpu(agi->agi_seqno)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agi->agi_seqno"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "cur->bc_private.a.agbp"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_inobt_init_ptr_from_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(cur->bc_private.a.agbp);\n\n\tASSERT(cur->bc_private.a.agno == be32_to_cpu(agi->agi_seqno));\n\n\tptr->s = agi->agi_root;\n}"
  },
  {
    "function_name": "xfs_inobt_init_rec_from_cur",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "164-172",
    "snippet": "STATIC void\nxfs_inobt_init_rec_from_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec)\n{\n\trec->inobt.ir_startino = cpu_to_be32(cur->bc_rec.i.ir_startino);\n\trec->inobt.ir_freecount = cpu_to_be32(cur->bc_rec.i.ir_freecount);\n\trec->inobt.ir_free = cpu_to_be64(cur->bc_rec.i.ir_free);\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "cur->bc_rec.i.ir_free"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "cur->bc_rec.i.ir_freecount"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "cur->bc_rec.i.ir_startino"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_inobt_init_rec_from_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec)\n{\n\trec->inobt.ir_startino = cpu_to_be32(cur->bc_rec.i.ir_startino);\n\trec->inobt.ir_freecount = cpu_to_be32(cur->bc_rec.i.ir_freecount);\n\trec->inobt.ir_free = cpu_to_be64(cur->bc_rec.i.ir_free);\n}"
  },
  {
    "function_name": "xfs_inobt_init_rec_from_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "156-162",
    "snippet": "STATIC void\nxfs_inobt_init_rec_from_key(\n\tunion xfs_btree_key\t*key,\n\tunion xfs_btree_rec\t*rec)\n{\n\trec->inobt.ir_startino = key->inobt.ir_startino;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_inobt_init_rec_from_key(\n\tunion xfs_btree_key\t*key,\n\tunion xfs_btree_rec\t*rec)\n{\n\trec->inobt.ir_startino = key->inobt.ir_startino;\n}"
  },
  {
    "function_name": "xfs_inobt_init_key_from_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "148-154",
    "snippet": "STATIC void\nxfs_inobt_init_key_from_rec(\n\tunion xfs_btree_key\t*key,\n\tunion xfs_btree_rec\t*rec)\n{\n\tkey->inobt.ir_startino = rec->inobt.ir_startino;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_inobt_init_key_from_rec(\n\tunion xfs_btree_key\t*key,\n\tunion xfs_btree_rec\t*rec)\n{\n\tkey->inobt.ir_startino = rec->inobt.ir_startino;\n}"
  },
  {
    "function_name": "xfs_inobt_get_maxrecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "140-146",
    "snippet": "STATIC int\nxfs_inobt_get_maxrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\treturn cur->bc_mp->m_inobt_mxr[level != 0];\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_inobt_get_maxrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\treturn cur->bc_mp->m_inobt_mxr[level != 0];\n}"
  },
  {
    "function_name": "xfs_inobt_free_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "123-138",
    "snippet": "STATIC int\nxfs_inobt_free_block(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp)\n{\n\txfs_fsblock_t\t\tfsbno;\n\tint\t\t\terror;\n\n\tfsbno = XFS_DADDR_TO_FSB(cur->bc_mp, XFS_BUF_ADDR(bp));\n\terror = xfs_free_extent(cur->bc_tp, fsbno, 1);\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_binval(cur->bc_tp, bp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_binval",
          "args": [
            "cur->bc_tp",
            "bp"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_binval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "584-626",
          "snippet": "void\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_free_extent",
          "args": [
            "cur->bc_tp",
            "fsbno",
            "1"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2587-2633",
          "snippet": "int\t\t\t\t/* error */\nxfs_free_extent(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_fsblock_t\tbno,\t/* starting block number of extent */\n\txfs_extlen_t\tlen)\t/* length of extent */\n{\n\txfs_alloc_arg_t\targs;\n\tint\t\terror;\n\n\tASSERT(len != 0);\n\tmemset(&args, 0, sizeof(xfs_alloc_arg_t));\n\targs.tp = tp;\n\targs.mp = tp->t_mountp;\n\n\t/*\n\t * validate that the block number is legal - the enables us to detect\n\t * and handle a silent filesystem corruption rather than crashing.\n\t */\n\targs.agno = XFS_FSB_TO_AGNO(args.mp, bno);\n\tif (args.agno >= args.mp->m_sb.sb_agcount)\n\t\treturn -EFSCORRUPTED;\n\n\targs.agbno = XFS_FSB_TO_AGBNO(args.mp, bno);\n\tif (args.agbno >= args.mp->m_sb.sb_agblocks)\n\t\treturn -EFSCORRUPTED;\n\n\targs.pag = xfs_perag_get(args.mp, args.agno);\n\tASSERT(args.pag);\n\n\terror = xfs_alloc_fix_freelist(&args, XFS_ALLOC_FLAG_FREEING);\n\tif (error)\n\t\tgoto error0;\n\n\t/* validate the extent size is legal now we have the agf locked */\n\tif (args.agbno + len >\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args.agbp)->agf_length)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\n\terror = xfs_free_ag_extent(tp, args.agbp, args.agno, args.agbno, len, 0);\n\tif (!error)\n\t\txfs_extent_busy_insert(tp, args.agno, args.agbno, len, 0);\nerror0:\n\txfs_perag_put(args.pag);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t/* error */\nxfs_free_extent(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_fsblock_t\tbno,\t/* starting block number of extent */\n\txfs_extlen_t\tlen)\t/* length of extent */\n{\n\txfs_alloc_arg_t\targs;\n\tint\t\terror;\n\n\tASSERT(len != 0);\n\tmemset(&args, 0, sizeof(xfs_alloc_arg_t));\n\targs.tp = tp;\n\targs.mp = tp->t_mountp;\n\n\t/*\n\t * validate that the block number is legal - the enables us to detect\n\t * and handle a silent filesystem corruption rather than crashing.\n\t */\n\targs.agno = XFS_FSB_TO_AGNO(args.mp, bno);\n\tif (args.agno >= args.mp->m_sb.sb_agcount)\n\t\treturn -EFSCORRUPTED;\n\n\targs.agbno = XFS_FSB_TO_AGBNO(args.mp, bno);\n\tif (args.agbno >= args.mp->m_sb.sb_agblocks)\n\t\treturn -EFSCORRUPTED;\n\n\targs.pag = xfs_perag_get(args.mp, args.agno);\n\tASSERT(args.pag);\n\n\terror = xfs_alloc_fix_freelist(&args, XFS_ALLOC_FLAG_FREEING);\n\tif (error)\n\t\tgoto error0;\n\n\t/* validate the extent size is legal now we have the agf locked */\n\tif (args.agbno + len >\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args.agbp)->agf_length)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\n\terror = xfs_free_ag_extent(tp, args.agbp, args.agno, args.agbno, len, 0);\n\tif (!error)\n\t\txfs_extent_busy_insert(tp, args.agno, args.agbno, len, 0);\nerror0:\n\txfs_perag_put(args.pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_DADDR_TO_FSB",
          "args": [
            "cur->bc_mp",
            "XFS_BUF_ADDR(bp)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "bp"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_inobt_free_block(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp)\n{\n\txfs_fsblock_t\t\tfsbno;\n\tint\t\t\terror;\n\n\tfsbno = XFS_DADDR_TO_FSB(cur->bc_mp, XFS_BUF_ADDR(bp));\n\terror = xfs_free_extent(cur->bc_tp, fsbno, 1);\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_binval(cur->bc_tp, bp);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_inobt_alloc_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "83-121",
    "snippet": "STATIC int\nxfs_inobt_alloc_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*start,\n\tunion xfs_btree_ptr\t*new,\n\tint\t\t\t*stat)\n{\n\txfs_alloc_arg_t\t\targs;\t\t/* block allocation args */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_agblock_t\t\tsbno = be32_to_cpu(start->s);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = cur->bc_tp;\n\targs.mp = cur->bc_mp;\n\targs.fsbno = XFS_AGB_TO_FSB(args.mp, cur->bc_private.a.agno, sbno);\n\targs.minlen = 1;\n\targs.maxlen = 1;\n\targs.prod = 1;\n\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\n\terror = xfs_alloc_vextent(&args);\n\tif (error) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\treturn error;\n\t}\n\tif (args.fsbno == NULLFSBLOCK) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\tASSERT(args.len == 1);\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\n\tnew->s = cpu_to_be32(XFS_FSB_TO_AGBNO(args.mp, args.fsbno));\n\t*stat = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_FSB_TO_AGBNO(args.mp, args.fsbno)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGBNO",
          "args": [
            "args.mp",
            "args.fsbno"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args.len == 1"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_vextent",
          "args": [
            "&args"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_vextent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2371-2580",
          "snippet": "int\t\t\t\t/* error */\nxfs_alloc_vextent(\n\txfs_alloc_arg_t\t*args)\t/* allocation argument structure */\n{\n\txfs_agblock_t\tagsize;\t/* allocation group size */\n\tint\t\terror;\n\tint\t\tflags;\t/* XFS_ALLOC_FLAG_... locking flags */\n\txfs_extlen_t\tminleft;/* minimum left value, temp copy */\n\txfs_mount_t\t*mp;\t/* mount structure pointer */\n\txfs_agnumber_t\tsagno;\t/* starting allocation group number */\n\txfs_alloctype_t\ttype;\t/* input allocation type */\n\tint\t\tbump_rotor = 0;\n\tint\t\tno_min = 0;\n\txfs_agnumber_t\trotorstep = xfs_rotorstep; /* inode32 agf stepper */\n\n\tmp = args->mp;\n\ttype = args->otype = args->type;\n\targs->agbno = NULLAGBLOCK;\n\t/*\n\t * Just fix this up, for the case where the last a.g. is shorter\n\t * (or there's only one a.g.) and the caller couldn't easily figure\n\t * that out (xfs_bmap_alloc).\n\t */\n\tagsize = mp->m_sb.sb_agblocks;\n\tif (args->maxlen > agsize)\n\t\targs->maxlen = agsize;\n\tif (args->alignment == 0)\n\t\targs->alignment = 1;\n\tASSERT(XFS_FSB_TO_AGNO(mp, args->fsbno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, args->fsbno) < agsize);\n\tASSERT(args->minlen <= args->maxlen);\n\tASSERT(args->minlen <= agsize);\n\tASSERT(args->mod < args->prod);\n\tif (XFS_FSB_TO_AGNO(mp, args->fsbno) >= mp->m_sb.sb_agcount ||\n\t    XFS_FSB_TO_AGBNO(mp, args->fsbno) >= agsize ||\n\t    args->minlen > args->maxlen || args->minlen > agsize ||\n\t    args->mod >= args->prod) {\n\t\targs->fsbno = NULLFSBLOCK;\n\t\ttrace_xfs_alloc_vextent_badargs(args);\n\t\treturn 0;\n\t}\n\tminleft = args->minleft;\n\n\tswitch (type) {\n\tcase XFS_ALLOCTYPE_THIS_AG:\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\t/*\n\t\t * These three force us into a single a.g.\n\t\t */\n\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\targs->minleft = 0;\n\t\terror = xfs_alloc_fix_freelist(args, 0);\n\t\targs->minleft = minleft;\n\t\tif (error) {\n\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\tgoto error0;\n\t\t}\n\t\tif (!args->agbp) {\n\t\t\ttrace_xfs_alloc_vextent_noagbp(args);\n\t\t\tbreak;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\tgoto error0;\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_START_BNO:\n\t\t/*\n\t\t * Try near allocation first, then anywhere-in-ag after\n\t\t * the first a.g. fails.\n\t\t */\n\t\tif ((args->userdata  == XFS_ALLOC_INITIAL_USER_DATA) &&\n\t\t    (mp->m_flags & XFS_MOUNT_32BITINODES)) {\n\t\t\targs->fsbno = XFS_AGB_TO_FSB(mp,\n\t\t\t\t\t((mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount), 0);\n\t\t\tbump_rotor = 1;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t/* FALLTHROUGH */\n\tcase XFS_ALLOCTYPE_ANY_AG:\n\tcase XFS_ALLOCTYPE_START_AG:\n\tcase XFS_ALLOCTYPE_FIRST_AG:\n\t\t/*\n\t\t * Rotate through the allocation groups looking for a winner.\n\t\t */\n\t\tif (type == XFS_ALLOCTYPE_ANY_AG) {\n\t\t\t/*\n\t\t\t * Start with the last place we left off.\n\t\t\t */\n\t\t\targs->agno = sagno = (mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount;\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t} else if (type == XFS_ALLOCTYPE_FIRST_AG) {\n\t\t\t/*\n\t\t\t * Start with allocation group given by bno.\n\t\t\t */\n\t\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tsagno = 0;\n\t\t\tflags = 0;\n\t\t} else {\n\t\t\tif (type == XFS_ALLOCTYPE_START_AG)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t * Start with the given allocation group.\n\t\t\t */\n\t\t\targs->agno = sagno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t}\n\t\t/*\n\t\t * Loop over allocation groups twice; first time with\n\t\t * trylock set, second time without.\n\t\t */\n\t\tfor (;;) {\n\t\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\t\tif (no_min) args->minleft = 0;\n\t\t\terror = xfs_alloc_fix_freelist(args, flags);\n\t\t\targs->minleft = minleft;\n\t\t\tif (error) {\n\t\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we get a buffer back then the allocation will fly.\n\t\t\t */\n\t\t\tif (args->agbp) {\n\t\t\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttrace_xfs_alloc_vextent_loopfailed(args);\n\n\t\t\t/*\n\t\t\t * Didn't work, figure out the next iteration.\n\t\t\t */\n\t\t\tif (args->agno == sagno &&\n\t\t\t    type == XFS_ALLOCTYPE_START_BNO)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t* For the first allocation, we can try any AG to get\n\t\t\t* space.  However, if we already have allocated a\n\t\t\t* block, we don't want to try AGs whose number is below\n\t\t\t* sagno. Otherwise, we may end up with out-of-order\n\t\t\t* locking of AGF, which might cause deadlock.\n\t\t\t*/\n\t\t\tif (++(args->agno) == mp->m_sb.sb_agcount) {\n\t\t\t\tif (args->firstblock != NULLFSBLOCK)\n\t\t\t\t\targs->agno = sagno;\n\t\t\t\telse\n\t\t\t\t\targs->agno = 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reached the starting a.g., must either be done\n\t\t\t * or switch to non-trylock mode.\n\t\t\t */\n\t\t\tif (args->agno == sagno) {\n\t\t\t\tif (no_min == 1) {\n\t\t\t\t\targs->agbno = NULLAGBLOCK;\n\t\t\t\t\ttrace_xfs_alloc_vextent_allfailed(args);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (flags == 0) {\n\t\t\t\t\tno_min = 1;\n\t\t\t\t} else {\n\t\t\t\t\tflags = 0;\n\t\t\t\t\tif (type == XFS_ALLOCTYPE_START_BNO) {\n\t\t\t\t\t\targs->agbno = XFS_FSB_TO_AGBNO(mp,\n\t\t\t\t\t\t\targs->fsbno);\n\t\t\t\t\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\txfs_perag_put(args->pag);\n\t\t}\n\t\tif (bump_rotor || (type == XFS_ALLOCTYPE_ANY_AG)) {\n\t\t\tif (args->agno == sagno)\n\t\t\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t\telse\n\t\t\t\tmp->m_agfrotor = (args->agno * rotorstep + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\t/* NOTREACHED */\n\t}\n\tif (args->agbno == NULLAGBLOCK)\n\t\targs->fsbno = NULLFSBLOCK;\n\telse {\n\t\targs->fsbno = XFS_AGB_TO_FSB(mp, args->agno, args->agbno);\n#ifdef DEBUG\n\t\tASSERT(args->len >= args->minlen);\n\t\tASSERT(args->len <= args->maxlen);\n\t\tASSERT(args->agbno % args->alignment == 0);\n\t\tXFS_AG_CHECK_DADDR(mp, XFS_FSB_TO_DADDR(mp, args->fsbno),\n\t\t\targs->len);\n#endif\n\t}\n\txfs_perag_put(args->pag);\n\treturn 0;\nerror0:\n\txfs_perag_put(args->pag);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t/* error */\nxfs_alloc_vextent(\n\txfs_alloc_arg_t\t*args)\t/* allocation argument structure */\n{\n\txfs_agblock_t\tagsize;\t/* allocation group size */\n\tint\t\terror;\n\tint\t\tflags;\t/* XFS_ALLOC_FLAG_... locking flags */\n\txfs_extlen_t\tminleft;/* minimum left value, temp copy */\n\txfs_mount_t\t*mp;\t/* mount structure pointer */\n\txfs_agnumber_t\tsagno;\t/* starting allocation group number */\n\txfs_alloctype_t\ttype;\t/* input allocation type */\n\tint\t\tbump_rotor = 0;\n\tint\t\tno_min = 0;\n\txfs_agnumber_t\trotorstep = xfs_rotorstep; /* inode32 agf stepper */\n\n\tmp = args->mp;\n\ttype = args->otype = args->type;\n\targs->agbno = NULLAGBLOCK;\n\t/*\n\t * Just fix this up, for the case where the last a.g. is shorter\n\t * (or there's only one a.g.) and the caller couldn't easily figure\n\t * that out (xfs_bmap_alloc).\n\t */\n\tagsize = mp->m_sb.sb_agblocks;\n\tif (args->maxlen > agsize)\n\t\targs->maxlen = agsize;\n\tif (args->alignment == 0)\n\t\targs->alignment = 1;\n\tASSERT(XFS_FSB_TO_AGNO(mp, args->fsbno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, args->fsbno) < agsize);\n\tASSERT(args->minlen <= args->maxlen);\n\tASSERT(args->minlen <= agsize);\n\tASSERT(args->mod < args->prod);\n\tif (XFS_FSB_TO_AGNO(mp, args->fsbno) >= mp->m_sb.sb_agcount ||\n\t    XFS_FSB_TO_AGBNO(mp, args->fsbno) >= agsize ||\n\t    args->minlen > args->maxlen || args->minlen > agsize ||\n\t    args->mod >= args->prod) {\n\t\targs->fsbno = NULLFSBLOCK;\n\t\ttrace_xfs_alloc_vextent_badargs(args);\n\t\treturn 0;\n\t}\n\tminleft = args->minleft;\n\n\tswitch (type) {\n\tcase XFS_ALLOCTYPE_THIS_AG:\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\t/*\n\t\t * These three force us into a single a.g.\n\t\t */\n\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\targs->minleft = 0;\n\t\terror = xfs_alloc_fix_freelist(args, 0);\n\t\targs->minleft = minleft;\n\t\tif (error) {\n\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\tgoto error0;\n\t\t}\n\t\tif (!args->agbp) {\n\t\t\ttrace_xfs_alloc_vextent_noagbp(args);\n\t\t\tbreak;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\tgoto error0;\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_START_BNO:\n\t\t/*\n\t\t * Try near allocation first, then anywhere-in-ag after\n\t\t * the first a.g. fails.\n\t\t */\n\t\tif ((args->userdata  == XFS_ALLOC_INITIAL_USER_DATA) &&\n\t\t    (mp->m_flags & XFS_MOUNT_32BITINODES)) {\n\t\t\targs->fsbno = XFS_AGB_TO_FSB(mp,\n\t\t\t\t\t((mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount), 0);\n\t\t\tbump_rotor = 1;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t/* FALLTHROUGH */\n\tcase XFS_ALLOCTYPE_ANY_AG:\n\tcase XFS_ALLOCTYPE_START_AG:\n\tcase XFS_ALLOCTYPE_FIRST_AG:\n\t\t/*\n\t\t * Rotate through the allocation groups looking for a winner.\n\t\t */\n\t\tif (type == XFS_ALLOCTYPE_ANY_AG) {\n\t\t\t/*\n\t\t\t * Start with the last place we left off.\n\t\t\t */\n\t\t\targs->agno = sagno = (mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount;\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t} else if (type == XFS_ALLOCTYPE_FIRST_AG) {\n\t\t\t/*\n\t\t\t * Start with allocation group given by bno.\n\t\t\t */\n\t\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tsagno = 0;\n\t\t\tflags = 0;\n\t\t} else {\n\t\t\tif (type == XFS_ALLOCTYPE_START_AG)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t * Start with the given allocation group.\n\t\t\t */\n\t\t\targs->agno = sagno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t}\n\t\t/*\n\t\t * Loop over allocation groups twice; first time with\n\t\t * trylock set, second time without.\n\t\t */\n\t\tfor (;;) {\n\t\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\t\tif (no_min) args->minleft = 0;\n\t\t\terror = xfs_alloc_fix_freelist(args, flags);\n\t\t\targs->minleft = minleft;\n\t\t\tif (error) {\n\t\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we get a buffer back then the allocation will fly.\n\t\t\t */\n\t\t\tif (args->agbp) {\n\t\t\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttrace_xfs_alloc_vextent_loopfailed(args);\n\n\t\t\t/*\n\t\t\t * Didn't work, figure out the next iteration.\n\t\t\t */\n\t\t\tif (args->agno == sagno &&\n\t\t\t    type == XFS_ALLOCTYPE_START_BNO)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t* For the first allocation, we can try any AG to get\n\t\t\t* space.  However, if we already have allocated a\n\t\t\t* block, we don't want to try AGs whose number is below\n\t\t\t* sagno. Otherwise, we may end up with out-of-order\n\t\t\t* locking of AGF, which might cause deadlock.\n\t\t\t*/\n\t\t\tif (++(args->agno) == mp->m_sb.sb_agcount) {\n\t\t\t\tif (args->firstblock != NULLFSBLOCK)\n\t\t\t\t\targs->agno = sagno;\n\t\t\t\telse\n\t\t\t\t\targs->agno = 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reached the starting a.g., must either be done\n\t\t\t * or switch to non-trylock mode.\n\t\t\t */\n\t\t\tif (args->agno == sagno) {\n\t\t\t\tif (no_min == 1) {\n\t\t\t\t\targs->agbno = NULLAGBLOCK;\n\t\t\t\t\ttrace_xfs_alloc_vextent_allfailed(args);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (flags == 0) {\n\t\t\t\t\tno_min = 1;\n\t\t\t\t} else {\n\t\t\t\t\tflags = 0;\n\t\t\t\t\tif (type == XFS_ALLOCTYPE_START_BNO) {\n\t\t\t\t\t\targs->agbno = XFS_FSB_TO_AGBNO(mp,\n\t\t\t\t\t\t\targs->fsbno);\n\t\t\t\t\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\txfs_perag_put(args->pag);\n\t\t}\n\t\tif (bump_rotor || (type == XFS_ALLOCTYPE_ANY_AG)) {\n\t\t\tif (args->agno == sagno)\n\t\t\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t\telse\n\t\t\t\tmp->m_agfrotor = (args->agno * rotorstep + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\t/* NOTREACHED */\n\t}\n\tif (args->agbno == NULLAGBLOCK)\n\t\targs->fsbno = NULLFSBLOCK;\n\telse {\n\t\targs->fsbno = XFS_AGB_TO_FSB(mp, args->agno, args->agbno);\n#ifdef DEBUG\n\t\tASSERT(args->len >= args->minlen);\n\t\tASSERT(args->len <= args->maxlen);\n\t\tASSERT(args->agbno % args->alignment == 0);\n\t\tXFS_AG_CHECK_DADDR(mp, XFS_FSB_TO_DADDR(mp, args->fsbno),\n\t\t\targs->len);\n#endif\n\t}\n\txfs_perag_put(args->pag);\n\treturn 0;\nerror0:\n\txfs_perag_put(args->pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_FSB",
          "args": [
            "args.mp",
            "cur->bc_private.a.agno",
            "sbno"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "start->s"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_inobt_alloc_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*start,\n\tunion xfs_btree_ptr\t*new,\n\tint\t\t\t*stat)\n{\n\txfs_alloc_arg_t\t\targs;\t\t/* block allocation args */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_agblock_t\t\tsbno = be32_to_cpu(start->s);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = cur->bc_tp;\n\targs.mp = cur->bc_mp;\n\targs.fsbno = XFS_AGB_TO_FSB(args.mp, cur->bc_private.a.agno, sbno);\n\targs.minlen = 1;\n\targs.maxlen = 1;\n\targs.prod = 1;\n\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\n\terror = xfs_alloc_vextent(&args);\n\tif (error) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\treturn error;\n\t}\n\tif (args.fsbno == NULLFSBLOCK) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\tASSERT(args.len == 1);\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\n\tnew->s = cpu_to_be32(XFS_FSB_TO_AGBNO(args.mp, args.fsbno));\n\t*stat = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_finobt_set_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "68-81",
    "snippet": "STATIC void\nxfs_finobt_set_root(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*nptr,\n\tint\t\t\tinc)\t/* level change */\n{\n\tstruct xfs_buf\t\t*agbp = cur->bc_private.a.agbp;\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\n\tagi->agi_free_root = nptr->s;\n\tbe32_add_cpu(&agi->agi_free_level, inc);\n\txfs_ialloc_log_agi(cur->bc_tp, agbp,\n\t\t\t   XFS_AGI_FREE_ROOT | XFS_AGI_FREE_LEVEL);\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ialloc_log_agi",
          "args": [
            "cur->bc_tp",
            "agbp",
            "XFS_AGI_FREE_ROOT | XFS_AGI_FREE_LEVEL"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_log_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "1971-2026",
          "snippet": "void\nxfs_ialloc_log_agi(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t\t/* allocation group header buffer */\n\tint\t\tfields)\t\t/* bitmask of fields to log */\n{\n\tint\t\t\tfirst;\t\t/* first byte number */\n\tint\t\t\tlast;\t\t/* last byte number */\n\tstatic const short\toffsets[] = {\t/* field starting offsets */\n\t\t\t\t\t/* keep in sync with bit definitions */\n\t\toffsetof(xfs_agi_t, agi_magicnum),\n\t\toffsetof(xfs_agi_t, agi_versionnum),\n\t\toffsetof(xfs_agi_t, agi_seqno),\n\t\toffsetof(xfs_agi_t, agi_length),\n\t\toffsetof(xfs_agi_t, agi_count),\n\t\toffsetof(xfs_agi_t, agi_root),\n\t\toffsetof(xfs_agi_t, agi_level),\n\t\toffsetof(xfs_agi_t, agi_freecount),\n\t\toffsetof(xfs_agi_t, agi_newino),\n\t\toffsetof(xfs_agi_t, agi_dirino),\n\t\toffsetof(xfs_agi_t, agi_unlinked),\n\t\toffsetof(xfs_agi_t, agi_free_root),\n\t\toffsetof(xfs_agi_t, agi_free_level),\n\t\tsizeof(xfs_agi_t)\n\t};\n#ifdef DEBUG\n\txfs_agi_t\t\t*agi;\t/* allocation group header */\n\n\tagi = XFS_BUF_TO_AGI(bp);\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n#endif\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGI_BUF);\n\n\t/*\n\t * Compute byte offsets for the first and last fields in the first\n\t * region and log the agi buffer. This only logs up through\n\t * agi_unlinked.\n\t */\n\tif (fields & XFS_AGI_ALL_BITS_R1) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R1,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n\n\t/*\n\t * Mask off the bits in the first region and calculate the first and\n\t * last field offsets for any bits in the second region.\n\t */\n\tfields &= ~XFS_AGI_ALL_BITS_R1;\n\tif (fields) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R2,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ialloc_log_agi(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t\t/* allocation group header buffer */\n\tint\t\tfields)\t\t/* bitmask of fields to log */\n{\n\tint\t\t\tfirst;\t\t/* first byte number */\n\tint\t\t\tlast;\t\t/* last byte number */\n\tstatic const short\toffsets[] = {\t/* field starting offsets */\n\t\t\t\t\t/* keep in sync with bit definitions */\n\t\toffsetof(xfs_agi_t, agi_magicnum),\n\t\toffsetof(xfs_agi_t, agi_versionnum),\n\t\toffsetof(xfs_agi_t, agi_seqno),\n\t\toffsetof(xfs_agi_t, agi_length),\n\t\toffsetof(xfs_agi_t, agi_count),\n\t\toffsetof(xfs_agi_t, agi_root),\n\t\toffsetof(xfs_agi_t, agi_level),\n\t\toffsetof(xfs_agi_t, agi_freecount),\n\t\toffsetof(xfs_agi_t, agi_newino),\n\t\toffsetof(xfs_agi_t, agi_dirino),\n\t\toffsetof(xfs_agi_t, agi_unlinked),\n\t\toffsetof(xfs_agi_t, agi_free_root),\n\t\toffsetof(xfs_agi_t, agi_free_level),\n\t\tsizeof(xfs_agi_t)\n\t};\n#ifdef DEBUG\n\txfs_agi_t\t\t*agi;\t/* allocation group header */\n\n\tagi = XFS_BUF_TO_AGI(bp);\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n#endif\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGI_BUF);\n\n\t/*\n\t * Compute byte offsets for the first and last fields in the first\n\t * region and log the agi buffer. This only logs up through\n\t * agi_unlinked.\n\t */\n\tif (fields & XFS_AGI_ALL_BITS_R1) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R1,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n\n\t/*\n\t * Mask off the bits in the first region and calculate the first and\n\t * last field offsets for any bits in the second region.\n\t */\n\tfields &= ~XFS_AGI_ALL_BITS_R1;\n\tif (fields) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R2,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agi->agi_free_level",
            "inc"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "agbp"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_finobt_set_root(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*nptr,\n\tint\t\t\tinc)\t/* level change */\n{\n\tstruct xfs_buf\t\t*agbp = cur->bc_private.a.agbp;\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\n\tagi->agi_free_root = nptr->s;\n\tbe32_add_cpu(&agi->agi_free_level, inc);\n\txfs_ialloc_log_agi(cur->bc_tp, agbp,\n\t\t\t   XFS_AGI_FREE_ROOT | XFS_AGI_FREE_LEVEL);\n}"
  },
  {
    "function_name": "xfs_inobt_set_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "54-66",
    "snippet": "STATIC void\nxfs_inobt_set_root(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*nptr,\n\tint\t\t\tinc)\t/* level change */\n{\n\tstruct xfs_buf\t\t*agbp = cur->bc_private.a.agbp;\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\n\tagi->agi_root = nptr->s;\n\tbe32_add_cpu(&agi->agi_level, inc);\n\txfs_ialloc_log_agi(cur->bc_tp, agbp, XFS_AGI_ROOT | XFS_AGI_LEVEL);\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ialloc_log_agi",
          "args": [
            "cur->bc_tp",
            "agbp",
            "XFS_AGI_ROOT | XFS_AGI_LEVEL"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_log_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "1971-2026",
          "snippet": "void\nxfs_ialloc_log_agi(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t\t/* allocation group header buffer */\n\tint\t\tfields)\t\t/* bitmask of fields to log */\n{\n\tint\t\t\tfirst;\t\t/* first byte number */\n\tint\t\t\tlast;\t\t/* last byte number */\n\tstatic const short\toffsets[] = {\t/* field starting offsets */\n\t\t\t\t\t/* keep in sync with bit definitions */\n\t\toffsetof(xfs_agi_t, agi_magicnum),\n\t\toffsetof(xfs_agi_t, agi_versionnum),\n\t\toffsetof(xfs_agi_t, agi_seqno),\n\t\toffsetof(xfs_agi_t, agi_length),\n\t\toffsetof(xfs_agi_t, agi_count),\n\t\toffsetof(xfs_agi_t, agi_root),\n\t\toffsetof(xfs_agi_t, agi_level),\n\t\toffsetof(xfs_agi_t, agi_freecount),\n\t\toffsetof(xfs_agi_t, agi_newino),\n\t\toffsetof(xfs_agi_t, agi_dirino),\n\t\toffsetof(xfs_agi_t, agi_unlinked),\n\t\toffsetof(xfs_agi_t, agi_free_root),\n\t\toffsetof(xfs_agi_t, agi_free_level),\n\t\tsizeof(xfs_agi_t)\n\t};\n#ifdef DEBUG\n\txfs_agi_t\t\t*agi;\t/* allocation group header */\n\n\tagi = XFS_BUF_TO_AGI(bp);\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n#endif\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGI_BUF);\n\n\t/*\n\t * Compute byte offsets for the first and last fields in the first\n\t * region and log the agi buffer. This only logs up through\n\t * agi_unlinked.\n\t */\n\tif (fields & XFS_AGI_ALL_BITS_R1) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R1,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n\n\t/*\n\t * Mask off the bits in the first region and calculate the first and\n\t * last field offsets for any bits in the second region.\n\t */\n\tfields &= ~XFS_AGI_ALL_BITS_R1;\n\tif (fields) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R2,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ialloc_log_agi(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_buf_t\t*bp,\t\t/* allocation group header buffer */\n\tint\t\tfields)\t\t/* bitmask of fields to log */\n{\n\tint\t\t\tfirst;\t\t/* first byte number */\n\tint\t\t\tlast;\t\t/* last byte number */\n\tstatic const short\toffsets[] = {\t/* field starting offsets */\n\t\t\t\t\t/* keep in sync with bit definitions */\n\t\toffsetof(xfs_agi_t, agi_magicnum),\n\t\toffsetof(xfs_agi_t, agi_versionnum),\n\t\toffsetof(xfs_agi_t, agi_seqno),\n\t\toffsetof(xfs_agi_t, agi_length),\n\t\toffsetof(xfs_agi_t, agi_count),\n\t\toffsetof(xfs_agi_t, agi_root),\n\t\toffsetof(xfs_agi_t, agi_level),\n\t\toffsetof(xfs_agi_t, agi_freecount),\n\t\toffsetof(xfs_agi_t, agi_newino),\n\t\toffsetof(xfs_agi_t, agi_dirino),\n\t\toffsetof(xfs_agi_t, agi_unlinked),\n\t\toffsetof(xfs_agi_t, agi_free_root),\n\t\toffsetof(xfs_agi_t, agi_free_level),\n\t\tsizeof(xfs_agi_t)\n\t};\n#ifdef DEBUG\n\txfs_agi_t\t\t*agi;\t/* allocation group header */\n\n\tagi = XFS_BUF_TO_AGI(bp);\n\tASSERT(agi->agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));\n#endif\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGI_BUF);\n\n\t/*\n\t * Compute byte offsets for the first and last fields in the first\n\t * region and log the agi buffer. This only logs up through\n\t * agi_unlinked.\n\t */\n\tif (fields & XFS_AGI_ALL_BITS_R1) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R1,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n\n\t/*\n\t * Mask off the bits in the first region and calculate the first and\n\t * last field offsets for any bits in the second region.\n\t */\n\tfields &= ~XFS_AGI_ALL_BITS_R1;\n\tif (fields) {\n\t\txfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS_R2,\n\t\t\t\t  &first, &last);\n\t\txfs_trans_log_buf(tp, bp, first, last);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&agi->agi_level",
            "inc"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGI",
          "args": [
            "agbp"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_inobt_set_root(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*nptr,\n\tint\t\t\tinc)\t/* level change */\n{\n\tstruct xfs_buf\t\t*agbp = cur->bc_private.a.agbp;\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\n\tagi->agi_root = nptr->s;\n\tbe32_add_cpu(&agi->agi_level, inc);\n\txfs_ialloc_log_agi(cur->bc_tp, agbp, XFS_AGI_ROOT | XFS_AGI_LEVEL);\n}"
  },
  {
    "function_name": "xfs_inobt_dup_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "45-52",
    "snippet": "xfs_btree_cur *\nxfs_inobt_dup_cursor(\n\tstruct xfs_btree_cur\t*cur)\n{\n\treturn xfs_inobt_init_cursor(cur->bc_mp, cur->bc_tp,\n\t\t\tcur->bc_private.a.agbp, cur->bc_private.a.agno,\n\t\t\tcur->bc_btnum);\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_inobt_init_cursor",
          "args": [
            "cur->bc_mp",
            "cur->bc_tp",
            "cur->bc_private.a.agbp",
            "cur->bc_private.a.agno",
            "cur->bc_btnum"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
          "lines": "371-404",
          "snippet": "struct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};",
            "static const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\nstatic const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nxfs_btree_cur *\nxfs_inobt_dup_cursor(\n\tstruct xfs_btree_cur\t*cur)\n{\n\treturn xfs_inobt_init_cursor(cur->bc_mp, cur->bc_tp,\n\t\t\tcur->bc_private.a.agbp, cur->bc_private.a.agno,\n\t\t\tcur->bc_btnum);\n}"
  },
  {
    "function_name": "xfs_inobt_get_minrecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
    "lines": "37-43",
    "snippet": "STATIC int\nxfs_inobt_get_minrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\treturn cur->bc_mp->m_inobt_mnr[level != 0];\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_inobt_get_minrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\treturn cur->bc_mp->m_inobt_mnr[level != 0];\n}"
  }
]