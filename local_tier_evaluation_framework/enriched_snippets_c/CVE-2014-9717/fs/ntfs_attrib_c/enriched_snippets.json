[
  {
    "function_name": "ntfs_attr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "2493-2612",
    "snippet": "int ntfs_attr_set(ntfs_inode *ni, const s64 ofs, const s64 cnt, const u8 val)\n{\n\tntfs_volume *vol = ni->vol;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tpgoff_t idx, end;\n\tunsigned start_ofs, end_ofs, size;\n\n\tntfs_debug(\"Entering for ofs 0x%llx, cnt 0x%llx, val 0x%hx.\",\n\t\t\t(long long)ofs, (long long)cnt, val);\n\tBUG_ON(ofs < 0);\n\tBUG_ON(cnt < 0);\n\tif (!cnt)\n\t\tgoto done;\n\t/*\n\t * FIXME: Compressed and encrypted attributes are not supported when\n\t * writing and we should never have gotten here for them.\n\t */\n\tBUG_ON(NInoCompressed(ni));\n\tBUG_ON(NInoEncrypted(ni));\n\tmapping = VFS_I(ni)->i_mapping;\n\t/* Work out the starting index and page offset. */\n\tidx = ofs >> PAGE_CACHE_SHIFT;\n\tstart_ofs = ofs & ~PAGE_CACHE_MASK;\n\t/* Work out the ending index and page offset. */\n\tend = ofs + cnt;\n\tend_ofs = end & ~PAGE_CACHE_MASK;\n\t/* If the end is outside the inode size return -ESPIPE. */\n\tif (unlikely(end > i_size_read(VFS_I(ni)))) {\n\t\tntfs_error(vol->sb, \"Request exceeds end of attribute.\");\n\t\treturn -ESPIPE;\n\t}\n\tend >>= PAGE_CACHE_SHIFT;\n\t/* If there is a first partial page, need to do it the slow way. */\n\tif (start_ofs) {\n\t\tpage = read_mapping_page(mapping, idx, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_error(vol->sb, \"Failed to read first partial \"\n\t\t\t\t\t\"page (error, index 0x%lx).\", idx);\n\t\t\treturn PTR_ERR(page);\n\t\t}\n\t\t/*\n\t\t * If the last page is the same as the first page, need to\n\t\t * limit the write to the end offset.\n\t\t */\n\t\tsize = PAGE_CACHE_SIZE;\n\t\tif (idx == end)\n\t\t\tsize = end_ofs;\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr + start_ofs, val, size - start_ofs);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(kaddr);\n\t\tset_page_dirty(page);\n\t\tpage_cache_release(page);\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t\tif (idx == end)\n\t\t\tgoto done;\n\t\tidx++;\n\t}\n\t/* Do the whole pages the fast way. */\n\tfor (; idx < end; idx++) {\n\t\t/* Find or create the current page.  (The page is locked.) */\n\t\tpage = grab_cache_page(mapping, idx);\n\t\tif (unlikely(!page)) {\n\t\t\tntfs_error(vol->sb, \"Insufficient memory to grab \"\n\t\t\t\t\t\"page (index 0x%lx).\", idx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr, val, PAGE_CACHE_SIZE);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(kaddr);\n\t\t/*\n\t\t * If the page has buffers, mark them uptodate since buffer\n\t\t * state and not page state is definitive in 2.6 kernels.\n\t\t */\n\t\tif (page_has_buffers(page)) {\n\t\t\tstruct buffer_head *bh, *head;\n\n\t\t\tbh = head = page_buffers(page);\n\t\t\tdo {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t} while ((bh = bh->b_this_page) != head);\n\t\t}\n\t\t/* Now that buffers are uptodate, set the page uptodate, too. */\n\t\tSetPageUptodate(page);\n\t\t/*\n\t\t * Set the page and all its buffers dirty and mark the inode\n\t\t * dirty, too.  The VM will write the page later on.\n\t\t */\n\t\tset_page_dirty(page);\n\t\t/* Finally unlock and release the page. */\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t}\n\t/* If there is a last partial page, need to do it the slow way. */\n\tif (end_ofs) {\n\t\tpage = read_mapping_page(mapping, idx, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_error(vol->sb, \"Failed to read last partial page \"\n\t\t\t\t\t\"(error, index 0x%lx).\", idx);\n\t\t\treturn PTR_ERR(page);\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr, val, end_ofs);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(kaddr);\n\t\tset_page_dirty(page);\n\t\tpage_cache_release(page);\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t}\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 2610
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_dirty_pages_ratelimited",
          "args": [
            "mapping"
          ],
          "line": 2606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 2604
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 2602
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr",
            "val",
            "end_ofs"
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 2598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to read last partial page \"\n\t\t\t\t\t\"(error, index 0x%lx).\"",
            "idx"
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "idx",
            "NULL"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_dirty_pages_ratelimited",
          "args": [
            "mapping"
          ],
          "line": 2589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2587
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 2580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2576
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 2574
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr",
            "val",
            "PAGE_CACHE_SIZE"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "mapping",
            "idx"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_dirty_pages_ratelimited",
          "args": [
            "mapping"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr + start_ofs",
            "val",
            "size - start_ofs"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "idx",
            "NULL"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Request exceeds end of attribute.\""
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "end > i_size_read(VFS_I(ni))"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "VFS_I(ni)"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ni"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "245-248",
          "snippet": "static inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoEncrypted(ni)"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoEncrypted",
          "args": [
            "ni"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoCompressed(ni)"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cnt < 0"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ofs < 0"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for ofs 0x%llx, cnt 0x%llx, val 0x%hx.\"",
            "(long long)ofs",
            "(long long)cnt",
            "val"
          ],
          "line": 2502
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_set(ntfs_inode *ni, const s64 ofs, const s64 cnt, const u8 val)\n{\n\tntfs_volume *vol = ni->vol;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tpgoff_t idx, end;\n\tunsigned start_ofs, end_ofs, size;\n\n\tntfs_debug(\"Entering for ofs 0x%llx, cnt 0x%llx, val 0x%hx.\",\n\t\t\t(long long)ofs, (long long)cnt, val);\n\tBUG_ON(ofs < 0);\n\tBUG_ON(cnt < 0);\n\tif (!cnt)\n\t\tgoto done;\n\t/*\n\t * FIXME: Compressed and encrypted attributes are not supported when\n\t * writing and we should never have gotten here for them.\n\t */\n\tBUG_ON(NInoCompressed(ni));\n\tBUG_ON(NInoEncrypted(ni));\n\tmapping = VFS_I(ni)->i_mapping;\n\t/* Work out the starting index and page offset. */\n\tidx = ofs >> PAGE_CACHE_SHIFT;\n\tstart_ofs = ofs & ~PAGE_CACHE_MASK;\n\t/* Work out the ending index and page offset. */\n\tend = ofs + cnt;\n\tend_ofs = end & ~PAGE_CACHE_MASK;\n\t/* If the end is outside the inode size return -ESPIPE. */\n\tif (unlikely(end > i_size_read(VFS_I(ni)))) {\n\t\tntfs_error(vol->sb, \"Request exceeds end of attribute.\");\n\t\treturn -ESPIPE;\n\t}\n\tend >>= PAGE_CACHE_SHIFT;\n\t/* If there is a first partial page, need to do it the slow way. */\n\tif (start_ofs) {\n\t\tpage = read_mapping_page(mapping, idx, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_error(vol->sb, \"Failed to read first partial \"\n\t\t\t\t\t\"page (error, index 0x%lx).\", idx);\n\t\t\treturn PTR_ERR(page);\n\t\t}\n\t\t/*\n\t\t * If the last page is the same as the first page, need to\n\t\t * limit the write to the end offset.\n\t\t */\n\t\tsize = PAGE_CACHE_SIZE;\n\t\tif (idx == end)\n\t\t\tsize = end_ofs;\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr + start_ofs, val, size - start_ofs);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(kaddr);\n\t\tset_page_dirty(page);\n\t\tpage_cache_release(page);\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t\tif (idx == end)\n\t\t\tgoto done;\n\t\tidx++;\n\t}\n\t/* Do the whole pages the fast way. */\n\tfor (; idx < end; idx++) {\n\t\t/* Find or create the current page.  (The page is locked.) */\n\t\tpage = grab_cache_page(mapping, idx);\n\t\tif (unlikely(!page)) {\n\t\t\tntfs_error(vol->sb, \"Insufficient memory to grab \"\n\t\t\t\t\t\"page (index 0x%lx).\", idx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr, val, PAGE_CACHE_SIZE);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(kaddr);\n\t\t/*\n\t\t * If the page has buffers, mark them uptodate since buffer\n\t\t * state and not page state is definitive in 2.6 kernels.\n\t\t */\n\t\tif (page_has_buffers(page)) {\n\t\t\tstruct buffer_head *bh, *head;\n\n\t\t\tbh = head = page_buffers(page);\n\t\t\tdo {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t} while ((bh = bh->b_this_page) != head);\n\t\t}\n\t\t/* Now that buffers are uptodate, set the page uptodate, too. */\n\t\tSetPageUptodate(page);\n\t\t/*\n\t\t * Set the page and all its buffers dirty and mark the inode\n\t\t * dirty, too.  The VM will write the page later on.\n\t\t */\n\t\tset_page_dirty(page);\n\t\t/* Finally unlock and release the page. */\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t}\n\t/* If there is a last partial page, need to do it the slow way. */\n\tif (end_ofs) {\n\t\tpage = read_mapping_page(mapping, idx, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tntfs_error(vol->sb, \"Failed to read last partial page \"\n\t\t\t\t\t\"(error, index 0x%lx).\", idx);\n\t\t\treturn PTR_ERR(page);\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr, val, end_ofs);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(kaddr);\n\t\tset_page_dirty(page);\n\t\tpage_cache_release(page);\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t}\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}"
  },
  {
    "function_name": "ntfs_attr_extend_allocation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "1904-2471",
    "snippet": "s64 ntfs_attr_extend_allocation(ntfs_inode *ni, s64 new_alloc_size,\n\t\tconst s64 new_data_size, const s64 data_start)\n{\n\tVCN vcn;\n\ts64 ll, allocated_size, start = data_start;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_volume *vol = ni->vol;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\trunlist_element *rl, *rl2;\n\tunsigned long flags;\n\tint err, mp_size;\n\tu32 attr_len = 0; /* Silence stupid gcc warning. */\n\tbool mp_rebuilt;\n\n#ifdef DEBUG\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tntfs_debug(\"Entering for i_ino 0x%lx, attribute type 0x%x, \"\n\t\t\t\"old_allocated_size 0x%llx, \"\n\t\t\t\"new_allocated_size 0x%llx, new_data_size 0x%llx, \"\n\t\t\t\"data_start 0x%llx.\", vi->i_ino,\n\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t(unsigned long long)allocated_size,\n\t\t\t(unsigned long long)new_alloc_size,\n\t\t\t(unsigned long long)new_data_size,\n\t\t\t(unsigned long long)start);\n#endif\nretry_extend:\n\t/*\n\t * For non-resident attributes, @start and @new_size need to be aligned\n\t * to cluster boundaries for allocation purposes.\n\t */\n\tif (NInoNonResident(ni)) {\n\t\tif (start > 0)\n\t\t\tstart &= ~(s64)vol->cluster_size_mask;\n\t\tnew_alloc_size = (new_alloc_size + vol->cluster_size - 1) &\n\t\t\t\t~(s64)vol->cluster_size_mask;\n\t}\n\tBUG_ON(new_data_size >= 0 && new_data_size > new_alloc_size);\n\t/* Check if new size is allowed in $AttrDef. */\n\terr = ntfs_attr_size_bounds_check(vol, ni->type, new_alloc_size);\n\tif (unlikely(err)) {\n\t\t/* Only emit errors when the write will fail completely. */\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (start < 0 || start >= allocated_size) {\n\t\t\tif (err == -ERANGE) {\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because the new \"\n\t\t\t\t\t\t\"allocation would exceed the \"\n\t\t\t\t\t\t\"maximum allowed size for \"\n\t\t\t\t\t\t\"this attribute type.\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t} else {\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because this \"\n\t\t\t\t\t\t\"attribute type is not \"\n\t\t\t\t\t\t\"defined on the NTFS volume.  \"\n\t\t\t\t\t\t\"Possible corruption!  You \"\n\t\t\t\t\t\t\"should run chkdsk!\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t}\n\t\t}\n\t\t/* Translate error code to be POSIX conformant for write(2). */\n\t\tif (err == -ERANGE)\n\t\t\terr = -EFBIG;\n\t\telse\n\t\t\terr = -EIO;\n\t\treturn err;\n\t}\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t/*\n\t * We will be modifying both the runlist (if non-resident) and the mft\n\t * record so lock them both down.\n\t */\n\tdown_write(&ni->runlist.lock);\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t/*\n\t * If non-resident, seek to the last extent.  If resident, there is\n\t * only one extent, so seek to that.\n\t */\n\tvcn = NInoNonResident(ni) ? allocated_size >> vol->cluster_size_bits :\n\t\t\t0;\n\t/*\n\t * Abort if someone did the work whilst we waited for the locks.  If we\n\t * just converted the attribute from resident to non-resident it is\n\t * likely that exactly this has happened already.  We cannot quite\n\t * abort if we need to update the data size.\n\t */\n\tif (unlikely(new_alloc_size <= allocated_size)) {\n\t\tntfs_debug(\"Allocated size already exceeds requested size.\");\n\t\tnew_alloc_size = allocated_size;\n\t\tif (new_data_size < 0)\n\t\t\tgoto done;\n\t\t/*\n\t\t * We want the first attribute extent so that we can update the\n\t\t * data size.\n\t\t */\n\t\tvcn = 0;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\t/* Use goto to reduce indentation. */\n\tif (a->non_resident)\n\t\tgoto do_non_resident_extend;\n\tBUG_ON(NInoNonResident(ni));\n\t/* The total length of the attribute value. */\n\tattr_len = le32_to_cpu(a->data.resident.value_length);\n\t/*\n\t * Extend the attribute record to be able to store the new attribute\n\t * size.  ntfs_attr_record_resize() will not do anything if the size is\n\t * not changing.\n\t */\n\tif (new_alloc_size < vol->mft_record_size &&\n\t\t\t!ntfs_attr_record_resize(m, a,\n\t\t\tle16_to_cpu(a->data.resident.value_offset) +\n\t\t\tnew_alloc_size)) {\n\t\t/* The resize succeeded! */\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset);\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (new_data_size >= 0) {\n\t\t\tBUG_ON(new_data_size < attr_len);\n\t\t\ta->data.resident.value_length =\n\t\t\t\t\tcpu_to_le32((u32)new_data_size);\n\t\t}\n\t\tgoto flush_done;\n\t}\n\t/*\n\t * We have to drop all the locks so we can call\n\t * ntfs_attr_make_non_resident().  This could be optimised by try-\n\t * locking the first page cache page and only if that fails dropping\n\t * the locks, locking the page, and redoing all the locking and\n\t * lookups.  While this would be a huge optimisation, it is not worth\n\t * it as this is definitely a slow code path.\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\t/*\n\t * Not enough space in the mft record, try to make the attribute\n\t * non-resident and if successful restart the extension process.\n\t */\n\terr = ntfs_attr_make_non_resident(ni, attr_len);\n\tif (likely(!err))\n\t\tgoto retry_extend;\n\t/*\n\t * Could not make non-resident.  If this is due to this not being\n\t * permitted for this attribute type or there not being enough space,\n\t * try to make other attributes non-resident.  Otherwise fail.\n\t */\n\tif (unlikely(err != -EPERM && err != -ENOSPC)) {\n\t\t/* Only emit errors when the write will fail completely. */\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the conversion from resident \"\n\t\t\t\t\t\"to non-resident attribute failed \"\n\t\t\t\t\t\"with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM)\n\t\t\terr = -EIO;\n\t\tgoto conv_err_out;\n\t}\n\t/* TODO: Not implemented from here, abort. */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (start < 0 || start >= allocated_size) {\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record/on disk for the non-resident \"\n\t\t\t\t\t\"attribute value.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\telse /* if (err == -EPERM) */\n\t\t\tntfs_error(vol->sb, \"This attribute type may not be \"\n\t\t\t\t\t\"non-resident.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t}\n\terr = -EOPNOTSUPP;\n\tgoto conv_err_out;\n#if 0\n\t// TODO: Attempt to make other attributes non-resident.\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t/*\n\t * Both the attribute list attribute and the standard information\n\t * attribute must remain in the base inode.  Thus, if this is one of\n\t * these attributes, we have to try to move other attributes out into\n\t * extent mft records instead.\n\t */\n\tif (ni->type == AT_ATTRIBUTE_LIST ||\n\t\t\tni->type == AT_STANDARD_INFORMATION) {\n\t\t// TODO: Attempt to move other attributes into extent mft\n\t\t// records.\n\t\terr = -EOPNOTSUPP;\n\t\tif (!err)\n\t\t\tgoto do_resident_extend;\n\t\tgoto err_out;\n\t}\n\t// TODO: Attempt to move this attribute to an extent mft record, but\n\t// only if it is not already the only attribute in an mft record in\n\t// which case there would be nothing to gain.\n\terr = -EOPNOTSUPP;\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t/* There is nothing we can do to make enough space. )-: */\n\tgoto err_out;\n#endif\ndo_non_resident_extend:\n\tBUG_ON(!NInoNonResident(ni));\n\tif (new_alloc_size == allocated_size) {\n\t\tBUG_ON(vcn);\n\t\tgoto alloc_done;\n\t}\n\t/*\n\t * If the data starts after the end of the old allocation, this is a\n\t * $DATA attribute and sparse attributes are enabled on the volume and\n\t * for this inode, then create a sparse region between the old\n\t * allocated size and the start of the data.  Otherwise simply proceed\n\t * with filling the whole space between the old allocated size and the\n\t * new allocated size with clusters.\n\t */\n\tif ((start >= 0 && start <= allocated_size) || ni->type != AT_DATA ||\n\t\t\t!NVolSparseEnabled(vol) || NInoSparseDisabled(ni))\n\t\tgoto skip_sparse;\n\t// TODO: This is not implemented yet.  We just fill in with real\n\t// clusters for now...\n\tntfs_debug(\"Inserting holes is not-implemented yet.  Falling back to \"\n\t\t\t\"allocating real clusters instead.\");\nskip_sparse:\n\trl = ni->runlist.rl;\n\tif (likely(rl)) {\n\t\t/* Seek to the end of the runlist. */\n\t\twhile (rl->length)\n\t\t\trl++;\n\t}\n\t/* If this attribute extent is not mapped, map it now. */\n\tif (unlikely(!rl || rl->lcn == LCN_RL_NOT_MAPPED ||\n\t\t\t(rl->lcn == LCN_ENOENT && rl > ni->runlist.rl &&\n\t\t\t(rl-1)->lcn == LCN_RL_NOT_MAPPED))) {\n\t\tif (!rl && !allocated_size)\n\t\t\tgoto first_alloc;\n\t\trl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tif (start < 0 || start >= allocated_size)\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because the \"\n\t\t\t\t\t\t\"mapping of a runlist \"\n\t\t\t\t\t\t\"fragment failed with error \"\n\t\t\t\t\t\t\"code %i.\", vi->i_ino,\n\t\t\t\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t\t\t\terr);\n\t\t\tif (err != -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tni->runlist.rl = rl;\n\t\t/* Seek to the end of the runlist. */\n\t\twhile (rl->length)\n\t\t\trl++;\n\t}\n\t/*\n\t * We now know the runlist of the last extent is mapped and @rl is at\n\t * the end of the runlist.  We want to begin allocating clusters\n\t * starting at the last allocated cluster to reduce fragmentation.  If\n\t * there are no valid LCNs in the attribute we let the cluster\n\t * allocator choose the starting cluster.\n\t */\n\t/* If the last LCN is a hole or simillar seek back to last real LCN. */\n\twhile (rl->lcn < 0 && rl > ni->runlist.rl)\n\t\trl--;\nfirst_alloc:\n\t// FIXME: Need to implement partial allocations so at least part of the\n\t// write can be performed when start >= 0.  (Needed for POSIX write(2)\n\t// conformance.)\n\trl2 = ntfs_cluster_alloc(vol, allocated_size >> vol->cluster_size_bits,\n\t\t\t(new_alloc_size - allocated_size) >>\n\t\t\tvol->cluster_size_bits, (rl && (rl->lcn >= 0)) ?\n\t\t\trl->lcn + rl->length : -1, DATA_ZONE, true);\n\tif (IS_ERR(rl2)) {\n\t\terr = PTR_ERR(rl2);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the allocation of clusters \"\n\t\t\t\t\t\"failed with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM && err != -ENOSPC)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_runlists_merge(ni->runlist.rl, rl2);\n\tif (IS_ERR(rl)) {\n\t\terr = PTR_ERR(rl);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the runlist merge failed \"\n\t\t\t\t\t\"with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM)\n\t\t\terr = -EIO;\n\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\tntfs_error(vol->sb, \"Failed to release allocated \"\n\t\t\t\t\t\"cluster(s) in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover the lost \"\n\t\t\t\t\t\"cluster(s).\");\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl2);\n\t\tgoto err_out;\n\t}\n\tni->runlist.rl = rl;\n\tntfs_debug(\"Allocated 0x%llx clusters.\", (long long)(new_alloc_size -\n\t\t\tallocated_size) >> vol->cluster_size_bits);\n\t/* Find the runlist element with which the attribute extent starts. */\n\tll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\trl2 = ntfs_rl_find_vcn_nolock(rl, ll);\n\tBUG_ON(!rl2);\n\tBUG_ON(!rl2->length);\n\tBUG_ON(rl2->lcn < LCN_HOLE);\n\tmp_rebuilt = false;\n\t/* Get the size for the new mapping pairs array for this extent. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\terr = mp_size;\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because determining the size for the \"\n\t\t\t\t\t\"mapping pairs failed with error code \"\n\t\t\t\t\t\"%i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\terr = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Extend the attribute record to fit the bigger mapping pairs array. */\n\tattr_len = le32_to_cpu(a->length);\n\terr = ntfs_attr_record_resize(m, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tif (unlikely(err)) {\n\t\tBUG_ON(err != -ENOSPC);\n\t\t// TODO: Deal with this by moving this extent to a new mft\n\t\t// record or by starting a new extent in a new mft record,\n\t\t// possibly by extending this extent partially and filling it\n\t\t// and creating a new extent for the remainder, or by making\n\t\t// other attributes non-resident and/or by moving other\n\t\t// attributes out of this mft record.\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record for the extended attribute \"\n\t\t\t\t\t\"record.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto undo_alloc;\n\t}\n\tmp_rebuilt = true;\n\t/* Generate the mapping pairs array directly into the attr record. */\n\terr = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, rl2, ll, -1, NULL);\n\tif (unlikely(err)) {\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because building the mapping pairs \"\n\t\t\t\t\t\"failed with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\terr = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Update the highest_vcn. */\n\ta->data.non_resident.highest_vcn = cpu_to_sle64((new_alloc_size >>\n\t\t\tvol->cluster_size_bits) - 1);\n\t/*\n\t * We now have extended the allocated size of the attribute.  Reflect\n\t * this in the ntfs_inode structure and the attribute record.\n\t */\n\tif (a->data.non_resident.lowest_vcn) {\n\t\t/*\n\t\t * We are not in the first attribute extent, switch to it, but\n\t\t * first ensure the changes will make it to disk later.\n\t\t */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err))\n\t\t\tgoto restore_undo_alloc;\n\t\t/* @m is not used any more so no need to set it. */\n\t\ta = ctx->attr;\n\t}\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = new_alloc_size;\n\ta->data.non_resident.allocated_size = cpu_to_sle64(new_alloc_size);\n\t/*\n\t * FIXME: This would fail if @ni is a directory, $MFT, or an index,\n\t * since those can have sparse/compressed set.  For example can be\n\t * set compressed even though it is not compressed itself and in that\n\t * case the bit means that files are to be created compressed in the\n\t * directory...  At present this is ok as this code is only called for\n\t * regular files, and only for their $DATA attribute(s).\n\t * FIXME: The calculation is wrong if we created a hole above.  For now\n\t * it does not matter as we never create holes.\n\t */\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\tni->itype.compressed.size += new_alloc_size - allocated_size;\n\t\ta->data.non_resident.compressed_size =\n\t\t\t\tcpu_to_sle64(ni->itype.compressed.size);\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t} else\n\t\tvi->i_blocks = new_alloc_size >> 9;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\nalloc_done:\n\tif (new_data_size >= 0) {\n\t\tBUG_ON(new_data_size <\n\t\t\t\tsle64_to_cpu(a->data.non_resident.data_size));\n\t\ta->data.non_resident.data_size = cpu_to_sle64(new_data_size);\n\t}\nflush_done:\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\ndone:\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\tntfs_debug(\"Done, new_allocated_size 0x%llx.\",\n\t\t\t(unsigned long long)new_alloc_size);\n\treturn new_alloc_size;\nrestore_undo_alloc:\n\tif (start < 0 || start >= allocated_size)\n\t\tntfs_error(vol->sb, \"Cannot complete extension of allocation \"\n\t\t\t\t\"of inode 0x%lx, attribute type 0x%x, because \"\n\t\t\t\t\"lookup of first attribute extent failed with \"\n\t\t\t\t\"error code %i.\", vi->i_ino,\n\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\tif (err == -ENOENT)\n\t\terr = -EIO;\n\tntfs_attr_reinit_search_ctx(ctx);\n\tif (ntfs_attr_lookup(ni->type, ni->name, ni->name_len, CASE_SENSITIVE,\n\t\t\tallocated_size >> vol->cluster_size_bits, NULL, 0,\n\t\t\tctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"attribute in error code path.  Run chkdsk to \"\n\t\t\t\t\"recover.\");\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->allocated_size = new_alloc_size;\n\t\t/*\n\t\t * FIXME: This would fail if @ni is a directory...  See above.\n\t\t * FIXME: The calculation is wrong if we created a hole above.\n\t\t * For now it does not matter as we never create holes.\n\t\t */\n\t\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\t\tni->itype.compressed.size += new_alloc_size -\n\t\t\t\t\tallocated_size;\n\t\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t\t} else\n\t\t\tvi->i_blocks = new_alloc_size >> 9;\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t\tup_write(&ni->runlist.lock);\n\t\t/*\n\t\t * The only thing that is now wrong is the allocated size of the\n\t\t * base attribute extent which chkdsk should be able to fix.\n\t\t */\n\t\tNVolSetErrors(vol);\n\t\treturn err;\n\t}\n\tctx->attr->data.non_resident.highest_vcn = cpu_to_sle64(\n\t\t\t(allocated_size >> vol->cluster_size_bits) - 1);\nundo_alloc:\n\tll = allocated_size >> vol->cluster_size_bits;\n\tif (ntfs_cluster_free(ni, ll, -1, ctx) < 0) {\n\t\tntfs_error(vol->sb, \"Failed to release allocated cluster(s) \"\n\t\t\t\t\"in error code path.  Run chkdsk to recover \"\n\t\t\t\t\"the lost cluster(s).\");\n\t\tNVolSetErrors(vol);\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\t/*\n\t * If the runlist truncation fails and/or the search context is no\n\t * longer valid, we cannot resize the attribute record or build the\n\t * mapping pairs array thus we mark the inode bad so that no access to\n\t * the freed clusters can happen.\n\t */\n\tif (ntfs_rl_truncate_nolock(vol, &ni->runlist, ll) || IS_ERR(m)) {\n\t\tntfs_error(vol->sb, \"Failed to %s in error code path.  Run \"\n\t\t\t\t\"chkdsk to recover.\", IS_ERR(m) ?\n\t\t\t\t\"restore attribute search context\" :\n\t\t\t\t\"truncate attribute runlist\");\n\t\tNVolSetErrors(vol);\n\t} else if (mp_rebuilt) {\n\t\tif (ntfs_attr_record_resize(m, a, attr_len)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover.\");\n\t\t\tNVolSetErrors(vol);\n\t\t} else /* if (success) */ {\n\t\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), attr_len -\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), rl2, ll, -1,\n\t\t\t\t\tNULL)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to restore \"\n\t\t\t\t\t\t\"mapping pairs array in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t}\n\t}\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\nconv_err_out:\n\tntfs_debug(\"Failed.  Returning error code %i.\", err);\n\treturn err;\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Failed.  Returning error code %i.\"",
            "err"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "base_ni"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 2464
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_mft_record_dirty",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_mft_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "395-410",
          "snippet": "void __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_mft_record_page",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 2458
        },
        "resolved": true,
        "details": {
          "function_name": "flush_dcache_mft_record_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "55-58",
          "snippet": "static inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to restore \"\n\t\t\t\t\t\t\"mapping pairs array in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover.\""
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_mapping_pairs_build",
          "args": [
            "vol",
            "(u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset)",
            "attr_len -\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset)",
            "rl2",
            "ll",
            "-1",
            "NULL"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_mapping_pairs_build",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1323-1473",
          "snippet": "int ntfs_mapping_pairs_build(const ntfs_volume *vol, s8 *dst,\n\t\tconst int dst_len, const runlist_element *rl,\n\t\tconst VCN first_vcn, const VCN last_vcn, VCN *const stop_vcn)\n{\n\tLCN prev_lcn;\n\ts8 *dst_max, *dst_next;\n\tint err = -ENOSPC;\n\tbool the_end = false;\n\ts8 len_len, lcn_len;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tBUG_ON(dst_len < 1);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\tif (stop_vcn)\n\t\t\t*stop_vcn = 0;\n\t\t/* Terminator byte. */\n\t\t*dst = 0;\n\t\treturn 0;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\t/*\n\t * @dst_max is used for bounds checking in\n\t * ntfs_write_significant_bytes().\n\t */\n\tdst_max = dst + dst_len - 1;\n\tprev_lcn = 0;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength - delta);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, rl->lcn - prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t\tprev_lcn = rl->lcn;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t}\n\t/* Success. */\n\terr = 0;\nsize_err:\n\t/* Set stop vcn. */\n\tif (stop_vcn)\n\t\t*stop_vcn = rl->vcn;\n\t/* Add terminator byte. */\n\t*dst = 0;\n\treturn err;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\terr = -EINVAL;\n\telse\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_mapping_pairs_build(const ntfs_volume *vol, s8 *dst,\n\t\tconst int dst_len, const runlist_element *rl,\n\t\tconst VCN first_vcn, const VCN last_vcn, VCN *const stop_vcn)\n{\n\tLCN prev_lcn;\n\ts8 *dst_max, *dst_next;\n\tint err = -ENOSPC;\n\tbool the_end = false;\n\ts8 len_len, lcn_len;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tBUG_ON(dst_len < 1);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\tif (stop_vcn)\n\t\t\t*stop_vcn = 0;\n\t\t/* Terminator byte. */\n\t\t*dst = 0;\n\t\treturn 0;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\t/*\n\t * @dst_max is used for bounds checking in\n\t * ntfs_write_significant_bytes().\n\t */\n\tdst_max = dst + dst_len - 1;\n\tprev_lcn = 0;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength - delta);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, rl->lcn - prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t\tprev_lcn = rl->lcn;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t}\n\t/* Success. */\n\terr = 0;\nsize_err:\n\t/* Set stop vcn. */\n\tif (stop_vcn)\n\t\t*stop_vcn = rl->vcn;\n\t/* Add terminator byte. */\n\t*dst = 0;\n\treturn err;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\terr = -EINVAL;\n\telse\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to restore attribute \"\n\t\t\t\t\t\"record in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover.\""
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_record_resize",
          "args": [
            "m",
            "a",
            "attr_len"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_record_resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1435-1459",
          "snippet": "int ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)\n{\n\tntfs_debug(\"Entering for new_size %u.\", new_size);\n\t/* Align to 8 bytes if it is not already done. */\n\tif (new_size & 7)\n\t\tnew_size = (new_size + 7) & ~7;\n\t/* If the actual attribute length has changed, move things around. */\n\tif (new_size != le32_to_cpu(a->length)) {\n\t\tu32 new_muse = le32_to_cpu(m->bytes_in_use) -\n\t\t\t\tle32_to_cpu(a->length) + new_size;\n\t\t/* Not enough space in this mft record. */\n\t\tif (new_muse > le32_to_cpu(m->bytes_allocated))\n\t\t\treturn -ENOSPC;\n\t\t/* Move attributes following @a to their new location. */\n\t\tmemmove((u8*)a + new_size, (u8*)a + le32_to_cpu(a->length),\n\t\t\t\tle32_to_cpu(m->bytes_in_use) - ((u8*)a -\n\t\t\t\t(u8*)m) - le32_to_cpu(a->length));\n\t\t/* Adjust @m to reflect the change in used space. */\n\t\tm->bytes_in_use = cpu_to_le32(new_muse);\n\t\t/* Adjust @a to reflect the new size. */\n\t\tif (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))\n\t\t\ta->length = cpu_to_le32(new_size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)\n{\n\tntfs_debug(\"Entering for new_size %u.\", new_size);\n\t/* Align to 8 bytes if it is not already done. */\n\tif (new_size & 7)\n\t\tnew_size = (new_size + 7) & ~7;\n\t/* If the actual attribute length has changed, move things around. */\n\tif (new_size != le32_to_cpu(a->length)) {\n\t\tu32 new_muse = le32_to_cpu(m->bytes_in_use) -\n\t\t\t\tle32_to_cpu(a->length) + new_size;\n\t\t/* Not enough space in this mft record. */\n\t\tif (new_muse > le32_to_cpu(m->bytes_allocated))\n\t\t\treturn -ENOSPC;\n\t\t/* Move attributes following @a to their new location. */\n\t\tmemmove((u8*)a + new_size, (u8*)a + le32_to_cpu(a->length),\n\t\t\t\tle32_to_cpu(m->bytes_in_use) - ((u8*)a -\n\t\t\t\t(u8*)m) - le32_to_cpu(a->length));\n\t\t/* Adjust @m to reflect the change in used space. */\n\t\tm->bytes_in_use = cpu_to_le32(new_muse);\n\t\t/* Adjust @a to reflect the new size. */\n\t\tif (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))\n\t\t\ta->length = cpu_to_le32(new_size);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to %s in error code path.  Run \"\n\t\t\t\t\"chkdsk to recover.\"",
            "IS_ERR(m) ?\n\t\t\t\t\"restore attribute search context\" :\n\t\t\t\t\"truncate attribute runlist\""
          ],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_truncate_nolock",
          "args": [
            "vol",
            "&ni->runlist",
            "ll"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_truncate_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1499-1621",
          "snippet": "int ntfs_rl_truncate_nolock(const ntfs_volume *vol, runlist *const runlist,\n\t\tconst s64 new_length)\n{\n\trunlist_element *rl;\n\tint old_size;\n\n\tntfs_debug(\"Entering for new_length 0x%llx.\", (long long)new_length);\n\tBUG_ON(!runlist);\n\tBUG_ON(new_length < 0);\n\trl = runlist->rl;\n\tif (!new_length) {\n\t\tntfs_debug(\"Freeing runlist.\");\n\t\trunlist->rl = NULL;\n\t\tif (rl)\n\t\t\tntfs_free(rl);\n\t\treturn 0;\n\t}\n\tif (unlikely(!rl)) {\n\t\t/*\n\t\t * Create a runlist consisting of a sparse runlist element of\n\t\t * length @new_length followed by a terminator runlist element.\n\t\t */\n\t\trl = ntfs_malloc_nofs(PAGE_SIZE);\n\t\tif (unlikely(!rl)) {\n\t\t\tntfs_error(vol->sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"runlist element buffer.\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trunlist->rl = rl;\n\t\trl[1].length = rl->vcn = 0;\n\t\trl->lcn = LCN_HOLE;\n\t\trl[1].vcn = rl->length = new_length;\n\t\trl[1].lcn = LCN_ENOENT;\n\t\treturn 0;\n\t}\n\tBUG_ON(new_length < rl->vcn);\n\t/* Find @new_length in the runlist. */\n\twhile (likely(rl->length && new_length >= rl[1].vcn))\n\t\trl++;\n\t/*\n\t * If not at the end of the runlist we need to shrink it.\n\t * If at the end of the runlist we need to expand it.\n\t */\n\tif (rl->length) {\n\t\trunlist_element *trl;\n\t\tbool is_end;\n\n\t\tntfs_debug(\"Shrinking runlist.\");\n\t\t/* Determine the runlist size. */\n\t\ttrl = rl + 1;\n\t\twhile (likely(trl->length))\n\t\t\ttrl++;\n\t\told_size = trl - runlist->rl + 1;\n\t\t/* Truncate the run. */\n\t\trl->length = new_length - rl->vcn;\n\t\t/*\n\t\t * If a run was partially truncated, make the following runlist\n\t\t * element a terminator.\n\t\t */\n\t\tis_end = false;\n\t\tif (rl->length) {\n\t\t\trl++;\n\t\t\tif (!rl->length)\n\t\t\t\tis_end = true;\n\t\t\trl->vcn = new_length;\n\t\t\trl->length = 0;\n\t\t}\n\t\trl->lcn = LCN_ENOENT;\n\t\t/* Reallocate memory if necessary. */\n\t\tif (!is_end) {\n\t\t\tint new_size = rl - runlist->rl + 1;\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size, new_size);\n\t\t\tif (IS_ERR(rl))\n\t\t\t\tntfs_warning(vol->sb, \"Failed to shrink \"\n\t\t\t\t\t\t\"runlist buffer.  This just \"\n\t\t\t\t\t\t\"wastes a bit of memory \"\n\t\t\t\t\t\t\"temporarily so we ignore it \"\n\t\t\t\t\t\t\"and return success.\");\n\t\t\telse\n\t\t\t\trunlist->rl = rl;\n\t\t}\n\t} else if (likely(/* !rl->length && */ new_length > rl->vcn)) {\n\t\tntfs_debug(\"Expanding runlist.\");\n\t\t/*\n\t\t * If there is a previous runlist element and it is a sparse\n\t\t * one, extend it.  Otherwise need to add a new, sparse runlist\n\t\t * element.\n\t\t */\n\t\tif ((rl > runlist->rl) && ((rl - 1)->lcn == LCN_HOLE))\n\t\t\t(rl - 1)->length = new_length - (rl - 1)->vcn;\n\t\telse {\n\t\t\t/* Determine the runlist size. */\n\t\t\told_size = rl - runlist->rl + 1;\n\t\t\t/* Reallocate memory if necessary. */\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size,\n\t\t\t\t\told_size + 1);\n\t\t\tif (IS_ERR(rl)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to expand runlist \"\n\t\t\t\t\t\t\"buffer, aborting.\");\n\t\t\t\treturn PTR_ERR(rl);\n\t\t\t}\n\t\t\trunlist->rl = rl;\n\t\t\t/*\n\t\t\t * Set @rl to the same runlist element in the new\n\t\t\t * runlist as before in the old runlist.\n\t\t\t */\n\t\t\trl += old_size - 1;\n\t\t\t/* Add a new, sparse runlist element. */\n\t\t\trl->lcn = LCN_HOLE;\n\t\t\trl->length = new_length - rl->vcn;\n\t\t\t/* Add a new terminator runlist element. */\n\t\t\trl++;\n\t\t\trl->length = 0;\n\t\t}\n\t\trl->vcn = new_length;\n\t\trl->lcn = LCN_ENOENT;\n\t} else /* if (unlikely(!rl->length && new_length == rl->vcn)) */ {\n\t\t/* Runlist already has same size as requested. */\n\t\trl->lcn = LCN_ENOENT;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_rl_truncate_nolock(const ntfs_volume *vol, runlist *const runlist,\n\t\tconst s64 new_length)\n{\n\trunlist_element *rl;\n\tint old_size;\n\n\tntfs_debug(\"Entering for new_length 0x%llx.\", (long long)new_length);\n\tBUG_ON(!runlist);\n\tBUG_ON(new_length < 0);\n\trl = runlist->rl;\n\tif (!new_length) {\n\t\tntfs_debug(\"Freeing runlist.\");\n\t\trunlist->rl = NULL;\n\t\tif (rl)\n\t\t\tntfs_free(rl);\n\t\treturn 0;\n\t}\n\tif (unlikely(!rl)) {\n\t\t/*\n\t\t * Create a runlist consisting of a sparse runlist element of\n\t\t * length @new_length followed by a terminator runlist element.\n\t\t */\n\t\trl = ntfs_malloc_nofs(PAGE_SIZE);\n\t\tif (unlikely(!rl)) {\n\t\t\tntfs_error(vol->sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"runlist element buffer.\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trunlist->rl = rl;\n\t\trl[1].length = rl->vcn = 0;\n\t\trl->lcn = LCN_HOLE;\n\t\trl[1].vcn = rl->length = new_length;\n\t\trl[1].lcn = LCN_ENOENT;\n\t\treturn 0;\n\t}\n\tBUG_ON(new_length < rl->vcn);\n\t/* Find @new_length in the runlist. */\n\twhile (likely(rl->length && new_length >= rl[1].vcn))\n\t\trl++;\n\t/*\n\t * If not at the end of the runlist we need to shrink it.\n\t * If at the end of the runlist we need to expand it.\n\t */\n\tif (rl->length) {\n\t\trunlist_element *trl;\n\t\tbool is_end;\n\n\t\tntfs_debug(\"Shrinking runlist.\");\n\t\t/* Determine the runlist size. */\n\t\ttrl = rl + 1;\n\t\twhile (likely(trl->length))\n\t\t\ttrl++;\n\t\told_size = trl - runlist->rl + 1;\n\t\t/* Truncate the run. */\n\t\trl->length = new_length - rl->vcn;\n\t\t/*\n\t\t * If a run was partially truncated, make the following runlist\n\t\t * element a terminator.\n\t\t */\n\t\tis_end = false;\n\t\tif (rl->length) {\n\t\t\trl++;\n\t\t\tif (!rl->length)\n\t\t\t\tis_end = true;\n\t\t\trl->vcn = new_length;\n\t\t\trl->length = 0;\n\t\t}\n\t\trl->lcn = LCN_ENOENT;\n\t\t/* Reallocate memory if necessary. */\n\t\tif (!is_end) {\n\t\t\tint new_size = rl - runlist->rl + 1;\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size, new_size);\n\t\t\tif (IS_ERR(rl))\n\t\t\t\tntfs_warning(vol->sb, \"Failed to shrink \"\n\t\t\t\t\t\t\"runlist buffer.  This just \"\n\t\t\t\t\t\t\"wastes a bit of memory \"\n\t\t\t\t\t\t\"temporarily so we ignore it \"\n\t\t\t\t\t\t\"and return success.\");\n\t\t\telse\n\t\t\t\trunlist->rl = rl;\n\t\t}\n\t} else if (likely(/* !rl->length && */ new_length > rl->vcn)) {\n\t\tntfs_debug(\"Expanding runlist.\");\n\t\t/*\n\t\t * If there is a previous runlist element and it is a sparse\n\t\t * one, extend it.  Otherwise need to add a new, sparse runlist\n\t\t * element.\n\t\t */\n\t\tif ((rl > runlist->rl) && ((rl - 1)->lcn == LCN_HOLE))\n\t\t\t(rl - 1)->length = new_length - (rl - 1)->vcn;\n\t\telse {\n\t\t\t/* Determine the runlist size. */\n\t\t\told_size = rl - runlist->rl + 1;\n\t\t\t/* Reallocate memory if necessary. */\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size,\n\t\t\t\t\told_size + 1);\n\t\t\tif (IS_ERR(rl)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to expand runlist \"\n\t\t\t\t\t\t\"buffer, aborting.\");\n\t\t\t\treturn PTR_ERR(rl);\n\t\t\t}\n\t\t\trunlist->rl = rl;\n\t\t\t/*\n\t\t\t * Set @rl to the same runlist element in the new\n\t\t\t * runlist as before in the old runlist.\n\t\t\t */\n\t\t\trl += old_size - 1;\n\t\t\t/* Add a new, sparse runlist element. */\n\t\t\trl->lcn = LCN_HOLE;\n\t\t\trl->length = new_length - rl->vcn;\n\t\t\t/* Add a new terminator runlist element. */\n\t\t\trl++;\n\t\t\trl->length = 0;\n\t\t}\n\t\trl->vcn = new_length;\n\t\trl->lcn = LCN_ENOENT;\n\t} else /* if (unlikely(!rl->length && new_length == rl->vcn)) */ {\n\t\t/* Runlist already has same size as requested. */\n\t\trl->lcn = LCN_ENOENT;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to release allocated cluster(s) \"\n\t\t\t\t\"in error code path.  Run chkdsk to recover \"\n\t\t\t\t\"the lost cluster(s).\""
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_cluster_free",
          "args": [
            "ni",
            "ll",
            "-1",
            "ctx"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_cluster_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.h",
          "lines": "107-111",
          "snippet": "static inline s64 ntfs_cluster_free(ntfs_inode *ni, const VCN start_vcn,\n\t\ts64 count, ntfs_attr_search_ctx *ctx)\n{\n\treturn __ntfs_cluster_free(ni, start_vcn, count, ctx, false);\n}",
          "includes": [
            "#include \"volume.h\"",
            "#include \"runlist.h\"",
            "#include \"inode.h\"",
            "#include \"types.h\"",
            "#include \"attrib.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volume.h\"\n#include \"runlist.h\"\n#include \"inode.h\"\n#include \"types.h\"\n#include \"attrib.h\"\n#include <linux/fs.h>\n\nstatic inline s64 ntfs_cluster_free(ntfs_inode *ni, const VCN start_vcn,\n\t\ts64 count, ntfs_attr_search_ctx *ctx)\n{\n\treturn __ntfs_cluster_free(ni, start_vcn, count, ctx, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_sle64",
          "args": [
            "(allocated_size >> vol->cluster_size_bits) - 1"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_sle64p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "88-91",
          "snippet": "static inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSparse",
          "args": [
            "ni"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to find last attribute extent of \"\n\t\t\t\t\"attribute in error code path.  Run chkdsk to \"\n\t\t\t\t\"recover.\""
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "ni->type",
            "ni->name",
            "ni->name_len",
            "CASE_SENSITIVE",
            "allocated_size >> vol->cluster_size_bits",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 2385
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_reinit_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_reinit_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1240-1259",
          "snippet": "void ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ni->type"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done, new_allocated_size 0x%llx.\"",
            "(unsigned long long)new_alloc_size"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "new_data_size <\n\t\t\t\tsle64_to_cpu(a->data.non_resident.data_size)"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "a->data.non_resident.data_size"
          ],
          "line": 2361
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSparse",
          "args": [
            "ni"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Not enough space in the mft \"\n\t\t\t\t\t\"record for the extended attribute \"\n\t\t\t\t\t\"record.  This case is not \"\n\t\t\t\t\t\"implemented yet.\""
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err != -ENOSPC"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mp_size <= 0"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_get_size_for_mapping_pairs",
          "args": [
            "vol",
            "rl2",
            "ll",
            "-1"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_get_size_for_mapping_pairs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1131-1232",
          "snippet": "int ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,\n\t\tconst runlist_element *rl, const VCN first_vcn,\n\t\tconst VCN last_vcn)\n{\n\tLCN prev_lcn;\n\tint rls;\n\tbool the_end = false;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\treturn 1;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\tprev_lcn = 0;\n\t/* Always need the termining zero byte. */\n\trls = 1;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length - delta);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(prev_lcn);\n\t\t}\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(rl->lcn -\n\t\t\t\t\tprev_lcn);\n\t\t\tprev_lcn = rl->lcn;\n\t\t}\n\t}\n\treturn rls;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\trls = -EINVAL;\n\telse\n\t\trls = -EIO;\n\treturn rls;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,\n\t\tconst runlist_element *rl, const VCN first_vcn,\n\t\tconst VCN last_vcn)\n{\n\tLCN prev_lcn;\n\tint rls;\n\tbool the_end = false;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\treturn 1;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\tprev_lcn = 0;\n\t/* Always need the termining zero byte. */\n\trls = 1;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length - delta);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(prev_lcn);\n\t\t}\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(rl->lcn -\n\t\t\t\t\tprev_lcn);\n\t\t\tprev_lcn = rl->lcn;\n\t\t}\n\t}\n\treturn rls;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\trls = -EINVAL;\n\telse\n\t\trls = -EIO;\n\treturn rls;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rl2->lcn < LCN_HOLE"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!rl2->length"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!rl2"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_find_vcn_nolock",
          "args": [
            "rl",
            "ll"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_find_vcn_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1053-1069",
          "snippet": "runlist_element *ntfs_rl_find_vcn_nolock(runlist_element *rl, const VCN vcn)\n{\n\tBUG_ON(vcn < 0);\n\tif (unlikely(!rl || vcn < rl[0].vcn))\n\t\treturn NULL;\n\twhile (likely(rl->length)) {\n\t\tif (unlikely(vcn < rl[1].vcn)) {\n\t\t\tif (likely(rl->lcn >= LCN_HOLE))\n\t\t\t\treturn rl;\n\t\t\treturn NULL;\n\t\t}\n\t\trl++;\n\t}\n\tif (likely(rl->lcn == LCN_ENOENT))\n\t\treturn rl;\n\treturn NULL;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nrunlist_element *ntfs_rl_find_vcn_nolock(runlist_element *rl, const VCN vcn)\n{\n\tBUG_ON(vcn < 0);\n\tif (unlikely(!rl || vcn < rl[0].vcn))\n\t\treturn NULL;\n\twhile (likely(rl->length)) {\n\t\tif (unlikely(vcn < rl[1].vcn)) {\n\t\t\tif (likely(rl->lcn >= LCN_HOLE))\n\t\t\t\treturn rl;\n\t\t\treturn NULL;\n\t\t}\n\t\trl++;\n\t}\n\tif (likely(rl->lcn == LCN_ENOENT))\n\t\treturn rl;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Allocated 0x%llx clusters.\"",
            "(long long)(new_alloc_size -\n\t\t\tallocated_size) >> vol->cluster_size_bits"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "rl2"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to release allocated \"\n\t\t\t\t\t\"cluster(s) in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover the lost \"\n\t\t\t\t\t\"cluster(s).\""
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_cluster_free_from_rl",
          "args": [
            "vol",
            "rl2"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_cluster_free_from_rl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.h",
          "lines": "132-141",
          "snippet": "static inline int ntfs_cluster_free_from_rl(ntfs_volume *vol,\n\t\tconst runlist_element *rl)\n{\n\tint ret;\n\n\tdown_write(&vol->lcnbmp_lock);\n\tret = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"volume.h\"",
            "#include \"runlist.h\"",
            "#include \"inode.h\"",
            "#include \"types.h\"",
            "#include \"attrib.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volume.h\"\n#include \"runlist.h\"\n#include \"inode.h\"\n#include \"types.h\"\n#include \"attrib.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_cluster_free_from_rl(ntfs_volume *vol,\n\t\tconst runlist_element *rl)\n{\n\tint ret;\n\n\tdown_write(&vol->lcnbmp_lock);\n\tret = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rl"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_runlists_merge",
          "args": [
            "ni->runlist.rl",
            "rl2"
          ],
          "line": 2235
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_runlists_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "531-719",
          "snippet": "runlist_element *ntfs_runlists_merge(runlist_element *drl,\n\t\trunlist_element *srl)\n{\n\tint di, si;\t\t/* Current index into @[ds]rl. */\n\tint sstart;\t\t/* First index with lcn > LCN_RL_NOT_MAPPED. */\n\tint dins;\t\t/* Index into @drl at which to insert @srl. */\n\tint dend, send;\t\t/* Last index into @[ds]rl. */\n\tint dfinal, sfinal;\t/* The last index into @[ds]rl with\n\t\t\t\t   lcn >= LCN_HOLE. */\n\tint marker = 0;\n\tVCN marker_vcn = 0;\n\n#ifdef DEBUG\n\tntfs_debug(\"dst:\");\n\tntfs_debug_dump_runlist(drl);\n\tntfs_debug(\"src:\");\n\tntfs_debug_dump_runlist(srl);\n#endif\n\n\t/* Check for silly calling... */\n\tif (unlikely(!srl))\n\t\treturn drl;\n\tif (IS_ERR(srl) || IS_ERR(drl))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Check for the case where the first mapping is being done now. */\n\tif (unlikely(!drl)) {\n\t\tdrl = srl;\n\t\t/* Complete the source runlist if necessary. */\n\t\tif (unlikely(drl[0].vcn)) {\n\t\t\t/* Scan to the end of the source runlist. */\n\t\t\tfor (dend = 0; likely(drl[dend].length); dend++)\n\t\t\t\t;\n\t\t\tdend++;\n\t\t\tdrl = ntfs_rl_realloc(drl, dend, dend + 1);\n\t\t\tif (IS_ERR(drl))\n\t\t\t\treturn drl;\n\t\t\t/* Insert start element at the front of the runlist. */\n\t\t\tntfs_rl_mm(drl, 1, 0, dend);\n\t\t\tdrl[0].vcn = 0;\n\t\t\tdrl[0].lcn = LCN_RL_NOT_MAPPED;\n\t\t\tdrl[0].length = drl[1].vcn;\n\t\t}\n\t\tgoto finished;\n\t}\n\n\tsi = di = 0;\n\n\t/* Skip any unmapped start element(s) in the source runlist. */\n\twhile (srl[si].length && srl[si].lcn < LCN_HOLE)\n\t\tsi++;\n\n\t/* Can't have an entirely unmapped source runlist. */\n\tBUG_ON(!srl[si].length);\n\n\t/* Record the starting points. */\n\tsstart = si;\n\n\t/*\n\t * Skip forward in @drl until we reach the position where @srl needs to\n\t * be inserted. If we reach the end of @drl, @srl just needs to be\n\t * appended to @drl.\n\t */\n\tfor (; drl[di].length; di++) {\n\t\tif (drl[di].vcn + drl[di].length > srl[sstart].vcn)\n\t\t\tbreak;\n\t}\n\tdins = di;\n\n\t/* Sanity check for illegal overlaps. */\n\tif ((drl[di].vcn == srl[si].vcn) && (drl[di].lcn >= 0) &&\n\t\t\t(srl[si].lcn >= 0)) {\n\t\tntfs_error(NULL, \"Run lists overlap. Cannot merge!\");\n\t\treturn ERR_PTR(-ERANGE);\n\t}\n\n\t/* Scan to the end of both runlists in order to know their sizes. */\n\tfor (send = si; srl[send].length; send++)\n\t\t;\n\tfor (dend = di; drl[dend].length; dend++)\n\t\t;\n\n\tif (srl[send].lcn == LCN_ENOENT)\n\t\tmarker_vcn = srl[marker = send].vcn;\n\n\t/* Scan to the last element with lcn >= LCN_HOLE. */\n\tfor (sfinal = send; sfinal >= 0 && srl[sfinal].lcn < LCN_HOLE; sfinal--)\n\t\t;\n\tfor (dfinal = dend; dfinal >= 0 && drl[dfinal].lcn < LCN_HOLE; dfinal--)\n\t\t;\n\n\t{\n\tbool start;\n\tbool finish;\n\tint ds = dend + 1;\t\t/* Number of elements in drl & srl */\n\tint ss = sfinal - sstart + 1;\n\n\tstart  = ((drl[dins].lcn <  LCN_RL_NOT_MAPPED) ||    /* End of file   */\n\t\t  (drl[dins].vcn == srl[sstart].vcn));\t     /* Start of hole */\n\tfinish = ((drl[dins].lcn >= LCN_RL_NOT_MAPPED) &&    /* End of file   */\n\t\t ((drl[dins].vcn + drl[dins].length) <=      /* End of hole   */\n\t\t  (srl[send - 1].vcn + srl[send - 1].length)));\n\n\t/* Or we will lose an end marker. */\n\tif (finish && !drl[dins].length)\n\t\tss++;\n\tif (marker && (drl[dins].vcn + drl[dins].length > srl[send - 1].vcn))\n\t\tfinish = false;\n#if 0\n\tntfs_debug(\"dfinal = %i, dend = %i\", dfinal, dend);\n\tntfs_debug(\"sstart = %i, sfinal = %i, send = %i\", sstart, sfinal, send);\n\tntfs_debug(\"start = %i, finish = %i\", start, finish);\n\tntfs_debug(\"ds = %i, ss = %i, dins = %i\", ds, ss, dins);\n#endif\n\tif (start) {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_replace(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_insert(drl, ds, srl + sstart, ss, dins);\n\t} else {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_append(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_split(drl, ds, srl + sstart, ss, dins);\n\t}\n\tif (IS_ERR(drl)) {\n\t\tntfs_error(NULL, \"Merge failed.\");\n\t\treturn drl;\n\t}\n\tntfs_free(srl);\n\tif (marker) {\n\t\tntfs_debug(\"Triggering marker code.\");\n\t\tfor (ds = dend; drl[ds].length; ds++)\n\t\t\t;\n\t\t/* We only need to care if @srl ended after @drl. */\n\t\tif (drl[ds].vcn <= marker_vcn) {\n\t\t\tint slots = 0;\n\n\t\t\tif (drl[ds].vcn == marker_vcn) {\n\t\t\t\tntfs_debug(\"Old marker = 0x%llx, replacing \"\n\t\t\t\t\t\t\"with LCN_ENOENT.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tdrl[ds].lcn);\n\t\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\t\tgoto finished;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We need to create an unmapped runlist element in\n\t\t\t * @drl or extend an existing one before adding the\n\t\t\t * ENOENT terminator.\n\t\t\t */\n\t\t\tif (drl[ds].lcn == LCN_ENOENT) {\n\t\t\t\tds--;\n\t\t\t\tslots = 1;\n\t\t\t}\n\t\t\tif (drl[ds].lcn != LCN_RL_NOT_MAPPED) {\n\t\t\t\t/* Add an unmapped runlist element. */\n\t\t\t\tif (!slots) {\n\t\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds,\n\t\t\t\t\t\t\tds + 2);\n\t\t\t\t\tslots = 2;\n\t\t\t\t}\n\t\t\t\tds++;\n\t\t\t\t/* Need to set vcn if it isn't set already. */\n\t\t\t\tif (slots != 1)\n\t\t\t\t\tdrl[ds].vcn = drl[ds - 1].vcn +\n\t\t\t\t\t\t\tdrl[ds - 1].length;\n\t\t\t\tdrl[ds].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\t/* We now used up a slot. */\n\t\t\t\tslots--;\n\t\t\t}\n\t\t\tdrl[ds].length = marker_vcn - drl[ds].vcn;\n\t\t\t/* Finally add the ENOENT terminator. */\n\t\t\tds++;\n\t\t\tif (!slots)\n\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds, ds + 1);\n\t\t\tdrl[ds].vcn = marker_vcn;\n\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\tdrl[ds].length = (s64)0;\n\t\t}\n\t}\n\t}\n\nfinished:\n\t/* The merge was completed successfully. */\n\tntfs_debug(\"Merged runlist:\");\n\tntfs_debug_dump_runlist(drl);\n\treturn drl;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nrunlist_element *ntfs_runlists_merge(runlist_element *drl,\n\t\trunlist_element *srl)\n{\n\tint di, si;\t\t/* Current index into @[ds]rl. */\n\tint sstart;\t\t/* First index with lcn > LCN_RL_NOT_MAPPED. */\n\tint dins;\t\t/* Index into @drl at which to insert @srl. */\n\tint dend, send;\t\t/* Last index into @[ds]rl. */\n\tint dfinal, sfinal;\t/* The last index into @[ds]rl with\n\t\t\t\t   lcn >= LCN_HOLE. */\n\tint marker = 0;\n\tVCN marker_vcn = 0;\n\n#ifdef DEBUG\n\tntfs_debug(\"dst:\");\n\tntfs_debug_dump_runlist(drl);\n\tntfs_debug(\"src:\");\n\tntfs_debug_dump_runlist(srl);\n#endif\n\n\t/* Check for silly calling... */\n\tif (unlikely(!srl))\n\t\treturn drl;\n\tif (IS_ERR(srl) || IS_ERR(drl))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Check for the case where the first mapping is being done now. */\n\tif (unlikely(!drl)) {\n\t\tdrl = srl;\n\t\t/* Complete the source runlist if necessary. */\n\t\tif (unlikely(drl[0].vcn)) {\n\t\t\t/* Scan to the end of the source runlist. */\n\t\t\tfor (dend = 0; likely(drl[dend].length); dend++)\n\t\t\t\t;\n\t\t\tdend++;\n\t\t\tdrl = ntfs_rl_realloc(drl, dend, dend + 1);\n\t\t\tif (IS_ERR(drl))\n\t\t\t\treturn drl;\n\t\t\t/* Insert start element at the front of the runlist. */\n\t\t\tntfs_rl_mm(drl, 1, 0, dend);\n\t\t\tdrl[0].vcn = 0;\n\t\t\tdrl[0].lcn = LCN_RL_NOT_MAPPED;\n\t\t\tdrl[0].length = drl[1].vcn;\n\t\t}\n\t\tgoto finished;\n\t}\n\n\tsi = di = 0;\n\n\t/* Skip any unmapped start element(s) in the source runlist. */\n\twhile (srl[si].length && srl[si].lcn < LCN_HOLE)\n\t\tsi++;\n\n\t/* Can't have an entirely unmapped source runlist. */\n\tBUG_ON(!srl[si].length);\n\n\t/* Record the starting points. */\n\tsstart = si;\n\n\t/*\n\t * Skip forward in @drl until we reach the position where @srl needs to\n\t * be inserted. If we reach the end of @drl, @srl just needs to be\n\t * appended to @drl.\n\t */\n\tfor (; drl[di].length; di++) {\n\t\tif (drl[di].vcn + drl[di].length > srl[sstart].vcn)\n\t\t\tbreak;\n\t}\n\tdins = di;\n\n\t/* Sanity check for illegal overlaps. */\n\tif ((drl[di].vcn == srl[si].vcn) && (drl[di].lcn >= 0) &&\n\t\t\t(srl[si].lcn >= 0)) {\n\t\tntfs_error(NULL, \"Run lists overlap. Cannot merge!\");\n\t\treturn ERR_PTR(-ERANGE);\n\t}\n\n\t/* Scan to the end of both runlists in order to know their sizes. */\n\tfor (send = si; srl[send].length; send++)\n\t\t;\n\tfor (dend = di; drl[dend].length; dend++)\n\t\t;\n\n\tif (srl[send].lcn == LCN_ENOENT)\n\t\tmarker_vcn = srl[marker = send].vcn;\n\n\t/* Scan to the last element with lcn >= LCN_HOLE. */\n\tfor (sfinal = send; sfinal >= 0 && srl[sfinal].lcn < LCN_HOLE; sfinal--)\n\t\t;\n\tfor (dfinal = dend; dfinal >= 0 && drl[dfinal].lcn < LCN_HOLE; dfinal--)\n\t\t;\n\n\t{\n\tbool start;\n\tbool finish;\n\tint ds = dend + 1;\t\t/* Number of elements in drl & srl */\n\tint ss = sfinal - sstart + 1;\n\n\tstart  = ((drl[dins].lcn <  LCN_RL_NOT_MAPPED) ||    /* End of file   */\n\t\t  (drl[dins].vcn == srl[sstart].vcn));\t     /* Start of hole */\n\tfinish = ((drl[dins].lcn >= LCN_RL_NOT_MAPPED) &&    /* End of file   */\n\t\t ((drl[dins].vcn + drl[dins].length) <=      /* End of hole   */\n\t\t  (srl[send - 1].vcn + srl[send - 1].length)));\n\n\t/* Or we will lose an end marker. */\n\tif (finish && !drl[dins].length)\n\t\tss++;\n\tif (marker && (drl[dins].vcn + drl[dins].length > srl[send - 1].vcn))\n\t\tfinish = false;\n#if 0\n\tntfs_debug(\"dfinal = %i, dend = %i\", dfinal, dend);\n\tntfs_debug(\"sstart = %i, sfinal = %i, send = %i\", sstart, sfinal, send);\n\tntfs_debug(\"start = %i, finish = %i\", start, finish);\n\tntfs_debug(\"ds = %i, ss = %i, dins = %i\", ds, ss, dins);\n#endif\n\tif (start) {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_replace(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_insert(drl, ds, srl + sstart, ss, dins);\n\t} else {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_append(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_split(drl, ds, srl + sstart, ss, dins);\n\t}\n\tif (IS_ERR(drl)) {\n\t\tntfs_error(NULL, \"Merge failed.\");\n\t\treturn drl;\n\t}\n\tntfs_free(srl);\n\tif (marker) {\n\t\tntfs_debug(\"Triggering marker code.\");\n\t\tfor (ds = dend; drl[ds].length; ds++)\n\t\t\t;\n\t\t/* We only need to care if @srl ended after @drl. */\n\t\tif (drl[ds].vcn <= marker_vcn) {\n\t\t\tint slots = 0;\n\n\t\t\tif (drl[ds].vcn == marker_vcn) {\n\t\t\t\tntfs_debug(\"Old marker = 0x%llx, replacing \"\n\t\t\t\t\t\t\"with LCN_ENOENT.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tdrl[ds].lcn);\n\t\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\t\tgoto finished;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We need to create an unmapped runlist element in\n\t\t\t * @drl or extend an existing one before adding the\n\t\t\t * ENOENT terminator.\n\t\t\t */\n\t\t\tif (drl[ds].lcn == LCN_ENOENT) {\n\t\t\t\tds--;\n\t\t\t\tslots = 1;\n\t\t\t}\n\t\t\tif (drl[ds].lcn != LCN_RL_NOT_MAPPED) {\n\t\t\t\t/* Add an unmapped runlist element. */\n\t\t\t\tif (!slots) {\n\t\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds,\n\t\t\t\t\t\t\tds + 2);\n\t\t\t\t\tslots = 2;\n\t\t\t\t}\n\t\t\t\tds++;\n\t\t\t\t/* Need to set vcn if it isn't set already. */\n\t\t\t\tif (slots != 1)\n\t\t\t\t\tdrl[ds].vcn = drl[ds - 1].vcn +\n\t\t\t\t\t\t\tdrl[ds - 1].length;\n\t\t\t\tdrl[ds].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\t/* We now used up a slot. */\n\t\t\t\tslots--;\n\t\t\t}\n\t\t\tdrl[ds].length = marker_vcn - drl[ds].vcn;\n\t\t\t/* Finally add the ENOENT terminator. */\n\t\t\tds++;\n\t\t\tif (!slots)\n\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds, ds + 1);\n\t\t\tdrl[ds].vcn = marker_vcn;\n\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\tdrl[ds].length = (s64)0;\n\t\t}\n\t}\n\t}\n\nfinished:\n\t/* The merge was completed successfully. */\n\tntfs_debug(\"Merged runlist:\");\n\tntfs_debug_dump_runlist(drl);\n\treturn drl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rl2"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl2"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_cluster_alloc",
          "args": [
            "vol",
            "allocated_size >> vol->cluster_size_bits",
            "(new_alloc_size - allocated_size) >>\n\t\t\tvol->cluster_size_bits",
            "(rl && (rl->lcn >= 0)) ?\n\t\t\trl->lcn + rl->length : -1",
            "DATA_ZONE",
            "true"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_cluster_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.c",
          "lines": "146-787",
          "snippet": "runlist_element *ntfs_cluster_alloc(ntfs_volume *vol, const VCN start_vcn,\n\t\tconst s64 count, const LCN start_lcn,\n\t\tconst NTFS_CLUSTER_ALLOCATION_ZONES zone,\n\t\tconst bool is_extension)\n{\n\tLCN zone_start, zone_end, bmp_pos, bmp_initial_pos, last_read_pos, lcn;\n\tLCN prev_lcn = 0, prev_run_len = 0, mft_zone_size;\n\ts64 clusters;\n\tloff_t i_size;\n\tstruct inode *lcnbmp_vi;\n\trunlist_element *rl = NULL;\n\tstruct address_space *mapping;\n\tstruct page *page = NULL;\n\tu8 *buf, *byte;\n\tint err = 0, rlpos, rlsize, buf_size;\n\tu8 pass, done_zones, search_zone, need_writeback = 0, bit;\n\n\tntfs_debug(\"Entering for start_vcn 0x%llx, count 0x%llx, start_lcn \"\n\t\t\t\"0x%llx, zone %s_ZONE.\", (unsigned long long)start_vcn,\n\t\t\t(unsigned long long)count,\n\t\t\t(unsigned long long)start_lcn,\n\t\t\tzone == MFT_ZONE ? \"MFT\" : \"DATA\");\n\tBUG_ON(!vol);\n\tlcnbmp_vi = vol->lcnbmp_ino;\n\tBUG_ON(!lcnbmp_vi);\n\tBUG_ON(start_vcn < 0);\n\tBUG_ON(count < 0);\n\tBUG_ON(start_lcn < -1);\n\tBUG_ON(zone < FIRST_ZONE);\n\tBUG_ON(zone > LAST_ZONE);\n\n\t/* Return NULL if @count is zero. */\n\tif (!count)\n\t\treturn NULL;\n\t/* Take the lcnbmp lock for writing. */\n\tdown_write(&vol->lcnbmp_lock);\n\t/*\n\t * If no specific @start_lcn was requested, use the current data zone\n\t * position, otherwise use the requested @start_lcn but make sure it\n\t * lies outside the mft zone.  Also set done_zones to 0 (no zones done)\n\t * and pass depending on whether we are starting inside a zone (1) or\n\t * at the beginning of a zone (2).  If requesting from the MFT_ZONE,\n\t * we either start at the current position within the mft zone or at\n\t * the specified position.  If the latter is out of bounds then we start\n\t * at the beginning of the MFT_ZONE.\n\t */\n\tdone_zones = 0;\n\tpass = 1;\n\t/*\n\t * zone_start and zone_end are the current search range.  search_zone\n\t * is 1 for mft zone, 2 for data zone 1 (end of mft zone till end of\n\t * volume) and 4 for data zone 2 (start of volume till start of mft\n\t * zone).\n\t */\n\tzone_start = start_lcn;\n\tif (zone_start < 0) {\n\t\tif (zone == DATA_ZONE)\n\t\t\tzone_start = vol->data1_zone_pos;\n\t\telse\n\t\t\tzone_start = vol->mft_zone_pos;\n\t\tif (!zone_start) {\n\t\t\t/*\n\t\t\t * Zone starts at beginning of volume which means a\n\t\t\t * single pass is sufficient.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t}\n\t} else if (zone == DATA_ZONE && zone_start >= vol->mft_zone_start &&\n\t\t\tzone_start < vol->mft_zone_end) {\n\t\tzone_start = vol->mft_zone_end;\n\t\t/*\n\t\t * Starting at beginning of data1_zone which means a single\n\t\t * pass in this zone is sufficient.\n\t\t */\n\t\tpass = 2;\n\t} else if (zone == MFT_ZONE && (zone_start < vol->mft_zone_start ||\n\t\t\tzone_start >= vol->mft_zone_end)) {\n\t\tzone_start = vol->mft_lcn;\n\t\tif (!vol->mft_zone_end)\n\t\t\tzone_start = 0;\n\t\t/*\n\t\t * Starting at beginning of volume which means a single pass\n\t\t * is sufficient.\n\t\t */\n\t\tpass = 2;\n\t}\n\tif (zone == MFT_ZONE) {\n\t\tzone_end = vol->mft_zone_end;\n\t\tsearch_zone = 1;\n\t} else /* if (zone == DATA_ZONE) */ {\n\t\t/* Skip searching the mft zone. */\n\t\tdone_zones |= 1;\n\t\tif (zone_start >= vol->mft_zone_end) {\n\t\t\tzone_end = vol->nr_clusters;\n\t\t\tsearch_zone = 2;\n\t\t} else {\n\t\t\tzone_end = vol->mft_zone_start;\n\t\t\tsearch_zone = 4;\n\t\t}\n\t}\n\t/*\n\t * bmp_pos is the current bit position inside the bitmap.  We use\n\t * bmp_initial_pos to determine whether or not to do a zone switch.\n\t */\n\tbmp_pos = bmp_initial_pos = zone_start;\n\n\t/* Loop until all clusters are allocated, i.e. clusters == 0. */\n\tclusters = count;\n\trlpos = rlsize = 0;\n\tmapping = lcnbmp_vi->i_mapping;\n\ti_size = i_size_read(lcnbmp_vi);\n\twhile (1) {\n\t\tntfs_debug(\"Start of outer while loop: done_zones 0x%x, \"\n\t\t\t\t\"search_zone %i, pass %i, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, rlpos %i, rlsize %i.\",\n\t\t\t\tdone_zones, search_zone, pass,\n\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t(unsigned long long)bmp_pos, rlpos, rlsize);\n\t\t/* Loop until we run out of free clusters. */\n\t\tlast_read_pos = bmp_pos >> 3;\n\t\tntfs_debug(\"last_read_pos 0x%llx.\",\n\t\t\t\t(unsigned long long)last_read_pos);\n\t\tif (last_read_pos > i_size) {\n\t\t\tntfs_debug(\"End of attribute reached.  \"\n\t\t\t\t\t\"Skipping to zone_pass_done.\");\n\t\t\tgoto zone_pass_done;\n\t\t}\n\t\tif (likely(page)) {\n\t\t\tif (need_writeback) {\n\t\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tset_page_dirty(page);\n\t\t\t\tneed_writeback = 0;\n\t\t\t}\n\t\t\tntfs_unmap_page(page);\n\t\t}\n\t\tpage = ntfs_map_page(mapping, last_read_pos >>\n\t\t\t\tPAGE_CACHE_SHIFT);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tntfs_error(vol->sb, \"Failed to map page.\");\n\t\t\tgoto out;\n\t\t}\n\t\tbuf_size = last_read_pos & ~PAGE_CACHE_MASK;\n\t\tbuf = page_address(page) + buf_size;\n\t\tbuf_size = PAGE_CACHE_SIZE - buf_size;\n\t\tif (unlikely(last_read_pos + buf_size > i_size))\n\t\t\tbuf_size = i_size - last_read_pos;\n\t\tbuf_size <<= 3;\n\t\tlcn = bmp_pos & 7;\n\t\tbmp_pos &= ~(LCN)7;\n\t\tntfs_debug(\"Before inner while loop: buf_size %i, lcn 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, need_writeback %i.\", buf_size,\n\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\twhile (lcn < buf_size && lcn + bmp_pos < zone_end) {\n\t\t\tbyte = buf + (lcn >> 3);\n\t\t\tntfs_debug(\"In inner while loop: buf_size %i, \"\n\t\t\t\t\t\"lcn 0x%llx, bmp_pos 0x%llx, \"\n\t\t\t\t\t\"need_writeback %i, byte ofs 0x%x, \"\n\t\t\t\t\t\"*byte 0x%x.\", buf_size,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\tneed_writeback,\n\t\t\t\t\t(unsigned int)(lcn >> 3),\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/* Skip full bytes. */\n\t\t\tif (*byte == 0xff) {\n\t\t\t\tlcn = (lcn + 8) & ~(LCN)7;\n\t\t\t\tntfs_debug(\"Continuing while loop 1.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbit = 1 << (lcn & 7);\n\t\t\tntfs_debug(\"bit 0x%x.\", bit);\n\t\t\t/* If the bit is already set, go onto the next one. */\n\t\t\tif (*byte & bit) {\n\t\t\t\tlcn++;\n\t\t\t\tntfs_debug(\"Continuing while loop 2.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Allocate more memory if needed, including space for\n\t\t\t * the terminator element.\n\t\t\t * ntfs_malloc_nofs() operates on whole pages only.\n\t\t\t */\n\t\t\tif ((rlpos + 2) * sizeof(*rl) > rlsize) {\n\t\t\t\trunlist_element *rl2;\n\n\t\t\t\tntfs_debug(\"Reallocating memory.\");\n\t\t\t\tif (!rl)\n\t\t\t\t\tntfs_debug(\"First free bit is at LCN \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\t(lcn + bmp_pos));\n\t\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\t\tif (unlikely(!rl2)) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to \"\n\t\t\t\t\t\t\t\"allocate memory.\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\t\tntfs_free(rl);\n\t\t\t\trl = rl2;\n\t\t\t\trlsize += PAGE_SIZE;\n\t\t\t\tntfs_debug(\"Reallocated memory, rlsize 0x%x.\",\n\t\t\t\t\t\trlsize);\n\t\t\t}\n\t\t\t/* Allocate the bitmap bit. */\n\t\t\t*byte |= bit;\n\t\t\t/* We need to write this bitmap page to disk. */\n\t\t\tneed_writeback = 1;\n\t\t\tntfs_debug(\"*byte 0x%x, need_writeback is set.\",\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/*\n\t\t\t * Coalesce with previous run if adjacent LCNs.\n\t\t\t * Otherwise, append a new run.\n\t\t\t */\n\t\t\tntfs_debug(\"Adding run (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\"prev_lcn 0x%llx, lcn 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, prev_run_len 0x%llx, \"\n\t\t\t\t\t\"rlpos %i.\",\n\t\t\t\t\t(unsigned long long)(lcn + bmp_pos),\n\t\t\t\t\t1ULL, (unsigned long long)prev_lcn,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)prev_run_len,\n\t\t\t\t\trlpos);\n\t\t\tif (prev_lcn == lcn + bmp_pos - prev_run_len && rlpos) {\n\t\t\t\tntfs_debug(\"Coalescing to run (lcn 0x%llx, \"\n\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\trl[rlpos - 1].length = ++prev_run_len;\n\t\t\t\tntfs_debug(\"Run now (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\t\"prev_run_len 0x%llx.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tprev_run_len);\n\t\t\t} else {\n\t\t\t\tif (likely(rlpos)) {\n\t\t\t\t\tntfs_debug(\"Adding new run, (previous \"\n\t\t\t\t\t\t\t\"run lcn 0x%llx, \"\n\t\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\t\trl[rlpos].vcn = rl[rlpos - 1].vcn +\n\t\t\t\t\t\t\tprev_run_len;\n\t\t\t\t} else {\n\t\t\t\t\tntfs_debug(\"Adding new run, is first \"\n\t\t\t\t\t\t\t\"run.\");\n\t\t\t\t\trl[rlpos].vcn = start_vcn;\n\t\t\t\t}\n\t\t\t\trl[rlpos].lcn = prev_lcn = lcn + bmp_pos;\n\t\t\t\trl[rlpos].length = prev_run_len = 1;\n\t\t\t\trlpos++;\n\t\t\t}\n\t\t\t/* Done? */\n\t\t\tif (!--clusters) {\n\t\t\t\tLCN tc;\n\t\t\t\t/*\n\t\t\t\t * Update the current zone position.  Positions\n\t\t\t\t * of already scanned zones have been updated\n\t\t\t\t * during the respective zone switches.\n\t\t\t\t */\n\t\t\t\ttc = lcn + bmp_pos + 1;\n\t\t\t\tntfs_debug(\"Done. Updating current zone \"\n\t\t\t\t\t\t\"position, tc 0x%llx, \"\n\t\t\t\t\t\t\"search_zone %i.\",\n\t\t\t\t\t\t(unsigned long long)tc,\n\t\t\t\t\t\tsearch_zone);\n\t\t\t\tswitch (search_zone) {\n\t\t\t\tcase 1:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tntfs_debug(\"Finished.  Going to out.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlcn++;\n\t\t}\n\t\tbmp_pos += buf_size;\n\t\tntfs_debug(\"After inner while loop: buf_size 0x%x, lcn \"\n\t\t\t\t\"0x%llx, bmp_pos 0x%llx, need_writeback %i.\",\n\t\t\t\tbuf_size, (unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\tif (bmp_pos < zone_end) {\n\t\t\tntfs_debug(\"Continuing outer while loop, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tcontinue;\n\t\t}\nzone_pass_done:\t/* Finished with the current zone pass. */\n\t\tntfs_debug(\"At zone_pass_done, pass %i.\", pass);\n\t\tif (pass == 1) {\n\t\t\t/*\n\t\t\t * Now do pass 2, scanning the first part of the zone\n\t\t\t * we omitted in pass 1.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t\tzone_end = zone_start;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1: /* mft_zone */\n\t\t\t\tzone_start = vol->mft_zone_start;\n\t\t\t\tbreak;\n\t\t\tcase 2: /* data1_zone */\n\t\t\t\tzone_start = vol->mft_zone_end;\n\t\t\t\tbreak;\n\t\t\tcase 4: /* data2_zone */\n\t\t\t\tzone_start = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* Sanity check. */\n\t\t\tif (zone_end < zone_start)\n\t\t\t\tzone_end = zone_start;\n\t\t\tbmp_pos = zone_start;\n\t\t\tntfs_debug(\"Continuing outer while loop, pass 2, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx.\",\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t\t(unsigned long long)bmp_pos);\n\t\t\tcontinue;\n\t\t} /* pass == 2 */\ndone_zones_check:\n\t\tntfs_debug(\"At done_zones_check, search_zone %i, done_zones \"\n\t\t\t\t\"before 0x%x, done_zones after 0x%x.\",\n\t\t\t\tsearch_zone, done_zones,\n\t\t\t\tdone_zones | search_zone);\n\t\tdone_zones |= search_zone;\n\t\tif (done_zones < 7) {\n\t\t\tntfs_debug(\"Switching zone.\");\n\t\t\t/* Now switch to the next zone we haven't done yet. */\n\t\t\tpass = 1;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1:\n\t\t\t\tntfs_debug(\"Switching from mft zone to data1 \"\n\t\t\t\t\t\t\"zone.\");\n\t\t\t\t/* Update mft zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from mft zone to data1 zone. */\nswitch_to_data1_zone:\t\tsearch_zone = 2;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data1_zone_pos;\n\t\t\t\tzone_end = vol->nr_clusters;\n\t\t\t\tif (zone_start == vol->mft_zone_end)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data1_zone_pos = zone_start =\n\t\t\t\t\t\t\tvol->mft_zone_end;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tntfs_debug(\"Switching from data1 zone to \"\n\t\t\t\t\t\t\"data2 zone.\");\n\t\t\t\t/* Update data1 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data1 zone to data2 zone. */\n\t\t\t\tsearch_zone = 4;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data2_zone_pos;\n\t\t\t\tzone_end = vol->mft_zone_start;\n\t\t\t\tif (!zone_start)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data2_zone_pos = zone_start =\n\t\t\t\t\t\t\tbmp_initial_pos = 0;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tntfs_debug(\"Switching from data2 zone to \"\n\t\t\t\t\t\t\"data1 zone.\");\n\t\t\t\t/* Update data2 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data2 zone to data1 zone. */\n\t\t\t\tgoto switch_to_data1_zone;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tntfs_debug(\"After zone switch, search_zone %i, \"\n\t\t\t\t\t\"pass %i, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\tsearch_zone, pass,\n\t\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tbmp_pos = zone_start;\n\t\t\tif (zone_start == zone_end) {\n\t\t\t\tntfs_debug(\"Empty zone, going to \"\n\t\t\t\t\t\t\"done_zones_check.\");\n\t\t\t\t/* Empty zone. Don't bother searching it. */\n\t\t\t\tgoto done_zones_check;\n\t\t\t}\n\t\t\tntfs_debug(\"Continuing outer while loop.\");\n\t\t\tcontinue;\n\t\t} /* done_zones == 7 */\n\t\tntfs_debug(\"All zones are finished.\");\n\t\t/*\n\t\t * All zones are finished!  If DATA_ZONE, shrink mft zone.  If\n\t\t * MFT_ZONE, we have really run out of space.\n\t\t */\n\t\tmft_zone_size = vol->mft_zone_end - vol->mft_zone_start;\n\t\tntfs_debug(\"vol->mft_zone_start 0x%llx, vol->mft_zone_end \"\n\t\t\t\t\"0x%llx, mft_zone_size 0x%llx.\",\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)mft_zone_size);\n\t\tif (zone == MFT_ZONE || mft_zone_size <= 0) {\n\t\t\tntfs_debug(\"No free clusters left, going to out.\");\n\t\t\t/* Really no more space left on device. */\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out;\n\t\t} /* zone == DATA_ZONE && mft_zone_size > 0 */\n\t\tntfs_debug(\"Shrinking mft zone.\");\n\t\tzone_end = vol->mft_zone_end;\n\t\tmft_zone_size >>= 1;\n\t\tif (mft_zone_size > 0)\n\t\t\tvol->mft_zone_end = vol->mft_zone_start + mft_zone_size;\n\t\telse /* mft zone and data2 zone no longer exist. */\n\t\t\tvol->data2_zone_pos = vol->mft_zone_start =\n\t\t\t\t\tvol->mft_zone_end = 0;\n\t\tif (vol->mft_zone_pos >= vol->mft_zone_end) {\n\t\t\tvol->mft_zone_pos = vol->mft_lcn;\n\t\t\tif (!vol->mft_zone_end)\n\t\t\t\tvol->mft_zone_pos = 0;\n\t\t}\n\t\tbmp_pos = zone_start = bmp_initial_pos =\n\t\t\t\tvol->data1_zone_pos = vol->mft_zone_end;\n\t\tsearch_zone = 2;\n\t\tpass = 2;\n\t\tdone_zones &= ~2;\n\t\tntfs_debug(\"After shrinking mft zone, mft_zone_size 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_start 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_end 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_pos 0x%llx, search_zone 2, \"\n\t\t\t\t\"pass 2, dones_zones 0x%x, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, vol->data1_zone_pos 0x%llx, \"\n\t\t\t\t\"continuing outer while loop.\",\n\t\t\t\t(unsigned long long)mft_zone_size,\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)vol->mft_zone_pos,\n\t\t\t\tdone_zones, (unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)vol->data1_zone_pos);\n\t}\n\tntfs_debug(\"After outer while loop.\");\nout:\n\tntfs_debug(\"At out.\");\n\t/* Add runlist terminator element. */\n\tif (likely(rl)) {\n\t\trl[rlpos].vcn = rl[rlpos - 1].vcn + rl[rlpos - 1].length;\n\t\trl[rlpos].lcn = is_extension ? LCN_ENOENT : LCN_RL_NOT_MAPPED;\n\t\trl[rlpos].length = 0;\n\t}\n\tif (likely(page && !IS_ERR(page))) {\n\t\tif (need_writeback) {\n\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\tflush_dcache_page(page);\n\t\t\tset_page_dirty(page);\n\t\t\tneed_writeback = 0;\n\t\t}\n\t\tntfs_unmap_page(page);\n\t}\n\tif (likely(!err)) {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_debug(\"Done.\");\n\t\treturn rl;\n\t}\n\tntfs_error(vol->sb, \"Failed to allocate clusters, aborting \"\n\t\t\t\"(error %i).\", err);\n\tif (rl) {\n\t\tint err2;\n\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_debug(\"Not enough space to complete allocation, \"\n\t\t\t\t\t\"err -ENOSPC, first free lcn 0x%llx, \"\n\t\t\t\t\t\"could allocate up to 0x%llx \"\n\t\t\t\t\t\"clusters.\",\n\t\t\t\t\t(unsigned long long)rl[0].lcn,\n\t\t\t\t\t(unsigned long long)(count - clusters));\n\t\t/* Deallocate all allocated clusters. */\n\t\tntfs_debug(\"Attempting rollback...\");\n\t\terr2 = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\t\tif (err2) {\n\t\t\tntfs_error(vol->sb, \"Failed to rollback (error %i).  \"\n\t\t\t\t\t\"Leaving inconsistent metadata!  \"\n\t\t\t\t\t\"Unmount and run chkdsk.\", err2);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\t/* Free the runlist. */\n\t\tntfs_free(rl);\n\t} else if (err == -ENOSPC)\n\t\tntfs_debug(\"No space left at all, err = -ENOSPC, first free \"\n\t\t\t\t\"lcn = 0x%llx.\",\n\t\t\t\t(long long)vol->data1_zone_pos);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"aops.h\"",
            "#include \"malloc.h\"",
            "#include \"attrib.h\"",
            "#include \"volume.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"debug.h\"",
            "#include \"lcnalloc.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"aops.h\"\n#include \"malloc.h\"\n#include \"attrib.h\"\n#include \"volume.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"debug.h\"\n#include \"lcnalloc.h\"\n#include <linux/pagemap.h>\n\nrunlist_element *ntfs_cluster_alloc(ntfs_volume *vol, const VCN start_vcn,\n\t\tconst s64 count, const LCN start_lcn,\n\t\tconst NTFS_CLUSTER_ALLOCATION_ZONES zone,\n\t\tconst bool is_extension)\n{\n\tLCN zone_start, zone_end, bmp_pos, bmp_initial_pos, last_read_pos, lcn;\n\tLCN prev_lcn = 0, prev_run_len = 0, mft_zone_size;\n\ts64 clusters;\n\tloff_t i_size;\n\tstruct inode *lcnbmp_vi;\n\trunlist_element *rl = NULL;\n\tstruct address_space *mapping;\n\tstruct page *page = NULL;\n\tu8 *buf, *byte;\n\tint err = 0, rlpos, rlsize, buf_size;\n\tu8 pass, done_zones, search_zone, need_writeback = 0, bit;\n\n\tntfs_debug(\"Entering for start_vcn 0x%llx, count 0x%llx, start_lcn \"\n\t\t\t\"0x%llx, zone %s_ZONE.\", (unsigned long long)start_vcn,\n\t\t\t(unsigned long long)count,\n\t\t\t(unsigned long long)start_lcn,\n\t\t\tzone == MFT_ZONE ? \"MFT\" : \"DATA\");\n\tBUG_ON(!vol);\n\tlcnbmp_vi = vol->lcnbmp_ino;\n\tBUG_ON(!lcnbmp_vi);\n\tBUG_ON(start_vcn < 0);\n\tBUG_ON(count < 0);\n\tBUG_ON(start_lcn < -1);\n\tBUG_ON(zone < FIRST_ZONE);\n\tBUG_ON(zone > LAST_ZONE);\n\n\t/* Return NULL if @count is zero. */\n\tif (!count)\n\t\treturn NULL;\n\t/* Take the lcnbmp lock for writing. */\n\tdown_write(&vol->lcnbmp_lock);\n\t/*\n\t * If no specific @start_lcn was requested, use the current data zone\n\t * position, otherwise use the requested @start_lcn but make sure it\n\t * lies outside the mft zone.  Also set done_zones to 0 (no zones done)\n\t * and pass depending on whether we are starting inside a zone (1) or\n\t * at the beginning of a zone (2).  If requesting from the MFT_ZONE,\n\t * we either start at the current position within the mft zone or at\n\t * the specified position.  If the latter is out of bounds then we start\n\t * at the beginning of the MFT_ZONE.\n\t */\n\tdone_zones = 0;\n\tpass = 1;\n\t/*\n\t * zone_start and zone_end are the current search range.  search_zone\n\t * is 1 for mft zone, 2 for data zone 1 (end of mft zone till end of\n\t * volume) and 4 for data zone 2 (start of volume till start of mft\n\t * zone).\n\t */\n\tzone_start = start_lcn;\n\tif (zone_start < 0) {\n\t\tif (zone == DATA_ZONE)\n\t\t\tzone_start = vol->data1_zone_pos;\n\t\telse\n\t\t\tzone_start = vol->mft_zone_pos;\n\t\tif (!zone_start) {\n\t\t\t/*\n\t\t\t * Zone starts at beginning of volume which means a\n\t\t\t * single pass is sufficient.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t}\n\t} else if (zone == DATA_ZONE && zone_start >= vol->mft_zone_start &&\n\t\t\tzone_start < vol->mft_zone_end) {\n\t\tzone_start = vol->mft_zone_end;\n\t\t/*\n\t\t * Starting at beginning of data1_zone which means a single\n\t\t * pass in this zone is sufficient.\n\t\t */\n\t\tpass = 2;\n\t} else if (zone == MFT_ZONE && (zone_start < vol->mft_zone_start ||\n\t\t\tzone_start >= vol->mft_zone_end)) {\n\t\tzone_start = vol->mft_lcn;\n\t\tif (!vol->mft_zone_end)\n\t\t\tzone_start = 0;\n\t\t/*\n\t\t * Starting at beginning of volume which means a single pass\n\t\t * is sufficient.\n\t\t */\n\t\tpass = 2;\n\t}\n\tif (zone == MFT_ZONE) {\n\t\tzone_end = vol->mft_zone_end;\n\t\tsearch_zone = 1;\n\t} else /* if (zone == DATA_ZONE) */ {\n\t\t/* Skip searching the mft zone. */\n\t\tdone_zones |= 1;\n\t\tif (zone_start >= vol->mft_zone_end) {\n\t\t\tzone_end = vol->nr_clusters;\n\t\t\tsearch_zone = 2;\n\t\t} else {\n\t\t\tzone_end = vol->mft_zone_start;\n\t\t\tsearch_zone = 4;\n\t\t}\n\t}\n\t/*\n\t * bmp_pos is the current bit position inside the bitmap.  We use\n\t * bmp_initial_pos to determine whether or not to do a zone switch.\n\t */\n\tbmp_pos = bmp_initial_pos = zone_start;\n\n\t/* Loop until all clusters are allocated, i.e. clusters == 0. */\n\tclusters = count;\n\trlpos = rlsize = 0;\n\tmapping = lcnbmp_vi->i_mapping;\n\ti_size = i_size_read(lcnbmp_vi);\n\twhile (1) {\n\t\tntfs_debug(\"Start of outer while loop: done_zones 0x%x, \"\n\t\t\t\t\"search_zone %i, pass %i, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, rlpos %i, rlsize %i.\",\n\t\t\t\tdone_zones, search_zone, pass,\n\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t(unsigned long long)bmp_pos, rlpos, rlsize);\n\t\t/* Loop until we run out of free clusters. */\n\t\tlast_read_pos = bmp_pos >> 3;\n\t\tntfs_debug(\"last_read_pos 0x%llx.\",\n\t\t\t\t(unsigned long long)last_read_pos);\n\t\tif (last_read_pos > i_size) {\n\t\t\tntfs_debug(\"End of attribute reached.  \"\n\t\t\t\t\t\"Skipping to zone_pass_done.\");\n\t\t\tgoto zone_pass_done;\n\t\t}\n\t\tif (likely(page)) {\n\t\t\tif (need_writeback) {\n\t\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tset_page_dirty(page);\n\t\t\t\tneed_writeback = 0;\n\t\t\t}\n\t\t\tntfs_unmap_page(page);\n\t\t}\n\t\tpage = ntfs_map_page(mapping, last_read_pos >>\n\t\t\t\tPAGE_CACHE_SHIFT);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tntfs_error(vol->sb, \"Failed to map page.\");\n\t\t\tgoto out;\n\t\t}\n\t\tbuf_size = last_read_pos & ~PAGE_CACHE_MASK;\n\t\tbuf = page_address(page) + buf_size;\n\t\tbuf_size = PAGE_CACHE_SIZE - buf_size;\n\t\tif (unlikely(last_read_pos + buf_size > i_size))\n\t\t\tbuf_size = i_size - last_read_pos;\n\t\tbuf_size <<= 3;\n\t\tlcn = bmp_pos & 7;\n\t\tbmp_pos &= ~(LCN)7;\n\t\tntfs_debug(\"Before inner while loop: buf_size %i, lcn 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, need_writeback %i.\", buf_size,\n\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\twhile (lcn < buf_size && lcn + bmp_pos < zone_end) {\n\t\t\tbyte = buf + (lcn >> 3);\n\t\t\tntfs_debug(\"In inner while loop: buf_size %i, \"\n\t\t\t\t\t\"lcn 0x%llx, bmp_pos 0x%llx, \"\n\t\t\t\t\t\"need_writeback %i, byte ofs 0x%x, \"\n\t\t\t\t\t\"*byte 0x%x.\", buf_size,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\tneed_writeback,\n\t\t\t\t\t(unsigned int)(lcn >> 3),\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/* Skip full bytes. */\n\t\t\tif (*byte == 0xff) {\n\t\t\t\tlcn = (lcn + 8) & ~(LCN)7;\n\t\t\t\tntfs_debug(\"Continuing while loop 1.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbit = 1 << (lcn & 7);\n\t\t\tntfs_debug(\"bit 0x%x.\", bit);\n\t\t\t/* If the bit is already set, go onto the next one. */\n\t\t\tif (*byte & bit) {\n\t\t\t\tlcn++;\n\t\t\t\tntfs_debug(\"Continuing while loop 2.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Allocate more memory if needed, including space for\n\t\t\t * the terminator element.\n\t\t\t * ntfs_malloc_nofs() operates on whole pages only.\n\t\t\t */\n\t\t\tif ((rlpos + 2) * sizeof(*rl) > rlsize) {\n\t\t\t\trunlist_element *rl2;\n\n\t\t\t\tntfs_debug(\"Reallocating memory.\");\n\t\t\t\tif (!rl)\n\t\t\t\t\tntfs_debug(\"First free bit is at LCN \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\t(lcn + bmp_pos));\n\t\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\t\tif (unlikely(!rl2)) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to \"\n\t\t\t\t\t\t\t\"allocate memory.\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\t\tntfs_free(rl);\n\t\t\t\trl = rl2;\n\t\t\t\trlsize += PAGE_SIZE;\n\t\t\t\tntfs_debug(\"Reallocated memory, rlsize 0x%x.\",\n\t\t\t\t\t\trlsize);\n\t\t\t}\n\t\t\t/* Allocate the bitmap bit. */\n\t\t\t*byte |= bit;\n\t\t\t/* We need to write this bitmap page to disk. */\n\t\t\tneed_writeback = 1;\n\t\t\tntfs_debug(\"*byte 0x%x, need_writeback is set.\",\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/*\n\t\t\t * Coalesce with previous run if adjacent LCNs.\n\t\t\t * Otherwise, append a new run.\n\t\t\t */\n\t\t\tntfs_debug(\"Adding run (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\"prev_lcn 0x%llx, lcn 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, prev_run_len 0x%llx, \"\n\t\t\t\t\t\"rlpos %i.\",\n\t\t\t\t\t(unsigned long long)(lcn + bmp_pos),\n\t\t\t\t\t1ULL, (unsigned long long)prev_lcn,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)prev_run_len,\n\t\t\t\t\trlpos);\n\t\t\tif (prev_lcn == lcn + bmp_pos - prev_run_len && rlpos) {\n\t\t\t\tntfs_debug(\"Coalescing to run (lcn 0x%llx, \"\n\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\trl[rlpos - 1].length = ++prev_run_len;\n\t\t\t\tntfs_debug(\"Run now (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\t\"prev_run_len 0x%llx.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tprev_run_len);\n\t\t\t} else {\n\t\t\t\tif (likely(rlpos)) {\n\t\t\t\t\tntfs_debug(\"Adding new run, (previous \"\n\t\t\t\t\t\t\t\"run lcn 0x%llx, \"\n\t\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\t\trl[rlpos].vcn = rl[rlpos - 1].vcn +\n\t\t\t\t\t\t\tprev_run_len;\n\t\t\t\t} else {\n\t\t\t\t\tntfs_debug(\"Adding new run, is first \"\n\t\t\t\t\t\t\t\"run.\");\n\t\t\t\t\trl[rlpos].vcn = start_vcn;\n\t\t\t\t}\n\t\t\t\trl[rlpos].lcn = prev_lcn = lcn + bmp_pos;\n\t\t\t\trl[rlpos].length = prev_run_len = 1;\n\t\t\t\trlpos++;\n\t\t\t}\n\t\t\t/* Done? */\n\t\t\tif (!--clusters) {\n\t\t\t\tLCN tc;\n\t\t\t\t/*\n\t\t\t\t * Update the current zone position.  Positions\n\t\t\t\t * of already scanned zones have been updated\n\t\t\t\t * during the respective zone switches.\n\t\t\t\t */\n\t\t\t\ttc = lcn + bmp_pos + 1;\n\t\t\t\tntfs_debug(\"Done. Updating current zone \"\n\t\t\t\t\t\t\"position, tc 0x%llx, \"\n\t\t\t\t\t\t\"search_zone %i.\",\n\t\t\t\t\t\t(unsigned long long)tc,\n\t\t\t\t\t\tsearch_zone);\n\t\t\t\tswitch (search_zone) {\n\t\t\t\tcase 1:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tntfs_debug(\"Finished.  Going to out.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlcn++;\n\t\t}\n\t\tbmp_pos += buf_size;\n\t\tntfs_debug(\"After inner while loop: buf_size 0x%x, lcn \"\n\t\t\t\t\"0x%llx, bmp_pos 0x%llx, need_writeback %i.\",\n\t\t\t\tbuf_size, (unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\tif (bmp_pos < zone_end) {\n\t\t\tntfs_debug(\"Continuing outer while loop, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tcontinue;\n\t\t}\nzone_pass_done:\t/* Finished with the current zone pass. */\n\t\tntfs_debug(\"At zone_pass_done, pass %i.\", pass);\n\t\tif (pass == 1) {\n\t\t\t/*\n\t\t\t * Now do pass 2, scanning the first part of the zone\n\t\t\t * we omitted in pass 1.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t\tzone_end = zone_start;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1: /* mft_zone */\n\t\t\t\tzone_start = vol->mft_zone_start;\n\t\t\t\tbreak;\n\t\t\tcase 2: /* data1_zone */\n\t\t\t\tzone_start = vol->mft_zone_end;\n\t\t\t\tbreak;\n\t\t\tcase 4: /* data2_zone */\n\t\t\t\tzone_start = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* Sanity check. */\n\t\t\tif (zone_end < zone_start)\n\t\t\t\tzone_end = zone_start;\n\t\t\tbmp_pos = zone_start;\n\t\t\tntfs_debug(\"Continuing outer while loop, pass 2, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx.\",\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t\t(unsigned long long)bmp_pos);\n\t\t\tcontinue;\n\t\t} /* pass == 2 */\ndone_zones_check:\n\t\tntfs_debug(\"At done_zones_check, search_zone %i, done_zones \"\n\t\t\t\t\"before 0x%x, done_zones after 0x%x.\",\n\t\t\t\tsearch_zone, done_zones,\n\t\t\t\tdone_zones | search_zone);\n\t\tdone_zones |= search_zone;\n\t\tif (done_zones < 7) {\n\t\t\tntfs_debug(\"Switching zone.\");\n\t\t\t/* Now switch to the next zone we haven't done yet. */\n\t\t\tpass = 1;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1:\n\t\t\t\tntfs_debug(\"Switching from mft zone to data1 \"\n\t\t\t\t\t\t\"zone.\");\n\t\t\t\t/* Update mft zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from mft zone to data1 zone. */\nswitch_to_data1_zone:\t\tsearch_zone = 2;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data1_zone_pos;\n\t\t\t\tzone_end = vol->nr_clusters;\n\t\t\t\tif (zone_start == vol->mft_zone_end)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data1_zone_pos = zone_start =\n\t\t\t\t\t\t\tvol->mft_zone_end;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tntfs_debug(\"Switching from data1 zone to \"\n\t\t\t\t\t\t\"data2 zone.\");\n\t\t\t\t/* Update data1 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data1 zone to data2 zone. */\n\t\t\t\tsearch_zone = 4;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data2_zone_pos;\n\t\t\t\tzone_end = vol->mft_zone_start;\n\t\t\t\tif (!zone_start)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data2_zone_pos = zone_start =\n\t\t\t\t\t\t\tbmp_initial_pos = 0;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tntfs_debug(\"Switching from data2 zone to \"\n\t\t\t\t\t\t\"data1 zone.\");\n\t\t\t\t/* Update data2 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data2 zone to data1 zone. */\n\t\t\t\tgoto switch_to_data1_zone;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tntfs_debug(\"After zone switch, search_zone %i, \"\n\t\t\t\t\t\"pass %i, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\tsearch_zone, pass,\n\t\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tbmp_pos = zone_start;\n\t\t\tif (zone_start == zone_end) {\n\t\t\t\tntfs_debug(\"Empty zone, going to \"\n\t\t\t\t\t\t\"done_zones_check.\");\n\t\t\t\t/* Empty zone. Don't bother searching it. */\n\t\t\t\tgoto done_zones_check;\n\t\t\t}\n\t\t\tntfs_debug(\"Continuing outer while loop.\");\n\t\t\tcontinue;\n\t\t} /* done_zones == 7 */\n\t\tntfs_debug(\"All zones are finished.\");\n\t\t/*\n\t\t * All zones are finished!  If DATA_ZONE, shrink mft zone.  If\n\t\t * MFT_ZONE, we have really run out of space.\n\t\t */\n\t\tmft_zone_size = vol->mft_zone_end - vol->mft_zone_start;\n\t\tntfs_debug(\"vol->mft_zone_start 0x%llx, vol->mft_zone_end \"\n\t\t\t\t\"0x%llx, mft_zone_size 0x%llx.\",\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)mft_zone_size);\n\t\tif (zone == MFT_ZONE || mft_zone_size <= 0) {\n\t\t\tntfs_debug(\"No free clusters left, going to out.\");\n\t\t\t/* Really no more space left on device. */\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out;\n\t\t} /* zone == DATA_ZONE && mft_zone_size > 0 */\n\t\tntfs_debug(\"Shrinking mft zone.\");\n\t\tzone_end = vol->mft_zone_end;\n\t\tmft_zone_size >>= 1;\n\t\tif (mft_zone_size > 0)\n\t\t\tvol->mft_zone_end = vol->mft_zone_start + mft_zone_size;\n\t\telse /* mft zone and data2 zone no longer exist. */\n\t\t\tvol->data2_zone_pos = vol->mft_zone_start =\n\t\t\t\t\tvol->mft_zone_end = 0;\n\t\tif (vol->mft_zone_pos >= vol->mft_zone_end) {\n\t\t\tvol->mft_zone_pos = vol->mft_lcn;\n\t\t\tif (!vol->mft_zone_end)\n\t\t\t\tvol->mft_zone_pos = 0;\n\t\t}\n\t\tbmp_pos = zone_start = bmp_initial_pos =\n\t\t\t\tvol->data1_zone_pos = vol->mft_zone_end;\n\t\tsearch_zone = 2;\n\t\tpass = 2;\n\t\tdone_zones &= ~2;\n\t\tntfs_debug(\"After shrinking mft zone, mft_zone_size 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_start 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_end 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_pos 0x%llx, search_zone 2, \"\n\t\t\t\t\"pass 2, dones_zones 0x%x, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, vol->data1_zone_pos 0x%llx, \"\n\t\t\t\t\"continuing outer while loop.\",\n\t\t\t\t(unsigned long long)mft_zone_size,\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)vol->mft_zone_pos,\n\t\t\t\tdone_zones, (unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)vol->data1_zone_pos);\n\t}\n\tntfs_debug(\"After outer while loop.\");\nout:\n\tntfs_debug(\"At out.\");\n\t/* Add runlist terminator element. */\n\tif (likely(rl)) {\n\t\trl[rlpos].vcn = rl[rlpos - 1].vcn + rl[rlpos - 1].length;\n\t\trl[rlpos].lcn = is_extension ? LCN_ENOENT : LCN_RL_NOT_MAPPED;\n\t\trl[rlpos].length = 0;\n\t}\n\tif (likely(page && !IS_ERR(page))) {\n\t\tif (need_writeback) {\n\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\tflush_dcache_page(page);\n\t\t\tset_page_dirty(page);\n\t\t\tneed_writeback = 0;\n\t\t}\n\t\tntfs_unmap_page(page);\n\t}\n\tif (likely(!err)) {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_debug(\"Done.\");\n\t\treturn rl;\n\t}\n\tntfs_error(vol->sb, \"Failed to allocate clusters, aborting \"\n\t\t\t\"(error %i).\", err);\n\tif (rl) {\n\t\tint err2;\n\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_debug(\"Not enough space to complete allocation, \"\n\t\t\t\t\t\"err -ENOSPC, first free lcn 0x%llx, \"\n\t\t\t\t\t\"could allocate up to 0x%llx \"\n\t\t\t\t\t\"clusters.\",\n\t\t\t\t\t(unsigned long long)rl[0].lcn,\n\t\t\t\t\t(unsigned long long)(count - clusters));\n\t\t/* Deallocate all allocated clusters. */\n\t\tntfs_debug(\"Attempting rollback...\");\n\t\terr2 = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\t\tif (err2) {\n\t\t\tntfs_error(vol->sb, \"Failed to rollback (error %i).  \"\n\t\t\t\t\t\"Leaving inconsistent metadata!  \"\n\t\t\t\t\t\"Unmount and run chkdsk.\", err2);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\t/* Free the runlist. */\n\t\tntfs_free(rl);\n\t} else if (err == -ENOSPC)\n\t\tntfs_debug(\"No space left at all, err = -ENOSPC, first free \"\n\t\t\t\t\"lcn = 0x%llx.\",\n\t\t\t\t(long long)vol->data1_zone_pos);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rl"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_mapping_pairs_decompress",
          "args": [
            "vol",
            "a",
            "ni->runlist.rl"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_mapping_pairs_decompress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "749-978",
          "snippet": "runlist_element *ntfs_mapping_pairs_decompress(const ntfs_volume *vol,\n\t\tconst ATTR_RECORD *attr, runlist_element *old_rl)\n{\n\tVCN vcn;\t\t/* Current vcn. */\n\tLCN lcn;\t\t/* Current lcn. */\n\ts64 deltaxcn;\t\t/* Change in [vl]cn. */\n\trunlist_element *rl;\t/* The output runlist. */\n\tu8 *buf;\t\t/* Current position in mapping pairs array. */\n\tu8 *attr_end;\t\t/* End of attribute. */\n\tint rlsize;\t\t/* Size of runlist buffer. */\n\tu16 rlpos;\t\t/* Current runlist position in units of\n\t\t\t\t   runlist_elements. */\n\tu8 b;\t\t\t/* Current byte offset in buf. */\n\n#ifdef DEBUG\n\t/* Make sure attr exists and is non-resident. */\n\tif (!attr || !attr->non_resident || sle64_to_cpu(\n\t\t\tattr->data.non_resident.lowest_vcn) < (VCN)0) {\n\t\tntfs_error(vol->sb, \"Invalid arguments.\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\t/* Start at vcn = lowest_vcn and lcn 0. */\n\tvcn = sle64_to_cpu(attr->data.non_resident.lowest_vcn);\n\tlcn = 0;\n\t/* Get start of the mapping pairs array. */\n\tbuf = (u8*)attr + le16_to_cpu(\n\t\t\tattr->data.non_resident.mapping_pairs_offset);\n\tattr_end = (u8*)attr + le32_to_cpu(attr->length);\n\tif (unlikely(buf < (u8*)attr || buf > attr_end)) {\n\t\tntfs_error(vol->sb, \"Corrupt attribute.\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\t/* If the mapping pairs array is valid but empty, nothing to do. */\n\tif (!vcn && !*buf)\n\t\treturn old_rl;\n\t/* Current position in runlist array. */\n\trlpos = 0;\n\t/* Allocate first page and set current runlist size to one page. */\n\trl = ntfs_malloc_nofs(rlsize = PAGE_SIZE);\n\tif (unlikely(!rl))\n\t\treturn ERR_PTR(-ENOMEM);\n\t/* Insert unmapped starting element if necessary. */\n\tif (vcn) {\n\t\trl->vcn = 0;\n\t\trl->lcn = LCN_RL_NOT_MAPPED;\n\t\trl->length = vcn;\n\t\trlpos++;\n\t}\n\twhile (buf < attr_end && *buf) {\n\t\t/*\n\t\t * Allocate more memory if needed, including space for the\n\t\t * not-mapped and terminator elements. ntfs_malloc_nofs()\n\t\t * operates on whole pages only.\n\t\t */\n\t\tif (((rlpos + 3) * sizeof(*old_rl)) > rlsize) {\n\t\t\trunlist_element *rl2;\n\n\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\tif (unlikely(!rl2)) {\n\t\t\t\tntfs_free(rl);\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t}\n\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\tntfs_free(rl);\n\t\t\trl = rl2;\n\t\t\trlsize += PAGE_SIZE;\n\t\t}\n\t\t/* Enter the current vcn into the current runlist element. */\n\t\trl[rlpos].vcn = vcn;\n\t\t/*\n\t\t * Get the change in vcn, i.e. the run length in clusters.\n\t\t * Doing it this way ensures that we signextend negative values.\n\t\t * A negative run length doesn't make any sense, but hey, I\n\t\t * didn't make up the NTFS specs and Windows NT4 treats the run\n\t\t * length as a signed value so that's how it is...\n\t\t */\n\t\tb = *buf & 0xf;\n\t\tif (b) {\n\t\t\tif (unlikely(buf + b > attr_end))\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t} else { /* The length entry is compulsory. */\n\t\t\tntfs_error(vol->sb, \"Missing length entry in mapping \"\n\t\t\t\t\t\"pairs array.\");\n\t\t\tdeltaxcn = (s64)-1;\n\t\t}\n\t\t/*\n\t\t * Assume a negative length to indicate data corruption and\n\t\t * hence clean-up and return NULL.\n\t\t */\n\t\tif (unlikely(deltaxcn < 0)) {\n\t\t\tntfs_error(vol->sb, \"Invalid length in mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\t/*\n\t\t * Enter the current run length into the current runlist\n\t\t * element.\n\t\t */\n\t\trl[rlpos].length = deltaxcn;\n\t\t/* Increment the current vcn by the current run length. */\n\t\tvcn += deltaxcn;\n\t\t/*\n\t\t * There might be no lcn change at all, as is the case for\n\t\t * sparse clusters on NTFS 3.0+, in which case we set the lcn\n\t\t * to LCN_HOLE.\n\t\t */\n\t\tif (!(*buf & 0xf0))\n\t\t\trl[rlpos].lcn = LCN_HOLE;\n\t\telse {\n\t\t\t/* Get the lcn change which really can be negative. */\n\t\t\tu8 b2 = *buf & 0xf;\n\t\t\tb = b2 + ((*buf >> 4) & 0xf);\n\t\t\tif (buf + b > attr_end)\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b > b2; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t\t/* Change the current lcn to its new value. */\n\t\t\tlcn += deltaxcn;\n#ifdef DEBUG\n\t\t\t/*\n\t\t\t * On NTFS 1.2-, apparently can have lcn == -1 to\n\t\t\t * indicate a hole. But we haven't verified ourselves\n\t\t\t * whether it is really the lcn or the deltaxcn that is\n\t\t\t * -1. So if either is found give us a message so we\n\t\t\t * can investigate it further!\n\t\t\t */\n\t\t\tif (vol->major_ver < 3) {\n\t\t\t\tif (unlikely(deltaxcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn delta == -1\");\n\t\t\t\tif (unlikely(lcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn == -1\");\n\t\t\t}\n#endif\n\t\t\t/* Check lcn is not below -1. */\n\t\t\tif (unlikely(lcn < (LCN)-1)) {\n\t\t\t\tntfs_error(vol->sb, \"Invalid LCN < -1 in \"\n\t\t\t\t\t\t\"mapping pairs array.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t/* Enter the current lcn into the runlist element. */\n\t\t\trl[rlpos].lcn = lcn;\n\t\t}\n\t\t/* Get to the next runlist element. */\n\t\trlpos++;\n\t\t/* Increment the buffer position to the next mapping pair. */\n\t\tbuf += (*buf & 0xf) + ((*buf >> 4) & 0xf) + 1;\n\t}\n\tif (unlikely(buf >= attr_end))\n\t\tgoto io_error;\n\t/*\n\t * If there is a highest_vcn specified, it must be equal to the final\n\t * vcn in the runlist - 1, or something has gone badly wrong.\n\t */\n\tdeltaxcn = sle64_to_cpu(attr->data.non_resident.highest_vcn);\n\tif (unlikely(deltaxcn && vcn - 1 != deltaxcn)) {\nmpa_err:\n\t\tntfs_error(vol->sb, \"Corrupt mapping pairs array in \"\n\t\t\t\t\"non-resident attribute.\");\n\t\tgoto err_out;\n\t}\n\t/* Setup not mapped runlist element if this is the base extent. */\n\tif (!attr->data.non_resident.lowest_vcn) {\n\t\tVCN max_cluster;\n\n\t\tmax_cluster = ((sle64_to_cpu(\n\t\t\t\tattr->data.non_resident.allocated_size) +\n\t\t\t\tvol->cluster_size - 1) >>\n\t\t\t\tvol->cluster_size_bits) - 1;\n\t\t/*\n\t\t * A highest_vcn of zero means this is a single extent\n\t\t * attribute so simply terminate the runlist with LCN_ENOENT).\n\t\t */\n\t\tif (deltaxcn) {\n\t\t\t/*\n\t\t\t * If there is a difference between the highest_vcn and\n\t\t\t * the highest cluster, the runlist is either corrupt\n\t\t\t * or, more likely, there are more extents following\n\t\t\t * this one.\n\t\t\t */\n\t\t\tif (deltaxcn < max_cluster) {\n\t\t\t\tntfs_debug(\"More extents to follow; deltaxcn \"\n\t\t\t\t\t\t\"= 0x%llx, max_cluster = \"\n\t\t\t\t\t\t\"0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\trl[rlpos].vcn = vcn;\n\t\t\t\tvcn += rl[rlpos].length = max_cluster -\n\t\t\t\t\t\tdeltaxcn;\n\t\t\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\trlpos++;\n\t\t\t} else if (unlikely(deltaxcn > max_cluster)) {\n\t\t\t\tntfs_error(vol->sb, \"Corrupt attribute.  \"\n\t\t\t\t\t\t\"deltaxcn = 0x%llx, \"\n\t\t\t\t\t\t\"max_cluster = 0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\tgoto mpa_err;\n\t\t\t}\n\t\t}\n\t\trl[rlpos].lcn = LCN_ENOENT;\n\t} else /* Not the base extent. There may be more extents to follow. */\n\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\n\t/* Setup terminating runlist element. */\n\trl[rlpos].vcn = vcn;\n\trl[rlpos].length = (s64)0;\n\t/* If no existing runlist was specified, we are done. */\n\tif (!old_rl) {\n\t\tntfs_debug(\"Mapping pairs array successfully decompressed:\");\n\t\tntfs_debug_dump_runlist(rl);\n\t\treturn rl;\n\t}\n\t/* Now combine the new and old runlists checking for overlaps. */\n\told_rl = ntfs_runlists_merge(old_rl, rl);\n\tif (likely(!IS_ERR(old_rl)))\n\t\treturn old_rl;\n\tntfs_free(rl);\n\tntfs_error(vol->sb, \"Failed to merge runlists.\");\n\treturn old_rl;\nio_error:\n\tntfs_error(vol->sb, \"Corrupt attribute.\");\nerr_out:\n\tntfs_free(rl);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nrunlist_element *ntfs_mapping_pairs_decompress(const ntfs_volume *vol,\n\t\tconst ATTR_RECORD *attr, runlist_element *old_rl)\n{\n\tVCN vcn;\t\t/* Current vcn. */\n\tLCN lcn;\t\t/* Current lcn. */\n\ts64 deltaxcn;\t\t/* Change in [vl]cn. */\n\trunlist_element *rl;\t/* The output runlist. */\n\tu8 *buf;\t\t/* Current position in mapping pairs array. */\n\tu8 *attr_end;\t\t/* End of attribute. */\n\tint rlsize;\t\t/* Size of runlist buffer. */\n\tu16 rlpos;\t\t/* Current runlist position in units of\n\t\t\t\t   runlist_elements. */\n\tu8 b;\t\t\t/* Current byte offset in buf. */\n\n#ifdef DEBUG\n\t/* Make sure attr exists and is non-resident. */\n\tif (!attr || !attr->non_resident || sle64_to_cpu(\n\t\t\tattr->data.non_resident.lowest_vcn) < (VCN)0) {\n\t\tntfs_error(vol->sb, \"Invalid arguments.\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\t/* Start at vcn = lowest_vcn and lcn 0. */\n\tvcn = sle64_to_cpu(attr->data.non_resident.lowest_vcn);\n\tlcn = 0;\n\t/* Get start of the mapping pairs array. */\n\tbuf = (u8*)attr + le16_to_cpu(\n\t\t\tattr->data.non_resident.mapping_pairs_offset);\n\tattr_end = (u8*)attr + le32_to_cpu(attr->length);\n\tif (unlikely(buf < (u8*)attr || buf > attr_end)) {\n\t\tntfs_error(vol->sb, \"Corrupt attribute.\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\t/* If the mapping pairs array is valid but empty, nothing to do. */\n\tif (!vcn && !*buf)\n\t\treturn old_rl;\n\t/* Current position in runlist array. */\n\trlpos = 0;\n\t/* Allocate first page and set current runlist size to one page. */\n\trl = ntfs_malloc_nofs(rlsize = PAGE_SIZE);\n\tif (unlikely(!rl))\n\t\treturn ERR_PTR(-ENOMEM);\n\t/* Insert unmapped starting element if necessary. */\n\tif (vcn) {\n\t\trl->vcn = 0;\n\t\trl->lcn = LCN_RL_NOT_MAPPED;\n\t\trl->length = vcn;\n\t\trlpos++;\n\t}\n\twhile (buf < attr_end && *buf) {\n\t\t/*\n\t\t * Allocate more memory if needed, including space for the\n\t\t * not-mapped and terminator elements. ntfs_malloc_nofs()\n\t\t * operates on whole pages only.\n\t\t */\n\t\tif (((rlpos + 3) * sizeof(*old_rl)) > rlsize) {\n\t\t\trunlist_element *rl2;\n\n\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\tif (unlikely(!rl2)) {\n\t\t\t\tntfs_free(rl);\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t}\n\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\tntfs_free(rl);\n\t\t\trl = rl2;\n\t\t\trlsize += PAGE_SIZE;\n\t\t}\n\t\t/* Enter the current vcn into the current runlist element. */\n\t\trl[rlpos].vcn = vcn;\n\t\t/*\n\t\t * Get the change in vcn, i.e. the run length in clusters.\n\t\t * Doing it this way ensures that we signextend negative values.\n\t\t * A negative run length doesn't make any sense, but hey, I\n\t\t * didn't make up the NTFS specs and Windows NT4 treats the run\n\t\t * length as a signed value so that's how it is...\n\t\t */\n\t\tb = *buf & 0xf;\n\t\tif (b) {\n\t\t\tif (unlikely(buf + b > attr_end))\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t} else { /* The length entry is compulsory. */\n\t\t\tntfs_error(vol->sb, \"Missing length entry in mapping \"\n\t\t\t\t\t\"pairs array.\");\n\t\t\tdeltaxcn = (s64)-1;\n\t\t}\n\t\t/*\n\t\t * Assume a negative length to indicate data corruption and\n\t\t * hence clean-up and return NULL.\n\t\t */\n\t\tif (unlikely(deltaxcn < 0)) {\n\t\t\tntfs_error(vol->sb, \"Invalid length in mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\t/*\n\t\t * Enter the current run length into the current runlist\n\t\t * element.\n\t\t */\n\t\trl[rlpos].length = deltaxcn;\n\t\t/* Increment the current vcn by the current run length. */\n\t\tvcn += deltaxcn;\n\t\t/*\n\t\t * There might be no lcn change at all, as is the case for\n\t\t * sparse clusters on NTFS 3.0+, in which case we set the lcn\n\t\t * to LCN_HOLE.\n\t\t */\n\t\tif (!(*buf & 0xf0))\n\t\t\trl[rlpos].lcn = LCN_HOLE;\n\t\telse {\n\t\t\t/* Get the lcn change which really can be negative. */\n\t\t\tu8 b2 = *buf & 0xf;\n\t\t\tb = b2 + ((*buf >> 4) & 0xf);\n\t\t\tif (buf + b > attr_end)\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b > b2; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t\t/* Change the current lcn to its new value. */\n\t\t\tlcn += deltaxcn;\n#ifdef DEBUG\n\t\t\t/*\n\t\t\t * On NTFS 1.2-, apparently can have lcn == -1 to\n\t\t\t * indicate a hole. But we haven't verified ourselves\n\t\t\t * whether it is really the lcn or the deltaxcn that is\n\t\t\t * -1. So if either is found give us a message so we\n\t\t\t * can investigate it further!\n\t\t\t */\n\t\t\tif (vol->major_ver < 3) {\n\t\t\t\tif (unlikely(deltaxcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn delta == -1\");\n\t\t\t\tif (unlikely(lcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn == -1\");\n\t\t\t}\n#endif\n\t\t\t/* Check lcn is not below -1. */\n\t\t\tif (unlikely(lcn < (LCN)-1)) {\n\t\t\t\tntfs_error(vol->sb, \"Invalid LCN < -1 in \"\n\t\t\t\t\t\t\"mapping pairs array.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t/* Enter the current lcn into the runlist element. */\n\t\t\trl[rlpos].lcn = lcn;\n\t\t}\n\t\t/* Get to the next runlist element. */\n\t\trlpos++;\n\t\t/* Increment the buffer position to the next mapping pair. */\n\t\tbuf += (*buf & 0xf) + ((*buf >> 4) & 0xf) + 1;\n\t}\n\tif (unlikely(buf >= attr_end))\n\t\tgoto io_error;\n\t/*\n\t * If there is a highest_vcn specified, it must be equal to the final\n\t * vcn in the runlist - 1, or something has gone badly wrong.\n\t */\n\tdeltaxcn = sle64_to_cpu(attr->data.non_resident.highest_vcn);\n\tif (unlikely(deltaxcn && vcn - 1 != deltaxcn)) {\nmpa_err:\n\t\tntfs_error(vol->sb, \"Corrupt mapping pairs array in \"\n\t\t\t\t\"non-resident attribute.\");\n\t\tgoto err_out;\n\t}\n\t/* Setup not mapped runlist element if this is the base extent. */\n\tif (!attr->data.non_resident.lowest_vcn) {\n\t\tVCN max_cluster;\n\n\t\tmax_cluster = ((sle64_to_cpu(\n\t\t\t\tattr->data.non_resident.allocated_size) +\n\t\t\t\tvol->cluster_size - 1) >>\n\t\t\t\tvol->cluster_size_bits) - 1;\n\t\t/*\n\t\t * A highest_vcn of zero means this is a single extent\n\t\t * attribute so simply terminate the runlist with LCN_ENOENT).\n\t\t */\n\t\tif (deltaxcn) {\n\t\t\t/*\n\t\t\t * If there is a difference between the highest_vcn and\n\t\t\t * the highest cluster, the runlist is either corrupt\n\t\t\t * or, more likely, there are more extents following\n\t\t\t * this one.\n\t\t\t */\n\t\t\tif (deltaxcn < max_cluster) {\n\t\t\t\tntfs_debug(\"More extents to follow; deltaxcn \"\n\t\t\t\t\t\t\"= 0x%llx, max_cluster = \"\n\t\t\t\t\t\t\"0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\trl[rlpos].vcn = vcn;\n\t\t\t\tvcn += rl[rlpos].length = max_cluster -\n\t\t\t\t\t\tdeltaxcn;\n\t\t\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\trlpos++;\n\t\t\t} else if (unlikely(deltaxcn > max_cluster)) {\n\t\t\t\tntfs_error(vol->sb, \"Corrupt attribute.  \"\n\t\t\t\t\t\t\"deltaxcn = 0x%llx, \"\n\t\t\t\t\t\t\"max_cluster = 0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\tgoto mpa_err;\n\t\t\t}\n\t\t}\n\t\trl[rlpos].lcn = LCN_ENOENT;\n\t} else /* Not the base extent. There may be more extents to follow. */\n\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\n\t/* Setup terminating runlist element. */\n\trl[rlpos].vcn = vcn;\n\trl[rlpos].length = (s64)0;\n\t/* If no existing runlist was specified, we are done. */\n\tif (!old_rl) {\n\t\tntfs_debug(\"Mapping pairs array successfully decompressed:\");\n\t\tntfs_debug_dump_runlist(rl);\n\t\treturn rl;\n\t}\n\t/* Now combine the new and old runlists checking for overlaps. */\n\told_rl = ntfs_runlists_merge(old_rl, rl);\n\tif (likely(!IS_ERR(old_rl)))\n\t\treturn old_rl;\n\tntfs_free(rl);\n\tntfs_error(vol->sb, \"Failed to merge runlists.\");\n\treturn old_rl;\nio_error:\n\tntfs_error(vol->sb, \"Corrupt attribute.\");\nerr_out:\n\tntfs_free(rl);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rl || rl->lcn == LCN_RL_NOT_MAPPED ||\n\t\t\t(rl->lcn == LCN_ENOENT && rl > ni->runlist.rl &&\n\t\t\t(rl-1)->lcn == LCN_RL_NOT_MAPPED)"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Inserting holes is not-implemented yet.  Falling back to \"\n\t\t\t\"allocating real clusters instead.\""
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoSparseDisabled",
          "args": [
            "ni"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSparseEnabled",
          "args": [
            "vol"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vcn"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!NInoNonResident(ni)"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"This attribute type may not be \"\n\t\t\t\t\t\"non-resident.  This case is not \"\n\t\t\t\t\t\"implemented yet.\""
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Not enough space in the mft \"\n\t\t\t\t\t\"record/on disk for the non-resident \"\n\t\t\t\t\t\"attribute value.  This case is not \"\n\t\t\t\t\t\"implemented yet.\""
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err != -EPERM && err != -ENOSPC"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_make_non_resident",
          "args": [
            "ni",
            "attr_len"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_make_non_resident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1535-1843",
          "snippet": "int ntfs_attr_make_non_resident(ntfs_inode *ni, const u32 data_size)\n{\n\ts64 new_size;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_volume *vol = ni->vol;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tstruct page *page;\n\trunlist_element *rl;\n\tu8 *kaddr;\n\tunsigned long flags;\n\tint mp_size, mp_ofs, name_ofs, arec_size, err, err2;\n\tu32 attr_size;\n\tu8 old_res_attr_flags;\n\n\t/* Check that the attribute is allowed to be non-resident. */\n\terr = ntfs_attr_can_be_non_resident(vol, ni->type);\n\tif (unlikely(err)) {\n\t\tif (err == -EPERM)\n\t\t\tntfs_debug(\"Attribute is not allowed to be \"\n\t\t\t\t\t\"non-resident.\");\n\t\telse\n\t\t\tntfs_debug(\"Attribute not defined on the NTFS \"\n\t\t\t\t\t\"volume!\");\n\t\treturn err;\n\t}\n\t/*\n\t * FIXME: Compressed and encrypted attributes are not supported when\n\t * writing and we should never have gotten here for them.\n\t */\n\tBUG_ON(NInoCompressed(ni));\n\tBUG_ON(NInoEncrypted(ni));\n\t/*\n\t * The size needs to be aligned to a cluster boundary for allocation\n\t * purposes.\n\t */\n\tnew_size = (data_size + vol->cluster_size - 1) &\n\t\t\t~(vol->cluster_size - 1);\n\tif (new_size > 0) {\n\t\t/*\n\t\t * Will need the page later and since the page lock nests\n\t\t * outside all ntfs locks, we need to get the page now.\n\t\t */\n\t\tpage = find_or_create_page(vi->i_mapping, 0,\n\t\t\t\tmapping_gfp_mask(vi->i_mapping));\n\t\tif (unlikely(!page))\n\t\t\treturn -ENOMEM;\n\t\t/* Start by allocating clusters to hold the attribute value. */\n\t\trl = ntfs_cluster_alloc(vol, 0, new_size >>\n\t\t\t\tvol->cluster_size_bits, -1, DATA_ZONE, true);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tntfs_debug(\"Failed to allocate cluster%s, error code \"\n\t\t\t\t\t\"%i.\", (new_size >>\n\t\t\t\t\tvol->cluster_size_bits) > 1 ? \"s\" : \"\",\n\t\t\t\t\terr);\n\t\t\tgoto page_err_out;\n\t\t}\n\t} else {\n\t\trl = NULL;\n\t\tpage = NULL;\n\t}\n\t/* Determine the size of the mapping pairs array. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl, 0, -1);\n\tif (unlikely(mp_size < 0)) {\n\t\terr = mp_size;\n\t\tntfs_debug(\"Failed to get size for mapping pairs array, error \"\n\t\t\t\t\"code %i.\", err);\n\t\tgoto rl_err_out;\n\t}\n\tdown_write(&ni->runlist.lock);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tBUG_ON(NInoNonResident(ni));\n\tBUG_ON(a->non_resident);\n\t/*\n\t * Calculate new offsets for the name and the mapping pairs array.\n\t */\n\tif (NInoSparse(ni) || NInoCompressed(ni))\n\t\tname_ofs = (offsetof(ATTR_REC,\n\t\t\t\tdata.non_resident.compressed_size) +\n\t\t\t\tsizeof(a->data.non_resident.compressed_size) +\n\t\t\t\t7) & ~7;\n\telse\n\t\tname_ofs = (offsetof(ATTR_REC,\n\t\t\t\tdata.non_resident.compressed_size) + 7) & ~7;\n\tmp_ofs = (name_ofs + a->name_length * sizeof(ntfschar) + 7) & ~7;\n\t/*\n\t * Determine the size of the resident part of the now non-resident\n\t * attribute record.\n\t */\n\tarec_size = (mp_ofs + mp_size + 7) & ~7;\n\t/*\n\t * If the page is not uptodate bring it uptodate by copying from the\n\t * attribute value.\n\t */\n\tattr_size = le32_to_cpu(a->data.resident.value_length);\n\tBUG_ON(attr_size != data_size);\n\tif (page && !PageUptodate(page)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(kaddr, (u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset),\n\t\t\t\tattr_size);\n\t\tmemset(kaddr + attr_size, 0, PAGE_CACHE_SIZE - attr_size);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t}\n\t/* Backup the attribute flag. */\n\told_res_attr_flags = a->data.resident.flags;\n\t/* Resize the resident part of the attribute record. */\n\terr = ntfs_attr_record_resize(m, a, arec_size);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\t/*\n\t * Convert the resident part of the attribute record to describe a\n\t * non-resident attribute.\n\t */\n\ta->non_resident = 1;\n\t/* Move the attribute name if it exists and update the offset. */\n\tif (a->name_length)\n\t\tmemmove((u8*)a + name_ofs, (u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\ta->name_length * sizeof(ntfschar));\n\ta->name_offset = cpu_to_le16(name_ofs);\n\t/* Setup the fields specific to non-resident attributes. */\n\ta->data.non_resident.lowest_vcn = 0;\n\ta->data.non_resident.highest_vcn = cpu_to_sle64((new_size - 1) >>\n\t\t\tvol->cluster_size_bits);\n\ta->data.non_resident.mapping_pairs_offset = cpu_to_le16(mp_ofs);\n\tmemset(&a->data.non_resident.reserved, 0,\n\t\t\tsizeof(a->data.non_resident.reserved));\n\ta->data.non_resident.allocated_size = cpu_to_sle64(new_size);\n\ta->data.non_resident.data_size =\n\t\t\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(attr_size);\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\ta->data.non_resident.compression_unit = 0;\n\t\tif (NInoCompressed(ni) || vol->major_ver < 3)\n\t\t\ta->data.non_resident.compression_unit = 4;\n\t\ta->data.non_resident.compressed_size =\n\t\t\t\ta->data.non_resident.allocated_size;\n\t} else\n\t\ta->data.non_resident.compression_unit = 0;\n\t/* Generate the mapping pairs array into the attribute record. */\n\terr = ntfs_mapping_pairs_build(vol, (u8*)a + mp_ofs,\n\t\t\tarec_size - mp_ofs, rl, 0, -1, NULL);\n\tif (unlikely(err)) {\n\t\tntfs_debug(\"Failed to build mapping pairs, error code %i.\",\n\t\t\t\terr);\n\t\tgoto undo_err_out;\n\t}\n\t/* Setup the in-memory attribute structure to be non-resident. */\n\tni->runlist.rl = rl;\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = new_size;\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\tni->itype.compressed.size = ni->allocated_size;\n\t\tif (a->data.non_resident.compression_unit) {\n\t\t\tni->itype.compressed.block_size = 1U << (a->data.\n\t\t\t\t\tnon_resident.compression_unit +\n\t\t\t\t\tvol->cluster_size_bits);\n\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\tffs(ni->itype.compressed.block_size) -\n\t\t\t\t\t1;\n\t\t\tni->itype.compressed.block_clusters = 1U <<\n\t\t\t\t\ta->data.non_resident.compression_unit;\n\t\t} else {\n\t\t\tni->itype.compressed.block_size = 0;\n\t\t\tni->itype.compressed.block_size_bits = 0;\n\t\t\tni->itype.compressed.block_clusters = 0;\n\t\t}\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t} else\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t/*\n\t * This needs to be last since the address space operations ->readpage\n\t * and ->writepage can run concurrently with us as they are not\n\t * serialized on i_mutex.  Note, we are not allowed to fail once we flip\n\t * this switch, which is another reason to do this last.\n\t */\n\tNInoSetNonResident(ni);\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\tif (page) {\n\t\tset_page_dirty(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tntfs_debug(\"Done.\");\n\treturn 0;\nundo_err_out:\n\t/* Convert the attribute back into a resident attribute. */\n\ta->non_resident = 0;\n\t/* Move the attribute name if it exists and update the offset. */\n\tname_ofs = (offsetof(ATTR_RECORD, data.resident.reserved) +\n\t\t\tsizeof(a->data.resident.reserved) + 7) & ~7;\n\tif (a->name_length)\n\t\tmemmove((u8*)a + name_ofs, (u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\ta->name_length * sizeof(ntfschar));\n\tmp_ofs = (name_ofs + a->name_length * sizeof(ntfschar) + 7) & ~7;\n\ta->name_offset = cpu_to_le16(name_ofs);\n\tarec_size = (mp_ofs + attr_size + 7) & ~7;\n\t/* Resize the resident part of the attribute record. */\n\terr2 = ntfs_attr_record_resize(m, a, arec_size);\n\tif (unlikely(err2)) {\n\t\t/*\n\t\t * This cannot happen (well if memory corruption is at work it\n\t\t * could happen in theory), but deal with it as well as we can.\n\t\t * If the old size is too small, truncate the attribute,\n\t\t * otherwise simply give it a larger allocated size.\n\t\t * FIXME: Should check whether chkdsk complains when the\n\t\t * allocated size is much bigger than the resident value size.\n\t\t */\n\t\tarec_size = le32_to_cpu(a->length);\n\t\tif ((mp_ofs + attr_size) > arec_size) {\n\t\t\terr2 = attr_size;\n\t\t\tattr_size = arec_size - mp_ofs;\n\t\t\tntfs_error(vol->sb, \"Failed to undo partial resident \"\n\t\t\t\t\t\"to non-resident attribute \"\n\t\t\t\t\t\"conversion.  Truncating inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x from %i bytes to \"\n\t\t\t\t\t\"%i bytes to maintain metadata \"\n\t\t\t\t\t\"consistency.  THIS MEANS YOU ARE \"\n\t\t\t\t\t\"LOSING %i BYTES DATA FROM THIS %s.\",\n\t\t\t\t\tvi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t\t\terr2, attr_size, err2 - attr_size,\n\t\t\t\t\t((ni->type == AT_DATA) &&\n\t\t\t\t\t!ni->name_len) ? \"FILE\": \"ATTRIBUTE\");\n\t\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t\tni->initialized_size = attr_size;\n\t\t\ti_size_write(vi, attr_size);\n\t\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t}\n\t}\n\t/* Setup the fields specific to resident attributes. */\n\ta->data.resident.value_length = cpu_to_le32(attr_size);\n\ta->data.resident.value_offset = cpu_to_le16(mp_ofs);\n\ta->data.resident.flags = old_res_attr_flags;\n\tmemset(&a->data.resident.reserved, 0,\n\t\t\tsizeof(a->data.resident.reserved));\n\t/* Copy the data from the page back to the attribute value. */\n\tif (page) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy((u8*)a + mp_ofs, kaddr, attr_size);\n\t\tkunmap_atomic(kaddr);\n\t}\n\t/* Setup the allocated size in the ntfs inode in case it changed. */\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = arec_size - mp_ofs;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tni->runlist.rl = NULL;\n\tup_write(&ni->runlist.lock);\nrl_err_out:\n\tif (rl) {\n\t\tif (ntfs_cluster_free_from_rl(vol, rl) < 0) {\n\t\t\tntfs_error(vol->sb, \"Failed to release allocated \"\n\t\t\t\t\t\"cluster(s) in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover the lost \"\n\t\t\t\t\t\"cluster(s).\");\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl);\npage_err_out:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (err == -EINVAL)\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_make_non_resident(ntfs_inode *ni, const u32 data_size)\n{\n\ts64 new_size;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_volume *vol = ni->vol;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tstruct page *page;\n\trunlist_element *rl;\n\tu8 *kaddr;\n\tunsigned long flags;\n\tint mp_size, mp_ofs, name_ofs, arec_size, err, err2;\n\tu32 attr_size;\n\tu8 old_res_attr_flags;\n\n\t/* Check that the attribute is allowed to be non-resident. */\n\terr = ntfs_attr_can_be_non_resident(vol, ni->type);\n\tif (unlikely(err)) {\n\t\tif (err == -EPERM)\n\t\t\tntfs_debug(\"Attribute is not allowed to be \"\n\t\t\t\t\t\"non-resident.\");\n\t\telse\n\t\t\tntfs_debug(\"Attribute not defined on the NTFS \"\n\t\t\t\t\t\"volume!\");\n\t\treturn err;\n\t}\n\t/*\n\t * FIXME: Compressed and encrypted attributes are not supported when\n\t * writing and we should never have gotten here for them.\n\t */\n\tBUG_ON(NInoCompressed(ni));\n\tBUG_ON(NInoEncrypted(ni));\n\t/*\n\t * The size needs to be aligned to a cluster boundary for allocation\n\t * purposes.\n\t */\n\tnew_size = (data_size + vol->cluster_size - 1) &\n\t\t\t~(vol->cluster_size - 1);\n\tif (new_size > 0) {\n\t\t/*\n\t\t * Will need the page later and since the page lock nests\n\t\t * outside all ntfs locks, we need to get the page now.\n\t\t */\n\t\tpage = find_or_create_page(vi->i_mapping, 0,\n\t\t\t\tmapping_gfp_mask(vi->i_mapping));\n\t\tif (unlikely(!page))\n\t\t\treturn -ENOMEM;\n\t\t/* Start by allocating clusters to hold the attribute value. */\n\t\trl = ntfs_cluster_alloc(vol, 0, new_size >>\n\t\t\t\tvol->cluster_size_bits, -1, DATA_ZONE, true);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tntfs_debug(\"Failed to allocate cluster%s, error code \"\n\t\t\t\t\t\"%i.\", (new_size >>\n\t\t\t\t\tvol->cluster_size_bits) > 1 ? \"s\" : \"\",\n\t\t\t\t\terr);\n\t\t\tgoto page_err_out;\n\t\t}\n\t} else {\n\t\trl = NULL;\n\t\tpage = NULL;\n\t}\n\t/* Determine the size of the mapping pairs array. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl, 0, -1);\n\tif (unlikely(mp_size < 0)) {\n\t\terr = mp_size;\n\t\tntfs_debug(\"Failed to get size for mapping pairs array, error \"\n\t\t\t\t\"code %i.\", err);\n\t\tgoto rl_err_out;\n\t}\n\tdown_write(&ni->runlist.lock);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tBUG_ON(NInoNonResident(ni));\n\tBUG_ON(a->non_resident);\n\t/*\n\t * Calculate new offsets for the name and the mapping pairs array.\n\t */\n\tif (NInoSparse(ni) || NInoCompressed(ni))\n\t\tname_ofs = (offsetof(ATTR_REC,\n\t\t\t\tdata.non_resident.compressed_size) +\n\t\t\t\tsizeof(a->data.non_resident.compressed_size) +\n\t\t\t\t7) & ~7;\n\telse\n\t\tname_ofs = (offsetof(ATTR_REC,\n\t\t\t\tdata.non_resident.compressed_size) + 7) & ~7;\n\tmp_ofs = (name_ofs + a->name_length * sizeof(ntfschar) + 7) & ~7;\n\t/*\n\t * Determine the size of the resident part of the now non-resident\n\t * attribute record.\n\t */\n\tarec_size = (mp_ofs + mp_size + 7) & ~7;\n\t/*\n\t * If the page is not uptodate bring it uptodate by copying from the\n\t * attribute value.\n\t */\n\tattr_size = le32_to_cpu(a->data.resident.value_length);\n\tBUG_ON(attr_size != data_size);\n\tif (page && !PageUptodate(page)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(kaddr, (u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset),\n\t\t\t\tattr_size);\n\t\tmemset(kaddr + attr_size, 0, PAGE_CACHE_SIZE - attr_size);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t}\n\t/* Backup the attribute flag. */\n\told_res_attr_flags = a->data.resident.flags;\n\t/* Resize the resident part of the attribute record. */\n\terr = ntfs_attr_record_resize(m, a, arec_size);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\t/*\n\t * Convert the resident part of the attribute record to describe a\n\t * non-resident attribute.\n\t */\n\ta->non_resident = 1;\n\t/* Move the attribute name if it exists and update the offset. */\n\tif (a->name_length)\n\t\tmemmove((u8*)a + name_ofs, (u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\ta->name_length * sizeof(ntfschar));\n\ta->name_offset = cpu_to_le16(name_ofs);\n\t/* Setup the fields specific to non-resident attributes. */\n\ta->data.non_resident.lowest_vcn = 0;\n\ta->data.non_resident.highest_vcn = cpu_to_sle64((new_size - 1) >>\n\t\t\tvol->cluster_size_bits);\n\ta->data.non_resident.mapping_pairs_offset = cpu_to_le16(mp_ofs);\n\tmemset(&a->data.non_resident.reserved, 0,\n\t\t\tsizeof(a->data.non_resident.reserved));\n\ta->data.non_resident.allocated_size = cpu_to_sle64(new_size);\n\ta->data.non_resident.data_size =\n\t\t\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(attr_size);\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\ta->data.non_resident.compression_unit = 0;\n\t\tif (NInoCompressed(ni) || vol->major_ver < 3)\n\t\t\ta->data.non_resident.compression_unit = 4;\n\t\ta->data.non_resident.compressed_size =\n\t\t\t\ta->data.non_resident.allocated_size;\n\t} else\n\t\ta->data.non_resident.compression_unit = 0;\n\t/* Generate the mapping pairs array into the attribute record. */\n\terr = ntfs_mapping_pairs_build(vol, (u8*)a + mp_ofs,\n\t\t\tarec_size - mp_ofs, rl, 0, -1, NULL);\n\tif (unlikely(err)) {\n\t\tntfs_debug(\"Failed to build mapping pairs, error code %i.\",\n\t\t\t\terr);\n\t\tgoto undo_err_out;\n\t}\n\t/* Setup the in-memory attribute structure to be non-resident. */\n\tni->runlist.rl = rl;\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = new_size;\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\tni->itype.compressed.size = ni->allocated_size;\n\t\tif (a->data.non_resident.compression_unit) {\n\t\t\tni->itype.compressed.block_size = 1U << (a->data.\n\t\t\t\t\tnon_resident.compression_unit +\n\t\t\t\t\tvol->cluster_size_bits);\n\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\tffs(ni->itype.compressed.block_size) -\n\t\t\t\t\t1;\n\t\t\tni->itype.compressed.block_clusters = 1U <<\n\t\t\t\t\ta->data.non_resident.compression_unit;\n\t\t} else {\n\t\t\tni->itype.compressed.block_size = 0;\n\t\t\tni->itype.compressed.block_size_bits = 0;\n\t\t\tni->itype.compressed.block_clusters = 0;\n\t\t}\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t} else\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t/*\n\t * This needs to be last since the address space operations ->readpage\n\t * and ->writepage can run concurrently with us as they are not\n\t * serialized on i_mutex.  Note, we are not allowed to fail once we flip\n\t * this switch, which is another reason to do this last.\n\t */\n\tNInoSetNonResident(ni);\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\tif (page) {\n\t\tset_page_dirty(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tntfs_debug(\"Done.\");\n\treturn 0;\nundo_err_out:\n\t/* Convert the attribute back into a resident attribute. */\n\ta->non_resident = 0;\n\t/* Move the attribute name if it exists and update the offset. */\n\tname_ofs = (offsetof(ATTR_RECORD, data.resident.reserved) +\n\t\t\tsizeof(a->data.resident.reserved) + 7) & ~7;\n\tif (a->name_length)\n\t\tmemmove((u8*)a + name_ofs, (u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\ta->name_length * sizeof(ntfschar));\n\tmp_ofs = (name_ofs + a->name_length * sizeof(ntfschar) + 7) & ~7;\n\ta->name_offset = cpu_to_le16(name_ofs);\n\tarec_size = (mp_ofs + attr_size + 7) & ~7;\n\t/* Resize the resident part of the attribute record. */\n\terr2 = ntfs_attr_record_resize(m, a, arec_size);\n\tif (unlikely(err2)) {\n\t\t/*\n\t\t * This cannot happen (well if memory corruption is at work it\n\t\t * could happen in theory), but deal with it as well as we can.\n\t\t * If the old size is too small, truncate the attribute,\n\t\t * otherwise simply give it a larger allocated size.\n\t\t * FIXME: Should check whether chkdsk complains when the\n\t\t * allocated size is much bigger than the resident value size.\n\t\t */\n\t\tarec_size = le32_to_cpu(a->length);\n\t\tif ((mp_ofs + attr_size) > arec_size) {\n\t\t\terr2 = attr_size;\n\t\t\tattr_size = arec_size - mp_ofs;\n\t\t\tntfs_error(vol->sb, \"Failed to undo partial resident \"\n\t\t\t\t\t\"to non-resident attribute \"\n\t\t\t\t\t\"conversion.  Truncating inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x from %i bytes to \"\n\t\t\t\t\t\"%i bytes to maintain metadata \"\n\t\t\t\t\t\"consistency.  THIS MEANS YOU ARE \"\n\t\t\t\t\t\"LOSING %i BYTES DATA FROM THIS %s.\",\n\t\t\t\t\tvi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t\t\terr2, attr_size, err2 - attr_size,\n\t\t\t\t\t((ni->type == AT_DATA) &&\n\t\t\t\t\t!ni->name_len) ? \"FILE\": \"ATTRIBUTE\");\n\t\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t\tni->initialized_size = attr_size;\n\t\t\ti_size_write(vi, attr_size);\n\t\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t}\n\t}\n\t/* Setup the fields specific to resident attributes. */\n\ta->data.resident.value_length = cpu_to_le32(attr_size);\n\ta->data.resident.value_offset = cpu_to_le16(mp_ofs);\n\ta->data.resident.flags = old_res_attr_flags;\n\tmemset(&a->data.resident.reserved, 0,\n\t\t\tsizeof(a->data.resident.reserved));\n\t/* Copy the data from the page back to the attribute value. */\n\tif (page) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy((u8*)a + mp_ofs, kaddr, attr_size);\n\t\tkunmap_atomic(kaddr);\n\t}\n\t/* Setup the allocated size in the ntfs inode in case it changed. */\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = arec_size - mp_ofs;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tni->runlist.rl = NULL;\n\tup_write(&ni->runlist.lock);\nrl_err_out:\n\tif (rl) {\n\t\tif (ntfs_cluster_free_from_rl(vol, rl) < 0) {\n\t\t\tntfs_error(vol->sb, \"Failed to release allocated \"\n\t\t\t\t\t\"cluster(s) in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover the lost \"\n\t\t\t\t\t\"cluster(s).\");\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl);\npage_err_out:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (err == -EINVAL)\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)new_data_size"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "new_data_size < attr_len"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoNonResident(ni)"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "new_alloc_size <= allocated_size"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "base_ni",
            "m"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_size_bounds_check",
          "args": [
            "vol",
            "ni->type",
            "new_alloc_size"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_size_bounds_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1342-1365",
          "snippet": "int ntfs_attr_size_bounds_check(const ntfs_volume *vol, const ATTR_TYPE type,\n\t\tconst s64 size)\n{\n\tATTR_DEF *ad;\n\n\tBUG_ON(size < 0);\n\t/*\n\t * $ATTRIBUTE_LIST has a maximum size of 256kiB, but this is not\n\t * listed in $AttrDef.\n\t */\n\tif (unlikely(type == AT_ATTRIBUTE_LIST && size > 256 * 1024))\n\t\treturn -ERANGE;\n\t/* Get the $AttrDef entry for the attribute @type. */\n\tad = ntfs_attr_find_in_attrdef(vol, type);\n\tif (unlikely(!ad))\n\t\treturn -ENOENT;\n\t/* Do the bounds check. */\n\tif (((sle64_to_cpu(ad->min_size) > 0) &&\n\t\t\tsize < sle64_to_cpu(ad->min_size)) ||\n\t\t\t((sle64_to_cpu(ad->max_size) > 0) && size >\n\t\t\tsle64_to_cpu(ad->max_size)))\n\t\treturn -ERANGE;\n\treturn 0;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_size_bounds_check(const ntfs_volume *vol, const ATTR_TYPE type,\n\t\tconst s64 size)\n{\n\tATTR_DEF *ad;\n\n\tBUG_ON(size < 0);\n\t/*\n\t * $ATTRIBUTE_LIST has a maximum size of 256kiB, but this is not\n\t * listed in $AttrDef.\n\t */\n\tif (unlikely(type == AT_ATTRIBUTE_LIST && size > 256 * 1024))\n\t\treturn -ERANGE;\n\t/* Get the $AttrDef entry for the attribute @type. */\n\tad = ntfs_attr_find_in_attrdef(vol, type);\n\tif (unlikely(!ad))\n\t\treturn -ENOENT;\n\t/* Do the bounds check. */\n\tif (((sle64_to_cpu(ad->min_size) > 0) &&\n\t\t\tsize < sle64_to_cpu(ad->min_size)) ||\n\t\t\t((sle64_to_cpu(ad->max_size) > 0) && size >\n\t\t\tsle64_to_cpu(ad->max_size)))\n\t\treturn -ERANGE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "new_data_size >= 0 && new_data_size > new_alloc_size"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for i_ino 0x%lx, attribute type 0x%x, \"\n\t\t\t\"old_allocated_size 0x%llx, \"\n\t\t\t\"new_allocated_size 0x%llx, new_data_size 0x%llx, \"\n\t\t\t\"data_start 0x%llx.\"",
            "vi->i_ino",
            "(unsigned)le32_to_cpu(ni->type)",
            "(unsigned long long)allocated_size",
            "(unsigned long long)new_alloc_size",
            "(unsigned long long)new_data_size",
            "(unsigned long long)start"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ni"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "245-248",
          "snippet": "static inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\ns64 ntfs_attr_extend_allocation(ntfs_inode *ni, s64 new_alloc_size,\n\t\tconst s64 new_data_size, const s64 data_start)\n{\n\tVCN vcn;\n\ts64 ll, allocated_size, start = data_start;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_volume *vol = ni->vol;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\trunlist_element *rl, *rl2;\n\tunsigned long flags;\n\tint err, mp_size;\n\tu32 attr_len = 0; /* Silence stupid gcc warning. */\n\tbool mp_rebuilt;\n\n#ifdef DEBUG\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tntfs_debug(\"Entering for i_ino 0x%lx, attribute type 0x%x, \"\n\t\t\t\"old_allocated_size 0x%llx, \"\n\t\t\t\"new_allocated_size 0x%llx, new_data_size 0x%llx, \"\n\t\t\t\"data_start 0x%llx.\", vi->i_ino,\n\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t(unsigned long long)allocated_size,\n\t\t\t(unsigned long long)new_alloc_size,\n\t\t\t(unsigned long long)new_data_size,\n\t\t\t(unsigned long long)start);\n#endif\nretry_extend:\n\t/*\n\t * For non-resident attributes, @start and @new_size need to be aligned\n\t * to cluster boundaries for allocation purposes.\n\t */\n\tif (NInoNonResident(ni)) {\n\t\tif (start > 0)\n\t\t\tstart &= ~(s64)vol->cluster_size_mask;\n\t\tnew_alloc_size = (new_alloc_size + vol->cluster_size - 1) &\n\t\t\t\t~(s64)vol->cluster_size_mask;\n\t}\n\tBUG_ON(new_data_size >= 0 && new_data_size > new_alloc_size);\n\t/* Check if new size is allowed in $AttrDef. */\n\terr = ntfs_attr_size_bounds_check(vol, ni->type, new_alloc_size);\n\tif (unlikely(err)) {\n\t\t/* Only emit errors when the write will fail completely. */\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (start < 0 || start >= allocated_size) {\n\t\t\tif (err == -ERANGE) {\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because the new \"\n\t\t\t\t\t\t\"allocation would exceed the \"\n\t\t\t\t\t\t\"maximum allowed size for \"\n\t\t\t\t\t\t\"this attribute type.\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t} else {\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because this \"\n\t\t\t\t\t\t\"attribute type is not \"\n\t\t\t\t\t\t\"defined on the NTFS volume.  \"\n\t\t\t\t\t\t\"Possible corruption!  You \"\n\t\t\t\t\t\t\"should run chkdsk!\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t}\n\t\t}\n\t\t/* Translate error code to be POSIX conformant for write(2). */\n\t\tif (err == -ERANGE)\n\t\t\terr = -EFBIG;\n\t\telse\n\t\t\terr = -EIO;\n\t\treturn err;\n\t}\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t/*\n\t * We will be modifying both the runlist (if non-resident) and the mft\n\t * record so lock them both down.\n\t */\n\tdown_write(&ni->runlist.lock);\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t/*\n\t * If non-resident, seek to the last extent.  If resident, there is\n\t * only one extent, so seek to that.\n\t */\n\tvcn = NInoNonResident(ni) ? allocated_size >> vol->cluster_size_bits :\n\t\t\t0;\n\t/*\n\t * Abort if someone did the work whilst we waited for the locks.  If we\n\t * just converted the attribute from resident to non-resident it is\n\t * likely that exactly this has happened already.  We cannot quite\n\t * abort if we need to update the data size.\n\t */\n\tif (unlikely(new_alloc_size <= allocated_size)) {\n\t\tntfs_debug(\"Allocated size already exceeds requested size.\");\n\t\tnew_alloc_size = allocated_size;\n\t\tif (new_data_size < 0)\n\t\t\tgoto done;\n\t\t/*\n\t\t * We want the first attribute extent so that we can update the\n\t\t * data size.\n\t\t */\n\t\tvcn = 0;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\t/* Use goto to reduce indentation. */\n\tif (a->non_resident)\n\t\tgoto do_non_resident_extend;\n\tBUG_ON(NInoNonResident(ni));\n\t/* The total length of the attribute value. */\n\tattr_len = le32_to_cpu(a->data.resident.value_length);\n\t/*\n\t * Extend the attribute record to be able to store the new attribute\n\t * size.  ntfs_attr_record_resize() will not do anything if the size is\n\t * not changing.\n\t */\n\tif (new_alloc_size < vol->mft_record_size &&\n\t\t\t!ntfs_attr_record_resize(m, a,\n\t\t\tle16_to_cpu(a->data.resident.value_offset) +\n\t\t\tnew_alloc_size)) {\n\t\t/* The resize succeeded! */\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset);\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (new_data_size >= 0) {\n\t\t\tBUG_ON(new_data_size < attr_len);\n\t\t\ta->data.resident.value_length =\n\t\t\t\t\tcpu_to_le32((u32)new_data_size);\n\t\t}\n\t\tgoto flush_done;\n\t}\n\t/*\n\t * We have to drop all the locks so we can call\n\t * ntfs_attr_make_non_resident().  This could be optimised by try-\n\t * locking the first page cache page and only if that fails dropping\n\t * the locks, locking the page, and redoing all the locking and\n\t * lookups.  While this would be a huge optimisation, it is not worth\n\t * it as this is definitely a slow code path.\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\t/*\n\t * Not enough space in the mft record, try to make the attribute\n\t * non-resident and if successful restart the extension process.\n\t */\n\terr = ntfs_attr_make_non_resident(ni, attr_len);\n\tif (likely(!err))\n\t\tgoto retry_extend;\n\t/*\n\t * Could not make non-resident.  If this is due to this not being\n\t * permitted for this attribute type or there not being enough space,\n\t * try to make other attributes non-resident.  Otherwise fail.\n\t */\n\tif (unlikely(err != -EPERM && err != -ENOSPC)) {\n\t\t/* Only emit errors when the write will fail completely. */\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the conversion from resident \"\n\t\t\t\t\t\"to non-resident attribute failed \"\n\t\t\t\t\t\"with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM)\n\t\t\terr = -EIO;\n\t\tgoto conv_err_out;\n\t}\n\t/* TODO: Not implemented from here, abort. */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (start < 0 || start >= allocated_size) {\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record/on disk for the non-resident \"\n\t\t\t\t\t\"attribute value.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\telse /* if (err == -EPERM) */\n\t\t\tntfs_error(vol->sb, \"This attribute type may not be \"\n\t\t\t\t\t\"non-resident.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t}\n\terr = -EOPNOTSUPP;\n\tgoto conv_err_out;\n#if 0\n\t// TODO: Attempt to make other attributes non-resident.\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t/*\n\t * Both the attribute list attribute and the standard information\n\t * attribute must remain in the base inode.  Thus, if this is one of\n\t * these attributes, we have to try to move other attributes out into\n\t * extent mft records instead.\n\t */\n\tif (ni->type == AT_ATTRIBUTE_LIST ||\n\t\t\tni->type == AT_STANDARD_INFORMATION) {\n\t\t// TODO: Attempt to move other attributes into extent mft\n\t\t// records.\n\t\terr = -EOPNOTSUPP;\n\t\tif (!err)\n\t\t\tgoto do_resident_extend;\n\t\tgoto err_out;\n\t}\n\t// TODO: Attempt to move this attribute to an extent mft record, but\n\t// only if it is not already the only attribute in an mft record in\n\t// which case there would be nothing to gain.\n\terr = -EOPNOTSUPP;\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t/* There is nothing we can do to make enough space. )-: */\n\tgoto err_out;\n#endif\ndo_non_resident_extend:\n\tBUG_ON(!NInoNonResident(ni));\n\tif (new_alloc_size == allocated_size) {\n\t\tBUG_ON(vcn);\n\t\tgoto alloc_done;\n\t}\n\t/*\n\t * If the data starts after the end of the old allocation, this is a\n\t * $DATA attribute and sparse attributes are enabled on the volume and\n\t * for this inode, then create a sparse region between the old\n\t * allocated size and the start of the data.  Otherwise simply proceed\n\t * with filling the whole space between the old allocated size and the\n\t * new allocated size with clusters.\n\t */\n\tif ((start >= 0 && start <= allocated_size) || ni->type != AT_DATA ||\n\t\t\t!NVolSparseEnabled(vol) || NInoSparseDisabled(ni))\n\t\tgoto skip_sparse;\n\t// TODO: This is not implemented yet.  We just fill in with real\n\t// clusters for now...\n\tntfs_debug(\"Inserting holes is not-implemented yet.  Falling back to \"\n\t\t\t\"allocating real clusters instead.\");\nskip_sparse:\n\trl = ni->runlist.rl;\n\tif (likely(rl)) {\n\t\t/* Seek to the end of the runlist. */\n\t\twhile (rl->length)\n\t\t\trl++;\n\t}\n\t/* If this attribute extent is not mapped, map it now. */\n\tif (unlikely(!rl || rl->lcn == LCN_RL_NOT_MAPPED ||\n\t\t\t(rl->lcn == LCN_ENOENT && rl > ni->runlist.rl &&\n\t\t\t(rl-1)->lcn == LCN_RL_NOT_MAPPED))) {\n\t\tif (!rl && !allocated_size)\n\t\t\tgoto first_alloc;\n\t\trl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tif (start < 0 || start >= allocated_size)\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because the \"\n\t\t\t\t\t\t\"mapping of a runlist \"\n\t\t\t\t\t\t\"fragment failed with error \"\n\t\t\t\t\t\t\"code %i.\", vi->i_ino,\n\t\t\t\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t\t\t\terr);\n\t\t\tif (err != -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tni->runlist.rl = rl;\n\t\t/* Seek to the end of the runlist. */\n\t\twhile (rl->length)\n\t\t\trl++;\n\t}\n\t/*\n\t * We now know the runlist of the last extent is mapped and @rl is at\n\t * the end of the runlist.  We want to begin allocating clusters\n\t * starting at the last allocated cluster to reduce fragmentation.  If\n\t * there are no valid LCNs in the attribute we let the cluster\n\t * allocator choose the starting cluster.\n\t */\n\t/* If the last LCN is a hole or simillar seek back to last real LCN. */\n\twhile (rl->lcn < 0 && rl > ni->runlist.rl)\n\t\trl--;\nfirst_alloc:\n\t// FIXME: Need to implement partial allocations so at least part of the\n\t// write can be performed when start >= 0.  (Needed for POSIX write(2)\n\t// conformance.)\n\trl2 = ntfs_cluster_alloc(vol, allocated_size >> vol->cluster_size_bits,\n\t\t\t(new_alloc_size - allocated_size) >>\n\t\t\tvol->cluster_size_bits, (rl && (rl->lcn >= 0)) ?\n\t\t\trl->lcn + rl->length : -1, DATA_ZONE, true);\n\tif (IS_ERR(rl2)) {\n\t\terr = PTR_ERR(rl2);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the allocation of clusters \"\n\t\t\t\t\t\"failed with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM && err != -ENOSPC)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_runlists_merge(ni->runlist.rl, rl2);\n\tif (IS_ERR(rl)) {\n\t\terr = PTR_ERR(rl);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the runlist merge failed \"\n\t\t\t\t\t\"with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM)\n\t\t\terr = -EIO;\n\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\tntfs_error(vol->sb, \"Failed to release allocated \"\n\t\t\t\t\t\"cluster(s) in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover the lost \"\n\t\t\t\t\t\"cluster(s).\");\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl2);\n\t\tgoto err_out;\n\t}\n\tni->runlist.rl = rl;\n\tntfs_debug(\"Allocated 0x%llx clusters.\", (long long)(new_alloc_size -\n\t\t\tallocated_size) >> vol->cluster_size_bits);\n\t/* Find the runlist element with which the attribute extent starts. */\n\tll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\trl2 = ntfs_rl_find_vcn_nolock(rl, ll);\n\tBUG_ON(!rl2);\n\tBUG_ON(!rl2->length);\n\tBUG_ON(rl2->lcn < LCN_HOLE);\n\tmp_rebuilt = false;\n\t/* Get the size for the new mapping pairs array for this extent. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\terr = mp_size;\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because determining the size for the \"\n\t\t\t\t\t\"mapping pairs failed with error code \"\n\t\t\t\t\t\"%i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\terr = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Extend the attribute record to fit the bigger mapping pairs array. */\n\tattr_len = le32_to_cpu(a->length);\n\terr = ntfs_attr_record_resize(m, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tif (unlikely(err)) {\n\t\tBUG_ON(err != -ENOSPC);\n\t\t// TODO: Deal with this by moving this extent to a new mft\n\t\t// record or by starting a new extent in a new mft record,\n\t\t// possibly by extending this extent partially and filling it\n\t\t// and creating a new extent for the remainder, or by making\n\t\t// other attributes non-resident and/or by moving other\n\t\t// attributes out of this mft record.\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record for the extended attribute \"\n\t\t\t\t\t\"record.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto undo_alloc;\n\t}\n\tmp_rebuilt = true;\n\t/* Generate the mapping pairs array directly into the attr record. */\n\terr = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, rl2, ll, -1, NULL);\n\tif (unlikely(err)) {\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because building the mapping pairs \"\n\t\t\t\t\t\"failed with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\terr = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Update the highest_vcn. */\n\ta->data.non_resident.highest_vcn = cpu_to_sle64((new_alloc_size >>\n\t\t\tvol->cluster_size_bits) - 1);\n\t/*\n\t * We now have extended the allocated size of the attribute.  Reflect\n\t * this in the ntfs_inode structure and the attribute record.\n\t */\n\tif (a->data.non_resident.lowest_vcn) {\n\t\t/*\n\t\t * We are not in the first attribute extent, switch to it, but\n\t\t * first ensure the changes will make it to disk later.\n\t\t */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err))\n\t\t\tgoto restore_undo_alloc;\n\t\t/* @m is not used any more so no need to set it. */\n\t\ta = ctx->attr;\n\t}\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = new_alloc_size;\n\ta->data.non_resident.allocated_size = cpu_to_sle64(new_alloc_size);\n\t/*\n\t * FIXME: This would fail if @ni is a directory, $MFT, or an index,\n\t * since those can have sparse/compressed set.  For example can be\n\t * set compressed even though it is not compressed itself and in that\n\t * case the bit means that files are to be created compressed in the\n\t * directory...  At present this is ok as this code is only called for\n\t * regular files, and only for their $DATA attribute(s).\n\t * FIXME: The calculation is wrong if we created a hole above.  For now\n\t * it does not matter as we never create holes.\n\t */\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\tni->itype.compressed.size += new_alloc_size - allocated_size;\n\t\ta->data.non_resident.compressed_size =\n\t\t\t\tcpu_to_sle64(ni->itype.compressed.size);\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t} else\n\t\tvi->i_blocks = new_alloc_size >> 9;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\nalloc_done:\n\tif (new_data_size >= 0) {\n\t\tBUG_ON(new_data_size <\n\t\t\t\tsle64_to_cpu(a->data.non_resident.data_size));\n\t\ta->data.non_resident.data_size = cpu_to_sle64(new_data_size);\n\t}\nflush_done:\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\ndone:\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\tntfs_debug(\"Done, new_allocated_size 0x%llx.\",\n\t\t\t(unsigned long long)new_alloc_size);\n\treturn new_alloc_size;\nrestore_undo_alloc:\n\tif (start < 0 || start >= allocated_size)\n\t\tntfs_error(vol->sb, \"Cannot complete extension of allocation \"\n\t\t\t\t\"of inode 0x%lx, attribute type 0x%x, because \"\n\t\t\t\t\"lookup of first attribute extent failed with \"\n\t\t\t\t\"error code %i.\", vi->i_ino,\n\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\tif (err == -ENOENT)\n\t\terr = -EIO;\n\tntfs_attr_reinit_search_ctx(ctx);\n\tif (ntfs_attr_lookup(ni->type, ni->name, ni->name_len, CASE_SENSITIVE,\n\t\t\tallocated_size >> vol->cluster_size_bits, NULL, 0,\n\t\t\tctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"attribute in error code path.  Run chkdsk to \"\n\t\t\t\t\"recover.\");\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->allocated_size = new_alloc_size;\n\t\t/*\n\t\t * FIXME: This would fail if @ni is a directory...  See above.\n\t\t * FIXME: The calculation is wrong if we created a hole above.\n\t\t * For now it does not matter as we never create holes.\n\t\t */\n\t\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\t\tni->itype.compressed.size += new_alloc_size -\n\t\t\t\t\tallocated_size;\n\t\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t\t} else\n\t\t\tvi->i_blocks = new_alloc_size >> 9;\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t\tup_write(&ni->runlist.lock);\n\t\t/*\n\t\t * The only thing that is now wrong is the allocated size of the\n\t\t * base attribute extent which chkdsk should be able to fix.\n\t\t */\n\t\tNVolSetErrors(vol);\n\t\treturn err;\n\t}\n\tctx->attr->data.non_resident.highest_vcn = cpu_to_sle64(\n\t\t\t(allocated_size >> vol->cluster_size_bits) - 1);\nundo_alloc:\n\tll = allocated_size >> vol->cluster_size_bits;\n\tif (ntfs_cluster_free(ni, ll, -1, ctx) < 0) {\n\t\tntfs_error(vol->sb, \"Failed to release allocated cluster(s) \"\n\t\t\t\t\"in error code path.  Run chkdsk to recover \"\n\t\t\t\t\"the lost cluster(s).\");\n\t\tNVolSetErrors(vol);\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\t/*\n\t * If the runlist truncation fails and/or the search context is no\n\t * longer valid, we cannot resize the attribute record or build the\n\t * mapping pairs array thus we mark the inode bad so that no access to\n\t * the freed clusters can happen.\n\t */\n\tif (ntfs_rl_truncate_nolock(vol, &ni->runlist, ll) || IS_ERR(m)) {\n\t\tntfs_error(vol->sb, \"Failed to %s in error code path.  Run \"\n\t\t\t\t\"chkdsk to recover.\", IS_ERR(m) ?\n\t\t\t\t\"restore attribute search context\" :\n\t\t\t\t\"truncate attribute runlist\");\n\t\tNVolSetErrors(vol);\n\t} else if (mp_rebuilt) {\n\t\tif (ntfs_attr_record_resize(m, a, attr_len)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover.\");\n\t\t\tNVolSetErrors(vol);\n\t\t} else /* if (success) */ {\n\t\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), attr_len -\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), rl2, ll, -1,\n\t\t\t\t\tNULL)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to restore \"\n\t\t\t\t\t\t\"mapping pairs array in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t}\n\t}\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\nconv_err_out:\n\tntfs_debug(\"Failed.  Returning error code %i.\", err);\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_attr_make_non_resident",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "1535-1843",
    "snippet": "int ntfs_attr_make_non_resident(ntfs_inode *ni, const u32 data_size)\n{\n\ts64 new_size;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_volume *vol = ni->vol;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tstruct page *page;\n\trunlist_element *rl;\n\tu8 *kaddr;\n\tunsigned long flags;\n\tint mp_size, mp_ofs, name_ofs, arec_size, err, err2;\n\tu32 attr_size;\n\tu8 old_res_attr_flags;\n\n\t/* Check that the attribute is allowed to be non-resident. */\n\terr = ntfs_attr_can_be_non_resident(vol, ni->type);\n\tif (unlikely(err)) {\n\t\tif (err == -EPERM)\n\t\t\tntfs_debug(\"Attribute is not allowed to be \"\n\t\t\t\t\t\"non-resident.\");\n\t\telse\n\t\t\tntfs_debug(\"Attribute not defined on the NTFS \"\n\t\t\t\t\t\"volume!\");\n\t\treturn err;\n\t}\n\t/*\n\t * FIXME: Compressed and encrypted attributes are not supported when\n\t * writing and we should never have gotten here for them.\n\t */\n\tBUG_ON(NInoCompressed(ni));\n\tBUG_ON(NInoEncrypted(ni));\n\t/*\n\t * The size needs to be aligned to a cluster boundary for allocation\n\t * purposes.\n\t */\n\tnew_size = (data_size + vol->cluster_size - 1) &\n\t\t\t~(vol->cluster_size - 1);\n\tif (new_size > 0) {\n\t\t/*\n\t\t * Will need the page later and since the page lock nests\n\t\t * outside all ntfs locks, we need to get the page now.\n\t\t */\n\t\tpage = find_or_create_page(vi->i_mapping, 0,\n\t\t\t\tmapping_gfp_mask(vi->i_mapping));\n\t\tif (unlikely(!page))\n\t\t\treturn -ENOMEM;\n\t\t/* Start by allocating clusters to hold the attribute value. */\n\t\trl = ntfs_cluster_alloc(vol, 0, new_size >>\n\t\t\t\tvol->cluster_size_bits, -1, DATA_ZONE, true);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tntfs_debug(\"Failed to allocate cluster%s, error code \"\n\t\t\t\t\t\"%i.\", (new_size >>\n\t\t\t\t\tvol->cluster_size_bits) > 1 ? \"s\" : \"\",\n\t\t\t\t\terr);\n\t\t\tgoto page_err_out;\n\t\t}\n\t} else {\n\t\trl = NULL;\n\t\tpage = NULL;\n\t}\n\t/* Determine the size of the mapping pairs array. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl, 0, -1);\n\tif (unlikely(mp_size < 0)) {\n\t\terr = mp_size;\n\t\tntfs_debug(\"Failed to get size for mapping pairs array, error \"\n\t\t\t\t\"code %i.\", err);\n\t\tgoto rl_err_out;\n\t}\n\tdown_write(&ni->runlist.lock);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tBUG_ON(NInoNonResident(ni));\n\tBUG_ON(a->non_resident);\n\t/*\n\t * Calculate new offsets for the name and the mapping pairs array.\n\t */\n\tif (NInoSparse(ni) || NInoCompressed(ni))\n\t\tname_ofs = (offsetof(ATTR_REC,\n\t\t\t\tdata.non_resident.compressed_size) +\n\t\t\t\tsizeof(a->data.non_resident.compressed_size) +\n\t\t\t\t7) & ~7;\n\telse\n\t\tname_ofs = (offsetof(ATTR_REC,\n\t\t\t\tdata.non_resident.compressed_size) + 7) & ~7;\n\tmp_ofs = (name_ofs + a->name_length * sizeof(ntfschar) + 7) & ~7;\n\t/*\n\t * Determine the size of the resident part of the now non-resident\n\t * attribute record.\n\t */\n\tarec_size = (mp_ofs + mp_size + 7) & ~7;\n\t/*\n\t * If the page is not uptodate bring it uptodate by copying from the\n\t * attribute value.\n\t */\n\tattr_size = le32_to_cpu(a->data.resident.value_length);\n\tBUG_ON(attr_size != data_size);\n\tif (page && !PageUptodate(page)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(kaddr, (u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset),\n\t\t\t\tattr_size);\n\t\tmemset(kaddr + attr_size, 0, PAGE_CACHE_SIZE - attr_size);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t}\n\t/* Backup the attribute flag. */\n\told_res_attr_flags = a->data.resident.flags;\n\t/* Resize the resident part of the attribute record. */\n\terr = ntfs_attr_record_resize(m, a, arec_size);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\t/*\n\t * Convert the resident part of the attribute record to describe a\n\t * non-resident attribute.\n\t */\n\ta->non_resident = 1;\n\t/* Move the attribute name if it exists and update the offset. */\n\tif (a->name_length)\n\t\tmemmove((u8*)a + name_ofs, (u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\ta->name_length * sizeof(ntfschar));\n\ta->name_offset = cpu_to_le16(name_ofs);\n\t/* Setup the fields specific to non-resident attributes. */\n\ta->data.non_resident.lowest_vcn = 0;\n\ta->data.non_resident.highest_vcn = cpu_to_sle64((new_size - 1) >>\n\t\t\tvol->cluster_size_bits);\n\ta->data.non_resident.mapping_pairs_offset = cpu_to_le16(mp_ofs);\n\tmemset(&a->data.non_resident.reserved, 0,\n\t\t\tsizeof(a->data.non_resident.reserved));\n\ta->data.non_resident.allocated_size = cpu_to_sle64(new_size);\n\ta->data.non_resident.data_size =\n\t\t\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(attr_size);\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\ta->data.non_resident.compression_unit = 0;\n\t\tif (NInoCompressed(ni) || vol->major_ver < 3)\n\t\t\ta->data.non_resident.compression_unit = 4;\n\t\ta->data.non_resident.compressed_size =\n\t\t\t\ta->data.non_resident.allocated_size;\n\t} else\n\t\ta->data.non_resident.compression_unit = 0;\n\t/* Generate the mapping pairs array into the attribute record. */\n\terr = ntfs_mapping_pairs_build(vol, (u8*)a + mp_ofs,\n\t\t\tarec_size - mp_ofs, rl, 0, -1, NULL);\n\tif (unlikely(err)) {\n\t\tntfs_debug(\"Failed to build mapping pairs, error code %i.\",\n\t\t\t\terr);\n\t\tgoto undo_err_out;\n\t}\n\t/* Setup the in-memory attribute structure to be non-resident. */\n\tni->runlist.rl = rl;\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = new_size;\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\tni->itype.compressed.size = ni->allocated_size;\n\t\tif (a->data.non_resident.compression_unit) {\n\t\t\tni->itype.compressed.block_size = 1U << (a->data.\n\t\t\t\t\tnon_resident.compression_unit +\n\t\t\t\t\tvol->cluster_size_bits);\n\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\tffs(ni->itype.compressed.block_size) -\n\t\t\t\t\t1;\n\t\t\tni->itype.compressed.block_clusters = 1U <<\n\t\t\t\t\ta->data.non_resident.compression_unit;\n\t\t} else {\n\t\t\tni->itype.compressed.block_size = 0;\n\t\t\tni->itype.compressed.block_size_bits = 0;\n\t\t\tni->itype.compressed.block_clusters = 0;\n\t\t}\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t} else\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t/*\n\t * This needs to be last since the address space operations ->readpage\n\t * and ->writepage can run concurrently with us as they are not\n\t * serialized on i_mutex.  Note, we are not allowed to fail once we flip\n\t * this switch, which is another reason to do this last.\n\t */\n\tNInoSetNonResident(ni);\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\tif (page) {\n\t\tset_page_dirty(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tntfs_debug(\"Done.\");\n\treturn 0;\nundo_err_out:\n\t/* Convert the attribute back into a resident attribute. */\n\ta->non_resident = 0;\n\t/* Move the attribute name if it exists and update the offset. */\n\tname_ofs = (offsetof(ATTR_RECORD, data.resident.reserved) +\n\t\t\tsizeof(a->data.resident.reserved) + 7) & ~7;\n\tif (a->name_length)\n\t\tmemmove((u8*)a + name_ofs, (u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\ta->name_length * sizeof(ntfschar));\n\tmp_ofs = (name_ofs + a->name_length * sizeof(ntfschar) + 7) & ~7;\n\ta->name_offset = cpu_to_le16(name_ofs);\n\tarec_size = (mp_ofs + attr_size + 7) & ~7;\n\t/* Resize the resident part of the attribute record. */\n\terr2 = ntfs_attr_record_resize(m, a, arec_size);\n\tif (unlikely(err2)) {\n\t\t/*\n\t\t * This cannot happen (well if memory corruption is at work it\n\t\t * could happen in theory), but deal with it as well as we can.\n\t\t * If the old size is too small, truncate the attribute,\n\t\t * otherwise simply give it a larger allocated size.\n\t\t * FIXME: Should check whether chkdsk complains when the\n\t\t * allocated size is much bigger than the resident value size.\n\t\t */\n\t\tarec_size = le32_to_cpu(a->length);\n\t\tif ((mp_ofs + attr_size) > arec_size) {\n\t\t\terr2 = attr_size;\n\t\t\tattr_size = arec_size - mp_ofs;\n\t\t\tntfs_error(vol->sb, \"Failed to undo partial resident \"\n\t\t\t\t\t\"to non-resident attribute \"\n\t\t\t\t\t\"conversion.  Truncating inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x from %i bytes to \"\n\t\t\t\t\t\"%i bytes to maintain metadata \"\n\t\t\t\t\t\"consistency.  THIS MEANS YOU ARE \"\n\t\t\t\t\t\"LOSING %i BYTES DATA FROM THIS %s.\",\n\t\t\t\t\tvi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t\t\terr2, attr_size, err2 - attr_size,\n\t\t\t\t\t((ni->type == AT_DATA) &&\n\t\t\t\t\t!ni->name_len) ? \"FILE\": \"ATTRIBUTE\");\n\t\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t\tni->initialized_size = attr_size;\n\t\t\ti_size_write(vi, attr_size);\n\t\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t}\n\t}\n\t/* Setup the fields specific to resident attributes. */\n\ta->data.resident.value_length = cpu_to_le32(attr_size);\n\ta->data.resident.value_offset = cpu_to_le16(mp_ofs);\n\ta->data.resident.flags = old_res_attr_flags;\n\tmemset(&a->data.resident.reserved, 0,\n\t\t\tsizeof(a->data.resident.reserved));\n\t/* Copy the data from the page back to the attribute value. */\n\tif (page) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy((u8*)a + mp_ofs, kaddr, attr_size);\n\t\tkunmap_atomic(kaddr);\n\t}\n\t/* Setup the allocated size in the ntfs inode in case it changed. */\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = arec_size - mp_ofs;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tni->runlist.rl = NULL;\n\tup_write(&ni->runlist.lock);\nrl_err_out:\n\tif (rl) {\n\t\tif (ntfs_cluster_free_from_rl(vol, rl) < 0) {\n\t\t\tntfs_error(vol->sb, \"Failed to release allocated \"\n\t\t\t\t\t\"cluster(s) in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover the lost \"\n\t\t\t\t\t\"cluster(s).\");\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl);\npage_err_out:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (err == -EINVAL)\n\t\terr = -EIO;\n\treturn err;\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "rl"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to release allocated \"\n\t\t\t\t\t\"cluster(s) in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover the lost \"\n\t\t\t\t\t\"cluster(s).\""
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_cluster_free_from_rl",
          "args": [
            "vol",
            "rl"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_cluster_free_from_rl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.h",
          "lines": "132-141",
          "snippet": "static inline int ntfs_cluster_free_from_rl(ntfs_volume *vol,\n\t\tconst runlist_element *rl)\n{\n\tint ret;\n\n\tdown_write(&vol->lcnbmp_lock);\n\tret = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"volume.h\"",
            "#include \"runlist.h\"",
            "#include \"inode.h\"",
            "#include \"types.h\"",
            "#include \"attrib.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volume.h\"\n#include \"runlist.h\"\n#include \"inode.h\"\n#include \"types.h\"\n#include \"attrib.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_cluster_free_from_rl(ntfs_volume *vol,\n\t\tconst runlist_element *rl)\n{\n\tint ret;\n\n\tdown_write(&vol->lcnbmp_lock);\n\tret = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "base_ni"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_mft_record_dirty",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_mft_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "395-410",
          "snippet": "void __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_mft_record_page",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "flush_dcache_mft_record_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "55-58",
          "snippet": "static inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(u8*)a + mp_ofs",
            "kaddr",
            "attr_size"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&a->data.resident.reserved",
            "0",
            "sizeof(a->data.resident.reserved)"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "mp_ofs"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "attr_size"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "vi",
            "attr_size"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to undo partial resident \"\n\t\t\t\t\t\"to non-resident attribute \"\n\t\t\t\t\t\"conversion.  Truncating inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x from %i bytes to \"\n\t\t\t\t\t\"%i bytes to maintain metadata \"\n\t\t\t\t\t\"consistency.  THIS MEANS YOU ARE \"\n\t\t\t\t\t\"LOSING %i BYTES DATA FROM THIS %s.\"",
            "vi->i_ino",
            "(unsigned)le32_to_cpu(ni->type)",
            "err2",
            "attr_size",
            "err2 - attr_size",
            "((ni->type == AT_DATA) &&\n\t\t\t\t\t!ni->name_len) ? \"FILE\": \"ATTRIBUTE\""
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ni->type"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err2"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_record_resize",
          "args": [
            "m",
            "a",
            "arec_size"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_record_resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1435-1459",
          "snippet": "int ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)\n{\n\tntfs_debug(\"Entering for new_size %u.\", new_size);\n\t/* Align to 8 bytes if it is not already done. */\n\tif (new_size & 7)\n\t\tnew_size = (new_size + 7) & ~7;\n\t/* If the actual attribute length has changed, move things around. */\n\tif (new_size != le32_to_cpu(a->length)) {\n\t\tu32 new_muse = le32_to_cpu(m->bytes_in_use) -\n\t\t\t\tle32_to_cpu(a->length) + new_size;\n\t\t/* Not enough space in this mft record. */\n\t\tif (new_muse > le32_to_cpu(m->bytes_allocated))\n\t\t\treturn -ENOSPC;\n\t\t/* Move attributes following @a to their new location. */\n\t\tmemmove((u8*)a + new_size, (u8*)a + le32_to_cpu(a->length),\n\t\t\t\tle32_to_cpu(m->bytes_in_use) - ((u8*)a -\n\t\t\t\t(u8*)m) - le32_to_cpu(a->length));\n\t\t/* Adjust @m to reflect the change in used space. */\n\t\tm->bytes_in_use = cpu_to_le32(new_muse);\n\t\t/* Adjust @a to reflect the new size. */\n\t\tif (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))\n\t\t\ta->length = cpu_to_le32(new_size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)\n{\n\tntfs_debug(\"Entering for new_size %u.\", new_size);\n\t/* Align to 8 bytes if it is not already done. */\n\tif (new_size & 7)\n\t\tnew_size = (new_size + 7) & ~7;\n\t/* If the actual attribute length has changed, move things around. */\n\tif (new_size != le32_to_cpu(a->length)) {\n\t\tu32 new_muse = le32_to_cpu(m->bytes_in_use) -\n\t\t\t\tle32_to_cpu(a->length) + new_size;\n\t\t/* Not enough space in this mft record. */\n\t\tif (new_muse > le32_to_cpu(m->bytes_allocated))\n\t\t\treturn -ENOSPC;\n\t\t/* Move attributes following @a to their new location. */\n\t\tmemmove((u8*)a + new_size, (u8*)a + le32_to_cpu(a->length),\n\t\t\t\tle32_to_cpu(m->bytes_in_use) - ((u8*)a -\n\t\t\t\t(u8*)m) - le32_to_cpu(a->length));\n\t\t/* Adjust @m to reflect the change in used space. */\n\t\tm->bytes_in_use = cpu_to_le32(new_muse);\n\t\t/* Adjust @a to reflect the new size. */\n\t\tif (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))\n\t\t\ta->length = cpu_to_le32(new_size);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "name_ofs"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "(u8*)a + name_ofs",
            "(u8*)a + le16_to_cpu(a->name_offset)",
            "a->name_length * sizeof(ntfschar)"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "a->name_offset"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSetNonResident",
          "args": [
            "ni"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "ni->itype.compressed.block_size"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_ffs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "135-162",
          "snippet": "static inline int ntfs_ffs(int x)\n{\n\tint r = 1;\n\n\tif (!x)\n\t\treturn 0;\n\tif (!(x & 0xffff)) {\n\t\tx >>= 16;\n\t\tr += 16;\n\t}\n\tif (!(x & 0xff)) {\n\t\tx >>= 8;\n\t\tr += 8;\n\t}\n\tif (!(x & 0xf)) {\n\t\tx >>= 4;\n\t\tr += 4;\n\t}\n\tif (!(x & 3)) {\n\t\tx >>= 2;\n\t\tr += 2;\n\t}\n\tif (!(x & 1)) {\n\t\tx >>= 1;\n\t\tr += 1;\n\t}\n\treturn r;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline int ntfs_ffs(int x)\n{\n\tint r = 1;\n\n\tif (!x)\n\t\treturn 0;\n\tif (!(x & 0xffff)) {\n\t\tx >>= 16;\n\t\tr += 16;\n\t}\n\tif (!(x & 0xff)) {\n\t\tx >>= 8;\n\t\tr += 8;\n\t}\n\tif (!(x & 0xf)) {\n\t\tx >>= 4;\n\t\tr += 4;\n\t}\n\tif (!(x & 3)) {\n\t\tx >>= 2;\n\t\tr += 2;\n\t}\n\tif (!(x & 1)) {\n\t\tx >>= 1;\n\t\tr += 1;\n\t}\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSparse",
          "args": [
            "ni"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Failed to build mapping pairs, error code %i.\"",
            "err"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_mapping_pairs_build",
          "args": [
            "vol",
            "(u8*)a + mp_ofs",
            "arec_size - mp_ofs",
            "rl",
            "0",
            "-1",
            "NULL"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_mapping_pairs_build",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1323-1473",
          "snippet": "int ntfs_mapping_pairs_build(const ntfs_volume *vol, s8 *dst,\n\t\tconst int dst_len, const runlist_element *rl,\n\t\tconst VCN first_vcn, const VCN last_vcn, VCN *const stop_vcn)\n{\n\tLCN prev_lcn;\n\ts8 *dst_max, *dst_next;\n\tint err = -ENOSPC;\n\tbool the_end = false;\n\ts8 len_len, lcn_len;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tBUG_ON(dst_len < 1);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\tif (stop_vcn)\n\t\t\t*stop_vcn = 0;\n\t\t/* Terminator byte. */\n\t\t*dst = 0;\n\t\treturn 0;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\t/*\n\t * @dst_max is used for bounds checking in\n\t * ntfs_write_significant_bytes().\n\t */\n\tdst_max = dst + dst_len - 1;\n\tprev_lcn = 0;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength - delta);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, rl->lcn - prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t\tprev_lcn = rl->lcn;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t}\n\t/* Success. */\n\terr = 0;\nsize_err:\n\t/* Set stop vcn. */\n\tif (stop_vcn)\n\t\t*stop_vcn = rl->vcn;\n\t/* Add terminator byte. */\n\t*dst = 0;\n\treturn err;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\terr = -EINVAL;\n\telse\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_mapping_pairs_build(const ntfs_volume *vol, s8 *dst,\n\t\tconst int dst_len, const runlist_element *rl,\n\t\tconst VCN first_vcn, const VCN last_vcn, VCN *const stop_vcn)\n{\n\tLCN prev_lcn;\n\ts8 *dst_max, *dst_next;\n\tint err = -ENOSPC;\n\tbool the_end = false;\n\ts8 len_len, lcn_len;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tBUG_ON(dst_len < 1);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\tif (stop_vcn)\n\t\t\t*stop_vcn = 0;\n\t\t/* Terminator byte. */\n\t\t*dst = 0;\n\t\treturn 0;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\t/*\n\t * @dst_max is used for bounds checking in\n\t * ntfs_write_significant_bytes().\n\t */\n\tdst_max = dst + dst_len - 1;\n\tprev_lcn = 0;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength - delta);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, rl->lcn - prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t\tprev_lcn = rl->lcn;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t}\n\t/* Success. */\n\terr = 0;\nsize_err:\n\t/* Set stop vcn. */\n\tif (stop_vcn)\n\t\t*stop_vcn = rl->vcn;\n\t/* Add terminator byte. */\n\t*dst = 0;\n\treturn err;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\terr = -EINVAL;\n\telse\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSparse",
          "args": [
            "ni"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_sle64",
          "args": [
            "attr_size"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_sle64p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "88-91",
          "snippet": "static inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&a->data.non_resident.reserved",
            "0",
            "sizeof(a->data.non_resident.reserved)"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "mp_ofs"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "name_ofs"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "(u8*)a + name_ofs",
            "(u8*)a + le16_to_cpu(a->name_offset)",
            "a->name_length * sizeof(ntfschar)"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr + attr_size",
            "0",
            "PAGE_CACHE_SIZE - attr_size"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr",
            "(u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)",
            "attr_size"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "attr_size != data_size"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSparse",
          "args": [
            "ni"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "a->non_resident"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoNonResident(ni)"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "ni->type",
            "ni->name",
            "ni->name_len",
            "CASE_SENSITIVE",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "base_ni",
            "m"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Failed to get size for mapping pairs array, error \"\n\t\t\t\t\"code %i.\"",
            "err"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mp_size < 0"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_get_size_for_mapping_pairs",
          "args": [
            "vol",
            "rl",
            "0",
            "-1"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_get_size_for_mapping_pairs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1131-1232",
          "snippet": "int ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,\n\t\tconst runlist_element *rl, const VCN first_vcn,\n\t\tconst VCN last_vcn)\n{\n\tLCN prev_lcn;\n\tint rls;\n\tbool the_end = false;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\treturn 1;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\tprev_lcn = 0;\n\t/* Always need the termining zero byte. */\n\trls = 1;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length - delta);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(prev_lcn);\n\t\t}\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(rl->lcn -\n\t\t\t\t\tprev_lcn);\n\t\t\tprev_lcn = rl->lcn;\n\t\t}\n\t}\n\treturn rls;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\trls = -EINVAL;\n\telse\n\t\trls = -EIO;\n\treturn rls;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,\n\t\tconst runlist_element *rl, const VCN first_vcn,\n\t\tconst VCN last_vcn)\n{\n\tLCN prev_lcn;\n\tint rls;\n\tbool the_end = false;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\treturn 1;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\tprev_lcn = 0;\n\t/* Always need the termining zero byte. */\n\trls = 1;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length - delta);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(prev_lcn);\n\t\t}\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(rl->lcn -\n\t\t\t\t\tprev_lcn);\n\t\t\tprev_lcn = rl->lcn;\n\t\t}\n\t}\n\treturn rls;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\trls = -EINVAL;\n\telse\n\t\trls = -EIO;\n\treturn rls;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Failed to allocate cluster%s, error code \"\n\t\t\t\t\t\"%i.\"",
            "(new_size >>\n\t\t\t\t\tvol->cluster_size_bits) > 1 ? \"s\" : \"\"",
            "err"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rl"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_cluster_alloc",
          "args": [
            "vol",
            "0",
            "new_size >>\n\t\t\t\tvol->cluster_size_bits",
            "-1",
            "DATA_ZONE",
            "true"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_cluster_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.c",
          "lines": "146-787",
          "snippet": "runlist_element *ntfs_cluster_alloc(ntfs_volume *vol, const VCN start_vcn,\n\t\tconst s64 count, const LCN start_lcn,\n\t\tconst NTFS_CLUSTER_ALLOCATION_ZONES zone,\n\t\tconst bool is_extension)\n{\n\tLCN zone_start, zone_end, bmp_pos, bmp_initial_pos, last_read_pos, lcn;\n\tLCN prev_lcn = 0, prev_run_len = 0, mft_zone_size;\n\ts64 clusters;\n\tloff_t i_size;\n\tstruct inode *lcnbmp_vi;\n\trunlist_element *rl = NULL;\n\tstruct address_space *mapping;\n\tstruct page *page = NULL;\n\tu8 *buf, *byte;\n\tint err = 0, rlpos, rlsize, buf_size;\n\tu8 pass, done_zones, search_zone, need_writeback = 0, bit;\n\n\tntfs_debug(\"Entering for start_vcn 0x%llx, count 0x%llx, start_lcn \"\n\t\t\t\"0x%llx, zone %s_ZONE.\", (unsigned long long)start_vcn,\n\t\t\t(unsigned long long)count,\n\t\t\t(unsigned long long)start_lcn,\n\t\t\tzone == MFT_ZONE ? \"MFT\" : \"DATA\");\n\tBUG_ON(!vol);\n\tlcnbmp_vi = vol->lcnbmp_ino;\n\tBUG_ON(!lcnbmp_vi);\n\tBUG_ON(start_vcn < 0);\n\tBUG_ON(count < 0);\n\tBUG_ON(start_lcn < -1);\n\tBUG_ON(zone < FIRST_ZONE);\n\tBUG_ON(zone > LAST_ZONE);\n\n\t/* Return NULL if @count is zero. */\n\tif (!count)\n\t\treturn NULL;\n\t/* Take the lcnbmp lock for writing. */\n\tdown_write(&vol->lcnbmp_lock);\n\t/*\n\t * If no specific @start_lcn was requested, use the current data zone\n\t * position, otherwise use the requested @start_lcn but make sure it\n\t * lies outside the mft zone.  Also set done_zones to 0 (no zones done)\n\t * and pass depending on whether we are starting inside a zone (1) or\n\t * at the beginning of a zone (2).  If requesting from the MFT_ZONE,\n\t * we either start at the current position within the mft zone or at\n\t * the specified position.  If the latter is out of bounds then we start\n\t * at the beginning of the MFT_ZONE.\n\t */\n\tdone_zones = 0;\n\tpass = 1;\n\t/*\n\t * zone_start and zone_end are the current search range.  search_zone\n\t * is 1 for mft zone, 2 for data zone 1 (end of mft zone till end of\n\t * volume) and 4 for data zone 2 (start of volume till start of mft\n\t * zone).\n\t */\n\tzone_start = start_lcn;\n\tif (zone_start < 0) {\n\t\tif (zone == DATA_ZONE)\n\t\t\tzone_start = vol->data1_zone_pos;\n\t\telse\n\t\t\tzone_start = vol->mft_zone_pos;\n\t\tif (!zone_start) {\n\t\t\t/*\n\t\t\t * Zone starts at beginning of volume which means a\n\t\t\t * single pass is sufficient.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t}\n\t} else if (zone == DATA_ZONE && zone_start >= vol->mft_zone_start &&\n\t\t\tzone_start < vol->mft_zone_end) {\n\t\tzone_start = vol->mft_zone_end;\n\t\t/*\n\t\t * Starting at beginning of data1_zone which means a single\n\t\t * pass in this zone is sufficient.\n\t\t */\n\t\tpass = 2;\n\t} else if (zone == MFT_ZONE && (zone_start < vol->mft_zone_start ||\n\t\t\tzone_start >= vol->mft_zone_end)) {\n\t\tzone_start = vol->mft_lcn;\n\t\tif (!vol->mft_zone_end)\n\t\t\tzone_start = 0;\n\t\t/*\n\t\t * Starting at beginning of volume which means a single pass\n\t\t * is sufficient.\n\t\t */\n\t\tpass = 2;\n\t}\n\tif (zone == MFT_ZONE) {\n\t\tzone_end = vol->mft_zone_end;\n\t\tsearch_zone = 1;\n\t} else /* if (zone == DATA_ZONE) */ {\n\t\t/* Skip searching the mft zone. */\n\t\tdone_zones |= 1;\n\t\tif (zone_start >= vol->mft_zone_end) {\n\t\t\tzone_end = vol->nr_clusters;\n\t\t\tsearch_zone = 2;\n\t\t} else {\n\t\t\tzone_end = vol->mft_zone_start;\n\t\t\tsearch_zone = 4;\n\t\t}\n\t}\n\t/*\n\t * bmp_pos is the current bit position inside the bitmap.  We use\n\t * bmp_initial_pos to determine whether or not to do a zone switch.\n\t */\n\tbmp_pos = bmp_initial_pos = zone_start;\n\n\t/* Loop until all clusters are allocated, i.e. clusters == 0. */\n\tclusters = count;\n\trlpos = rlsize = 0;\n\tmapping = lcnbmp_vi->i_mapping;\n\ti_size = i_size_read(lcnbmp_vi);\n\twhile (1) {\n\t\tntfs_debug(\"Start of outer while loop: done_zones 0x%x, \"\n\t\t\t\t\"search_zone %i, pass %i, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, rlpos %i, rlsize %i.\",\n\t\t\t\tdone_zones, search_zone, pass,\n\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t(unsigned long long)bmp_pos, rlpos, rlsize);\n\t\t/* Loop until we run out of free clusters. */\n\t\tlast_read_pos = bmp_pos >> 3;\n\t\tntfs_debug(\"last_read_pos 0x%llx.\",\n\t\t\t\t(unsigned long long)last_read_pos);\n\t\tif (last_read_pos > i_size) {\n\t\t\tntfs_debug(\"End of attribute reached.  \"\n\t\t\t\t\t\"Skipping to zone_pass_done.\");\n\t\t\tgoto zone_pass_done;\n\t\t}\n\t\tif (likely(page)) {\n\t\t\tif (need_writeback) {\n\t\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tset_page_dirty(page);\n\t\t\t\tneed_writeback = 0;\n\t\t\t}\n\t\t\tntfs_unmap_page(page);\n\t\t}\n\t\tpage = ntfs_map_page(mapping, last_read_pos >>\n\t\t\t\tPAGE_CACHE_SHIFT);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tntfs_error(vol->sb, \"Failed to map page.\");\n\t\t\tgoto out;\n\t\t}\n\t\tbuf_size = last_read_pos & ~PAGE_CACHE_MASK;\n\t\tbuf = page_address(page) + buf_size;\n\t\tbuf_size = PAGE_CACHE_SIZE - buf_size;\n\t\tif (unlikely(last_read_pos + buf_size > i_size))\n\t\t\tbuf_size = i_size - last_read_pos;\n\t\tbuf_size <<= 3;\n\t\tlcn = bmp_pos & 7;\n\t\tbmp_pos &= ~(LCN)7;\n\t\tntfs_debug(\"Before inner while loop: buf_size %i, lcn 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, need_writeback %i.\", buf_size,\n\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\twhile (lcn < buf_size && lcn + bmp_pos < zone_end) {\n\t\t\tbyte = buf + (lcn >> 3);\n\t\t\tntfs_debug(\"In inner while loop: buf_size %i, \"\n\t\t\t\t\t\"lcn 0x%llx, bmp_pos 0x%llx, \"\n\t\t\t\t\t\"need_writeback %i, byte ofs 0x%x, \"\n\t\t\t\t\t\"*byte 0x%x.\", buf_size,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\tneed_writeback,\n\t\t\t\t\t(unsigned int)(lcn >> 3),\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/* Skip full bytes. */\n\t\t\tif (*byte == 0xff) {\n\t\t\t\tlcn = (lcn + 8) & ~(LCN)7;\n\t\t\t\tntfs_debug(\"Continuing while loop 1.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbit = 1 << (lcn & 7);\n\t\t\tntfs_debug(\"bit 0x%x.\", bit);\n\t\t\t/* If the bit is already set, go onto the next one. */\n\t\t\tif (*byte & bit) {\n\t\t\t\tlcn++;\n\t\t\t\tntfs_debug(\"Continuing while loop 2.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Allocate more memory if needed, including space for\n\t\t\t * the terminator element.\n\t\t\t * ntfs_malloc_nofs() operates on whole pages only.\n\t\t\t */\n\t\t\tif ((rlpos + 2) * sizeof(*rl) > rlsize) {\n\t\t\t\trunlist_element *rl2;\n\n\t\t\t\tntfs_debug(\"Reallocating memory.\");\n\t\t\t\tif (!rl)\n\t\t\t\t\tntfs_debug(\"First free bit is at LCN \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\t(lcn + bmp_pos));\n\t\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\t\tif (unlikely(!rl2)) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to \"\n\t\t\t\t\t\t\t\"allocate memory.\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\t\tntfs_free(rl);\n\t\t\t\trl = rl2;\n\t\t\t\trlsize += PAGE_SIZE;\n\t\t\t\tntfs_debug(\"Reallocated memory, rlsize 0x%x.\",\n\t\t\t\t\t\trlsize);\n\t\t\t}\n\t\t\t/* Allocate the bitmap bit. */\n\t\t\t*byte |= bit;\n\t\t\t/* We need to write this bitmap page to disk. */\n\t\t\tneed_writeback = 1;\n\t\t\tntfs_debug(\"*byte 0x%x, need_writeback is set.\",\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/*\n\t\t\t * Coalesce with previous run if adjacent LCNs.\n\t\t\t * Otherwise, append a new run.\n\t\t\t */\n\t\t\tntfs_debug(\"Adding run (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\"prev_lcn 0x%llx, lcn 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, prev_run_len 0x%llx, \"\n\t\t\t\t\t\"rlpos %i.\",\n\t\t\t\t\t(unsigned long long)(lcn + bmp_pos),\n\t\t\t\t\t1ULL, (unsigned long long)prev_lcn,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)prev_run_len,\n\t\t\t\t\trlpos);\n\t\t\tif (prev_lcn == lcn + bmp_pos - prev_run_len && rlpos) {\n\t\t\t\tntfs_debug(\"Coalescing to run (lcn 0x%llx, \"\n\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\trl[rlpos - 1].length = ++prev_run_len;\n\t\t\t\tntfs_debug(\"Run now (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\t\"prev_run_len 0x%llx.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tprev_run_len);\n\t\t\t} else {\n\t\t\t\tif (likely(rlpos)) {\n\t\t\t\t\tntfs_debug(\"Adding new run, (previous \"\n\t\t\t\t\t\t\t\"run lcn 0x%llx, \"\n\t\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\t\trl[rlpos].vcn = rl[rlpos - 1].vcn +\n\t\t\t\t\t\t\tprev_run_len;\n\t\t\t\t} else {\n\t\t\t\t\tntfs_debug(\"Adding new run, is first \"\n\t\t\t\t\t\t\t\"run.\");\n\t\t\t\t\trl[rlpos].vcn = start_vcn;\n\t\t\t\t}\n\t\t\t\trl[rlpos].lcn = prev_lcn = lcn + bmp_pos;\n\t\t\t\trl[rlpos].length = prev_run_len = 1;\n\t\t\t\trlpos++;\n\t\t\t}\n\t\t\t/* Done? */\n\t\t\tif (!--clusters) {\n\t\t\t\tLCN tc;\n\t\t\t\t/*\n\t\t\t\t * Update the current zone position.  Positions\n\t\t\t\t * of already scanned zones have been updated\n\t\t\t\t * during the respective zone switches.\n\t\t\t\t */\n\t\t\t\ttc = lcn + bmp_pos + 1;\n\t\t\t\tntfs_debug(\"Done. Updating current zone \"\n\t\t\t\t\t\t\"position, tc 0x%llx, \"\n\t\t\t\t\t\t\"search_zone %i.\",\n\t\t\t\t\t\t(unsigned long long)tc,\n\t\t\t\t\t\tsearch_zone);\n\t\t\t\tswitch (search_zone) {\n\t\t\t\tcase 1:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tntfs_debug(\"Finished.  Going to out.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlcn++;\n\t\t}\n\t\tbmp_pos += buf_size;\n\t\tntfs_debug(\"After inner while loop: buf_size 0x%x, lcn \"\n\t\t\t\t\"0x%llx, bmp_pos 0x%llx, need_writeback %i.\",\n\t\t\t\tbuf_size, (unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\tif (bmp_pos < zone_end) {\n\t\t\tntfs_debug(\"Continuing outer while loop, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tcontinue;\n\t\t}\nzone_pass_done:\t/* Finished with the current zone pass. */\n\t\tntfs_debug(\"At zone_pass_done, pass %i.\", pass);\n\t\tif (pass == 1) {\n\t\t\t/*\n\t\t\t * Now do pass 2, scanning the first part of the zone\n\t\t\t * we omitted in pass 1.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t\tzone_end = zone_start;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1: /* mft_zone */\n\t\t\t\tzone_start = vol->mft_zone_start;\n\t\t\t\tbreak;\n\t\t\tcase 2: /* data1_zone */\n\t\t\t\tzone_start = vol->mft_zone_end;\n\t\t\t\tbreak;\n\t\t\tcase 4: /* data2_zone */\n\t\t\t\tzone_start = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* Sanity check. */\n\t\t\tif (zone_end < zone_start)\n\t\t\t\tzone_end = zone_start;\n\t\t\tbmp_pos = zone_start;\n\t\t\tntfs_debug(\"Continuing outer while loop, pass 2, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx.\",\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t\t(unsigned long long)bmp_pos);\n\t\t\tcontinue;\n\t\t} /* pass == 2 */\ndone_zones_check:\n\t\tntfs_debug(\"At done_zones_check, search_zone %i, done_zones \"\n\t\t\t\t\"before 0x%x, done_zones after 0x%x.\",\n\t\t\t\tsearch_zone, done_zones,\n\t\t\t\tdone_zones | search_zone);\n\t\tdone_zones |= search_zone;\n\t\tif (done_zones < 7) {\n\t\t\tntfs_debug(\"Switching zone.\");\n\t\t\t/* Now switch to the next zone we haven't done yet. */\n\t\t\tpass = 1;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1:\n\t\t\t\tntfs_debug(\"Switching from mft zone to data1 \"\n\t\t\t\t\t\t\"zone.\");\n\t\t\t\t/* Update mft zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from mft zone to data1 zone. */\nswitch_to_data1_zone:\t\tsearch_zone = 2;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data1_zone_pos;\n\t\t\t\tzone_end = vol->nr_clusters;\n\t\t\t\tif (zone_start == vol->mft_zone_end)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data1_zone_pos = zone_start =\n\t\t\t\t\t\t\tvol->mft_zone_end;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tntfs_debug(\"Switching from data1 zone to \"\n\t\t\t\t\t\t\"data2 zone.\");\n\t\t\t\t/* Update data1 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data1 zone to data2 zone. */\n\t\t\t\tsearch_zone = 4;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data2_zone_pos;\n\t\t\t\tzone_end = vol->mft_zone_start;\n\t\t\t\tif (!zone_start)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data2_zone_pos = zone_start =\n\t\t\t\t\t\t\tbmp_initial_pos = 0;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tntfs_debug(\"Switching from data2 zone to \"\n\t\t\t\t\t\t\"data1 zone.\");\n\t\t\t\t/* Update data2 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data2 zone to data1 zone. */\n\t\t\t\tgoto switch_to_data1_zone;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tntfs_debug(\"After zone switch, search_zone %i, \"\n\t\t\t\t\t\"pass %i, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\tsearch_zone, pass,\n\t\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tbmp_pos = zone_start;\n\t\t\tif (zone_start == zone_end) {\n\t\t\t\tntfs_debug(\"Empty zone, going to \"\n\t\t\t\t\t\t\"done_zones_check.\");\n\t\t\t\t/* Empty zone. Don't bother searching it. */\n\t\t\t\tgoto done_zones_check;\n\t\t\t}\n\t\t\tntfs_debug(\"Continuing outer while loop.\");\n\t\t\tcontinue;\n\t\t} /* done_zones == 7 */\n\t\tntfs_debug(\"All zones are finished.\");\n\t\t/*\n\t\t * All zones are finished!  If DATA_ZONE, shrink mft zone.  If\n\t\t * MFT_ZONE, we have really run out of space.\n\t\t */\n\t\tmft_zone_size = vol->mft_zone_end - vol->mft_zone_start;\n\t\tntfs_debug(\"vol->mft_zone_start 0x%llx, vol->mft_zone_end \"\n\t\t\t\t\"0x%llx, mft_zone_size 0x%llx.\",\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)mft_zone_size);\n\t\tif (zone == MFT_ZONE || mft_zone_size <= 0) {\n\t\t\tntfs_debug(\"No free clusters left, going to out.\");\n\t\t\t/* Really no more space left on device. */\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out;\n\t\t} /* zone == DATA_ZONE && mft_zone_size > 0 */\n\t\tntfs_debug(\"Shrinking mft zone.\");\n\t\tzone_end = vol->mft_zone_end;\n\t\tmft_zone_size >>= 1;\n\t\tif (mft_zone_size > 0)\n\t\t\tvol->mft_zone_end = vol->mft_zone_start + mft_zone_size;\n\t\telse /* mft zone and data2 zone no longer exist. */\n\t\t\tvol->data2_zone_pos = vol->mft_zone_start =\n\t\t\t\t\tvol->mft_zone_end = 0;\n\t\tif (vol->mft_zone_pos >= vol->mft_zone_end) {\n\t\t\tvol->mft_zone_pos = vol->mft_lcn;\n\t\t\tif (!vol->mft_zone_end)\n\t\t\t\tvol->mft_zone_pos = 0;\n\t\t}\n\t\tbmp_pos = zone_start = bmp_initial_pos =\n\t\t\t\tvol->data1_zone_pos = vol->mft_zone_end;\n\t\tsearch_zone = 2;\n\t\tpass = 2;\n\t\tdone_zones &= ~2;\n\t\tntfs_debug(\"After shrinking mft zone, mft_zone_size 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_start 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_end 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_pos 0x%llx, search_zone 2, \"\n\t\t\t\t\"pass 2, dones_zones 0x%x, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, vol->data1_zone_pos 0x%llx, \"\n\t\t\t\t\"continuing outer while loop.\",\n\t\t\t\t(unsigned long long)mft_zone_size,\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)vol->mft_zone_pos,\n\t\t\t\tdone_zones, (unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)vol->data1_zone_pos);\n\t}\n\tntfs_debug(\"After outer while loop.\");\nout:\n\tntfs_debug(\"At out.\");\n\t/* Add runlist terminator element. */\n\tif (likely(rl)) {\n\t\trl[rlpos].vcn = rl[rlpos - 1].vcn + rl[rlpos - 1].length;\n\t\trl[rlpos].lcn = is_extension ? LCN_ENOENT : LCN_RL_NOT_MAPPED;\n\t\trl[rlpos].length = 0;\n\t}\n\tif (likely(page && !IS_ERR(page))) {\n\t\tif (need_writeback) {\n\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\tflush_dcache_page(page);\n\t\t\tset_page_dirty(page);\n\t\t\tneed_writeback = 0;\n\t\t}\n\t\tntfs_unmap_page(page);\n\t}\n\tif (likely(!err)) {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_debug(\"Done.\");\n\t\treturn rl;\n\t}\n\tntfs_error(vol->sb, \"Failed to allocate clusters, aborting \"\n\t\t\t\"(error %i).\", err);\n\tif (rl) {\n\t\tint err2;\n\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_debug(\"Not enough space to complete allocation, \"\n\t\t\t\t\t\"err -ENOSPC, first free lcn 0x%llx, \"\n\t\t\t\t\t\"could allocate up to 0x%llx \"\n\t\t\t\t\t\"clusters.\",\n\t\t\t\t\t(unsigned long long)rl[0].lcn,\n\t\t\t\t\t(unsigned long long)(count - clusters));\n\t\t/* Deallocate all allocated clusters. */\n\t\tntfs_debug(\"Attempting rollback...\");\n\t\terr2 = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\t\tif (err2) {\n\t\t\tntfs_error(vol->sb, \"Failed to rollback (error %i).  \"\n\t\t\t\t\t\"Leaving inconsistent metadata!  \"\n\t\t\t\t\t\"Unmount and run chkdsk.\", err2);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\t/* Free the runlist. */\n\t\tntfs_free(rl);\n\t} else if (err == -ENOSPC)\n\t\tntfs_debug(\"No space left at all, err = -ENOSPC, first free \"\n\t\t\t\t\"lcn = 0x%llx.\",\n\t\t\t\t(long long)vol->data1_zone_pos);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"aops.h\"",
            "#include \"malloc.h\"",
            "#include \"attrib.h\"",
            "#include \"volume.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"debug.h\"",
            "#include \"lcnalloc.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"aops.h\"\n#include \"malloc.h\"\n#include \"attrib.h\"\n#include \"volume.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"debug.h\"\n#include \"lcnalloc.h\"\n#include <linux/pagemap.h>\n\nrunlist_element *ntfs_cluster_alloc(ntfs_volume *vol, const VCN start_vcn,\n\t\tconst s64 count, const LCN start_lcn,\n\t\tconst NTFS_CLUSTER_ALLOCATION_ZONES zone,\n\t\tconst bool is_extension)\n{\n\tLCN zone_start, zone_end, bmp_pos, bmp_initial_pos, last_read_pos, lcn;\n\tLCN prev_lcn = 0, prev_run_len = 0, mft_zone_size;\n\ts64 clusters;\n\tloff_t i_size;\n\tstruct inode *lcnbmp_vi;\n\trunlist_element *rl = NULL;\n\tstruct address_space *mapping;\n\tstruct page *page = NULL;\n\tu8 *buf, *byte;\n\tint err = 0, rlpos, rlsize, buf_size;\n\tu8 pass, done_zones, search_zone, need_writeback = 0, bit;\n\n\tntfs_debug(\"Entering for start_vcn 0x%llx, count 0x%llx, start_lcn \"\n\t\t\t\"0x%llx, zone %s_ZONE.\", (unsigned long long)start_vcn,\n\t\t\t(unsigned long long)count,\n\t\t\t(unsigned long long)start_lcn,\n\t\t\tzone == MFT_ZONE ? \"MFT\" : \"DATA\");\n\tBUG_ON(!vol);\n\tlcnbmp_vi = vol->lcnbmp_ino;\n\tBUG_ON(!lcnbmp_vi);\n\tBUG_ON(start_vcn < 0);\n\tBUG_ON(count < 0);\n\tBUG_ON(start_lcn < -1);\n\tBUG_ON(zone < FIRST_ZONE);\n\tBUG_ON(zone > LAST_ZONE);\n\n\t/* Return NULL if @count is zero. */\n\tif (!count)\n\t\treturn NULL;\n\t/* Take the lcnbmp lock for writing. */\n\tdown_write(&vol->lcnbmp_lock);\n\t/*\n\t * If no specific @start_lcn was requested, use the current data zone\n\t * position, otherwise use the requested @start_lcn but make sure it\n\t * lies outside the mft zone.  Also set done_zones to 0 (no zones done)\n\t * and pass depending on whether we are starting inside a zone (1) or\n\t * at the beginning of a zone (2).  If requesting from the MFT_ZONE,\n\t * we either start at the current position within the mft zone or at\n\t * the specified position.  If the latter is out of bounds then we start\n\t * at the beginning of the MFT_ZONE.\n\t */\n\tdone_zones = 0;\n\tpass = 1;\n\t/*\n\t * zone_start and zone_end are the current search range.  search_zone\n\t * is 1 for mft zone, 2 for data zone 1 (end of mft zone till end of\n\t * volume) and 4 for data zone 2 (start of volume till start of mft\n\t * zone).\n\t */\n\tzone_start = start_lcn;\n\tif (zone_start < 0) {\n\t\tif (zone == DATA_ZONE)\n\t\t\tzone_start = vol->data1_zone_pos;\n\t\telse\n\t\t\tzone_start = vol->mft_zone_pos;\n\t\tif (!zone_start) {\n\t\t\t/*\n\t\t\t * Zone starts at beginning of volume which means a\n\t\t\t * single pass is sufficient.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t}\n\t} else if (zone == DATA_ZONE && zone_start >= vol->mft_zone_start &&\n\t\t\tzone_start < vol->mft_zone_end) {\n\t\tzone_start = vol->mft_zone_end;\n\t\t/*\n\t\t * Starting at beginning of data1_zone which means a single\n\t\t * pass in this zone is sufficient.\n\t\t */\n\t\tpass = 2;\n\t} else if (zone == MFT_ZONE && (zone_start < vol->mft_zone_start ||\n\t\t\tzone_start >= vol->mft_zone_end)) {\n\t\tzone_start = vol->mft_lcn;\n\t\tif (!vol->mft_zone_end)\n\t\t\tzone_start = 0;\n\t\t/*\n\t\t * Starting at beginning of volume which means a single pass\n\t\t * is sufficient.\n\t\t */\n\t\tpass = 2;\n\t}\n\tif (zone == MFT_ZONE) {\n\t\tzone_end = vol->mft_zone_end;\n\t\tsearch_zone = 1;\n\t} else /* if (zone == DATA_ZONE) */ {\n\t\t/* Skip searching the mft zone. */\n\t\tdone_zones |= 1;\n\t\tif (zone_start >= vol->mft_zone_end) {\n\t\t\tzone_end = vol->nr_clusters;\n\t\t\tsearch_zone = 2;\n\t\t} else {\n\t\t\tzone_end = vol->mft_zone_start;\n\t\t\tsearch_zone = 4;\n\t\t}\n\t}\n\t/*\n\t * bmp_pos is the current bit position inside the bitmap.  We use\n\t * bmp_initial_pos to determine whether or not to do a zone switch.\n\t */\n\tbmp_pos = bmp_initial_pos = zone_start;\n\n\t/* Loop until all clusters are allocated, i.e. clusters == 0. */\n\tclusters = count;\n\trlpos = rlsize = 0;\n\tmapping = lcnbmp_vi->i_mapping;\n\ti_size = i_size_read(lcnbmp_vi);\n\twhile (1) {\n\t\tntfs_debug(\"Start of outer while loop: done_zones 0x%x, \"\n\t\t\t\t\"search_zone %i, pass %i, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, rlpos %i, rlsize %i.\",\n\t\t\t\tdone_zones, search_zone, pass,\n\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t(unsigned long long)bmp_pos, rlpos, rlsize);\n\t\t/* Loop until we run out of free clusters. */\n\t\tlast_read_pos = bmp_pos >> 3;\n\t\tntfs_debug(\"last_read_pos 0x%llx.\",\n\t\t\t\t(unsigned long long)last_read_pos);\n\t\tif (last_read_pos > i_size) {\n\t\t\tntfs_debug(\"End of attribute reached.  \"\n\t\t\t\t\t\"Skipping to zone_pass_done.\");\n\t\t\tgoto zone_pass_done;\n\t\t}\n\t\tif (likely(page)) {\n\t\t\tif (need_writeback) {\n\t\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tset_page_dirty(page);\n\t\t\t\tneed_writeback = 0;\n\t\t\t}\n\t\t\tntfs_unmap_page(page);\n\t\t}\n\t\tpage = ntfs_map_page(mapping, last_read_pos >>\n\t\t\t\tPAGE_CACHE_SHIFT);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tntfs_error(vol->sb, \"Failed to map page.\");\n\t\t\tgoto out;\n\t\t}\n\t\tbuf_size = last_read_pos & ~PAGE_CACHE_MASK;\n\t\tbuf = page_address(page) + buf_size;\n\t\tbuf_size = PAGE_CACHE_SIZE - buf_size;\n\t\tif (unlikely(last_read_pos + buf_size > i_size))\n\t\t\tbuf_size = i_size - last_read_pos;\n\t\tbuf_size <<= 3;\n\t\tlcn = bmp_pos & 7;\n\t\tbmp_pos &= ~(LCN)7;\n\t\tntfs_debug(\"Before inner while loop: buf_size %i, lcn 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, need_writeback %i.\", buf_size,\n\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\twhile (lcn < buf_size && lcn + bmp_pos < zone_end) {\n\t\t\tbyte = buf + (lcn >> 3);\n\t\t\tntfs_debug(\"In inner while loop: buf_size %i, \"\n\t\t\t\t\t\"lcn 0x%llx, bmp_pos 0x%llx, \"\n\t\t\t\t\t\"need_writeback %i, byte ofs 0x%x, \"\n\t\t\t\t\t\"*byte 0x%x.\", buf_size,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\tneed_writeback,\n\t\t\t\t\t(unsigned int)(lcn >> 3),\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/* Skip full bytes. */\n\t\t\tif (*byte == 0xff) {\n\t\t\t\tlcn = (lcn + 8) & ~(LCN)7;\n\t\t\t\tntfs_debug(\"Continuing while loop 1.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbit = 1 << (lcn & 7);\n\t\t\tntfs_debug(\"bit 0x%x.\", bit);\n\t\t\t/* If the bit is already set, go onto the next one. */\n\t\t\tif (*byte & bit) {\n\t\t\t\tlcn++;\n\t\t\t\tntfs_debug(\"Continuing while loop 2.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Allocate more memory if needed, including space for\n\t\t\t * the terminator element.\n\t\t\t * ntfs_malloc_nofs() operates on whole pages only.\n\t\t\t */\n\t\t\tif ((rlpos + 2) * sizeof(*rl) > rlsize) {\n\t\t\t\trunlist_element *rl2;\n\n\t\t\t\tntfs_debug(\"Reallocating memory.\");\n\t\t\t\tif (!rl)\n\t\t\t\t\tntfs_debug(\"First free bit is at LCN \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\t(lcn + bmp_pos));\n\t\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\t\tif (unlikely(!rl2)) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to \"\n\t\t\t\t\t\t\t\"allocate memory.\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\t\tntfs_free(rl);\n\t\t\t\trl = rl2;\n\t\t\t\trlsize += PAGE_SIZE;\n\t\t\t\tntfs_debug(\"Reallocated memory, rlsize 0x%x.\",\n\t\t\t\t\t\trlsize);\n\t\t\t}\n\t\t\t/* Allocate the bitmap bit. */\n\t\t\t*byte |= bit;\n\t\t\t/* We need to write this bitmap page to disk. */\n\t\t\tneed_writeback = 1;\n\t\t\tntfs_debug(\"*byte 0x%x, need_writeback is set.\",\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/*\n\t\t\t * Coalesce with previous run if adjacent LCNs.\n\t\t\t * Otherwise, append a new run.\n\t\t\t */\n\t\t\tntfs_debug(\"Adding run (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\"prev_lcn 0x%llx, lcn 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, prev_run_len 0x%llx, \"\n\t\t\t\t\t\"rlpos %i.\",\n\t\t\t\t\t(unsigned long long)(lcn + bmp_pos),\n\t\t\t\t\t1ULL, (unsigned long long)prev_lcn,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)prev_run_len,\n\t\t\t\t\trlpos);\n\t\t\tif (prev_lcn == lcn + bmp_pos - prev_run_len && rlpos) {\n\t\t\t\tntfs_debug(\"Coalescing to run (lcn 0x%llx, \"\n\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\trl[rlpos - 1].length = ++prev_run_len;\n\t\t\t\tntfs_debug(\"Run now (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\t\"prev_run_len 0x%llx.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tprev_run_len);\n\t\t\t} else {\n\t\t\t\tif (likely(rlpos)) {\n\t\t\t\t\tntfs_debug(\"Adding new run, (previous \"\n\t\t\t\t\t\t\t\"run lcn 0x%llx, \"\n\t\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\t\trl[rlpos].vcn = rl[rlpos - 1].vcn +\n\t\t\t\t\t\t\tprev_run_len;\n\t\t\t\t} else {\n\t\t\t\t\tntfs_debug(\"Adding new run, is first \"\n\t\t\t\t\t\t\t\"run.\");\n\t\t\t\t\trl[rlpos].vcn = start_vcn;\n\t\t\t\t}\n\t\t\t\trl[rlpos].lcn = prev_lcn = lcn + bmp_pos;\n\t\t\t\trl[rlpos].length = prev_run_len = 1;\n\t\t\t\trlpos++;\n\t\t\t}\n\t\t\t/* Done? */\n\t\t\tif (!--clusters) {\n\t\t\t\tLCN tc;\n\t\t\t\t/*\n\t\t\t\t * Update the current zone position.  Positions\n\t\t\t\t * of already scanned zones have been updated\n\t\t\t\t * during the respective zone switches.\n\t\t\t\t */\n\t\t\t\ttc = lcn + bmp_pos + 1;\n\t\t\t\tntfs_debug(\"Done. Updating current zone \"\n\t\t\t\t\t\t\"position, tc 0x%llx, \"\n\t\t\t\t\t\t\"search_zone %i.\",\n\t\t\t\t\t\t(unsigned long long)tc,\n\t\t\t\t\t\tsearch_zone);\n\t\t\t\tswitch (search_zone) {\n\t\t\t\tcase 1:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tntfs_debug(\"Finished.  Going to out.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlcn++;\n\t\t}\n\t\tbmp_pos += buf_size;\n\t\tntfs_debug(\"After inner while loop: buf_size 0x%x, lcn \"\n\t\t\t\t\"0x%llx, bmp_pos 0x%llx, need_writeback %i.\",\n\t\t\t\tbuf_size, (unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\tif (bmp_pos < zone_end) {\n\t\t\tntfs_debug(\"Continuing outer while loop, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tcontinue;\n\t\t}\nzone_pass_done:\t/* Finished with the current zone pass. */\n\t\tntfs_debug(\"At zone_pass_done, pass %i.\", pass);\n\t\tif (pass == 1) {\n\t\t\t/*\n\t\t\t * Now do pass 2, scanning the first part of the zone\n\t\t\t * we omitted in pass 1.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t\tzone_end = zone_start;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1: /* mft_zone */\n\t\t\t\tzone_start = vol->mft_zone_start;\n\t\t\t\tbreak;\n\t\t\tcase 2: /* data1_zone */\n\t\t\t\tzone_start = vol->mft_zone_end;\n\t\t\t\tbreak;\n\t\t\tcase 4: /* data2_zone */\n\t\t\t\tzone_start = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* Sanity check. */\n\t\t\tif (zone_end < zone_start)\n\t\t\t\tzone_end = zone_start;\n\t\t\tbmp_pos = zone_start;\n\t\t\tntfs_debug(\"Continuing outer while loop, pass 2, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx.\",\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t\t(unsigned long long)bmp_pos);\n\t\t\tcontinue;\n\t\t} /* pass == 2 */\ndone_zones_check:\n\t\tntfs_debug(\"At done_zones_check, search_zone %i, done_zones \"\n\t\t\t\t\"before 0x%x, done_zones after 0x%x.\",\n\t\t\t\tsearch_zone, done_zones,\n\t\t\t\tdone_zones | search_zone);\n\t\tdone_zones |= search_zone;\n\t\tif (done_zones < 7) {\n\t\t\tntfs_debug(\"Switching zone.\");\n\t\t\t/* Now switch to the next zone we haven't done yet. */\n\t\t\tpass = 1;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1:\n\t\t\t\tntfs_debug(\"Switching from mft zone to data1 \"\n\t\t\t\t\t\t\"zone.\");\n\t\t\t\t/* Update mft zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from mft zone to data1 zone. */\nswitch_to_data1_zone:\t\tsearch_zone = 2;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data1_zone_pos;\n\t\t\t\tzone_end = vol->nr_clusters;\n\t\t\t\tif (zone_start == vol->mft_zone_end)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data1_zone_pos = zone_start =\n\t\t\t\t\t\t\tvol->mft_zone_end;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tntfs_debug(\"Switching from data1 zone to \"\n\t\t\t\t\t\t\"data2 zone.\");\n\t\t\t\t/* Update data1 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data1 zone to data2 zone. */\n\t\t\t\tsearch_zone = 4;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data2_zone_pos;\n\t\t\t\tzone_end = vol->mft_zone_start;\n\t\t\t\tif (!zone_start)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data2_zone_pos = zone_start =\n\t\t\t\t\t\t\tbmp_initial_pos = 0;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tntfs_debug(\"Switching from data2 zone to \"\n\t\t\t\t\t\t\"data1 zone.\");\n\t\t\t\t/* Update data2 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data2 zone to data1 zone. */\n\t\t\t\tgoto switch_to_data1_zone;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tntfs_debug(\"After zone switch, search_zone %i, \"\n\t\t\t\t\t\"pass %i, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\tsearch_zone, pass,\n\t\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tbmp_pos = zone_start;\n\t\t\tif (zone_start == zone_end) {\n\t\t\t\tntfs_debug(\"Empty zone, going to \"\n\t\t\t\t\t\t\"done_zones_check.\");\n\t\t\t\t/* Empty zone. Don't bother searching it. */\n\t\t\t\tgoto done_zones_check;\n\t\t\t}\n\t\t\tntfs_debug(\"Continuing outer while loop.\");\n\t\t\tcontinue;\n\t\t} /* done_zones == 7 */\n\t\tntfs_debug(\"All zones are finished.\");\n\t\t/*\n\t\t * All zones are finished!  If DATA_ZONE, shrink mft zone.  If\n\t\t * MFT_ZONE, we have really run out of space.\n\t\t */\n\t\tmft_zone_size = vol->mft_zone_end - vol->mft_zone_start;\n\t\tntfs_debug(\"vol->mft_zone_start 0x%llx, vol->mft_zone_end \"\n\t\t\t\t\"0x%llx, mft_zone_size 0x%llx.\",\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)mft_zone_size);\n\t\tif (zone == MFT_ZONE || mft_zone_size <= 0) {\n\t\t\tntfs_debug(\"No free clusters left, going to out.\");\n\t\t\t/* Really no more space left on device. */\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out;\n\t\t} /* zone == DATA_ZONE && mft_zone_size > 0 */\n\t\tntfs_debug(\"Shrinking mft zone.\");\n\t\tzone_end = vol->mft_zone_end;\n\t\tmft_zone_size >>= 1;\n\t\tif (mft_zone_size > 0)\n\t\t\tvol->mft_zone_end = vol->mft_zone_start + mft_zone_size;\n\t\telse /* mft zone and data2 zone no longer exist. */\n\t\t\tvol->data2_zone_pos = vol->mft_zone_start =\n\t\t\t\t\tvol->mft_zone_end = 0;\n\t\tif (vol->mft_zone_pos >= vol->mft_zone_end) {\n\t\t\tvol->mft_zone_pos = vol->mft_lcn;\n\t\t\tif (!vol->mft_zone_end)\n\t\t\t\tvol->mft_zone_pos = 0;\n\t\t}\n\t\tbmp_pos = zone_start = bmp_initial_pos =\n\t\t\t\tvol->data1_zone_pos = vol->mft_zone_end;\n\t\tsearch_zone = 2;\n\t\tpass = 2;\n\t\tdone_zones &= ~2;\n\t\tntfs_debug(\"After shrinking mft zone, mft_zone_size 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_start 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_end 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_pos 0x%llx, search_zone 2, \"\n\t\t\t\t\"pass 2, dones_zones 0x%x, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, vol->data1_zone_pos 0x%llx, \"\n\t\t\t\t\"continuing outer while loop.\",\n\t\t\t\t(unsigned long long)mft_zone_size,\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)vol->mft_zone_pos,\n\t\t\t\tdone_zones, (unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)vol->data1_zone_pos);\n\t}\n\tntfs_debug(\"After outer while loop.\");\nout:\n\tntfs_debug(\"At out.\");\n\t/* Add runlist terminator element. */\n\tif (likely(rl)) {\n\t\trl[rlpos].vcn = rl[rlpos - 1].vcn + rl[rlpos - 1].length;\n\t\trl[rlpos].lcn = is_extension ? LCN_ENOENT : LCN_RL_NOT_MAPPED;\n\t\trl[rlpos].length = 0;\n\t}\n\tif (likely(page && !IS_ERR(page))) {\n\t\tif (need_writeback) {\n\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\tflush_dcache_page(page);\n\t\t\tset_page_dirty(page);\n\t\t\tneed_writeback = 0;\n\t\t}\n\t\tntfs_unmap_page(page);\n\t}\n\tif (likely(!err)) {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_debug(\"Done.\");\n\t\treturn rl;\n\t}\n\tntfs_error(vol->sb, \"Failed to allocate clusters, aborting \"\n\t\t\t\"(error %i).\", err);\n\tif (rl) {\n\t\tint err2;\n\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_debug(\"Not enough space to complete allocation, \"\n\t\t\t\t\t\"err -ENOSPC, first free lcn 0x%llx, \"\n\t\t\t\t\t\"could allocate up to 0x%llx \"\n\t\t\t\t\t\"clusters.\",\n\t\t\t\t\t(unsigned long long)rl[0].lcn,\n\t\t\t\t\t(unsigned long long)(count - clusters));\n\t\t/* Deallocate all allocated clusters. */\n\t\tntfs_debug(\"Attempting rollback...\");\n\t\terr2 = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\t\tif (err2) {\n\t\t\tntfs_error(vol->sb, \"Failed to rollback (error %i).  \"\n\t\t\t\t\t\"Leaving inconsistent metadata!  \"\n\t\t\t\t\t\"Unmount and run chkdsk.\", err2);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\t/* Free the runlist. */\n\t\tntfs_free(rl);\n\t} else if (err == -ENOSPC)\n\t\tntfs_debug(\"No space left at all, err = -ENOSPC, first free \"\n\t\t\t\t\"lcn = 0x%llx.\",\n\t\t\t\t(long long)vol->data1_zone_pos);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "vi->i_mapping",
            "0",
            "mapping_gfp_mask(vi->i_mapping)"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "vi->i_mapping"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoEncrypted(ni)"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoEncrypted",
          "args": [
            "ni"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoCompressed(ni)"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_can_be_non_resident",
          "args": [
            "vol",
            "ni->type"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_can_be_non_resident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1378-1390",
          "snippet": "int ntfs_attr_can_be_non_resident(const ntfs_volume *vol, const ATTR_TYPE type)\n{\n\tATTR_DEF *ad;\n\n\t/* Find the attribute definition record in $AttrDef. */\n\tad = ntfs_attr_find_in_attrdef(vol, type);\n\tif (unlikely(!ad))\n\t\treturn -ENOENT;\n\t/* Check the flags and return the result. */\n\tif (ad->flags & ATTR_DEF_RESIDENT)\n\t\treturn -EPERM;\n\treturn 0;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_can_be_non_resident(const ntfs_volume *vol, const ATTR_TYPE type)\n{\n\tATTR_DEF *ad;\n\n\t/* Find the attribute definition record in $AttrDef. */\n\tad = ntfs_attr_find_in_attrdef(vol, type);\n\tif (unlikely(!ad))\n\t\treturn -ENOENT;\n\t/* Check the flags and return the result. */\n\tif (ad->flags & ATTR_DEF_RESIDENT)\n\t\treturn -EPERM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ni"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "245-248",
          "snippet": "static inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_make_non_resident(ntfs_inode *ni, const u32 data_size)\n{\n\ts64 new_size;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_volume *vol = ni->vol;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tstruct page *page;\n\trunlist_element *rl;\n\tu8 *kaddr;\n\tunsigned long flags;\n\tint mp_size, mp_ofs, name_ofs, arec_size, err, err2;\n\tu32 attr_size;\n\tu8 old_res_attr_flags;\n\n\t/* Check that the attribute is allowed to be non-resident. */\n\terr = ntfs_attr_can_be_non_resident(vol, ni->type);\n\tif (unlikely(err)) {\n\t\tif (err == -EPERM)\n\t\t\tntfs_debug(\"Attribute is not allowed to be \"\n\t\t\t\t\t\"non-resident.\");\n\t\telse\n\t\t\tntfs_debug(\"Attribute not defined on the NTFS \"\n\t\t\t\t\t\"volume!\");\n\t\treturn err;\n\t}\n\t/*\n\t * FIXME: Compressed and encrypted attributes are not supported when\n\t * writing and we should never have gotten here for them.\n\t */\n\tBUG_ON(NInoCompressed(ni));\n\tBUG_ON(NInoEncrypted(ni));\n\t/*\n\t * The size needs to be aligned to a cluster boundary for allocation\n\t * purposes.\n\t */\n\tnew_size = (data_size + vol->cluster_size - 1) &\n\t\t\t~(vol->cluster_size - 1);\n\tif (new_size > 0) {\n\t\t/*\n\t\t * Will need the page later and since the page lock nests\n\t\t * outside all ntfs locks, we need to get the page now.\n\t\t */\n\t\tpage = find_or_create_page(vi->i_mapping, 0,\n\t\t\t\tmapping_gfp_mask(vi->i_mapping));\n\t\tif (unlikely(!page))\n\t\t\treturn -ENOMEM;\n\t\t/* Start by allocating clusters to hold the attribute value. */\n\t\trl = ntfs_cluster_alloc(vol, 0, new_size >>\n\t\t\t\tvol->cluster_size_bits, -1, DATA_ZONE, true);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tntfs_debug(\"Failed to allocate cluster%s, error code \"\n\t\t\t\t\t\"%i.\", (new_size >>\n\t\t\t\t\tvol->cluster_size_bits) > 1 ? \"s\" : \"\",\n\t\t\t\t\terr);\n\t\t\tgoto page_err_out;\n\t\t}\n\t} else {\n\t\trl = NULL;\n\t\tpage = NULL;\n\t}\n\t/* Determine the size of the mapping pairs array. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl, 0, -1);\n\tif (unlikely(mp_size < 0)) {\n\t\terr = mp_size;\n\t\tntfs_debug(\"Failed to get size for mapping pairs array, error \"\n\t\t\t\t\"code %i.\", err);\n\t\tgoto rl_err_out;\n\t}\n\tdown_write(&ni->runlist.lock);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tBUG_ON(NInoNonResident(ni));\n\tBUG_ON(a->non_resident);\n\t/*\n\t * Calculate new offsets for the name and the mapping pairs array.\n\t */\n\tif (NInoSparse(ni) || NInoCompressed(ni))\n\t\tname_ofs = (offsetof(ATTR_REC,\n\t\t\t\tdata.non_resident.compressed_size) +\n\t\t\t\tsizeof(a->data.non_resident.compressed_size) +\n\t\t\t\t7) & ~7;\n\telse\n\t\tname_ofs = (offsetof(ATTR_REC,\n\t\t\t\tdata.non_resident.compressed_size) + 7) & ~7;\n\tmp_ofs = (name_ofs + a->name_length * sizeof(ntfschar) + 7) & ~7;\n\t/*\n\t * Determine the size of the resident part of the now non-resident\n\t * attribute record.\n\t */\n\tarec_size = (mp_ofs + mp_size + 7) & ~7;\n\t/*\n\t * If the page is not uptodate bring it uptodate by copying from the\n\t * attribute value.\n\t */\n\tattr_size = le32_to_cpu(a->data.resident.value_length);\n\tBUG_ON(attr_size != data_size);\n\tif (page && !PageUptodate(page)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(kaddr, (u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset),\n\t\t\t\tattr_size);\n\t\tmemset(kaddr + attr_size, 0, PAGE_CACHE_SIZE - attr_size);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t}\n\t/* Backup the attribute flag. */\n\told_res_attr_flags = a->data.resident.flags;\n\t/* Resize the resident part of the attribute record. */\n\terr = ntfs_attr_record_resize(m, a, arec_size);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\t/*\n\t * Convert the resident part of the attribute record to describe a\n\t * non-resident attribute.\n\t */\n\ta->non_resident = 1;\n\t/* Move the attribute name if it exists and update the offset. */\n\tif (a->name_length)\n\t\tmemmove((u8*)a + name_ofs, (u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\ta->name_length * sizeof(ntfschar));\n\ta->name_offset = cpu_to_le16(name_ofs);\n\t/* Setup the fields specific to non-resident attributes. */\n\ta->data.non_resident.lowest_vcn = 0;\n\ta->data.non_resident.highest_vcn = cpu_to_sle64((new_size - 1) >>\n\t\t\tvol->cluster_size_bits);\n\ta->data.non_resident.mapping_pairs_offset = cpu_to_le16(mp_ofs);\n\tmemset(&a->data.non_resident.reserved, 0,\n\t\t\tsizeof(a->data.non_resident.reserved));\n\ta->data.non_resident.allocated_size = cpu_to_sle64(new_size);\n\ta->data.non_resident.data_size =\n\t\t\ta->data.non_resident.initialized_size =\n\t\t\tcpu_to_sle64(attr_size);\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\ta->data.non_resident.compression_unit = 0;\n\t\tif (NInoCompressed(ni) || vol->major_ver < 3)\n\t\t\ta->data.non_resident.compression_unit = 4;\n\t\ta->data.non_resident.compressed_size =\n\t\t\t\ta->data.non_resident.allocated_size;\n\t} else\n\t\ta->data.non_resident.compression_unit = 0;\n\t/* Generate the mapping pairs array into the attribute record. */\n\terr = ntfs_mapping_pairs_build(vol, (u8*)a + mp_ofs,\n\t\t\tarec_size - mp_ofs, rl, 0, -1, NULL);\n\tif (unlikely(err)) {\n\t\tntfs_debug(\"Failed to build mapping pairs, error code %i.\",\n\t\t\t\terr);\n\t\tgoto undo_err_out;\n\t}\n\t/* Setup the in-memory attribute structure to be non-resident. */\n\tni->runlist.rl = rl;\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = new_size;\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\tni->itype.compressed.size = ni->allocated_size;\n\t\tif (a->data.non_resident.compression_unit) {\n\t\t\tni->itype.compressed.block_size = 1U << (a->data.\n\t\t\t\t\tnon_resident.compression_unit +\n\t\t\t\t\tvol->cluster_size_bits);\n\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\tffs(ni->itype.compressed.block_size) -\n\t\t\t\t\t1;\n\t\t\tni->itype.compressed.block_clusters = 1U <<\n\t\t\t\t\ta->data.non_resident.compression_unit;\n\t\t} else {\n\t\t\tni->itype.compressed.block_size = 0;\n\t\t\tni->itype.compressed.block_size_bits = 0;\n\t\t\tni->itype.compressed.block_clusters = 0;\n\t\t}\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t} else\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t/*\n\t * This needs to be last since the address space operations ->readpage\n\t * and ->writepage can run concurrently with us as they are not\n\t * serialized on i_mutex.  Note, we are not allowed to fail once we flip\n\t * this switch, which is another reason to do this last.\n\t */\n\tNInoSetNonResident(ni);\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\tif (page) {\n\t\tset_page_dirty(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tntfs_debug(\"Done.\");\n\treturn 0;\nundo_err_out:\n\t/* Convert the attribute back into a resident attribute. */\n\ta->non_resident = 0;\n\t/* Move the attribute name if it exists and update the offset. */\n\tname_ofs = (offsetof(ATTR_RECORD, data.resident.reserved) +\n\t\t\tsizeof(a->data.resident.reserved) + 7) & ~7;\n\tif (a->name_length)\n\t\tmemmove((u8*)a + name_ofs, (u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\ta->name_length * sizeof(ntfschar));\n\tmp_ofs = (name_ofs + a->name_length * sizeof(ntfschar) + 7) & ~7;\n\ta->name_offset = cpu_to_le16(name_ofs);\n\tarec_size = (mp_ofs + attr_size + 7) & ~7;\n\t/* Resize the resident part of the attribute record. */\n\terr2 = ntfs_attr_record_resize(m, a, arec_size);\n\tif (unlikely(err2)) {\n\t\t/*\n\t\t * This cannot happen (well if memory corruption is at work it\n\t\t * could happen in theory), but deal with it as well as we can.\n\t\t * If the old size is too small, truncate the attribute,\n\t\t * otherwise simply give it a larger allocated size.\n\t\t * FIXME: Should check whether chkdsk complains when the\n\t\t * allocated size is much bigger than the resident value size.\n\t\t */\n\t\tarec_size = le32_to_cpu(a->length);\n\t\tif ((mp_ofs + attr_size) > arec_size) {\n\t\t\terr2 = attr_size;\n\t\t\tattr_size = arec_size - mp_ofs;\n\t\t\tntfs_error(vol->sb, \"Failed to undo partial resident \"\n\t\t\t\t\t\"to non-resident attribute \"\n\t\t\t\t\t\"conversion.  Truncating inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x from %i bytes to \"\n\t\t\t\t\t\"%i bytes to maintain metadata \"\n\t\t\t\t\t\"consistency.  THIS MEANS YOU ARE \"\n\t\t\t\t\t\"LOSING %i BYTES DATA FROM THIS %s.\",\n\t\t\t\t\tvi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t\t\terr2, attr_size, err2 - attr_size,\n\t\t\t\t\t((ni->type == AT_DATA) &&\n\t\t\t\t\t!ni->name_len) ? \"FILE\": \"ATTRIBUTE\");\n\t\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t\tni->initialized_size = attr_size;\n\t\t\ti_size_write(vi, attr_size);\n\t\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t}\n\t}\n\t/* Setup the fields specific to resident attributes. */\n\ta->data.resident.value_length = cpu_to_le32(attr_size);\n\ta->data.resident.value_offset = cpu_to_le16(mp_ofs);\n\ta->data.resident.flags = old_res_attr_flags;\n\tmemset(&a->data.resident.reserved, 0,\n\t\t\tsizeof(a->data.resident.reserved));\n\t/* Copy the data from the page back to the attribute value. */\n\tif (page) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy((u8*)a + mp_ofs, kaddr, attr_size);\n\t\tkunmap_atomic(kaddr);\n\t}\n\t/* Setup the allocated size in the ntfs inode in case it changed. */\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = arec_size - mp_ofs;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tni->runlist.rl = NULL;\n\tup_write(&ni->runlist.lock);\nrl_err_out:\n\tif (rl) {\n\t\tif (ntfs_cluster_free_from_rl(vol, rl) < 0) {\n\t\t\tntfs_error(vol->sb, \"Failed to release allocated \"\n\t\t\t\t\t\"cluster(s) in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover the lost \"\n\t\t\t\t\t\"cluster(s).\");\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl);\npage_err_out:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (err == -EINVAL)\n\t\terr = -EIO;\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_resident_attr_value_resize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "1479-1499",
    "snippet": "int ntfs_resident_attr_value_resize(MFT_RECORD *m, ATTR_RECORD *a,\n\t\tconst u32 new_size)\n{\n\tu32 old_size;\n\n\t/* Resize the resident part of the attribute record. */\n\tif (ntfs_attr_record_resize(m, a,\n\t\t\tle16_to_cpu(a->data.resident.value_offset) + new_size))\n\t\treturn -ENOSPC;\n\t/*\n\t * The resize succeeded!  If we made the attribute value bigger, clear\n\t * the area between the old size and @new_size.\n\t */\n\told_size = le32_to_cpu(a->data.resident.value_length);\n\tif (new_size > old_size)\n\t\tmemset((u8*)a + le16_to_cpu(a->data.resident.value_offset) +\n\t\t\t\told_size, 0, new_size - old_size);\n\t/* Finally update the length of the attribute value. */\n\ta->data.resident.value_length = cpu_to_le32(new_size);\n\treturn 0;\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_size"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(u8*)a + le16_to_cpu(a->data.resident.value_offset) +\n\t\t\t\told_size",
            "0",
            "new_size - old_size"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "a->data.resident.value_offset"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "a->data.resident.value_length"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_record_resize",
          "args": [
            "m",
            "a",
            "le16_to_cpu(a->data.resident.value_offset) + new_size"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_record_resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1435-1459",
          "snippet": "int ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)\n{\n\tntfs_debug(\"Entering for new_size %u.\", new_size);\n\t/* Align to 8 bytes if it is not already done. */\n\tif (new_size & 7)\n\t\tnew_size = (new_size + 7) & ~7;\n\t/* If the actual attribute length has changed, move things around. */\n\tif (new_size != le32_to_cpu(a->length)) {\n\t\tu32 new_muse = le32_to_cpu(m->bytes_in_use) -\n\t\t\t\tle32_to_cpu(a->length) + new_size;\n\t\t/* Not enough space in this mft record. */\n\t\tif (new_muse > le32_to_cpu(m->bytes_allocated))\n\t\t\treturn -ENOSPC;\n\t\t/* Move attributes following @a to their new location. */\n\t\tmemmove((u8*)a + new_size, (u8*)a + le32_to_cpu(a->length),\n\t\t\t\tle32_to_cpu(m->bytes_in_use) - ((u8*)a -\n\t\t\t\t(u8*)m) - le32_to_cpu(a->length));\n\t\t/* Adjust @m to reflect the change in used space. */\n\t\tm->bytes_in_use = cpu_to_le32(new_muse);\n\t\t/* Adjust @a to reflect the new size. */\n\t\tif (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))\n\t\t\ta->length = cpu_to_le32(new_size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)\n{\n\tntfs_debug(\"Entering for new_size %u.\", new_size);\n\t/* Align to 8 bytes if it is not already done. */\n\tif (new_size & 7)\n\t\tnew_size = (new_size + 7) & ~7;\n\t/* If the actual attribute length has changed, move things around. */\n\tif (new_size != le32_to_cpu(a->length)) {\n\t\tu32 new_muse = le32_to_cpu(m->bytes_in_use) -\n\t\t\t\tle32_to_cpu(a->length) + new_size;\n\t\t/* Not enough space in this mft record. */\n\t\tif (new_muse > le32_to_cpu(m->bytes_allocated))\n\t\t\treturn -ENOSPC;\n\t\t/* Move attributes following @a to their new location. */\n\t\tmemmove((u8*)a + new_size, (u8*)a + le32_to_cpu(a->length),\n\t\t\t\tle32_to_cpu(m->bytes_in_use) - ((u8*)a -\n\t\t\t\t(u8*)m) - le32_to_cpu(a->length));\n\t\t/* Adjust @m to reflect the change in used space. */\n\t\tm->bytes_in_use = cpu_to_le32(new_muse);\n\t\t/* Adjust @a to reflect the new size. */\n\t\tif (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))\n\t\t\ta->length = cpu_to_le32(new_size);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_resident_attr_value_resize(MFT_RECORD *m, ATTR_RECORD *a,\n\t\tconst u32 new_size)\n{\n\tu32 old_size;\n\n\t/* Resize the resident part of the attribute record. */\n\tif (ntfs_attr_record_resize(m, a,\n\t\t\tle16_to_cpu(a->data.resident.value_offset) + new_size))\n\t\treturn -ENOSPC;\n\t/*\n\t * The resize succeeded!  If we made the attribute value bigger, clear\n\t * the area between the old size and @new_size.\n\t */\n\told_size = le32_to_cpu(a->data.resident.value_length);\n\tif (new_size > old_size)\n\t\tmemset((u8*)a + le16_to_cpu(a->data.resident.value_offset) +\n\t\t\t\told_size, 0, new_size - old_size);\n\t/* Finally update the length of the attribute value. */\n\ta->data.resident.value_length = cpu_to_le32(new_size);\n\treturn 0;\n}"
  },
  {
    "function_name": "ntfs_attr_record_resize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "1435-1459",
    "snippet": "int ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)\n{\n\tntfs_debug(\"Entering for new_size %u.\", new_size);\n\t/* Align to 8 bytes if it is not already done. */\n\tif (new_size & 7)\n\t\tnew_size = (new_size + 7) & ~7;\n\t/* If the actual attribute length has changed, move things around. */\n\tif (new_size != le32_to_cpu(a->length)) {\n\t\tu32 new_muse = le32_to_cpu(m->bytes_in_use) -\n\t\t\t\tle32_to_cpu(a->length) + new_size;\n\t\t/* Not enough space in this mft record. */\n\t\tif (new_muse > le32_to_cpu(m->bytes_allocated))\n\t\t\treturn -ENOSPC;\n\t\t/* Move attributes following @a to their new location. */\n\t\tmemmove((u8*)a + new_size, (u8*)a + le32_to_cpu(a->length),\n\t\t\t\tle32_to_cpu(m->bytes_in_use) - ((u8*)a -\n\t\t\t\t(u8*)m) - le32_to_cpu(a->length));\n\t\t/* Adjust @m to reflect the change in used space. */\n\t\tm->bytes_in_use = cpu_to_le32(new_muse);\n\t\t/* Adjust @a to reflect the new size. */\n\t\tif (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))\n\t\t\ta->length = cpu_to_le32(new_size);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_size"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_muse"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "(u8*)a + new_size",
            "(u8*)a + le32_to_cpu(a->length)",
            "le32_to_cpu(m->bytes_in_use) - ((u8*)a -\n\t\t\t\t(u8*)m) - le32_to_cpu(a->length)"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "a->length"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for new_size %u.\"",
            "new_size"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)\n{\n\tntfs_debug(\"Entering for new_size %u.\", new_size);\n\t/* Align to 8 bytes if it is not already done. */\n\tif (new_size & 7)\n\t\tnew_size = (new_size + 7) & ~7;\n\t/* If the actual attribute length has changed, move things around. */\n\tif (new_size != le32_to_cpu(a->length)) {\n\t\tu32 new_muse = le32_to_cpu(m->bytes_in_use) -\n\t\t\t\tle32_to_cpu(a->length) + new_size;\n\t\t/* Not enough space in this mft record. */\n\t\tif (new_muse > le32_to_cpu(m->bytes_allocated))\n\t\t\treturn -ENOSPC;\n\t\t/* Move attributes following @a to their new location. */\n\t\tmemmove((u8*)a + new_size, (u8*)a + le32_to_cpu(a->length),\n\t\t\t\tle32_to_cpu(m->bytes_in_use) - ((u8*)a -\n\t\t\t\t(u8*)m) - le32_to_cpu(a->length));\n\t\t/* Adjust @m to reflect the change in used space. */\n\t\tm->bytes_in_use = cpu_to_le32(new_muse);\n\t\t/* Adjust @a to reflect the new size. */\n\t\tif (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))\n\t\t\ta->length = cpu_to_le32(new_size);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ntfs_attr_can_be_resident",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "1410-1415",
    "snippet": "int ntfs_attr_can_be_resident(const ntfs_volume *vol, const ATTR_TYPE type)\n{\n\tif (type == AT_INDEX_ALLOCATION)\n\t\treturn -EPERM;\n\treturn 0;\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_can_be_resident(const ntfs_volume *vol, const ATTR_TYPE type)\n{\n\tif (type == AT_INDEX_ALLOCATION)\n\t\treturn -EPERM;\n\treturn 0;\n}"
  },
  {
    "function_name": "ntfs_attr_can_be_non_resident",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "1378-1390",
    "snippet": "int ntfs_attr_can_be_non_resident(const ntfs_volume *vol, const ATTR_TYPE type)\n{\n\tATTR_DEF *ad;\n\n\t/* Find the attribute definition record in $AttrDef. */\n\tad = ntfs_attr_find_in_attrdef(vol, type);\n\tif (unlikely(!ad))\n\t\treturn -ENOENT;\n\t/* Check the flags and return the result. */\n\tif (ad->flags & ATTR_DEF_RESIDENT)\n\t\treturn -EPERM;\n\treturn 0;\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ad"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_find_in_attrdef",
          "args": [
            "vol",
            "type"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_find_in_attrdef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1306-1328",
          "snippet": "static ATTR_DEF *ntfs_attr_find_in_attrdef(const ntfs_volume *vol,\n\t\tconst ATTR_TYPE type)\n{\n\tATTR_DEF *ad;\n\n\tBUG_ON(!vol->attrdef);\n\tBUG_ON(!type);\n\tfor (ad = vol->attrdef; (u8*)ad - (u8*)vol->attrdef <\n\t\t\tvol->attrdef_size && ad->type; ++ad) {\n\t\t/* We have not found it yet, carry on searching. */\n\t\tif (likely(le32_to_cpu(ad->type) < le32_to_cpu(type)))\n\t\t\tcontinue;\n\t\t/* We found the attribute; return it. */\n\t\tif (likely(ad->type == type))\n\t\t\treturn ad;\n\t\t/* We have gone too far already.  No point in continuing. */\n\t\tbreak;\n\t}\n\t/* Attribute not found. */\n\tntfs_debug(\"Attribute type 0x%x not found in $AttrDef.\",\n\t\t\tle32_to_cpu(type));\n\treturn NULL;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nstatic ATTR_DEF *ntfs_attr_find_in_attrdef(const ntfs_volume *vol,\n\t\tconst ATTR_TYPE type)\n{\n\tATTR_DEF *ad;\n\n\tBUG_ON(!vol->attrdef);\n\tBUG_ON(!type);\n\tfor (ad = vol->attrdef; (u8*)ad - (u8*)vol->attrdef <\n\t\t\tvol->attrdef_size && ad->type; ++ad) {\n\t\t/* We have not found it yet, carry on searching. */\n\t\tif (likely(le32_to_cpu(ad->type) < le32_to_cpu(type)))\n\t\t\tcontinue;\n\t\t/* We found the attribute; return it. */\n\t\tif (likely(ad->type == type))\n\t\t\treturn ad;\n\t\t/* We have gone too far already.  No point in continuing. */\n\t\tbreak;\n\t}\n\t/* Attribute not found. */\n\tntfs_debug(\"Attribute type 0x%x not found in $AttrDef.\",\n\t\t\tle32_to_cpu(type));\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_can_be_non_resident(const ntfs_volume *vol, const ATTR_TYPE type)\n{\n\tATTR_DEF *ad;\n\n\t/* Find the attribute definition record in $AttrDef. */\n\tad = ntfs_attr_find_in_attrdef(vol, type);\n\tif (unlikely(!ad))\n\t\treturn -ENOENT;\n\t/* Check the flags and return the result. */\n\tif (ad->flags & ATTR_DEF_RESIDENT)\n\t\treturn -EPERM;\n\treturn 0;\n}"
  },
  {
    "function_name": "ntfs_attr_size_bounds_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "1342-1365",
    "snippet": "int ntfs_attr_size_bounds_check(const ntfs_volume *vol, const ATTR_TYPE type,\n\t\tconst s64 size)\n{\n\tATTR_DEF *ad;\n\n\tBUG_ON(size < 0);\n\t/*\n\t * $ATTRIBUTE_LIST has a maximum size of 256kiB, but this is not\n\t * listed in $AttrDef.\n\t */\n\tif (unlikely(type == AT_ATTRIBUTE_LIST && size > 256 * 1024))\n\t\treturn -ERANGE;\n\t/* Get the $AttrDef entry for the attribute @type. */\n\tad = ntfs_attr_find_in_attrdef(vol, type);\n\tif (unlikely(!ad))\n\t\treturn -ENOENT;\n\t/* Do the bounds check. */\n\tif (((sle64_to_cpu(ad->min_size) > 0) &&\n\t\t\tsize < sle64_to_cpu(ad->min_size)) ||\n\t\t\t((sle64_to_cpu(ad->max_size) > 0) && size >\n\t\t\tsle64_to_cpu(ad->max_size)))\n\t\treturn -ERANGE;\n\treturn 0;\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "ad->max_size"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ad"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_find_in_attrdef",
          "args": [
            "vol",
            "type"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_find_in_attrdef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1306-1328",
          "snippet": "static ATTR_DEF *ntfs_attr_find_in_attrdef(const ntfs_volume *vol,\n\t\tconst ATTR_TYPE type)\n{\n\tATTR_DEF *ad;\n\n\tBUG_ON(!vol->attrdef);\n\tBUG_ON(!type);\n\tfor (ad = vol->attrdef; (u8*)ad - (u8*)vol->attrdef <\n\t\t\tvol->attrdef_size && ad->type; ++ad) {\n\t\t/* We have not found it yet, carry on searching. */\n\t\tif (likely(le32_to_cpu(ad->type) < le32_to_cpu(type)))\n\t\t\tcontinue;\n\t\t/* We found the attribute; return it. */\n\t\tif (likely(ad->type == type))\n\t\t\treturn ad;\n\t\t/* We have gone too far already.  No point in continuing. */\n\t\tbreak;\n\t}\n\t/* Attribute not found. */\n\tntfs_debug(\"Attribute type 0x%x not found in $AttrDef.\",\n\t\t\tle32_to_cpu(type));\n\treturn NULL;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nstatic ATTR_DEF *ntfs_attr_find_in_attrdef(const ntfs_volume *vol,\n\t\tconst ATTR_TYPE type)\n{\n\tATTR_DEF *ad;\n\n\tBUG_ON(!vol->attrdef);\n\tBUG_ON(!type);\n\tfor (ad = vol->attrdef; (u8*)ad - (u8*)vol->attrdef <\n\t\t\tvol->attrdef_size && ad->type; ++ad) {\n\t\t/* We have not found it yet, carry on searching. */\n\t\tif (likely(le32_to_cpu(ad->type) < le32_to_cpu(type)))\n\t\t\tcontinue;\n\t\t/* We found the attribute; return it. */\n\t\tif (likely(ad->type == type))\n\t\t\treturn ad;\n\t\t/* We have gone too far already.  No point in continuing. */\n\t\tbreak;\n\t}\n\t/* Attribute not found. */\n\tntfs_debug(\"Attribute type 0x%x not found in $AttrDef.\",\n\t\t\tle32_to_cpu(type));\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "type == AT_ATTRIBUTE_LIST && size > 256 * 1024"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "size < 0"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_size_bounds_check(const ntfs_volume *vol, const ATTR_TYPE type,\n\t\tconst s64 size)\n{\n\tATTR_DEF *ad;\n\n\tBUG_ON(size < 0);\n\t/*\n\t * $ATTRIBUTE_LIST has a maximum size of 256kiB, but this is not\n\t * listed in $AttrDef.\n\t */\n\tif (unlikely(type == AT_ATTRIBUTE_LIST && size > 256 * 1024))\n\t\treturn -ERANGE;\n\t/* Get the $AttrDef entry for the attribute @type. */\n\tad = ntfs_attr_find_in_attrdef(vol, type);\n\tif (unlikely(!ad))\n\t\treturn -ENOENT;\n\t/* Do the bounds check. */\n\tif (((sle64_to_cpu(ad->min_size) > 0) &&\n\t\t\tsize < sle64_to_cpu(ad->min_size)) ||\n\t\t\t((sle64_to_cpu(ad->max_size) > 0) && size >\n\t\t\tsle64_to_cpu(ad->max_size)))\n\t\treturn -ERANGE;\n\treturn 0;\n}"
  },
  {
    "function_name": "ntfs_attr_find_in_attrdef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "1306-1328",
    "snippet": "static ATTR_DEF *ntfs_attr_find_in_attrdef(const ntfs_volume *vol,\n\t\tconst ATTR_TYPE type)\n{\n\tATTR_DEF *ad;\n\n\tBUG_ON(!vol->attrdef);\n\tBUG_ON(!type);\n\tfor (ad = vol->attrdef; (u8*)ad - (u8*)vol->attrdef <\n\t\t\tvol->attrdef_size && ad->type; ++ad) {\n\t\t/* We have not found it yet, carry on searching. */\n\t\tif (likely(le32_to_cpu(ad->type) < le32_to_cpu(type)))\n\t\t\tcontinue;\n\t\t/* We found the attribute; return it. */\n\t\tif (likely(ad->type == type))\n\t\t\treturn ad;\n\t\t/* We have gone too far already.  No point in continuing. */\n\t\tbreak;\n\t}\n\t/* Attribute not found. */\n\tntfs_debug(\"Attribute type 0x%x not found in $AttrDef.\",\n\t\t\tle32_to_cpu(type));\n\treturn NULL;\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Attribute type 0x%x not found in $AttrDef.\"",
            "le32_to_cpu(type)"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "type"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ad->type == type"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "le32_to_cpu(ad->type) < le32_to_cpu(type)"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!type"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!vol->attrdef"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nstatic ATTR_DEF *ntfs_attr_find_in_attrdef(const ntfs_volume *vol,\n\t\tconst ATTR_TYPE type)\n{\n\tATTR_DEF *ad;\n\n\tBUG_ON(!vol->attrdef);\n\tBUG_ON(!type);\n\tfor (ad = vol->attrdef; (u8*)ad - (u8*)vol->attrdef <\n\t\t\tvol->attrdef_size && ad->type; ++ad) {\n\t\t/* We have not found it yet, carry on searching. */\n\t\tif (likely(le32_to_cpu(ad->type) < le32_to_cpu(type)))\n\t\t\tcontinue;\n\t\t/* We found the attribute; return it. */\n\t\tif (likely(ad->type == type))\n\t\t\treturn ad;\n\t\t/* We have gone too far already.  No point in continuing. */\n\t\tbreak;\n\t}\n\t/* Attribute not found. */\n\tntfs_debug(\"Attribute type 0x%x not found in $AttrDef.\",\n\t\t\tle32_to_cpu(type));\n\treturn NULL;\n}"
  },
  {
    "function_name": "ntfs_attr_put_search_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "1286-1292",
    "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ntfs_attr_ctx_cache",
            "ctx"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_extent_mft_record",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_extent_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "38-42",
          "snippet": "static inline void unmap_extent_mft_record(ntfs_inode *ni)\n{\n\tunmap_mft_record(ni);\n\treturn;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void unmap_extent_mft_record(ntfs_inode *ni)\n{\n\tunmap_mft_record(ni);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
  },
  {
    "function_name": "ntfs_attr_get_search_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "1269-1277",
    "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_attr_init_search_ctx",
          "args": [
            "ctx",
            "ni",
            "mrec"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_init_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1217-1228",
          "snippet": "static inline void ntfs_attr_init_search_ctx(ntfs_attr_search_ctx *ctx,\n\t\tntfs_inode *ni, MFT_RECORD *mrec)\n{\n\t*ctx = (ntfs_attr_search_ctx) {\n\t\t.mrec = mrec,\n\t\t/* Sanity checks are performed elsewhere. */\n\t\t.attr = (ATTR_RECORD*)((u8*)mrec +\n\t\t\t\tle16_to_cpu(mrec->attrs_offset)),\n\t\t.is_first = true,\n\t\t.ntfs_ino = ni,\n\t};\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nstatic inline void ntfs_attr_init_search_ctx(ntfs_attr_search_ctx *ctx,\n\t\tntfs_inode *ni, MFT_RECORD *mrec)\n{\n\t*ctx = (ntfs_attr_search_ctx) {\n\t\t.mrec = mrec,\n\t\t/* Sanity checks are performed elsewhere. */\n\t\t.attr = (ATTR_RECORD*)((u8*)mrec +\n\t\t\t\tle16_to_cpu(mrec->attrs_offset)),\n\t\t.is_first = true,\n\t\t.ntfs_ino = ni,\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ntfs_attr_ctx_cache",
            "GFP_NOFS"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
  },
  {
    "function_name": "ntfs_attr_reinit_search_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "1240-1259",
    "snippet": "void ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_attr_init_search_ctx",
          "args": [
            "ctx",
            "ctx->base_ntfs_ino",
            "ctx->base_mrec"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_init_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1217-1228",
          "snippet": "static inline void ntfs_attr_init_search_ctx(ntfs_attr_search_ctx *ctx,\n\t\tntfs_inode *ni, MFT_RECORD *mrec)\n{\n\t*ctx = (ntfs_attr_search_ctx) {\n\t\t.mrec = mrec,\n\t\t/* Sanity checks are performed elsewhere. */\n\t\t.attr = (ATTR_RECORD*)((u8*)mrec +\n\t\t\t\tle16_to_cpu(mrec->attrs_offset)),\n\t\t.is_first = true,\n\t\t.ntfs_ino = ni,\n\t};\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nstatic inline void ntfs_attr_init_search_ctx(ntfs_attr_search_ctx *ctx,\n\t\tntfs_inode *ni, MFT_RECORD *mrec)\n{\n\t*ctx = (ntfs_attr_search_ctx) {\n\t\t.mrec = mrec,\n\t\t/* Sanity checks are performed elsewhere. */\n\t\t.attr = (ATTR_RECORD*)((u8*)mrec +\n\t\t\t\tle16_to_cpu(mrec->attrs_offset)),\n\t\t.is_first = true,\n\t\t.ntfs_ino = ni,\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_extent_mft_record",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_extent_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "38-42",
          "snippet": "static inline void unmap_extent_mft_record(ntfs_inode *ni)\n{\n\tunmap_mft_record(ni);\n\treturn;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void unmap_extent_mft_record(ntfs_inode *ni)\n{\n\tunmap_mft_record(ni);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ctx->mrec->attrs_offset"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ctx->base_ntfs_ino"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}"
  },
  {
    "function_name": "ntfs_attr_init_search_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "1217-1228",
    "snippet": "static inline void ntfs_attr_init_search_ctx(ntfs_attr_search_ctx *ctx,\n\t\tntfs_inode *ni, MFT_RECORD *mrec)\n{\n\t*ctx = (ntfs_attr_search_ctx) {\n\t\t.mrec = mrec,\n\t\t/* Sanity checks are performed elsewhere. */\n\t\t.attr = (ATTR_RECORD*)((u8*)mrec +\n\t\t\t\tle16_to_cpu(mrec->attrs_offset)),\n\t\t.is_first = true,\n\t\t.ntfs_ino = ni,\n\t};\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "mrec->attrs_offset"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nstatic inline void ntfs_attr_init_search_ctx(ntfs_attr_search_ctx *ctx,\n\t\tntfs_inode *ni, MFT_RECORD *mrec)\n{\n\t*ctx = (ntfs_attr_search_ctx) {\n\t\t.mrec = mrec,\n\t\t/* Sanity checks are performed elsewhere. */\n\t\t.attr = (ATTR_RECORD*)((u8*)mrec +\n\t\t\t\tle16_to_cpu(mrec->attrs_offset)),\n\t\t.is_first = true,\n\t\t.ntfs_ino = ni,\n\t};\n}"
  },
  {
    "function_name": "ntfs_attr_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "1187-1207",
    "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_external_attr_find",
          "args": [
            "type",
            "name",
            "name_len",
            "ic",
            "lowest_vcn",
            "val",
            "val_len",
            "ctx"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_external_attr_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "857-1146",
          "snippet": "static int ntfs_external_attr_find(const ATTR_TYPE type,\n\t\tconst ntfschar *name, const u32 name_len,\n\t\tconst IGNORE_CASE_BOOL ic, const VCN lowest_vcn,\n\t\tconst u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni, *ni;\n\tntfs_volume *vol;\n\tATTR_LIST_ENTRY *al_entry, *next_al_entry;\n\tu8 *al_start, *al_end;\n\tATTR_RECORD *a;\n\tntfschar *al_name;\n\tu32 al_name_len;\n\tint err = 0;\n\tstatic const char *es = \" Unmount and run chkdsk.\";\n\n\tni = ctx->ntfs_ino;\n\tbase_ni = ctx->base_ntfs_ino;\n\tntfs_debug(\"Entering for inode 0x%lx, type 0x%x.\", ni->mft_no, type);\n\tif (!base_ni) {\n\t\t/* First call happens with the base mft record. */\n\t\tbase_ni = ctx->base_ntfs_ino = ctx->ntfs_ino;\n\t\tctx->base_mrec = ctx->mrec;\n\t}\n\tif (ni == base_ni)\n\t\tctx->base_attr = ctx->attr;\n\tif (type == AT_END)\n\t\tgoto not_found;\n\tvol = base_ni->vol;\n\tal_start = base_ni->attr_list;\n\tal_end = al_start + base_ni->attr_list_size;\n\tif (!ctx->al_entry)\n\t\tctx->al_entry = (ATTR_LIST_ENTRY*)al_start;\n\t/*\n\t * Iterate over entries in attribute list starting at @ctx->al_entry,\n\t * or the entry following that, if @ctx->is_first is 'true'.\n\t */\n\tif (ctx->is_first) {\n\t\tal_entry = ctx->al_entry;\n\t\tctx->is_first = false;\n\t} else\n\t\tal_entry = (ATTR_LIST_ENTRY*)((u8*)ctx->al_entry +\n\t\t\t\tle16_to_cpu(ctx->al_entry->length));\n\tfor (;; al_entry = next_al_entry) {\n\t\t/* Out of bounds check. */\n\t\tif ((u8*)al_entry < base_ni->attr_list ||\n\t\t\t\t(u8*)al_entry > al_end)\n\t\t\tbreak;\t/* Inode is corrupt. */\n\t\tctx->al_entry = al_entry;\n\t\t/* Catch the end of the attribute list. */\n\t\tif ((u8*)al_entry == al_end)\n\t\t\tgoto not_found;\n\t\tif (!al_entry->length)\n\t\t\tbreak;\n\t\tif ((u8*)al_entry + 6 > al_end || (u8*)al_entry +\n\t\t\t\tle16_to_cpu(al_entry->length) > al_end)\n\t\t\tbreak;\n\t\tnext_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +\n\t\t\t\tle16_to_cpu(al_entry->length));\n\t\tif (le32_to_cpu(al_entry->type) > le32_to_cpu(type))\n\t\t\tgoto not_found;\n\t\tif (type != al_entry->type)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If @name is present, compare the two names.  If @name is\n\t\t * missing, assume we want an unnamed attribute.\n\t\t */\n\t\tal_name_len = al_entry->name_length;\n\t\tal_name = (ntfschar*)((u8*)al_entry + al_entry->name_offset);\n\t\tif (!name) {\n\t\t\tif (al_name_len)\n\t\t\t\tgoto not_found;\n\t\t} else if (!ntfs_are_names_equal(al_name, al_name_len, name,\n\t\t\t\tname_len, ic, vol->upcase, vol->upcase_len)) {\n\t\t\tregister int rc;\n\n\t\t\trc = ntfs_collate_names(name, name_len, al_name,\n\t\t\t\t\tal_name_len, 1, IGNORE_CASE,\n\t\t\t\t\tvol->upcase, vol->upcase_len);\n\t\t\t/*\n\t\t\t * If @name collates before al_name, there is no\n\t\t\t * matching attribute.\n\t\t\t */\n\t\t\tif (rc == -1)\n\t\t\t\tgoto not_found;\n\t\t\t/* If the strings are not equal, continue search. */\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * FIXME: Reverse engineering showed 0, IGNORE_CASE but\n\t\t\t * that is inconsistent with ntfs_attr_find().  The\n\t\t\t * subsequent rc checks were also different.  Perhaps I\n\t\t\t * made a mistake in one of the two.  Need to recheck\n\t\t\t * which is correct or at least see what is going on...\n\t\t\t * (AIA)\n\t\t\t */\n\t\t\trc = ntfs_collate_names(name, name_len, al_name,\n\t\t\t\t\tal_name_len, 1, CASE_SENSITIVE,\n\t\t\t\t\tvol->upcase, vol->upcase_len);\n\t\t\tif (rc == -1)\n\t\t\t\tgoto not_found;\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * The names match or @name not present and attribute is\n\t\t * unnamed.  Now check @lowest_vcn.  Continue search if the\n\t\t * next attribute list entry still fits @lowest_vcn.  Otherwise\n\t\t * we have reached the right one or the search has failed.\n\t\t */\n\t\tif (lowest_vcn && (u8*)next_al_entry >= al_start\t    &&\n\t\t\t\t(u8*)next_al_entry + 6 < al_end\t\t    &&\n\t\t\t\t(u8*)next_al_entry + le16_to_cpu(\n\t\t\t\t\tnext_al_entry->length) <= al_end    &&\n\t\t\t\tsle64_to_cpu(next_al_entry->lowest_vcn) <=\n\t\t\t\t\tlowest_vcn\t\t\t    &&\n\t\t\t\tnext_al_entry->type == al_entry->type\t    &&\n\t\t\t\tnext_al_entry->name_length == al_name_len   &&\n\t\t\t\tntfs_are_names_equal((ntfschar*)((u8*)\n\t\t\t\t\tnext_al_entry +\n\t\t\t\t\tnext_al_entry->name_offset),\n\t\t\t\t\tnext_al_entry->name_length,\n\t\t\t\t\tal_name, al_name_len, CASE_SENSITIVE,\n\t\t\t\t\tvol->upcase, vol->upcase_len))\n\t\t\tcontinue;\n\t\tif (MREF_LE(al_entry->mft_reference) == ni->mft_no) {\n\t\t\tif (MSEQNO_LE(al_entry->mft_reference) != ni->seq_no) {\n\t\t\t\tntfs_error(vol->sb, \"Found stale mft \"\n\t\t\t\t\t\t\"reference in attribute list \"\n\t\t\t\t\t\t\"of base inode 0x%lx.%s\",\n\t\t\t\t\t\tbase_ni->mft_no, es);\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else { /* Mft references do not match. */\n\t\t\t/* If there is a mapped record unmap it first. */\n\t\t\tif (ni != base_ni)\n\t\t\t\tunmap_extent_mft_record(ni);\n\t\t\t/* Do we want the base record back? */\n\t\t\tif (MREF_LE(al_entry->mft_reference) ==\n\t\t\t\t\tbase_ni->mft_no) {\n\t\t\t\tni = ctx->ntfs_ino = base_ni;\n\t\t\t\tctx->mrec = ctx->base_mrec;\n\t\t\t} else {\n\t\t\t\t/* We want an extent record. */\n\t\t\t\tctx->mrec = map_extent_mft_record(base_ni,\n\t\t\t\t\t\tle64_to_cpu(\n\t\t\t\t\t\tal_entry->mft_reference), &ni);\n\t\t\t\tif (IS_ERR(ctx->mrec)) {\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to map \"\n\t\t\t\t\t\t\t\"extent mft record \"\n\t\t\t\t\t\t\t\"0x%lx of base inode \"\n\t\t\t\t\t\t\t\"0x%lx.%s\",\n\t\t\t\t\t\t\tMREF_LE(al_entry->\n\t\t\t\t\t\t\tmft_reference),\n\t\t\t\t\t\t\tbase_ni->mft_no, es);\n\t\t\t\t\terr = PTR_ERR(ctx->mrec);\n\t\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\t\terr = -EIO;\n\t\t\t\t\t/* Cause @ctx to be sanitized below. */\n\t\t\t\t\tni = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx->ntfs_ino = ni;\n\t\t\t}\n\t\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t}\n\t\t/*\n\t\t * ctx->vfs_ino, ctx->mrec, and ctx->attr now point to the\n\t\t * mft record containing the attribute represented by the\n\t\t * current al_entry.\n\t\t */\n\t\t/*\n\t\t * We could call into ntfs_attr_find() to find the right\n\t\t * attribute in this mft record but this would be less\n\t\t * efficient and not quite accurate as ntfs_attr_find() ignores\n\t\t * the attribute instance numbers for example which become\n\t\t * important when one plays with attribute lists.  Also,\n\t\t * because a proper match has been found in the attribute list\n\t\t * entry above, the comparison can now be optimized.  So it is\n\t\t * worth re-implementing a simplified ntfs_attr_find() here.\n\t\t */\n\t\ta = ctx->attr;\n\t\t/*\n\t\t * Use a manual loop so we can still use break and continue\n\t\t * with the same meanings as above.\n\t\t */\ndo_next_attr_loop:\n\t\tif ((u8*)a < (u8*)ctx->mrec || (u8*)a > (u8*)ctx->mrec +\n\t\t\t\tle32_to_cpu(ctx->mrec->bytes_allocated))\n\t\t\tbreak;\n\t\tif (a->type == AT_END)\n\t\t\tbreak;\n\t\tif (!a->length)\n\t\t\tbreak;\n\t\tif (al_entry->instance != a->instance)\n\t\t\tgoto do_next_attr;\n\t\t/*\n\t\t * If the type and/or the name are mismatched between the\n\t\t * attribute list entry and the attribute record, there is\n\t\t * corruption so we break and return error EIO.\n\t\t */\n\t\tif (al_entry->type != a->type)\n\t\t\tbreak;\n\t\tif (!ntfs_are_names_equal((ntfschar*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->name_offset)), a->name_length,\n\t\t\t\tal_name, al_name_len, CASE_SENSITIVE,\n\t\t\t\tvol->upcase, vol->upcase_len))\n\t\t\tbreak;\n\t\tctx->attr = a;\n\t\t/*\n\t\t * If no @val specified or @val specified and it matches, we\n\t\t * have found it!\n\t\t */\n\t\tif (!val || (!a->non_resident && le32_to_cpu(\n\t\t\t\ta->data.resident.value_length) == val_len &&\n\t\t\t\t!memcmp((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset),\n\t\t\t\tval, val_len))) {\n\t\t\tntfs_debug(\"Done, found.\");\n\t\t\treturn 0;\n\t\t}\ndo_next_attr:\n\t\t/* Proceed to the next attribute in the current mft record. */\n\t\ta = (ATTR_RECORD*)((u8*)a + le32_to_cpu(a->length));\n\t\tgoto do_next_attr_loop;\n\t}\n\tif (!err) {\n\t\tntfs_error(vol->sb, \"Base inode 0x%lx contains corrupt \"\n\t\t\t\t\"attribute list attribute.%s\", base_ni->mft_no,\n\t\t\t\tes);\n\t\terr = -EIO;\n\t}\n\tif (ni != base_ni) {\n\t\tif (ni)\n\t\t\tunmap_extent_mft_record(ni);\n\t\tctx->ntfs_ino = base_ni;\n\t\tctx->mrec = ctx->base_mrec;\n\t\tctx->attr = ctx->base_attr;\n\t}\n\tif (err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\nnot_found:\n\t/*\n\t * If we were looking for AT_END, we reset the search context @ctx and\n\t * use ntfs_attr_find() to seek to the end of the base mft record.\n\t */\n\tif (type == AT_END) {\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\treturn ntfs_attr_find(AT_END, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\t}\n\t/*\n\t * The attribute was not found.  Before we return, we want to ensure\n\t * @ctx->mrec and @ctx->attr indicate the position at which the\n\t * attribute should be inserted in the base mft record.  Since we also\n\t * want to preserve @ctx->al_entry we cannot reinitialize the search\n\t * context using ntfs_attr_reinit_search_ctx() as this would set\n\t * @ctx->al_entry to NULL.  Thus we do the necessary bits manually (see\n\t * ntfs_attr_init_search_ctx() below).  Note, we _only_ preserve\n\t * @ctx->al_entry as the remaining fields (base_*) are identical to\n\t * their non base_ counterparts and we cannot set @ctx->base_attr\n\t * correctly yet as we do not know what @ctx->attr will be set to by\n\t * the call to ntfs_attr_find() below.\n\t */\n\tif (ni != base_ni)\n\t\tunmap_extent_mft_record(ni);\n\tctx->mrec = ctx->base_mrec;\n\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\tctx->is_first = true;\n\tctx->ntfs_ino = base_ni;\n\tctx->base_ntfs_ino = NULL;\n\tctx->base_mrec = NULL;\n\tctx->base_attr = NULL;\n\t/*\n\t * In case there are multiple matches in the base mft record, need to\n\t * keep enumerating until we get an attribute not found response (or\n\t * another error), otherwise we would keep returning the same attribute\n\t * over and over again and all programs using us for enumeration would\n\t * lock up in a tight loop.\n\t */\n\tdo {\n\t\terr = ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\t} while (!err);\n\tntfs_debug(\"Done, not found.\");\n\treturn err;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_external_attr_find(const ATTR_TYPE type,\n\t\tconst ntfschar *name, const u32 name_len,\n\t\tconst IGNORE_CASE_BOOL ic, const VCN lowest_vcn,\n\t\tconst u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni, *ni;\n\tntfs_volume *vol;\n\tATTR_LIST_ENTRY *al_entry, *next_al_entry;\n\tu8 *al_start, *al_end;\n\tATTR_RECORD *a;\n\tntfschar *al_name;\n\tu32 al_name_len;\n\tint err = 0;\n\tstatic const char *es = \" Unmount and run chkdsk.\";\n\n\tni = ctx->ntfs_ino;\n\tbase_ni = ctx->base_ntfs_ino;\n\tntfs_debug(\"Entering for inode 0x%lx, type 0x%x.\", ni->mft_no, type);\n\tif (!base_ni) {\n\t\t/* First call happens with the base mft record. */\n\t\tbase_ni = ctx->base_ntfs_ino = ctx->ntfs_ino;\n\t\tctx->base_mrec = ctx->mrec;\n\t}\n\tif (ni == base_ni)\n\t\tctx->base_attr = ctx->attr;\n\tif (type == AT_END)\n\t\tgoto not_found;\n\tvol = base_ni->vol;\n\tal_start = base_ni->attr_list;\n\tal_end = al_start + base_ni->attr_list_size;\n\tif (!ctx->al_entry)\n\t\tctx->al_entry = (ATTR_LIST_ENTRY*)al_start;\n\t/*\n\t * Iterate over entries in attribute list starting at @ctx->al_entry,\n\t * or the entry following that, if @ctx->is_first is 'true'.\n\t */\n\tif (ctx->is_first) {\n\t\tal_entry = ctx->al_entry;\n\t\tctx->is_first = false;\n\t} else\n\t\tal_entry = (ATTR_LIST_ENTRY*)((u8*)ctx->al_entry +\n\t\t\t\tle16_to_cpu(ctx->al_entry->length));\n\tfor (;; al_entry = next_al_entry) {\n\t\t/* Out of bounds check. */\n\t\tif ((u8*)al_entry < base_ni->attr_list ||\n\t\t\t\t(u8*)al_entry > al_end)\n\t\t\tbreak;\t/* Inode is corrupt. */\n\t\tctx->al_entry = al_entry;\n\t\t/* Catch the end of the attribute list. */\n\t\tif ((u8*)al_entry == al_end)\n\t\t\tgoto not_found;\n\t\tif (!al_entry->length)\n\t\t\tbreak;\n\t\tif ((u8*)al_entry + 6 > al_end || (u8*)al_entry +\n\t\t\t\tle16_to_cpu(al_entry->length) > al_end)\n\t\t\tbreak;\n\t\tnext_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +\n\t\t\t\tle16_to_cpu(al_entry->length));\n\t\tif (le32_to_cpu(al_entry->type) > le32_to_cpu(type))\n\t\t\tgoto not_found;\n\t\tif (type != al_entry->type)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If @name is present, compare the two names.  If @name is\n\t\t * missing, assume we want an unnamed attribute.\n\t\t */\n\t\tal_name_len = al_entry->name_length;\n\t\tal_name = (ntfschar*)((u8*)al_entry + al_entry->name_offset);\n\t\tif (!name) {\n\t\t\tif (al_name_len)\n\t\t\t\tgoto not_found;\n\t\t} else if (!ntfs_are_names_equal(al_name, al_name_len, name,\n\t\t\t\tname_len, ic, vol->upcase, vol->upcase_len)) {\n\t\t\tregister int rc;\n\n\t\t\trc = ntfs_collate_names(name, name_len, al_name,\n\t\t\t\t\tal_name_len, 1, IGNORE_CASE,\n\t\t\t\t\tvol->upcase, vol->upcase_len);\n\t\t\t/*\n\t\t\t * If @name collates before al_name, there is no\n\t\t\t * matching attribute.\n\t\t\t */\n\t\t\tif (rc == -1)\n\t\t\t\tgoto not_found;\n\t\t\t/* If the strings are not equal, continue search. */\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * FIXME: Reverse engineering showed 0, IGNORE_CASE but\n\t\t\t * that is inconsistent with ntfs_attr_find().  The\n\t\t\t * subsequent rc checks were also different.  Perhaps I\n\t\t\t * made a mistake in one of the two.  Need to recheck\n\t\t\t * which is correct or at least see what is going on...\n\t\t\t * (AIA)\n\t\t\t */\n\t\t\trc = ntfs_collate_names(name, name_len, al_name,\n\t\t\t\t\tal_name_len, 1, CASE_SENSITIVE,\n\t\t\t\t\tvol->upcase, vol->upcase_len);\n\t\t\tif (rc == -1)\n\t\t\t\tgoto not_found;\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * The names match or @name not present and attribute is\n\t\t * unnamed.  Now check @lowest_vcn.  Continue search if the\n\t\t * next attribute list entry still fits @lowest_vcn.  Otherwise\n\t\t * we have reached the right one or the search has failed.\n\t\t */\n\t\tif (lowest_vcn && (u8*)next_al_entry >= al_start\t    &&\n\t\t\t\t(u8*)next_al_entry + 6 < al_end\t\t    &&\n\t\t\t\t(u8*)next_al_entry + le16_to_cpu(\n\t\t\t\t\tnext_al_entry->length) <= al_end    &&\n\t\t\t\tsle64_to_cpu(next_al_entry->lowest_vcn) <=\n\t\t\t\t\tlowest_vcn\t\t\t    &&\n\t\t\t\tnext_al_entry->type == al_entry->type\t    &&\n\t\t\t\tnext_al_entry->name_length == al_name_len   &&\n\t\t\t\tntfs_are_names_equal((ntfschar*)((u8*)\n\t\t\t\t\tnext_al_entry +\n\t\t\t\t\tnext_al_entry->name_offset),\n\t\t\t\t\tnext_al_entry->name_length,\n\t\t\t\t\tal_name, al_name_len, CASE_SENSITIVE,\n\t\t\t\t\tvol->upcase, vol->upcase_len))\n\t\t\tcontinue;\n\t\tif (MREF_LE(al_entry->mft_reference) == ni->mft_no) {\n\t\t\tif (MSEQNO_LE(al_entry->mft_reference) != ni->seq_no) {\n\t\t\t\tntfs_error(vol->sb, \"Found stale mft \"\n\t\t\t\t\t\t\"reference in attribute list \"\n\t\t\t\t\t\t\"of base inode 0x%lx.%s\",\n\t\t\t\t\t\tbase_ni->mft_no, es);\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else { /* Mft references do not match. */\n\t\t\t/* If there is a mapped record unmap it first. */\n\t\t\tif (ni != base_ni)\n\t\t\t\tunmap_extent_mft_record(ni);\n\t\t\t/* Do we want the base record back? */\n\t\t\tif (MREF_LE(al_entry->mft_reference) ==\n\t\t\t\t\tbase_ni->mft_no) {\n\t\t\t\tni = ctx->ntfs_ino = base_ni;\n\t\t\t\tctx->mrec = ctx->base_mrec;\n\t\t\t} else {\n\t\t\t\t/* We want an extent record. */\n\t\t\t\tctx->mrec = map_extent_mft_record(base_ni,\n\t\t\t\t\t\tle64_to_cpu(\n\t\t\t\t\t\tal_entry->mft_reference), &ni);\n\t\t\t\tif (IS_ERR(ctx->mrec)) {\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to map \"\n\t\t\t\t\t\t\t\"extent mft record \"\n\t\t\t\t\t\t\t\"0x%lx of base inode \"\n\t\t\t\t\t\t\t\"0x%lx.%s\",\n\t\t\t\t\t\t\tMREF_LE(al_entry->\n\t\t\t\t\t\t\tmft_reference),\n\t\t\t\t\t\t\tbase_ni->mft_no, es);\n\t\t\t\t\terr = PTR_ERR(ctx->mrec);\n\t\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\t\terr = -EIO;\n\t\t\t\t\t/* Cause @ctx to be sanitized below. */\n\t\t\t\t\tni = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx->ntfs_ino = ni;\n\t\t\t}\n\t\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t}\n\t\t/*\n\t\t * ctx->vfs_ino, ctx->mrec, and ctx->attr now point to the\n\t\t * mft record containing the attribute represented by the\n\t\t * current al_entry.\n\t\t */\n\t\t/*\n\t\t * We could call into ntfs_attr_find() to find the right\n\t\t * attribute in this mft record but this would be less\n\t\t * efficient and not quite accurate as ntfs_attr_find() ignores\n\t\t * the attribute instance numbers for example which become\n\t\t * important when one plays with attribute lists.  Also,\n\t\t * because a proper match has been found in the attribute list\n\t\t * entry above, the comparison can now be optimized.  So it is\n\t\t * worth re-implementing a simplified ntfs_attr_find() here.\n\t\t */\n\t\ta = ctx->attr;\n\t\t/*\n\t\t * Use a manual loop so we can still use break and continue\n\t\t * with the same meanings as above.\n\t\t */\ndo_next_attr_loop:\n\t\tif ((u8*)a < (u8*)ctx->mrec || (u8*)a > (u8*)ctx->mrec +\n\t\t\t\tle32_to_cpu(ctx->mrec->bytes_allocated))\n\t\t\tbreak;\n\t\tif (a->type == AT_END)\n\t\t\tbreak;\n\t\tif (!a->length)\n\t\t\tbreak;\n\t\tif (al_entry->instance != a->instance)\n\t\t\tgoto do_next_attr;\n\t\t/*\n\t\t * If the type and/or the name are mismatched between the\n\t\t * attribute list entry and the attribute record, there is\n\t\t * corruption so we break and return error EIO.\n\t\t */\n\t\tif (al_entry->type != a->type)\n\t\t\tbreak;\n\t\tif (!ntfs_are_names_equal((ntfschar*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->name_offset)), a->name_length,\n\t\t\t\tal_name, al_name_len, CASE_SENSITIVE,\n\t\t\t\tvol->upcase, vol->upcase_len))\n\t\t\tbreak;\n\t\tctx->attr = a;\n\t\t/*\n\t\t * If no @val specified or @val specified and it matches, we\n\t\t * have found it!\n\t\t */\n\t\tif (!val || (!a->non_resident && le32_to_cpu(\n\t\t\t\ta->data.resident.value_length) == val_len &&\n\t\t\t\t!memcmp((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset),\n\t\t\t\tval, val_len))) {\n\t\t\tntfs_debug(\"Done, found.\");\n\t\t\treturn 0;\n\t\t}\ndo_next_attr:\n\t\t/* Proceed to the next attribute in the current mft record. */\n\t\ta = (ATTR_RECORD*)((u8*)a + le32_to_cpu(a->length));\n\t\tgoto do_next_attr_loop;\n\t}\n\tif (!err) {\n\t\tntfs_error(vol->sb, \"Base inode 0x%lx contains corrupt \"\n\t\t\t\t\"attribute list attribute.%s\", base_ni->mft_no,\n\t\t\t\tes);\n\t\terr = -EIO;\n\t}\n\tif (ni != base_ni) {\n\t\tif (ni)\n\t\t\tunmap_extent_mft_record(ni);\n\t\tctx->ntfs_ino = base_ni;\n\t\tctx->mrec = ctx->base_mrec;\n\t\tctx->attr = ctx->base_attr;\n\t}\n\tif (err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\nnot_found:\n\t/*\n\t * If we were looking for AT_END, we reset the search context @ctx and\n\t * use ntfs_attr_find() to seek to the end of the base mft record.\n\t */\n\tif (type == AT_END) {\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\treturn ntfs_attr_find(AT_END, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\t}\n\t/*\n\t * The attribute was not found.  Before we return, we want to ensure\n\t * @ctx->mrec and @ctx->attr indicate the position at which the\n\t * attribute should be inserted in the base mft record.  Since we also\n\t * want to preserve @ctx->al_entry we cannot reinitialize the search\n\t * context using ntfs_attr_reinit_search_ctx() as this would set\n\t * @ctx->al_entry to NULL.  Thus we do the necessary bits manually (see\n\t * ntfs_attr_init_search_ctx() below).  Note, we _only_ preserve\n\t * @ctx->al_entry as the remaining fields (base_*) are identical to\n\t * their non base_ counterparts and we cannot set @ctx->base_attr\n\t * correctly yet as we do not know what @ctx->attr will be set to by\n\t * the call to ntfs_attr_find() below.\n\t */\n\tif (ni != base_ni)\n\t\tunmap_extent_mft_record(ni);\n\tctx->mrec = ctx->base_mrec;\n\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\tctx->is_first = true;\n\tctx->ntfs_ino = base_ni;\n\tctx->base_ntfs_ino = NULL;\n\tctx->base_mrec = NULL;\n\tctx->base_attr = NULL;\n\t/*\n\t * In case there are multiple matches in the base mft record, need to\n\t * keep enumerating until we get an attribute not found response (or\n\t * another error), otherwise we would keep returning the same attribute\n\t * over and over again and all programs using us for enumeration would\n\t * lock up in a tight loop.\n\t */\n\tdo {\n\t\terr = ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\t} while (!err);\n\tntfs_debug(\"Done, not found.\");\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_find",
          "args": [
            "type",
            "name",
            "name_len",
            "ic",
            "val",
            "val_len",
            "ctx"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "589-692",
          "snippet": "static int ntfs_attr_find(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)\n{\n\tATTR_RECORD *a;\n\tntfs_volume *vol = ctx->ntfs_ino->vol;\n\tntfschar *upcase = vol->upcase;\n\tu32 upcase_len = vol->upcase_len;\n\n\t/*\n\t * Iterate over attributes in mft record starting at @ctx->attr, or the\n\t * attribute following that, if @ctx->is_first is 'true'.\n\t */\n\tif (ctx->is_first) {\n\t\ta = ctx->attr;\n\t\tctx->is_first = false;\n\t} else\n\t\ta = (ATTR_RECORD*)((u8*)ctx->attr +\n\t\t\t\tle32_to_cpu(ctx->attr->length));\n\tfor (;;\ta = (ATTR_RECORD*)((u8*)a + le32_to_cpu(a->length))) {\n\t\tif ((u8*)a < (u8*)ctx->mrec || (u8*)a > (u8*)ctx->mrec +\n\t\t\t\tle32_to_cpu(ctx->mrec->bytes_allocated))\n\t\t\tbreak;\n\t\tctx->attr = a;\n\t\tif (unlikely(le32_to_cpu(a->type) > le32_to_cpu(type) ||\n\t\t\t\ta->type == AT_END))\n\t\t\treturn -ENOENT;\n\t\tif (unlikely(!a->length))\n\t\t\tbreak;\n\t\tif (a->type != type)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If @name is present, compare the two names.  If @name is\n\t\t * missing, assume we want an unnamed attribute.\n\t\t */\n\t\tif (!name) {\n\t\t\t/* The search failed if the found attribute is named. */\n\t\t\tif (a->name_length)\n\t\t\t\treturn -ENOENT;\n\t\t} else if (!ntfs_are_names_equal(name, name_len,\n\t\t\t    (ntfschar*)((u8*)a + le16_to_cpu(a->name_offset)),\n\t\t\t    a->name_length, ic, upcase, upcase_len)) {\n\t\t\tregister int rc;\n\n\t\t\trc = ntfs_collate_names(name, name_len,\n\t\t\t\t\t(ntfschar*)((u8*)a +\n\t\t\t\t\tle16_to_cpu(a->name_offset)),\n\t\t\t\t\ta->name_length, 1, IGNORE_CASE,\n\t\t\t\t\tupcase, upcase_len);\n\t\t\t/*\n\t\t\t * If @name collates before a->name, there is no\n\t\t\t * matching attribute.\n\t\t\t */\n\t\t\tif (rc == -1)\n\t\t\t\treturn -ENOENT;\n\t\t\t/* If the strings are not equal, continue search. */\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t\trc = ntfs_collate_names(name, name_len,\n\t\t\t\t\t(ntfschar*)((u8*)a +\n\t\t\t\t\tle16_to_cpu(a->name_offset)),\n\t\t\t\t\ta->name_length, 1, CASE_SENSITIVE,\n\t\t\t\t\tupcase, upcase_len);\n\t\t\tif (rc == -1)\n\t\t\t\treturn -ENOENT;\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * The names match or @name not present and attribute is\n\t\t * unnamed.  If no @val specified, we have found the attribute\n\t\t * and are done.\n\t\t */\n\t\tif (!val)\n\t\t\treturn 0;\n\t\t/* @val is present; compare values. */\n\t\telse {\n\t\t\tregister int rc;\n\n\t\t\trc = memcmp(val, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tmin_t(u32, val_len, le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length)));\n\t\t\t/*\n\t\t\t * If @val collates before the current attribute's\n\t\t\t * value, there is no matching attribute.\n\t\t\t */\n\t\t\tif (!rc) {\n\t\t\t\tregister u32 avl;\n\n\t\t\t\tavl = le32_to_cpu(\n\t\t\t\t\t\ta->data.resident.value_length);\n\t\t\t\tif (val_len == avl)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (val_len < avl)\n\t\t\t\t\treturn -ENOENT;\n\t\t\t} else if (rc < 0)\n\t\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\tntfs_error(vol->sb, \"Inode is corrupt.  Run chkdsk.\");\n\tNVolSetErrors(vol);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_attr_find(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)\n{\n\tATTR_RECORD *a;\n\tntfs_volume *vol = ctx->ntfs_ino->vol;\n\tntfschar *upcase = vol->upcase;\n\tu32 upcase_len = vol->upcase_len;\n\n\t/*\n\t * Iterate over attributes in mft record starting at @ctx->attr, or the\n\t * attribute following that, if @ctx->is_first is 'true'.\n\t */\n\tif (ctx->is_first) {\n\t\ta = ctx->attr;\n\t\tctx->is_first = false;\n\t} else\n\t\ta = (ATTR_RECORD*)((u8*)ctx->attr +\n\t\t\t\tle32_to_cpu(ctx->attr->length));\n\tfor (;;\ta = (ATTR_RECORD*)((u8*)a + le32_to_cpu(a->length))) {\n\t\tif ((u8*)a < (u8*)ctx->mrec || (u8*)a > (u8*)ctx->mrec +\n\t\t\t\tle32_to_cpu(ctx->mrec->bytes_allocated))\n\t\t\tbreak;\n\t\tctx->attr = a;\n\t\tif (unlikely(le32_to_cpu(a->type) > le32_to_cpu(type) ||\n\t\t\t\ta->type == AT_END))\n\t\t\treturn -ENOENT;\n\t\tif (unlikely(!a->length))\n\t\t\tbreak;\n\t\tif (a->type != type)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If @name is present, compare the two names.  If @name is\n\t\t * missing, assume we want an unnamed attribute.\n\t\t */\n\t\tif (!name) {\n\t\t\t/* The search failed if the found attribute is named. */\n\t\t\tif (a->name_length)\n\t\t\t\treturn -ENOENT;\n\t\t} else if (!ntfs_are_names_equal(name, name_len,\n\t\t\t    (ntfschar*)((u8*)a + le16_to_cpu(a->name_offset)),\n\t\t\t    a->name_length, ic, upcase, upcase_len)) {\n\t\t\tregister int rc;\n\n\t\t\trc = ntfs_collate_names(name, name_len,\n\t\t\t\t\t(ntfschar*)((u8*)a +\n\t\t\t\t\tle16_to_cpu(a->name_offset)),\n\t\t\t\t\ta->name_length, 1, IGNORE_CASE,\n\t\t\t\t\tupcase, upcase_len);\n\t\t\t/*\n\t\t\t * If @name collates before a->name, there is no\n\t\t\t * matching attribute.\n\t\t\t */\n\t\t\tif (rc == -1)\n\t\t\t\treturn -ENOENT;\n\t\t\t/* If the strings are not equal, continue search. */\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t\trc = ntfs_collate_names(name, name_len,\n\t\t\t\t\t(ntfschar*)((u8*)a +\n\t\t\t\t\tle16_to_cpu(a->name_offset)),\n\t\t\t\t\ta->name_length, 1, CASE_SENSITIVE,\n\t\t\t\t\tupcase, upcase_len);\n\t\t\tif (rc == -1)\n\t\t\t\treturn -ENOENT;\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * The names match or @name not present and attribute is\n\t\t * unnamed.  If no @val specified, we have found the attribute\n\t\t * and are done.\n\t\t */\n\t\tif (!val)\n\t\t\treturn 0;\n\t\t/* @val is present; compare values. */\n\t\telse {\n\t\t\tregister int rc;\n\n\t\t\trc = memcmp(val, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tmin_t(u32, val_len, le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length)));\n\t\t\t/*\n\t\t\t * If @val collates before the current attribute's\n\t\t\t * value, there is no matching attribute.\n\t\t\t */\n\t\t\tif (!rc) {\n\t\t\t\tregister u32 avl;\n\n\t\t\t\tavl = le32_to_cpu(\n\t\t\t\t\t\ta->data.resident.value_length);\n\t\t\t\tif (val_len == avl)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (val_len < avl)\n\t\t\t\t\treturn -ENOENT;\n\t\t\t} else if (rc < 0)\n\t\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\tntfs_error(vol->sb, \"Inode is corrupt.  Run chkdsk.\");\n\tNVolSetErrors(vol);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoAttrList",
          "args": [
            "base_ni"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!base_ni"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "IS_ERR(ctx->mrec)"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ctx->mrec"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering.\""
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
  },
  {
    "function_name": "ntfs_external_attr_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "857-1146",
    "snippet": "static int ntfs_external_attr_find(const ATTR_TYPE type,\n\t\tconst ntfschar *name, const u32 name_len,\n\t\tconst IGNORE_CASE_BOOL ic, const VCN lowest_vcn,\n\t\tconst u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni, *ni;\n\tntfs_volume *vol;\n\tATTR_LIST_ENTRY *al_entry, *next_al_entry;\n\tu8 *al_start, *al_end;\n\tATTR_RECORD *a;\n\tntfschar *al_name;\n\tu32 al_name_len;\n\tint err = 0;\n\tstatic const char *es = \" Unmount and run chkdsk.\";\n\n\tni = ctx->ntfs_ino;\n\tbase_ni = ctx->base_ntfs_ino;\n\tntfs_debug(\"Entering for inode 0x%lx, type 0x%x.\", ni->mft_no, type);\n\tif (!base_ni) {\n\t\t/* First call happens with the base mft record. */\n\t\tbase_ni = ctx->base_ntfs_ino = ctx->ntfs_ino;\n\t\tctx->base_mrec = ctx->mrec;\n\t}\n\tif (ni == base_ni)\n\t\tctx->base_attr = ctx->attr;\n\tif (type == AT_END)\n\t\tgoto not_found;\n\tvol = base_ni->vol;\n\tal_start = base_ni->attr_list;\n\tal_end = al_start + base_ni->attr_list_size;\n\tif (!ctx->al_entry)\n\t\tctx->al_entry = (ATTR_LIST_ENTRY*)al_start;\n\t/*\n\t * Iterate over entries in attribute list starting at @ctx->al_entry,\n\t * or the entry following that, if @ctx->is_first is 'true'.\n\t */\n\tif (ctx->is_first) {\n\t\tal_entry = ctx->al_entry;\n\t\tctx->is_first = false;\n\t} else\n\t\tal_entry = (ATTR_LIST_ENTRY*)((u8*)ctx->al_entry +\n\t\t\t\tle16_to_cpu(ctx->al_entry->length));\n\tfor (;; al_entry = next_al_entry) {\n\t\t/* Out of bounds check. */\n\t\tif ((u8*)al_entry < base_ni->attr_list ||\n\t\t\t\t(u8*)al_entry > al_end)\n\t\t\tbreak;\t/* Inode is corrupt. */\n\t\tctx->al_entry = al_entry;\n\t\t/* Catch the end of the attribute list. */\n\t\tif ((u8*)al_entry == al_end)\n\t\t\tgoto not_found;\n\t\tif (!al_entry->length)\n\t\t\tbreak;\n\t\tif ((u8*)al_entry + 6 > al_end || (u8*)al_entry +\n\t\t\t\tle16_to_cpu(al_entry->length) > al_end)\n\t\t\tbreak;\n\t\tnext_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +\n\t\t\t\tle16_to_cpu(al_entry->length));\n\t\tif (le32_to_cpu(al_entry->type) > le32_to_cpu(type))\n\t\t\tgoto not_found;\n\t\tif (type != al_entry->type)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If @name is present, compare the two names.  If @name is\n\t\t * missing, assume we want an unnamed attribute.\n\t\t */\n\t\tal_name_len = al_entry->name_length;\n\t\tal_name = (ntfschar*)((u8*)al_entry + al_entry->name_offset);\n\t\tif (!name) {\n\t\t\tif (al_name_len)\n\t\t\t\tgoto not_found;\n\t\t} else if (!ntfs_are_names_equal(al_name, al_name_len, name,\n\t\t\t\tname_len, ic, vol->upcase, vol->upcase_len)) {\n\t\t\tregister int rc;\n\n\t\t\trc = ntfs_collate_names(name, name_len, al_name,\n\t\t\t\t\tal_name_len, 1, IGNORE_CASE,\n\t\t\t\t\tvol->upcase, vol->upcase_len);\n\t\t\t/*\n\t\t\t * If @name collates before al_name, there is no\n\t\t\t * matching attribute.\n\t\t\t */\n\t\t\tif (rc == -1)\n\t\t\t\tgoto not_found;\n\t\t\t/* If the strings are not equal, continue search. */\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * FIXME: Reverse engineering showed 0, IGNORE_CASE but\n\t\t\t * that is inconsistent with ntfs_attr_find().  The\n\t\t\t * subsequent rc checks were also different.  Perhaps I\n\t\t\t * made a mistake in one of the two.  Need to recheck\n\t\t\t * which is correct or at least see what is going on...\n\t\t\t * (AIA)\n\t\t\t */\n\t\t\trc = ntfs_collate_names(name, name_len, al_name,\n\t\t\t\t\tal_name_len, 1, CASE_SENSITIVE,\n\t\t\t\t\tvol->upcase, vol->upcase_len);\n\t\t\tif (rc == -1)\n\t\t\t\tgoto not_found;\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * The names match or @name not present and attribute is\n\t\t * unnamed.  Now check @lowest_vcn.  Continue search if the\n\t\t * next attribute list entry still fits @lowest_vcn.  Otherwise\n\t\t * we have reached the right one or the search has failed.\n\t\t */\n\t\tif (lowest_vcn && (u8*)next_al_entry >= al_start\t    &&\n\t\t\t\t(u8*)next_al_entry + 6 < al_end\t\t    &&\n\t\t\t\t(u8*)next_al_entry + le16_to_cpu(\n\t\t\t\t\tnext_al_entry->length) <= al_end    &&\n\t\t\t\tsle64_to_cpu(next_al_entry->lowest_vcn) <=\n\t\t\t\t\tlowest_vcn\t\t\t    &&\n\t\t\t\tnext_al_entry->type == al_entry->type\t    &&\n\t\t\t\tnext_al_entry->name_length == al_name_len   &&\n\t\t\t\tntfs_are_names_equal((ntfschar*)((u8*)\n\t\t\t\t\tnext_al_entry +\n\t\t\t\t\tnext_al_entry->name_offset),\n\t\t\t\t\tnext_al_entry->name_length,\n\t\t\t\t\tal_name, al_name_len, CASE_SENSITIVE,\n\t\t\t\t\tvol->upcase, vol->upcase_len))\n\t\t\tcontinue;\n\t\tif (MREF_LE(al_entry->mft_reference) == ni->mft_no) {\n\t\t\tif (MSEQNO_LE(al_entry->mft_reference) != ni->seq_no) {\n\t\t\t\tntfs_error(vol->sb, \"Found stale mft \"\n\t\t\t\t\t\t\"reference in attribute list \"\n\t\t\t\t\t\t\"of base inode 0x%lx.%s\",\n\t\t\t\t\t\tbase_ni->mft_no, es);\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else { /* Mft references do not match. */\n\t\t\t/* If there is a mapped record unmap it first. */\n\t\t\tif (ni != base_ni)\n\t\t\t\tunmap_extent_mft_record(ni);\n\t\t\t/* Do we want the base record back? */\n\t\t\tif (MREF_LE(al_entry->mft_reference) ==\n\t\t\t\t\tbase_ni->mft_no) {\n\t\t\t\tni = ctx->ntfs_ino = base_ni;\n\t\t\t\tctx->mrec = ctx->base_mrec;\n\t\t\t} else {\n\t\t\t\t/* We want an extent record. */\n\t\t\t\tctx->mrec = map_extent_mft_record(base_ni,\n\t\t\t\t\t\tle64_to_cpu(\n\t\t\t\t\t\tal_entry->mft_reference), &ni);\n\t\t\t\tif (IS_ERR(ctx->mrec)) {\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to map \"\n\t\t\t\t\t\t\t\"extent mft record \"\n\t\t\t\t\t\t\t\"0x%lx of base inode \"\n\t\t\t\t\t\t\t\"0x%lx.%s\",\n\t\t\t\t\t\t\tMREF_LE(al_entry->\n\t\t\t\t\t\t\tmft_reference),\n\t\t\t\t\t\t\tbase_ni->mft_no, es);\n\t\t\t\t\terr = PTR_ERR(ctx->mrec);\n\t\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\t\terr = -EIO;\n\t\t\t\t\t/* Cause @ctx to be sanitized below. */\n\t\t\t\t\tni = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx->ntfs_ino = ni;\n\t\t\t}\n\t\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t}\n\t\t/*\n\t\t * ctx->vfs_ino, ctx->mrec, and ctx->attr now point to the\n\t\t * mft record containing the attribute represented by the\n\t\t * current al_entry.\n\t\t */\n\t\t/*\n\t\t * We could call into ntfs_attr_find() to find the right\n\t\t * attribute in this mft record but this would be less\n\t\t * efficient and not quite accurate as ntfs_attr_find() ignores\n\t\t * the attribute instance numbers for example which become\n\t\t * important when one plays with attribute lists.  Also,\n\t\t * because a proper match has been found in the attribute list\n\t\t * entry above, the comparison can now be optimized.  So it is\n\t\t * worth re-implementing a simplified ntfs_attr_find() here.\n\t\t */\n\t\ta = ctx->attr;\n\t\t/*\n\t\t * Use a manual loop so we can still use break and continue\n\t\t * with the same meanings as above.\n\t\t */\ndo_next_attr_loop:\n\t\tif ((u8*)a < (u8*)ctx->mrec || (u8*)a > (u8*)ctx->mrec +\n\t\t\t\tle32_to_cpu(ctx->mrec->bytes_allocated))\n\t\t\tbreak;\n\t\tif (a->type == AT_END)\n\t\t\tbreak;\n\t\tif (!a->length)\n\t\t\tbreak;\n\t\tif (al_entry->instance != a->instance)\n\t\t\tgoto do_next_attr;\n\t\t/*\n\t\t * If the type and/or the name are mismatched between the\n\t\t * attribute list entry and the attribute record, there is\n\t\t * corruption so we break and return error EIO.\n\t\t */\n\t\tif (al_entry->type != a->type)\n\t\t\tbreak;\n\t\tif (!ntfs_are_names_equal((ntfschar*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->name_offset)), a->name_length,\n\t\t\t\tal_name, al_name_len, CASE_SENSITIVE,\n\t\t\t\tvol->upcase, vol->upcase_len))\n\t\t\tbreak;\n\t\tctx->attr = a;\n\t\t/*\n\t\t * If no @val specified or @val specified and it matches, we\n\t\t * have found it!\n\t\t */\n\t\tif (!val || (!a->non_resident && le32_to_cpu(\n\t\t\t\ta->data.resident.value_length) == val_len &&\n\t\t\t\t!memcmp((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset),\n\t\t\t\tval, val_len))) {\n\t\t\tntfs_debug(\"Done, found.\");\n\t\t\treturn 0;\n\t\t}\ndo_next_attr:\n\t\t/* Proceed to the next attribute in the current mft record. */\n\t\ta = (ATTR_RECORD*)((u8*)a + le32_to_cpu(a->length));\n\t\tgoto do_next_attr_loop;\n\t}\n\tif (!err) {\n\t\tntfs_error(vol->sb, \"Base inode 0x%lx contains corrupt \"\n\t\t\t\t\"attribute list attribute.%s\", base_ni->mft_no,\n\t\t\t\tes);\n\t\terr = -EIO;\n\t}\n\tif (ni != base_ni) {\n\t\tif (ni)\n\t\t\tunmap_extent_mft_record(ni);\n\t\tctx->ntfs_ino = base_ni;\n\t\tctx->mrec = ctx->base_mrec;\n\t\tctx->attr = ctx->base_attr;\n\t}\n\tif (err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\nnot_found:\n\t/*\n\t * If we were looking for AT_END, we reset the search context @ctx and\n\t * use ntfs_attr_find() to seek to the end of the base mft record.\n\t */\n\tif (type == AT_END) {\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\treturn ntfs_attr_find(AT_END, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\t}\n\t/*\n\t * The attribute was not found.  Before we return, we want to ensure\n\t * @ctx->mrec and @ctx->attr indicate the position at which the\n\t * attribute should be inserted in the base mft record.  Since we also\n\t * want to preserve @ctx->al_entry we cannot reinitialize the search\n\t * context using ntfs_attr_reinit_search_ctx() as this would set\n\t * @ctx->al_entry to NULL.  Thus we do the necessary bits manually (see\n\t * ntfs_attr_init_search_ctx() below).  Note, we _only_ preserve\n\t * @ctx->al_entry as the remaining fields (base_*) are identical to\n\t * their non base_ counterparts and we cannot set @ctx->base_attr\n\t * correctly yet as we do not know what @ctx->attr will be set to by\n\t * the call to ntfs_attr_find() below.\n\t */\n\tif (ni != base_ni)\n\t\tunmap_extent_mft_record(ni);\n\tctx->mrec = ctx->base_mrec;\n\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\tctx->is_first = true;\n\tctx->ntfs_ino = base_ni;\n\tctx->base_ntfs_ino = NULL;\n\tctx->base_mrec = NULL;\n\tctx->base_attr = NULL;\n\t/*\n\t * In case there are multiple matches in the base mft record, need to\n\t * keep enumerating until we get an attribute not found response (or\n\t * another error), otherwise we would keep returning the same attribute\n\t * over and over again and all programs using us for enumeration would\n\t * lock up in a tight loop.\n\t */\n\tdo {\n\t\terr = ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\t} while (!err);\n\tntfs_debug(\"Done, not found.\");\n\treturn err;\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done, not found.\""
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_find",
          "args": [
            "type",
            "name",
            "name_len",
            "ic",
            "val",
            "val_len",
            "ctx"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "589-692",
          "snippet": "static int ntfs_attr_find(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)\n{\n\tATTR_RECORD *a;\n\tntfs_volume *vol = ctx->ntfs_ino->vol;\n\tntfschar *upcase = vol->upcase;\n\tu32 upcase_len = vol->upcase_len;\n\n\t/*\n\t * Iterate over attributes in mft record starting at @ctx->attr, or the\n\t * attribute following that, if @ctx->is_first is 'true'.\n\t */\n\tif (ctx->is_first) {\n\t\ta = ctx->attr;\n\t\tctx->is_first = false;\n\t} else\n\t\ta = (ATTR_RECORD*)((u8*)ctx->attr +\n\t\t\t\tle32_to_cpu(ctx->attr->length));\n\tfor (;;\ta = (ATTR_RECORD*)((u8*)a + le32_to_cpu(a->length))) {\n\t\tif ((u8*)a < (u8*)ctx->mrec || (u8*)a > (u8*)ctx->mrec +\n\t\t\t\tle32_to_cpu(ctx->mrec->bytes_allocated))\n\t\t\tbreak;\n\t\tctx->attr = a;\n\t\tif (unlikely(le32_to_cpu(a->type) > le32_to_cpu(type) ||\n\t\t\t\ta->type == AT_END))\n\t\t\treturn -ENOENT;\n\t\tif (unlikely(!a->length))\n\t\t\tbreak;\n\t\tif (a->type != type)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If @name is present, compare the two names.  If @name is\n\t\t * missing, assume we want an unnamed attribute.\n\t\t */\n\t\tif (!name) {\n\t\t\t/* The search failed if the found attribute is named. */\n\t\t\tif (a->name_length)\n\t\t\t\treturn -ENOENT;\n\t\t} else if (!ntfs_are_names_equal(name, name_len,\n\t\t\t    (ntfschar*)((u8*)a + le16_to_cpu(a->name_offset)),\n\t\t\t    a->name_length, ic, upcase, upcase_len)) {\n\t\t\tregister int rc;\n\n\t\t\trc = ntfs_collate_names(name, name_len,\n\t\t\t\t\t(ntfschar*)((u8*)a +\n\t\t\t\t\tle16_to_cpu(a->name_offset)),\n\t\t\t\t\ta->name_length, 1, IGNORE_CASE,\n\t\t\t\t\tupcase, upcase_len);\n\t\t\t/*\n\t\t\t * If @name collates before a->name, there is no\n\t\t\t * matching attribute.\n\t\t\t */\n\t\t\tif (rc == -1)\n\t\t\t\treturn -ENOENT;\n\t\t\t/* If the strings are not equal, continue search. */\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t\trc = ntfs_collate_names(name, name_len,\n\t\t\t\t\t(ntfschar*)((u8*)a +\n\t\t\t\t\tle16_to_cpu(a->name_offset)),\n\t\t\t\t\ta->name_length, 1, CASE_SENSITIVE,\n\t\t\t\t\tupcase, upcase_len);\n\t\t\tif (rc == -1)\n\t\t\t\treturn -ENOENT;\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * The names match or @name not present and attribute is\n\t\t * unnamed.  If no @val specified, we have found the attribute\n\t\t * and are done.\n\t\t */\n\t\tif (!val)\n\t\t\treturn 0;\n\t\t/* @val is present; compare values. */\n\t\telse {\n\t\t\tregister int rc;\n\n\t\t\trc = memcmp(val, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tmin_t(u32, val_len, le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length)));\n\t\t\t/*\n\t\t\t * If @val collates before the current attribute's\n\t\t\t * value, there is no matching attribute.\n\t\t\t */\n\t\t\tif (!rc) {\n\t\t\t\tregister u32 avl;\n\n\t\t\t\tavl = le32_to_cpu(\n\t\t\t\t\t\ta->data.resident.value_length);\n\t\t\t\tif (val_len == avl)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (val_len < avl)\n\t\t\t\t\treturn -ENOENT;\n\t\t\t} else if (rc < 0)\n\t\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\tntfs_error(vol->sb, \"Inode is corrupt.  Run chkdsk.\");\n\tNVolSetErrors(vol);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_attr_find(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)\n{\n\tATTR_RECORD *a;\n\tntfs_volume *vol = ctx->ntfs_ino->vol;\n\tntfschar *upcase = vol->upcase;\n\tu32 upcase_len = vol->upcase_len;\n\n\t/*\n\t * Iterate over attributes in mft record starting at @ctx->attr, or the\n\t * attribute following that, if @ctx->is_first is 'true'.\n\t */\n\tif (ctx->is_first) {\n\t\ta = ctx->attr;\n\t\tctx->is_first = false;\n\t} else\n\t\ta = (ATTR_RECORD*)((u8*)ctx->attr +\n\t\t\t\tle32_to_cpu(ctx->attr->length));\n\tfor (;;\ta = (ATTR_RECORD*)((u8*)a + le32_to_cpu(a->length))) {\n\t\tif ((u8*)a < (u8*)ctx->mrec || (u8*)a > (u8*)ctx->mrec +\n\t\t\t\tle32_to_cpu(ctx->mrec->bytes_allocated))\n\t\t\tbreak;\n\t\tctx->attr = a;\n\t\tif (unlikely(le32_to_cpu(a->type) > le32_to_cpu(type) ||\n\t\t\t\ta->type == AT_END))\n\t\t\treturn -ENOENT;\n\t\tif (unlikely(!a->length))\n\t\t\tbreak;\n\t\tif (a->type != type)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If @name is present, compare the two names.  If @name is\n\t\t * missing, assume we want an unnamed attribute.\n\t\t */\n\t\tif (!name) {\n\t\t\t/* The search failed if the found attribute is named. */\n\t\t\tif (a->name_length)\n\t\t\t\treturn -ENOENT;\n\t\t} else if (!ntfs_are_names_equal(name, name_len,\n\t\t\t    (ntfschar*)((u8*)a + le16_to_cpu(a->name_offset)),\n\t\t\t    a->name_length, ic, upcase, upcase_len)) {\n\t\t\tregister int rc;\n\n\t\t\trc = ntfs_collate_names(name, name_len,\n\t\t\t\t\t(ntfschar*)((u8*)a +\n\t\t\t\t\tle16_to_cpu(a->name_offset)),\n\t\t\t\t\ta->name_length, 1, IGNORE_CASE,\n\t\t\t\t\tupcase, upcase_len);\n\t\t\t/*\n\t\t\t * If @name collates before a->name, there is no\n\t\t\t * matching attribute.\n\t\t\t */\n\t\t\tif (rc == -1)\n\t\t\t\treturn -ENOENT;\n\t\t\t/* If the strings are not equal, continue search. */\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t\trc = ntfs_collate_names(name, name_len,\n\t\t\t\t\t(ntfschar*)((u8*)a +\n\t\t\t\t\tle16_to_cpu(a->name_offset)),\n\t\t\t\t\ta->name_length, 1, CASE_SENSITIVE,\n\t\t\t\t\tupcase, upcase_len);\n\t\t\tif (rc == -1)\n\t\t\t\treturn -ENOENT;\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * The names match or @name not present and attribute is\n\t\t * unnamed.  If no @val specified, we have found the attribute\n\t\t * and are done.\n\t\t */\n\t\tif (!val)\n\t\t\treturn 0;\n\t\t/* @val is present; compare values. */\n\t\telse {\n\t\t\tregister int rc;\n\n\t\t\trc = memcmp(val, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tmin_t(u32, val_len, le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length)));\n\t\t\t/*\n\t\t\t * If @val collates before the current attribute's\n\t\t\t * value, there is no matching attribute.\n\t\t\t */\n\t\t\tif (!rc) {\n\t\t\t\tregister u32 avl;\n\n\t\t\t\tavl = le32_to_cpu(\n\t\t\t\t\t\ta->data.resident.value_length);\n\t\t\t\tif (val_len == avl)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (val_len < avl)\n\t\t\t\t\treturn -ENOENT;\n\t\t\t} else if (rc < 0)\n\t\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\tntfs_error(vol->sb, \"Inode is corrupt.  Run chkdsk.\");\n\tNVolSetErrors(vol);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ctx->mrec->attrs_offset"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_extent_mft_record",
          "args": [
            "ni"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_extent_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "38-42",
          "snippet": "static inline void unmap_extent_mft_record(ntfs_inode *ni)\n{\n\tunmap_mft_record(ni);\n\treturn;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void unmap_extent_mft_record(ntfs_inode *ni)\n{\n\tunmap_mft_record(ni);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_reinit_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_reinit_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1240-1259",
          "snippet": "void ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Base inode 0x%lx contains corrupt \"\n\t\t\t\t\"attribute list attribute.%s\"",
            "base_ni->mft_no",
            "es"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "a->length"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "(u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)",
            "val",
            "val_len"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_are_names_equal",
          "args": [
            "(ntfschar*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->name_offset))",
            "a->name_length",
            "al_name",
            "al_name_len",
            "CASE_SENSITIVE",
            "vol->upcase",
            "vol->upcase_len"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_are_names_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
          "lines": "68-77",
          "snippet": "bool ntfs_are_names_equal(const ntfschar *s1, size_t s1_len,\n\t\tconst ntfschar *s2, size_t s2_len, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_size)\n{\n\tif (s1_len != s2_len)\n\t\treturn false;\n\tif (ic == CASE_SENSITIVE)\n\t\treturn !ntfs_ucsncmp(s1, s2, s1_len);\n\treturn !ntfs_ucsncasecmp(s1, s2, s1_len, upcase, upcase_size);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"types.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nbool ntfs_are_names_equal(const ntfschar *s1, size_t s1_len,\n\t\tconst ntfschar *s2, size_t s2_len, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_size)\n{\n\tif (s1_len != s2_len)\n\t\treturn false;\n\tif (ic == CASE_SENSITIVE)\n\t\treturn !ntfs_ucsncmp(s1, s2, s1_len);\n\treturn !ntfs_ucsncasecmp(s1, s2, s1_len, upcase, upcase_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ctx->mrec"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MREF_LE",
          "args": [
            "al_entry->\n\t\t\t\t\t\t\tmft_reference"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ctx->mrec"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_extent_mft_record",
          "args": [
            "base_ni",
            "le64_to_cpu(\n\t\t\t\t\t\tal_entry->mft_reference)",
            "&ni"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "map_extent_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "246-368",
          "snippet": "MFT_RECORD *map_extent_mft_record(ntfs_inode *base_ni, MFT_REF mref,\n\t\tntfs_inode **ntfs_ino)\n{\n\tMFT_RECORD *m;\n\tntfs_inode *ni = NULL;\n\tntfs_inode **extent_nis = NULL;\n\tint i;\n\tunsigned long mft_no = MREF(mref);\n\tu16 seq_no = MSEQNO(mref);\n\tbool destroy_ni = false;\n\n\tntfs_debug(\"Mapping extent mft record 0x%lx (base mft record 0x%lx).\",\n\t\t\tmft_no, base_ni->mft_no);\n\t/* Make sure the base ntfs inode doesn't go away. */\n\tatomic_inc(&base_ni->count);\n\t/*\n\t * Check if this extent inode has already been added to the base inode,\n\t * in which case just return it. If not found, add it to the base\n\t * inode before returning it.\n\t */\n\tmutex_lock(&base_ni->extent_lock);\n\tif (base_ni->nr_extents > 0) {\n\t\textent_nis = base_ni->ext.extent_ntfs_inos;\n\t\tfor (i = 0; i < base_ni->nr_extents; i++) {\n\t\t\tif (mft_no != extent_nis[i]->mft_no)\n\t\t\t\tcontinue;\n\t\t\tni = extent_nis[i];\n\t\t\t/* Make sure the ntfs inode doesn't go away. */\n\t\t\tatomic_inc(&ni->count);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (likely(ni != NULL)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\t/* We found the record; just have to map and return it. */\n\t\tm = map_mft_record(ni);\n\t\t/* map_mft_record() has incremented this on success. */\n\t\tatomic_dec(&ni->count);\n\t\tif (likely(!IS_ERR(m))) {\n\t\t\t/* Verify the sequence number. */\n\t\t\tif (likely(le16_to_cpu(m->sequence_number) == seq_no)) {\n\t\t\t\tntfs_debug(\"Done 1.\");\n\t\t\t\t*ntfs_ino = ni;\n\t\t\t\treturn m;\n\t\t\t}\n\t\t\tunmap_mft_record(ni);\n\t\t\tntfs_error(base_ni->vol->sb, \"Found stale extent mft \"\n\t\t\t\t\t\"reference! Corrupt filesystem. \"\n\t\t\t\t\t\"Run chkdsk.\");\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\nmap_err_out:\n\t\tntfs_error(base_ni->vol->sb, \"Failed to map extent \"\n\t\t\t\t\"mft record, error code %ld.\", -PTR_ERR(m));\n\t\treturn m;\n\t}\n\t/* Record wasn't there. Get a new ntfs inode and initialize it. */\n\tni = ntfs_new_extent_inode(base_ni->vol->sb, mft_no);\n\tif (unlikely(!ni)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tni->vol = base_ni->vol;\n\tni->seq_no = seq_no;\n\tni->nr_extents = -1;\n\tni->ext.base_ntfs_ino = base_ni;\n\t/* Now map the record. */\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\tntfs_clear_extent_inode(ni);\n\t\tgoto map_err_out;\n\t}\n\t/* Verify the sequence number if it is present. */\n\tif (seq_no && (le16_to_cpu(m->sequence_number) != seq_no)) {\n\t\tntfs_error(base_ni->vol->sb, \"Found stale extent mft \"\n\t\t\t\t\"reference! Corrupt filesystem. Run chkdsk.\");\n\t\tdestroy_ni = true;\n\t\tm = ERR_PTR(-EIO);\n\t\tgoto unm_err_out;\n\t}\n\t/* Attach extent inode to base inode, reallocating memory if needed. */\n\tif (!(base_ni->nr_extents & 3)) {\n\t\tntfs_inode **tmp;\n\t\tint new_size = (base_ni->nr_extents + 4) * sizeof(ntfs_inode *);\n\n\t\ttmp = kmalloc(new_size, GFP_NOFS);\n\t\tif (unlikely(!tmp)) {\n\t\t\tntfs_error(base_ni->vol->sb, \"Failed to allocate \"\n\t\t\t\t\t\"internal buffer.\");\n\t\t\tdestroy_ni = true;\n\t\t\tm = ERR_PTR(-ENOMEM);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (base_ni->nr_extents) {\n\t\t\tBUG_ON(!base_ni->ext.extent_ntfs_inos);\n\t\t\tmemcpy(tmp, base_ni->ext.extent_ntfs_inos, new_size -\n\t\t\t\t\t4 * sizeof(ntfs_inode *));\n\t\t\tkfree(base_ni->ext.extent_ntfs_inos);\n\t\t}\n\t\tbase_ni->ext.extent_ntfs_inos = tmp;\n\t}\n\tbase_ni->ext.extent_ntfs_inos[base_ni->nr_extents++] = ni;\n\tmutex_unlock(&base_ni->extent_lock);\n\tatomic_dec(&base_ni->count);\n\tntfs_debug(\"Done 2.\");\n\t*ntfs_ino = ni;\n\treturn m;\nunm_err_out:\n\tunmap_mft_record(ni);\n\tmutex_unlock(&base_ni->extent_lock);\n\tatomic_dec(&base_ni->count);\n\t/*\n\t * If the extent inode was not attached to the base inode we need to\n\t * release it or we will leak memory.\n\t */\n\tif (destroy_ni)\n\t\tntfs_clear_extent_inode(ni);\n\treturn m;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nMFT_RECORD *map_extent_mft_record(ntfs_inode *base_ni, MFT_REF mref,\n\t\tntfs_inode **ntfs_ino)\n{\n\tMFT_RECORD *m;\n\tntfs_inode *ni = NULL;\n\tntfs_inode **extent_nis = NULL;\n\tint i;\n\tunsigned long mft_no = MREF(mref);\n\tu16 seq_no = MSEQNO(mref);\n\tbool destroy_ni = false;\n\n\tntfs_debug(\"Mapping extent mft record 0x%lx (base mft record 0x%lx).\",\n\t\t\tmft_no, base_ni->mft_no);\n\t/* Make sure the base ntfs inode doesn't go away. */\n\tatomic_inc(&base_ni->count);\n\t/*\n\t * Check if this extent inode has already been added to the base inode,\n\t * in which case just return it. If not found, add it to the base\n\t * inode before returning it.\n\t */\n\tmutex_lock(&base_ni->extent_lock);\n\tif (base_ni->nr_extents > 0) {\n\t\textent_nis = base_ni->ext.extent_ntfs_inos;\n\t\tfor (i = 0; i < base_ni->nr_extents; i++) {\n\t\t\tif (mft_no != extent_nis[i]->mft_no)\n\t\t\t\tcontinue;\n\t\t\tni = extent_nis[i];\n\t\t\t/* Make sure the ntfs inode doesn't go away. */\n\t\t\tatomic_inc(&ni->count);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (likely(ni != NULL)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\t/* We found the record; just have to map and return it. */\n\t\tm = map_mft_record(ni);\n\t\t/* map_mft_record() has incremented this on success. */\n\t\tatomic_dec(&ni->count);\n\t\tif (likely(!IS_ERR(m))) {\n\t\t\t/* Verify the sequence number. */\n\t\t\tif (likely(le16_to_cpu(m->sequence_number) == seq_no)) {\n\t\t\t\tntfs_debug(\"Done 1.\");\n\t\t\t\t*ntfs_ino = ni;\n\t\t\t\treturn m;\n\t\t\t}\n\t\t\tunmap_mft_record(ni);\n\t\t\tntfs_error(base_ni->vol->sb, \"Found stale extent mft \"\n\t\t\t\t\t\"reference! Corrupt filesystem. \"\n\t\t\t\t\t\"Run chkdsk.\");\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\nmap_err_out:\n\t\tntfs_error(base_ni->vol->sb, \"Failed to map extent \"\n\t\t\t\t\"mft record, error code %ld.\", -PTR_ERR(m));\n\t\treturn m;\n\t}\n\t/* Record wasn't there. Get a new ntfs inode and initialize it. */\n\tni = ntfs_new_extent_inode(base_ni->vol->sb, mft_no);\n\tif (unlikely(!ni)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tni->vol = base_ni->vol;\n\tni->seq_no = seq_no;\n\tni->nr_extents = -1;\n\tni->ext.base_ntfs_ino = base_ni;\n\t/* Now map the record. */\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\tmutex_unlock(&base_ni->extent_lock);\n\t\tatomic_dec(&base_ni->count);\n\t\tntfs_clear_extent_inode(ni);\n\t\tgoto map_err_out;\n\t}\n\t/* Verify the sequence number if it is present. */\n\tif (seq_no && (le16_to_cpu(m->sequence_number) != seq_no)) {\n\t\tntfs_error(base_ni->vol->sb, \"Found stale extent mft \"\n\t\t\t\t\"reference! Corrupt filesystem. Run chkdsk.\");\n\t\tdestroy_ni = true;\n\t\tm = ERR_PTR(-EIO);\n\t\tgoto unm_err_out;\n\t}\n\t/* Attach extent inode to base inode, reallocating memory if needed. */\n\tif (!(base_ni->nr_extents & 3)) {\n\t\tntfs_inode **tmp;\n\t\tint new_size = (base_ni->nr_extents + 4) * sizeof(ntfs_inode *);\n\n\t\ttmp = kmalloc(new_size, GFP_NOFS);\n\t\tif (unlikely(!tmp)) {\n\t\t\tntfs_error(base_ni->vol->sb, \"Failed to allocate \"\n\t\t\t\t\t\"internal buffer.\");\n\t\t\tdestroy_ni = true;\n\t\t\tm = ERR_PTR(-ENOMEM);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (base_ni->nr_extents) {\n\t\t\tBUG_ON(!base_ni->ext.extent_ntfs_inos);\n\t\t\tmemcpy(tmp, base_ni->ext.extent_ntfs_inos, new_size -\n\t\t\t\t\t4 * sizeof(ntfs_inode *));\n\t\t\tkfree(base_ni->ext.extent_ntfs_inos);\n\t\t}\n\t\tbase_ni->ext.extent_ntfs_inos = tmp;\n\t}\n\tbase_ni->ext.extent_ntfs_inos[base_ni->nr_extents++] = ni;\n\tmutex_unlock(&base_ni->extent_lock);\n\tatomic_dec(&base_ni->count);\n\tntfs_debug(\"Done 2.\");\n\t*ntfs_ino = ni;\n\treturn m;\nunm_err_out:\n\tunmap_mft_record(ni);\n\tmutex_unlock(&base_ni->extent_lock);\n\tatomic_dec(&base_ni->count);\n\t/*\n\t * If the extent inode was not attached to the base inode we need to\n\t * release it or we will leak memory.\n\t */\n\tif (destroy_ni)\n\t\tntfs_clear_extent_inode(ni);\n\treturn m;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "al_entry->mft_reference"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MREF_LE",
          "args": [
            "al_entry->mft_reference"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSEQNO_LE",
          "args": [
            "al_entry->mft_reference"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MREF_LE",
          "args": [
            "al_entry->mft_reference"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_collate_names",
          "args": [
            "name",
            "name_len",
            "al_name",
            "al_name_len",
            "1",
            "CASE_SENSITIVE",
            "vol->upcase",
            "vol->upcase_len"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_collate_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
          "lines": "97-133",
          "snippet": "int ntfs_collate_names(const ntfschar *name1, const u32 name1_len,\n\t\tconst ntfschar *name2, const u32 name2_len,\n\t\tconst int err_val, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\tu32 cnt, min_len;\n\tu16 c1, c2;\n\n\tmin_len = name1_len;\n\tif (name1_len > name2_len)\n\t\tmin_len = name2_len;\n\tfor (cnt = 0; cnt < min_len; ++cnt) {\n\t\tc1 = le16_to_cpu(*name1++);\n\t\tc2 = le16_to_cpu(*name2++);\n\t\tif (ic) {\n\t\t\tif (c1 < upcase_len)\n\t\t\t\tc1 = le16_to_cpu(upcase[c1]);\n\t\t\tif (c2 < upcase_len)\n\t\t\t\tc2 = le16_to_cpu(upcase[c2]);\n\t\t}\n\t\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\t\treturn err_val;\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t}\n\tif (name1_len < name2_len)\n\t\treturn -1;\n\tif (name1_len == name2_len)\n\t\treturn 0;\n\t/* name1_len > name2_len */\n\tc1 = le16_to_cpu(*name1);\n\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\treturn err_val;\n\treturn 1;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"types.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const u8 legal_ansi_char_array[0x40] = {\n\t0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x17, 0x07, 0x18, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x18, 0x16, 0x16, 0x17, 0x07, 0x00,\n\n\t0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x04, 0x16, 0x18, 0x16, 0x18, 0x18,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nstatic const u8 legal_ansi_char_array[0x40] = {\n\t0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x17, 0x07, 0x18, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x18, 0x16, 0x16, 0x17, 0x07, 0x00,\n\n\t0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x04, 0x16, 0x18, 0x16, 0x18, 0x18,\n};\n\nint ntfs_collate_names(const ntfschar *name1, const u32 name1_len,\n\t\tconst ntfschar *name2, const u32 name2_len,\n\t\tconst int err_val, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\tu32 cnt, min_len;\n\tu16 c1, c2;\n\n\tmin_len = name1_len;\n\tif (name1_len > name2_len)\n\t\tmin_len = name2_len;\n\tfor (cnt = 0; cnt < min_len; ++cnt) {\n\t\tc1 = le16_to_cpu(*name1++);\n\t\tc2 = le16_to_cpu(*name2++);\n\t\tif (ic) {\n\t\t\tif (c1 < upcase_len)\n\t\t\t\tc1 = le16_to_cpu(upcase[c1]);\n\t\t\tif (c2 < upcase_len)\n\t\t\t\tc2 = le16_to_cpu(upcase[c2]);\n\t\t}\n\t\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\t\treturn err_val;\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t}\n\tif (name1_len < name2_len)\n\t\treturn -1;\n\tif (name1_len == name2_len)\n\t\treturn 0;\n\t/* name1_len > name2_len */\n\tc1 = le16_to_cpu(*name1);\n\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\treturn err_val;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for inode 0x%lx, type 0x%x.\"",
            "ni->mft_no",
            "type"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_external_attr_find(const ATTR_TYPE type,\n\t\tconst ntfschar *name, const u32 name_len,\n\t\tconst IGNORE_CASE_BOOL ic, const VCN lowest_vcn,\n\t\tconst u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni, *ni;\n\tntfs_volume *vol;\n\tATTR_LIST_ENTRY *al_entry, *next_al_entry;\n\tu8 *al_start, *al_end;\n\tATTR_RECORD *a;\n\tntfschar *al_name;\n\tu32 al_name_len;\n\tint err = 0;\n\tstatic const char *es = \" Unmount and run chkdsk.\";\n\n\tni = ctx->ntfs_ino;\n\tbase_ni = ctx->base_ntfs_ino;\n\tntfs_debug(\"Entering for inode 0x%lx, type 0x%x.\", ni->mft_no, type);\n\tif (!base_ni) {\n\t\t/* First call happens with the base mft record. */\n\t\tbase_ni = ctx->base_ntfs_ino = ctx->ntfs_ino;\n\t\tctx->base_mrec = ctx->mrec;\n\t}\n\tif (ni == base_ni)\n\t\tctx->base_attr = ctx->attr;\n\tif (type == AT_END)\n\t\tgoto not_found;\n\tvol = base_ni->vol;\n\tal_start = base_ni->attr_list;\n\tal_end = al_start + base_ni->attr_list_size;\n\tif (!ctx->al_entry)\n\t\tctx->al_entry = (ATTR_LIST_ENTRY*)al_start;\n\t/*\n\t * Iterate over entries in attribute list starting at @ctx->al_entry,\n\t * or the entry following that, if @ctx->is_first is 'true'.\n\t */\n\tif (ctx->is_first) {\n\t\tal_entry = ctx->al_entry;\n\t\tctx->is_first = false;\n\t} else\n\t\tal_entry = (ATTR_LIST_ENTRY*)((u8*)ctx->al_entry +\n\t\t\t\tle16_to_cpu(ctx->al_entry->length));\n\tfor (;; al_entry = next_al_entry) {\n\t\t/* Out of bounds check. */\n\t\tif ((u8*)al_entry < base_ni->attr_list ||\n\t\t\t\t(u8*)al_entry > al_end)\n\t\t\tbreak;\t/* Inode is corrupt. */\n\t\tctx->al_entry = al_entry;\n\t\t/* Catch the end of the attribute list. */\n\t\tif ((u8*)al_entry == al_end)\n\t\t\tgoto not_found;\n\t\tif (!al_entry->length)\n\t\t\tbreak;\n\t\tif ((u8*)al_entry + 6 > al_end || (u8*)al_entry +\n\t\t\t\tle16_to_cpu(al_entry->length) > al_end)\n\t\t\tbreak;\n\t\tnext_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +\n\t\t\t\tle16_to_cpu(al_entry->length));\n\t\tif (le32_to_cpu(al_entry->type) > le32_to_cpu(type))\n\t\t\tgoto not_found;\n\t\tif (type != al_entry->type)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If @name is present, compare the two names.  If @name is\n\t\t * missing, assume we want an unnamed attribute.\n\t\t */\n\t\tal_name_len = al_entry->name_length;\n\t\tal_name = (ntfschar*)((u8*)al_entry + al_entry->name_offset);\n\t\tif (!name) {\n\t\t\tif (al_name_len)\n\t\t\t\tgoto not_found;\n\t\t} else if (!ntfs_are_names_equal(al_name, al_name_len, name,\n\t\t\t\tname_len, ic, vol->upcase, vol->upcase_len)) {\n\t\t\tregister int rc;\n\n\t\t\trc = ntfs_collate_names(name, name_len, al_name,\n\t\t\t\t\tal_name_len, 1, IGNORE_CASE,\n\t\t\t\t\tvol->upcase, vol->upcase_len);\n\t\t\t/*\n\t\t\t * If @name collates before al_name, there is no\n\t\t\t * matching attribute.\n\t\t\t */\n\t\t\tif (rc == -1)\n\t\t\t\tgoto not_found;\n\t\t\t/* If the strings are not equal, continue search. */\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * FIXME: Reverse engineering showed 0, IGNORE_CASE but\n\t\t\t * that is inconsistent with ntfs_attr_find().  The\n\t\t\t * subsequent rc checks were also different.  Perhaps I\n\t\t\t * made a mistake in one of the two.  Need to recheck\n\t\t\t * which is correct or at least see what is going on...\n\t\t\t * (AIA)\n\t\t\t */\n\t\t\trc = ntfs_collate_names(name, name_len, al_name,\n\t\t\t\t\tal_name_len, 1, CASE_SENSITIVE,\n\t\t\t\t\tvol->upcase, vol->upcase_len);\n\t\t\tif (rc == -1)\n\t\t\t\tgoto not_found;\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * The names match or @name not present and attribute is\n\t\t * unnamed.  Now check @lowest_vcn.  Continue search if the\n\t\t * next attribute list entry still fits @lowest_vcn.  Otherwise\n\t\t * we have reached the right one or the search has failed.\n\t\t */\n\t\tif (lowest_vcn && (u8*)next_al_entry >= al_start\t    &&\n\t\t\t\t(u8*)next_al_entry + 6 < al_end\t\t    &&\n\t\t\t\t(u8*)next_al_entry + le16_to_cpu(\n\t\t\t\t\tnext_al_entry->length) <= al_end    &&\n\t\t\t\tsle64_to_cpu(next_al_entry->lowest_vcn) <=\n\t\t\t\t\tlowest_vcn\t\t\t    &&\n\t\t\t\tnext_al_entry->type == al_entry->type\t    &&\n\t\t\t\tnext_al_entry->name_length == al_name_len   &&\n\t\t\t\tntfs_are_names_equal((ntfschar*)((u8*)\n\t\t\t\t\tnext_al_entry +\n\t\t\t\t\tnext_al_entry->name_offset),\n\t\t\t\t\tnext_al_entry->name_length,\n\t\t\t\t\tal_name, al_name_len, CASE_SENSITIVE,\n\t\t\t\t\tvol->upcase, vol->upcase_len))\n\t\t\tcontinue;\n\t\tif (MREF_LE(al_entry->mft_reference) == ni->mft_no) {\n\t\t\tif (MSEQNO_LE(al_entry->mft_reference) != ni->seq_no) {\n\t\t\t\tntfs_error(vol->sb, \"Found stale mft \"\n\t\t\t\t\t\t\"reference in attribute list \"\n\t\t\t\t\t\t\"of base inode 0x%lx.%s\",\n\t\t\t\t\t\tbase_ni->mft_no, es);\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else { /* Mft references do not match. */\n\t\t\t/* If there is a mapped record unmap it first. */\n\t\t\tif (ni != base_ni)\n\t\t\t\tunmap_extent_mft_record(ni);\n\t\t\t/* Do we want the base record back? */\n\t\t\tif (MREF_LE(al_entry->mft_reference) ==\n\t\t\t\t\tbase_ni->mft_no) {\n\t\t\t\tni = ctx->ntfs_ino = base_ni;\n\t\t\t\tctx->mrec = ctx->base_mrec;\n\t\t\t} else {\n\t\t\t\t/* We want an extent record. */\n\t\t\t\tctx->mrec = map_extent_mft_record(base_ni,\n\t\t\t\t\t\tle64_to_cpu(\n\t\t\t\t\t\tal_entry->mft_reference), &ni);\n\t\t\t\tif (IS_ERR(ctx->mrec)) {\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to map \"\n\t\t\t\t\t\t\t\"extent mft record \"\n\t\t\t\t\t\t\t\"0x%lx of base inode \"\n\t\t\t\t\t\t\t\"0x%lx.%s\",\n\t\t\t\t\t\t\tMREF_LE(al_entry->\n\t\t\t\t\t\t\tmft_reference),\n\t\t\t\t\t\t\tbase_ni->mft_no, es);\n\t\t\t\t\terr = PTR_ERR(ctx->mrec);\n\t\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\t\terr = -EIO;\n\t\t\t\t\t/* Cause @ctx to be sanitized below. */\n\t\t\t\t\tni = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx->ntfs_ino = ni;\n\t\t\t}\n\t\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t}\n\t\t/*\n\t\t * ctx->vfs_ino, ctx->mrec, and ctx->attr now point to the\n\t\t * mft record containing the attribute represented by the\n\t\t * current al_entry.\n\t\t */\n\t\t/*\n\t\t * We could call into ntfs_attr_find() to find the right\n\t\t * attribute in this mft record but this would be less\n\t\t * efficient and not quite accurate as ntfs_attr_find() ignores\n\t\t * the attribute instance numbers for example which become\n\t\t * important when one plays with attribute lists.  Also,\n\t\t * because a proper match has been found in the attribute list\n\t\t * entry above, the comparison can now be optimized.  So it is\n\t\t * worth re-implementing a simplified ntfs_attr_find() here.\n\t\t */\n\t\ta = ctx->attr;\n\t\t/*\n\t\t * Use a manual loop so we can still use break and continue\n\t\t * with the same meanings as above.\n\t\t */\ndo_next_attr_loop:\n\t\tif ((u8*)a < (u8*)ctx->mrec || (u8*)a > (u8*)ctx->mrec +\n\t\t\t\tle32_to_cpu(ctx->mrec->bytes_allocated))\n\t\t\tbreak;\n\t\tif (a->type == AT_END)\n\t\t\tbreak;\n\t\tif (!a->length)\n\t\t\tbreak;\n\t\tif (al_entry->instance != a->instance)\n\t\t\tgoto do_next_attr;\n\t\t/*\n\t\t * If the type and/or the name are mismatched between the\n\t\t * attribute list entry and the attribute record, there is\n\t\t * corruption so we break and return error EIO.\n\t\t */\n\t\tif (al_entry->type != a->type)\n\t\t\tbreak;\n\t\tif (!ntfs_are_names_equal((ntfschar*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->name_offset)), a->name_length,\n\t\t\t\tal_name, al_name_len, CASE_SENSITIVE,\n\t\t\t\tvol->upcase, vol->upcase_len))\n\t\t\tbreak;\n\t\tctx->attr = a;\n\t\t/*\n\t\t * If no @val specified or @val specified and it matches, we\n\t\t * have found it!\n\t\t */\n\t\tif (!val || (!a->non_resident && le32_to_cpu(\n\t\t\t\ta->data.resident.value_length) == val_len &&\n\t\t\t\t!memcmp((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset),\n\t\t\t\tval, val_len))) {\n\t\t\tntfs_debug(\"Done, found.\");\n\t\t\treturn 0;\n\t\t}\ndo_next_attr:\n\t\t/* Proceed to the next attribute in the current mft record. */\n\t\ta = (ATTR_RECORD*)((u8*)a + le32_to_cpu(a->length));\n\t\tgoto do_next_attr_loop;\n\t}\n\tif (!err) {\n\t\tntfs_error(vol->sb, \"Base inode 0x%lx contains corrupt \"\n\t\t\t\t\"attribute list attribute.%s\", base_ni->mft_no,\n\t\t\t\tes);\n\t\terr = -EIO;\n\t}\n\tif (ni != base_ni) {\n\t\tif (ni)\n\t\t\tunmap_extent_mft_record(ni);\n\t\tctx->ntfs_ino = base_ni;\n\t\tctx->mrec = ctx->base_mrec;\n\t\tctx->attr = ctx->base_attr;\n\t}\n\tif (err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\nnot_found:\n\t/*\n\t * If we were looking for AT_END, we reset the search context @ctx and\n\t * use ntfs_attr_find() to seek to the end of the base mft record.\n\t */\n\tif (type == AT_END) {\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\treturn ntfs_attr_find(AT_END, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\t}\n\t/*\n\t * The attribute was not found.  Before we return, we want to ensure\n\t * @ctx->mrec and @ctx->attr indicate the position at which the\n\t * attribute should be inserted in the base mft record.  Since we also\n\t * want to preserve @ctx->al_entry we cannot reinitialize the search\n\t * context using ntfs_attr_reinit_search_ctx() as this would set\n\t * @ctx->al_entry to NULL.  Thus we do the necessary bits manually (see\n\t * ntfs_attr_init_search_ctx() below).  Note, we _only_ preserve\n\t * @ctx->al_entry as the remaining fields (base_*) are identical to\n\t * their non base_ counterparts and we cannot set @ctx->base_attr\n\t * correctly yet as we do not know what @ctx->attr will be set to by\n\t * the call to ntfs_attr_find() below.\n\t */\n\tif (ni != base_ni)\n\t\tunmap_extent_mft_record(ni);\n\tctx->mrec = ctx->base_mrec;\n\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\tctx->is_first = true;\n\tctx->ntfs_ino = base_ni;\n\tctx->base_ntfs_ino = NULL;\n\tctx->base_mrec = NULL;\n\tctx->base_attr = NULL;\n\t/*\n\t * In case there are multiple matches in the base mft record, need to\n\t * keep enumerating until we get an attribute not found response (or\n\t * another error), otherwise we would keep returning the same attribute\n\t * over and over again and all programs using us for enumeration would\n\t * lock up in a tight loop.\n\t */\n\tdo {\n\t\terr = ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\t} while (!err);\n\tntfs_debug(\"Done, not found.\");\n\treturn err;\n}"
  },
  {
    "function_name": "load_attribute_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "710-805",
    "snippet": "int load_attribute_list(ntfs_volume *vol, runlist *runlist, u8 *al_start,\n\t\tconst s64 size, const s64 initialized_size)\n{\n\tLCN lcn;\n\tu8 *al = al_start;\n\tu8 *al_end = al + initialized_size;\n\trunlist_element *rl;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb;\n\tunsigned long block_size;\n\tunsigned long block, max_block;\n\tint err = 0;\n\tunsigned char block_size_bits;\n\n\tntfs_debug(\"Entering.\");\n\tif (!vol || !runlist || !al || size <= 0 || initialized_size < 0 ||\n\t\t\tinitialized_size > size)\n\t\treturn -EINVAL;\n\tif (!initialized_size) {\n\t\tmemset(al, 0, size);\n\t\treturn 0;\n\t}\n\tsb = vol->sb;\n\tblock_size = sb->s_blocksize;\n\tblock_size_bits = sb->s_blocksize_bits;\n\tdown_read(&runlist->lock);\n\trl = runlist->rl;\n\tif (!rl) {\n\t\tntfs_error(sb, \"Cannot read attribute list since runlist is \"\n\t\t\t\t\"missing.\");\n\t\tgoto err_out;\t\n\t}\n\t/* Read all clusters specified by the runlist one run at a time. */\n\twhile (rl->length) {\n\t\tlcn = ntfs_rl_vcn_to_lcn(rl, rl->vcn);\n\t\tntfs_debug(\"Reading vcn = 0x%llx, lcn = 0x%llx.\",\n\t\t\t\t(unsigned long long)rl->vcn,\n\t\t\t\t(unsigned long long)lcn);\n\t\t/* The attribute list cannot be sparse. */\n\t\tif (lcn < 0) {\n\t\t\tntfs_error(sb, \"ntfs_rl_vcn_to_lcn() failed.  Cannot \"\n\t\t\t\t\t\"read attribute list.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tblock = lcn << vol->cluster_size_bits >> block_size_bits;\n\t\t/* Read the run from device in chunks of block_size bytes. */\n\t\tmax_block = block + (rl->length << vol->cluster_size_bits >>\n\t\t\t\tblock_size_bits);\n\t\tntfs_debug(\"max_block = 0x%lx.\", max_block);\n\t\tdo {\n\t\t\tntfs_debug(\"Reading block = 0x%lx.\", block);\n\t\t\tbh = sb_bread(sb, block);\n\t\t\tif (!bh) {\n\t\t\t\tntfs_error(sb, \"sb_bread() failed. Cannot \"\n\t\t\t\t\t\t\"read attribute list.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (al + block_size >= al_end)\n\t\t\t\tgoto do_final;\n\t\t\tmemcpy(al, bh->b_data, block_size);\n\t\t\tbrelse(bh);\n\t\t\tal += block_size;\n\t\t} while (++block < max_block);\n\t\trl++;\n\t}\n\tif (initialized_size < size) {\ninitialize:\n\t\tmemset(al_start + initialized_size, 0, size - initialized_size);\n\t}\ndone:\n\tup_read(&runlist->lock);\n\treturn err;\ndo_final:\n\tif (al < al_end) {\n\t\t/*\n\t\t * Partial block.\n\t\t *\n\t\t * Note: The attribute list can be smaller than its allocation\n\t\t * by multiple clusters.  This has been encountered by at least\n\t\t * two people running Windows XP, thus we cannot do any\n\t\t * truncation sanity checking here. (AIA)\n\t\t */\n\t\tmemcpy(al, bh->b_data, al_end - al);\n\t\tbrelse(bh);\n\t\tif (initialized_size < size)\n\t\t\tgoto initialize;\n\t\tgoto done;\n\t}\n\tbrelse(bh);\n\t/* Real overflow! */\n\tntfs_error(sb, \"Attribute list buffer overflow. Read attribute list \"\n\t\t\t\"is truncated.\");\nerr_out:\n\terr = -EIO;\n\tgoto done;\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Attribute list buffer overflow. Read attribute list \"\n\t\t\t\"is truncated.\""
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "al",
            "bh->b_data",
            "al_end - al"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&runlist->lock"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "al_start + initialized_size",
            "0",
            "size - initialized_size"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "al",
            "bh->b_data",
            "block_size"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"sb_bread() failed. Cannot \"\n\t\t\t\t\t\t\"read attribute list.\""
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "block"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Reading block = 0x%lx.\"",
            "block"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"max_block = 0x%lx.\"",
            "max_block"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"ntfs_rl_vcn_to_lcn() failed.  Cannot \"\n\t\t\t\t\t\"read attribute list.\""
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Reading vcn = 0x%llx, lcn = 0x%llx.\"",
            "(unsigned long long)rl->vcn",
            "(unsigned long long)lcn"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_vcn_to_lcn",
          "args": [
            "rl",
            "rl->vcn"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_vcn_to_lcn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1004-1036",
          "snippet": "LCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nLCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Cannot read attribute list since runlist is \"\n\t\t\t\t\"missing.\""
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&runlist->lock"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "al",
            "0",
            "size"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering.\""
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint load_attribute_list(ntfs_volume *vol, runlist *runlist, u8 *al_start,\n\t\tconst s64 size, const s64 initialized_size)\n{\n\tLCN lcn;\n\tu8 *al = al_start;\n\tu8 *al_end = al + initialized_size;\n\trunlist_element *rl;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb;\n\tunsigned long block_size;\n\tunsigned long block, max_block;\n\tint err = 0;\n\tunsigned char block_size_bits;\n\n\tntfs_debug(\"Entering.\");\n\tif (!vol || !runlist || !al || size <= 0 || initialized_size < 0 ||\n\t\t\tinitialized_size > size)\n\t\treturn -EINVAL;\n\tif (!initialized_size) {\n\t\tmemset(al, 0, size);\n\t\treturn 0;\n\t}\n\tsb = vol->sb;\n\tblock_size = sb->s_blocksize;\n\tblock_size_bits = sb->s_blocksize_bits;\n\tdown_read(&runlist->lock);\n\trl = runlist->rl;\n\tif (!rl) {\n\t\tntfs_error(sb, \"Cannot read attribute list since runlist is \"\n\t\t\t\t\"missing.\");\n\t\tgoto err_out;\t\n\t}\n\t/* Read all clusters specified by the runlist one run at a time. */\n\twhile (rl->length) {\n\t\tlcn = ntfs_rl_vcn_to_lcn(rl, rl->vcn);\n\t\tntfs_debug(\"Reading vcn = 0x%llx, lcn = 0x%llx.\",\n\t\t\t\t(unsigned long long)rl->vcn,\n\t\t\t\t(unsigned long long)lcn);\n\t\t/* The attribute list cannot be sparse. */\n\t\tif (lcn < 0) {\n\t\t\tntfs_error(sb, \"ntfs_rl_vcn_to_lcn() failed.  Cannot \"\n\t\t\t\t\t\"read attribute list.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tblock = lcn << vol->cluster_size_bits >> block_size_bits;\n\t\t/* Read the run from device in chunks of block_size bytes. */\n\t\tmax_block = block + (rl->length << vol->cluster_size_bits >>\n\t\t\t\tblock_size_bits);\n\t\tntfs_debug(\"max_block = 0x%lx.\", max_block);\n\t\tdo {\n\t\t\tntfs_debug(\"Reading block = 0x%lx.\", block);\n\t\t\tbh = sb_bread(sb, block);\n\t\t\tif (!bh) {\n\t\t\t\tntfs_error(sb, \"sb_bread() failed. Cannot \"\n\t\t\t\t\t\t\"read attribute list.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (al + block_size >= al_end)\n\t\t\t\tgoto do_final;\n\t\t\tmemcpy(al, bh->b_data, block_size);\n\t\t\tbrelse(bh);\n\t\t\tal += block_size;\n\t\t} while (++block < max_block);\n\t\trl++;\n\t}\n\tif (initialized_size < size) {\ninitialize:\n\t\tmemset(al_start + initialized_size, 0, size - initialized_size);\n\t}\ndone:\n\tup_read(&runlist->lock);\n\treturn err;\ndo_final:\n\tif (al < al_end) {\n\t\t/*\n\t\t * Partial block.\n\t\t *\n\t\t * Note: The attribute list can be smaller than its allocation\n\t\t * by multiple clusters.  This has been encountered by at least\n\t\t * two people running Windows XP, thus we cannot do any\n\t\t * truncation sanity checking here. (AIA)\n\t\t */\n\t\tmemcpy(al, bh->b_data, al_end - al);\n\t\tbrelse(bh);\n\t\tif (initialized_size < size)\n\t\t\tgoto initialize;\n\t\tgoto done;\n\t}\n\tbrelse(bh);\n\t/* Real overflow! */\n\tntfs_error(sb, \"Attribute list buffer overflow. Read attribute list \"\n\t\t\t\"is truncated.\");\nerr_out:\n\terr = -EIO;\n\tgoto done;\n}"
  },
  {
    "function_name": "ntfs_attr_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "589-692",
    "snippet": "static int ntfs_attr_find(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)\n{\n\tATTR_RECORD *a;\n\tntfs_volume *vol = ctx->ntfs_ino->vol;\n\tntfschar *upcase = vol->upcase;\n\tu32 upcase_len = vol->upcase_len;\n\n\t/*\n\t * Iterate over attributes in mft record starting at @ctx->attr, or the\n\t * attribute following that, if @ctx->is_first is 'true'.\n\t */\n\tif (ctx->is_first) {\n\t\ta = ctx->attr;\n\t\tctx->is_first = false;\n\t} else\n\t\ta = (ATTR_RECORD*)((u8*)ctx->attr +\n\t\t\t\tle32_to_cpu(ctx->attr->length));\n\tfor (;;\ta = (ATTR_RECORD*)((u8*)a + le32_to_cpu(a->length))) {\n\t\tif ((u8*)a < (u8*)ctx->mrec || (u8*)a > (u8*)ctx->mrec +\n\t\t\t\tle32_to_cpu(ctx->mrec->bytes_allocated))\n\t\t\tbreak;\n\t\tctx->attr = a;\n\t\tif (unlikely(le32_to_cpu(a->type) > le32_to_cpu(type) ||\n\t\t\t\ta->type == AT_END))\n\t\t\treturn -ENOENT;\n\t\tif (unlikely(!a->length))\n\t\t\tbreak;\n\t\tif (a->type != type)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If @name is present, compare the two names.  If @name is\n\t\t * missing, assume we want an unnamed attribute.\n\t\t */\n\t\tif (!name) {\n\t\t\t/* The search failed if the found attribute is named. */\n\t\t\tif (a->name_length)\n\t\t\t\treturn -ENOENT;\n\t\t} else if (!ntfs_are_names_equal(name, name_len,\n\t\t\t    (ntfschar*)((u8*)a + le16_to_cpu(a->name_offset)),\n\t\t\t    a->name_length, ic, upcase, upcase_len)) {\n\t\t\tregister int rc;\n\n\t\t\trc = ntfs_collate_names(name, name_len,\n\t\t\t\t\t(ntfschar*)((u8*)a +\n\t\t\t\t\tle16_to_cpu(a->name_offset)),\n\t\t\t\t\ta->name_length, 1, IGNORE_CASE,\n\t\t\t\t\tupcase, upcase_len);\n\t\t\t/*\n\t\t\t * If @name collates before a->name, there is no\n\t\t\t * matching attribute.\n\t\t\t */\n\t\t\tif (rc == -1)\n\t\t\t\treturn -ENOENT;\n\t\t\t/* If the strings are not equal, continue search. */\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t\trc = ntfs_collate_names(name, name_len,\n\t\t\t\t\t(ntfschar*)((u8*)a +\n\t\t\t\t\tle16_to_cpu(a->name_offset)),\n\t\t\t\t\ta->name_length, 1, CASE_SENSITIVE,\n\t\t\t\t\tupcase, upcase_len);\n\t\t\tif (rc == -1)\n\t\t\t\treturn -ENOENT;\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * The names match or @name not present and attribute is\n\t\t * unnamed.  If no @val specified, we have found the attribute\n\t\t * and are done.\n\t\t */\n\t\tif (!val)\n\t\t\treturn 0;\n\t\t/* @val is present; compare values. */\n\t\telse {\n\t\t\tregister int rc;\n\n\t\t\trc = memcmp(val, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tmin_t(u32, val_len, le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length)));\n\t\t\t/*\n\t\t\t * If @val collates before the current attribute's\n\t\t\t * value, there is no matching attribute.\n\t\t\t */\n\t\t\tif (!rc) {\n\t\t\t\tregister u32 avl;\n\n\t\t\t\tavl = le32_to_cpu(\n\t\t\t\t\t\ta->data.resident.value_length);\n\t\t\t\tif (val_len == avl)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (val_len < avl)\n\t\t\t\t\treturn -ENOENT;\n\t\t\t} else if (rc < 0)\n\t\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\tntfs_error(vol->sb, \"Inode is corrupt.  Run chkdsk.\");\n\tNVolSetErrors(vol);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Inode is corrupt.  Run chkdsk.\""
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "a->data.resident.value_length"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "val",
            "(u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset)",
            "min_t(u32, val_len, le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length))"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "val_len",
            "le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length)"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "a->data.resident.value_offset"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_collate_names",
          "args": [
            "name",
            "name_len",
            "(ntfschar*)((u8*)a +\n\t\t\t\t\tle16_to_cpu(a->name_offset))",
            "a->name_length",
            "1",
            "CASE_SENSITIVE",
            "upcase",
            "upcase_len"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_collate_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
          "lines": "97-133",
          "snippet": "int ntfs_collate_names(const ntfschar *name1, const u32 name1_len,\n\t\tconst ntfschar *name2, const u32 name2_len,\n\t\tconst int err_val, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\tu32 cnt, min_len;\n\tu16 c1, c2;\n\n\tmin_len = name1_len;\n\tif (name1_len > name2_len)\n\t\tmin_len = name2_len;\n\tfor (cnt = 0; cnt < min_len; ++cnt) {\n\t\tc1 = le16_to_cpu(*name1++);\n\t\tc2 = le16_to_cpu(*name2++);\n\t\tif (ic) {\n\t\t\tif (c1 < upcase_len)\n\t\t\t\tc1 = le16_to_cpu(upcase[c1]);\n\t\t\tif (c2 < upcase_len)\n\t\t\t\tc2 = le16_to_cpu(upcase[c2]);\n\t\t}\n\t\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\t\treturn err_val;\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t}\n\tif (name1_len < name2_len)\n\t\treturn -1;\n\tif (name1_len == name2_len)\n\t\treturn 0;\n\t/* name1_len > name2_len */\n\tc1 = le16_to_cpu(*name1);\n\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\treturn err_val;\n\treturn 1;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"types.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const u8 legal_ansi_char_array[0x40] = {\n\t0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x17, 0x07, 0x18, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x18, 0x16, 0x16, 0x17, 0x07, 0x00,\n\n\t0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x04, 0x16, 0x18, 0x16, 0x18, 0x18,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nstatic const u8 legal_ansi_char_array[0x40] = {\n\t0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x17, 0x07, 0x18, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x18, 0x16, 0x16, 0x17, 0x07, 0x00,\n\n\t0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x04, 0x16, 0x18, 0x16, 0x18, 0x18,\n};\n\nint ntfs_collate_names(const ntfschar *name1, const u32 name1_len,\n\t\tconst ntfschar *name2, const u32 name2_len,\n\t\tconst int err_val, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\tu32 cnt, min_len;\n\tu16 c1, c2;\n\n\tmin_len = name1_len;\n\tif (name1_len > name2_len)\n\t\tmin_len = name2_len;\n\tfor (cnt = 0; cnt < min_len; ++cnt) {\n\t\tc1 = le16_to_cpu(*name1++);\n\t\tc2 = le16_to_cpu(*name2++);\n\t\tif (ic) {\n\t\t\tif (c1 < upcase_len)\n\t\t\t\tc1 = le16_to_cpu(upcase[c1]);\n\t\t\tif (c2 < upcase_len)\n\t\t\t\tc2 = le16_to_cpu(upcase[c2]);\n\t\t}\n\t\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\t\treturn err_val;\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t}\n\tif (name1_len < name2_len)\n\t\treturn -1;\n\tif (name1_len == name2_len)\n\t\treturn 0;\n\t/* name1_len > name2_len */\n\tc1 = le16_to_cpu(*name1);\n\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\treturn err_val;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_are_names_equal",
          "args": [
            "name",
            "name_len",
            "(ntfschar*)((u8*)a + le16_to_cpu(a->name_offset))",
            "a->name_length",
            "ic",
            "upcase",
            "upcase_len"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_are_names_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
          "lines": "68-77",
          "snippet": "bool ntfs_are_names_equal(const ntfschar *s1, size_t s1_len,\n\t\tconst ntfschar *s2, size_t s2_len, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_size)\n{\n\tif (s1_len != s2_len)\n\t\treturn false;\n\tif (ic == CASE_SENSITIVE)\n\t\treturn !ntfs_ucsncmp(s1, s2, s1_len);\n\treturn !ntfs_ucsncasecmp(s1, s2, s1_len, upcase, upcase_size);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"types.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nbool ntfs_are_names_equal(const ntfschar *s1, size_t s1_len,\n\t\tconst ntfschar *s2, size_t s2_len, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_size)\n{\n\tif (s1_len != s2_len)\n\t\treturn false;\n\tif (ic == CASE_SENSITIVE)\n\t\treturn !ntfs_ucsncmp(s1, s2, s1_len);\n\treturn !ntfs_ucsncasecmp(s1, s2, s1_len, upcase, upcase_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!a->length"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "le32_to_cpu(a->type) > le32_to_cpu(type) ||\n\t\t\t\ta->type == AT_END"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_attr_find(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)\n{\n\tATTR_RECORD *a;\n\tntfs_volume *vol = ctx->ntfs_ino->vol;\n\tntfschar *upcase = vol->upcase;\n\tu32 upcase_len = vol->upcase_len;\n\n\t/*\n\t * Iterate over attributes in mft record starting at @ctx->attr, or the\n\t * attribute following that, if @ctx->is_first is 'true'.\n\t */\n\tif (ctx->is_first) {\n\t\ta = ctx->attr;\n\t\tctx->is_first = false;\n\t} else\n\t\ta = (ATTR_RECORD*)((u8*)ctx->attr +\n\t\t\t\tle32_to_cpu(ctx->attr->length));\n\tfor (;;\ta = (ATTR_RECORD*)((u8*)a + le32_to_cpu(a->length))) {\n\t\tif ((u8*)a < (u8*)ctx->mrec || (u8*)a > (u8*)ctx->mrec +\n\t\t\t\tle32_to_cpu(ctx->mrec->bytes_allocated))\n\t\t\tbreak;\n\t\tctx->attr = a;\n\t\tif (unlikely(le32_to_cpu(a->type) > le32_to_cpu(type) ||\n\t\t\t\ta->type == AT_END))\n\t\t\treturn -ENOENT;\n\t\tif (unlikely(!a->length))\n\t\t\tbreak;\n\t\tif (a->type != type)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If @name is present, compare the two names.  If @name is\n\t\t * missing, assume we want an unnamed attribute.\n\t\t */\n\t\tif (!name) {\n\t\t\t/* The search failed if the found attribute is named. */\n\t\t\tif (a->name_length)\n\t\t\t\treturn -ENOENT;\n\t\t} else if (!ntfs_are_names_equal(name, name_len,\n\t\t\t    (ntfschar*)((u8*)a + le16_to_cpu(a->name_offset)),\n\t\t\t    a->name_length, ic, upcase, upcase_len)) {\n\t\t\tregister int rc;\n\n\t\t\trc = ntfs_collate_names(name, name_len,\n\t\t\t\t\t(ntfschar*)((u8*)a +\n\t\t\t\t\tle16_to_cpu(a->name_offset)),\n\t\t\t\t\ta->name_length, 1, IGNORE_CASE,\n\t\t\t\t\tupcase, upcase_len);\n\t\t\t/*\n\t\t\t * If @name collates before a->name, there is no\n\t\t\t * matching attribute.\n\t\t\t */\n\t\t\tif (rc == -1)\n\t\t\t\treturn -ENOENT;\n\t\t\t/* If the strings are not equal, continue search. */\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t\trc = ntfs_collate_names(name, name_len,\n\t\t\t\t\t(ntfschar*)((u8*)a +\n\t\t\t\t\tle16_to_cpu(a->name_offset)),\n\t\t\t\t\ta->name_length, 1, CASE_SENSITIVE,\n\t\t\t\t\tupcase, upcase_len);\n\t\t\tif (rc == -1)\n\t\t\t\treturn -ENOENT;\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * The names match or @name not present and attribute is\n\t\t * unnamed.  If no @val specified, we have found the attribute\n\t\t * and are done.\n\t\t */\n\t\tif (!val)\n\t\t\treturn 0;\n\t\t/* @val is present; compare values. */\n\t\telse {\n\t\t\tregister int rc;\n\n\t\t\trc = memcmp(val, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tmin_t(u32, val_len, le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length)));\n\t\t\t/*\n\t\t\t * If @val collates before the current attribute's\n\t\t\t * value, there is no matching attribute.\n\t\t\t */\n\t\t\tif (!rc) {\n\t\t\t\tregister u32 avl;\n\n\t\t\t\tavl = le32_to_cpu(\n\t\t\t\t\t\ta->data.resident.value_length);\n\t\t\t\tif (val_len == avl)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (val_len < avl)\n\t\t\t\t\treturn -ENOENT;\n\t\t\t} else if (rc < 0)\n\t\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\tntfs_error(vol->sb, \"Inode is corrupt.  Run chkdsk.\");\n\tNVolSetErrors(vol);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "ntfs_attr_find_vcn_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "464-530",
    "snippet": "runlist_element *ntfs_attr_find_vcn_nolock(ntfs_inode *ni, const VCN vcn,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tunsigned long flags;\n\trunlist_element *rl;\n\tint err = 0;\n\tbool is_retry = false;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, vcn 0x%llx, with%s ctx.\",\n\t\t\tni->mft_no, (unsigned long long)vcn, ctx ? \"\" : \"out\");\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(vcn < 0);\n\tif (!ni->runlist.rl) {\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tif (!ni->allocated_size) {\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t}\nretry_remap:\n\trl = ni->runlist.rl;\n\tif (likely(rl && vcn >= rl[0].vcn)) {\n\t\twhile (likely(rl->length)) {\n\t\t\tif (unlikely(vcn < rl[1].vcn)) {\n\t\t\t\tif (likely(rl->lcn >= LCN_HOLE)) {\n\t\t\t\t\tntfs_debug(\"Done.\");\n\t\t\t\t\treturn rl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trl++;\n\t\t}\n\t\tif (likely(rl->lcn != LCN_RL_NOT_MAPPED)) {\n\t\t\tif (likely(rl->lcn == LCN_ENOENT))\n\t\t\t\terr = -ENOENT;\n\t\t\telse\n\t\t\t\terr = -EIO;\n\t\t}\n\t}\n\tif (!err && !is_retry) {\n\t\t/*\n\t\t * If the search context is invalid we cannot map the unmapped\n\t\t * region.\n\t\t */\n\t\tif (IS_ERR(ctx->mrec))\n\t\t\terr = PTR_ERR(ctx->mrec);\n\t\telse {\n\t\t\t/*\n\t\t\t * The @vcn is in an unmapped region, map the runlist\n\t\t\t * and retry.\n\t\t\t */\n\t\t\terr = ntfs_map_runlist_nolock(ni, vcn, ctx);\n\t\t\tif (likely(!err)) {\n\t\t\t\tis_retry = true;\n\t\t\t\tgoto retry_remap;\n\t\t\t}\n\t\t}\n\t\tif (err == -EINVAL)\n\t\t\terr = -EIO;\n\t} else if (!err)\n\t\terr = -EIO;\n\tif (err != -ENOENT)\n\t\tntfs_error(ni->vol->sb, \"Failed with error code %i.\", err);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "ni->vol->sb",
            "\"Failed with error code %i.\"",
            "err"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_runlist_nolock",
          "args": [
            "ni",
            "vcn",
            "ctx"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_runlist_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "84-281",
          "snippet": "int ntfs_map_runlist_nolock(ntfs_inode *ni, VCN vcn, ntfs_attr_search_ctx *ctx)\n{\n\tVCN end_vcn;\n\tunsigned long flags;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\trunlist_element *rl;\n\tstruct page *put_this_page = NULL;\n\tint err = 0;\n\tbool ctx_is_temporary, ctx_needs_reset;\n\tntfs_attr_search_ctx old_ctx = { NULL, };\n\n\tntfs_debug(\"Mapping runlist part containing vcn 0x%llx.\",\n\t\t\t(unsigned long long)vcn);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tif (!ctx) {\n\t\tctx_is_temporary = ctx_needs_reset = true;\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m))\n\t\t\treturn PTR_ERR(m);\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tVCN allocated_size_vcn;\n\n\t\tBUG_ON(IS_ERR(ctx->mrec));\n\t\ta = ctx->attr;\n\t\tBUG_ON(!a->non_resident);\n\t\tctx_is_temporary = false;\n\t\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size_vcn = ni->allocated_size >>\n\t\t\t\tni->vol->cluster_size_bits;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (!a->data.non_resident.lowest_vcn && end_vcn <= 0)\n\t\t\tend_vcn = allocated_size_vcn - 1;\n\t\t/*\n\t\t * If we already have the attribute extent containing @vcn in\n\t\t * @ctx, no need to look it up again.  We slightly cheat in\n\t\t * that if vcn exceeds the allocated size, we will refuse to\n\t\t * map the runlist below, so there is definitely no need to get\n\t\t * the right attribute extent.\n\t\t */\n\t\tif (vcn >= allocated_size_vcn || (a->type == ni->type &&\n\t\t\t\ta->name_length == ni->name_len &&\n\t\t\t\t!memcmp((u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\tni->name, ni->name_len) &&\n\t\t\t\tsle64_to_cpu(a->data.non_resident.lowest_vcn)\n\t\t\t\t<= vcn && end_vcn >= vcn))\n\t\t\tctx_needs_reset = false;\n\t\telse {\n\t\t\t/* Save the old search context. */\n\t\t\told_ctx = *ctx;\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * base inode we will unmap it when we reinitialize the\n\t\t\t * search context which means we need to get a\n\t\t\t * reference to the page containing the mapped mft\n\t\t\t * record so we do not accidentally drop changes to the\n\t\t\t * mft record when it has not been marked dirty yet.\n\t\t\t */\n\t\t\tif (old_ctx.base_ntfs_ino && old_ctx.ntfs_ino !=\n\t\t\t\t\told_ctx.base_ntfs_ino) {\n\t\t\t\tput_this_page = old_ctx.ntfs_ino->page;\n\t\t\t\tpage_cache_get(put_this_page);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reinitialize the search context so we can lookup the\n\t\t\t * needed attribute extent.\n\t\t\t */\n\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t\tctx_needs_reset = true;\n\t\t}\n\t}\n\tif (ctx_needs_reset) {\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tBUG_ON(!ctx->attr->non_resident);\n\t}\n\ta = ctx->attr;\n\t/*\n\t * Only decompress the mapping pairs if @vcn is inside it.  Otherwise\n\t * we get into problems when we try to map an out of bounds vcn because\n\t * we then try to map the already mapped runlist fragment and\n\t * ntfs_mapping_pairs_decompress() fails.\n\t */\n\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn) + 1;\n\tif (unlikely(vcn && vcn >= end_vcn)) {\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_mapping_pairs_decompress(ni->vol, a, ni->runlist.rl);\n\tif (IS_ERR(rl))\n\t\terr = PTR_ERR(rl);\n\telse\n\t\tni->runlist.rl = rl;\nerr_out:\n\tif (ctx_is_temporary) {\n\t\tif (likely(ctx))\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t} else if (ctx_needs_reset) {\n\t\t/*\n\t\t * If there is no attribute list, restoring the search context\n\t\t * is accomplished simply by copying the saved context back over\n\t\t * the caller supplied context.  If there is an attribute list,\n\t\t * things are more complicated as we need to deal with mapping\n\t\t * of mft records and resulting potential changes in pointers.\n\t\t */\n\t\tif (NInoAttrList(base_ni)) {\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * one we had before, we need to unmap it and map the\n\t\t\t * old one.\n\t\t\t */\n\t\t\tif (ctx->ntfs_ino != old_ctx.ntfs_ino) {\n\t\t\t\t/*\n\t\t\t\t * If the currently mapped inode is not the\n\t\t\t\t * base inode, unmap it.\n\t\t\t\t */\n\t\t\t\tif (ctx->base_ntfs_ino && ctx->ntfs_ino !=\n\t\t\t\t\t\tctx->base_ntfs_ino) {\n\t\t\t\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\t\t\t\t\tctx->mrec = ctx->base_mrec;\n\t\t\t\t\tBUG_ON(!ctx->mrec);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If the old mapped inode is not the base\n\t\t\t\t * inode, map it.\n\t\t\t\t */\n\t\t\t\tif (old_ctx.base_ntfs_ino &&\n\t\t\t\t\t\told_ctx.ntfs_ino !=\n\t\t\t\t\t\told_ctx.base_ntfs_ino) {\nretry_map:\n\t\t\t\t\tctx->mrec = map_mft_record(\n\t\t\t\t\t\t\told_ctx.ntfs_ino);\n\t\t\t\t\t/*\n\t\t\t\t\t * Something bad has happened.  If out\n\t\t\t\t\t * of memory retry till it succeeds.\n\t\t\t\t\t * Any other errors are fatal and we\n\t\t\t\t\t * return the error code in ctx->mrec.\n\t\t\t\t\t * Let the caller deal with it...  We\n\t\t\t\t\t * just need to fudge things so the\n\t\t\t\t\t * caller can reinit and/or put the\n\t\t\t\t\t * search context safely.\n\t\t\t\t\t */\n\t\t\t\t\tif (IS_ERR(ctx->mrec)) {\n\t\t\t\t\t\tif (PTR_ERR(ctx->mrec) ==\n\t\t\t\t\t\t\t\t-ENOMEM) {\n\t\t\t\t\t\t\tschedule();\n\t\t\t\t\t\t\tgoto retry_map;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\told_ctx.ntfs_ino =\n\t\t\t\t\t\t\t\told_ctx.\n\t\t\t\t\t\t\t\tbase_ntfs_ino;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Update the changed pointers in the saved context. */\n\t\t\tif (ctx->mrec != old_ctx.mrec) {\n\t\t\t\tif (!IS_ERR(ctx->mrec))\n\t\t\t\t\told_ctx.attr = (ATTR_RECORD*)(\n\t\t\t\t\t\t\t(u8*)ctx->mrec +\n\t\t\t\t\t\t\t((u8*)old_ctx.attr -\n\t\t\t\t\t\t\t(u8*)old_ctx.mrec));\n\t\t\t\told_ctx.mrec = ctx->mrec;\n\t\t\t}\n\t\t}\n\t\t/* Restore the search context to the saved one. */\n\t\t*ctx = old_ctx;\n\t\t/*\n\t\t * We drop the reference on the page we took earlier.  In the\n\t\t * case that IS_ERR(ctx->mrec) is true this means we might lose\n\t\t * some changes to the mft record that had been made between\n\t\t * the last time it was marked dirty/written out and now.  This\n\t\t * at this stage is not a problem as the mapping error is fatal\n\t\t * enough that the mft record cannot be written out anyway and\n\t\t * the caller is very likely to shutdown the whole inode\n\t\t * immediately and mark the volume dirty for chkdsk to pick up\n\t\t * the pieces anyway.\n\t\t */\n\t\tif (put_this_page)\n\t\t\tpage_cache_release(put_this_page);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_map_runlist_nolock(ntfs_inode *ni, VCN vcn, ntfs_attr_search_ctx *ctx)\n{\n\tVCN end_vcn;\n\tunsigned long flags;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\trunlist_element *rl;\n\tstruct page *put_this_page = NULL;\n\tint err = 0;\n\tbool ctx_is_temporary, ctx_needs_reset;\n\tntfs_attr_search_ctx old_ctx = { NULL, };\n\n\tntfs_debug(\"Mapping runlist part containing vcn 0x%llx.\",\n\t\t\t(unsigned long long)vcn);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tif (!ctx) {\n\t\tctx_is_temporary = ctx_needs_reset = true;\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m))\n\t\t\treturn PTR_ERR(m);\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tVCN allocated_size_vcn;\n\n\t\tBUG_ON(IS_ERR(ctx->mrec));\n\t\ta = ctx->attr;\n\t\tBUG_ON(!a->non_resident);\n\t\tctx_is_temporary = false;\n\t\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size_vcn = ni->allocated_size >>\n\t\t\t\tni->vol->cluster_size_bits;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (!a->data.non_resident.lowest_vcn && end_vcn <= 0)\n\t\t\tend_vcn = allocated_size_vcn - 1;\n\t\t/*\n\t\t * If we already have the attribute extent containing @vcn in\n\t\t * @ctx, no need to look it up again.  We slightly cheat in\n\t\t * that if vcn exceeds the allocated size, we will refuse to\n\t\t * map the runlist below, so there is definitely no need to get\n\t\t * the right attribute extent.\n\t\t */\n\t\tif (vcn >= allocated_size_vcn || (a->type == ni->type &&\n\t\t\t\ta->name_length == ni->name_len &&\n\t\t\t\t!memcmp((u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\tni->name, ni->name_len) &&\n\t\t\t\tsle64_to_cpu(a->data.non_resident.lowest_vcn)\n\t\t\t\t<= vcn && end_vcn >= vcn))\n\t\t\tctx_needs_reset = false;\n\t\telse {\n\t\t\t/* Save the old search context. */\n\t\t\told_ctx = *ctx;\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * base inode we will unmap it when we reinitialize the\n\t\t\t * search context which means we need to get a\n\t\t\t * reference to the page containing the mapped mft\n\t\t\t * record so we do not accidentally drop changes to the\n\t\t\t * mft record when it has not been marked dirty yet.\n\t\t\t */\n\t\t\tif (old_ctx.base_ntfs_ino && old_ctx.ntfs_ino !=\n\t\t\t\t\told_ctx.base_ntfs_ino) {\n\t\t\t\tput_this_page = old_ctx.ntfs_ino->page;\n\t\t\t\tpage_cache_get(put_this_page);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reinitialize the search context so we can lookup the\n\t\t\t * needed attribute extent.\n\t\t\t */\n\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t\tctx_needs_reset = true;\n\t\t}\n\t}\n\tif (ctx_needs_reset) {\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tBUG_ON(!ctx->attr->non_resident);\n\t}\n\ta = ctx->attr;\n\t/*\n\t * Only decompress the mapping pairs if @vcn is inside it.  Otherwise\n\t * we get into problems when we try to map an out of bounds vcn because\n\t * we then try to map the already mapped runlist fragment and\n\t * ntfs_mapping_pairs_decompress() fails.\n\t */\n\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn) + 1;\n\tif (unlikely(vcn && vcn >= end_vcn)) {\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_mapping_pairs_decompress(ni->vol, a, ni->runlist.rl);\n\tif (IS_ERR(rl))\n\t\terr = PTR_ERR(rl);\n\telse\n\t\tni->runlist.rl = rl;\nerr_out:\n\tif (ctx_is_temporary) {\n\t\tif (likely(ctx))\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t} else if (ctx_needs_reset) {\n\t\t/*\n\t\t * If there is no attribute list, restoring the search context\n\t\t * is accomplished simply by copying the saved context back over\n\t\t * the caller supplied context.  If there is an attribute list,\n\t\t * things are more complicated as we need to deal with mapping\n\t\t * of mft records and resulting potential changes in pointers.\n\t\t */\n\t\tif (NInoAttrList(base_ni)) {\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * one we had before, we need to unmap it and map the\n\t\t\t * old one.\n\t\t\t */\n\t\t\tif (ctx->ntfs_ino != old_ctx.ntfs_ino) {\n\t\t\t\t/*\n\t\t\t\t * If the currently mapped inode is not the\n\t\t\t\t * base inode, unmap it.\n\t\t\t\t */\n\t\t\t\tif (ctx->base_ntfs_ino && ctx->ntfs_ino !=\n\t\t\t\t\t\tctx->base_ntfs_ino) {\n\t\t\t\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\t\t\t\t\tctx->mrec = ctx->base_mrec;\n\t\t\t\t\tBUG_ON(!ctx->mrec);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If the old mapped inode is not the base\n\t\t\t\t * inode, map it.\n\t\t\t\t */\n\t\t\t\tif (old_ctx.base_ntfs_ino &&\n\t\t\t\t\t\told_ctx.ntfs_ino !=\n\t\t\t\t\t\told_ctx.base_ntfs_ino) {\nretry_map:\n\t\t\t\t\tctx->mrec = map_mft_record(\n\t\t\t\t\t\t\told_ctx.ntfs_ino);\n\t\t\t\t\t/*\n\t\t\t\t\t * Something bad has happened.  If out\n\t\t\t\t\t * of memory retry till it succeeds.\n\t\t\t\t\t * Any other errors are fatal and we\n\t\t\t\t\t * return the error code in ctx->mrec.\n\t\t\t\t\t * Let the caller deal with it...  We\n\t\t\t\t\t * just need to fudge things so the\n\t\t\t\t\t * caller can reinit and/or put the\n\t\t\t\t\t * search context safely.\n\t\t\t\t\t */\n\t\t\t\t\tif (IS_ERR(ctx->mrec)) {\n\t\t\t\t\t\tif (PTR_ERR(ctx->mrec) ==\n\t\t\t\t\t\t\t\t-ENOMEM) {\n\t\t\t\t\t\t\tschedule();\n\t\t\t\t\t\t\tgoto retry_map;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\told_ctx.ntfs_ino =\n\t\t\t\t\t\t\t\told_ctx.\n\t\t\t\t\t\t\t\tbase_ntfs_ino;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Update the changed pointers in the saved context. */\n\t\t\tif (ctx->mrec != old_ctx.mrec) {\n\t\t\t\tif (!IS_ERR(ctx->mrec))\n\t\t\t\t\told_ctx.attr = (ATTR_RECORD*)(\n\t\t\t\t\t\t\t(u8*)ctx->mrec +\n\t\t\t\t\t\t\t((u8*)old_ctx.attr -\n\t\t\t\t\t\t\t(u8*)old_ctx.mrec));\n\t\t\t\told_ctx.mrec = ctx->mrec;\n\t\t\t}\n\t\t}\n\t\t/* Restore the search context to the saved one. */\n\t\t*ctx = old_ctx;\n\t\t/*\n\t\t * We drop the reference on the page we took earlier.  In the\n\t\t * case that IS_ERR(ctx->mrec) is true this means we might lose\n\t\t * some changes to the mft record that had been made between\n\t\t * the last time it was marked dirty/written out and now.  This\n\t\t * at this stage is not a problem as the mapping error is fatal\n\t\t * enough that the mft record cannot be written out anyway and\n\t\t * the caller is very likely to shutdown the whole inode\n\t\t * immediately and mark the volume dirty for chkdsk to pick up\n\t\t * the pieces anyway.\n\t\t */\n\t\tif (put_this_page)\n\t\t\tpage_cache_release(put_this_page);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ctx->mrec"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ctx->mrec"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl->lcn == LCN_ENOENT"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl->lcn != LCN_RL_NOT_MAPPED"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl->lcn >= LCN_HOLE"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcn < rl[1].vcn"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl->length"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl && vcn >= rl[0].vcn"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vcn < 0"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!NInoNonResident(ni)"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for i_ino 0x%lx, vcn 0x%llx, with%s ctx.\"",
            "ni->mft_no",
            "(unsigned long long)vcn",
            "ctx ? \"\" : \"out\""
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ni"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nrunlist_element *ntfs_attr_find_vcn_nolock(ntfs_inode *ni, const VCN vcn,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tunsigned long flags;\n\trunlist_element *rl;\n\tint err = 0;\n\tbool is_retry = false;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, vcn 0x%llx, with%s ctx.\",\n\t\t\tni->mft_no, (unsigned long long)vcn, ctx ? \"\" : \"out\");\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(vcn < 0);\n\tif (!ni->runlist.rl) {\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tif (!ni->allocated_size) {\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t}\nretry_remap:\n\trl = ni->runlist.rl;\n\tif (likely(rl && vcn >= rl[0].vcn)) {\n\t\twhile (likely(rl->length)) {\n\t\t\tif (unlikely(vcn < rl[1].vcn)) {\n\t\t\t\tif (likely(rl->lcn >= LCN_HOLE)) {\n\t\t\t\t\tntfs_debug(\"Done.\");\n\t\t\t\t\treturn rl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trl++;\n\t\t}\n\t\tif (likely(rl->lcn != LCN_RL_NOT_MAPPED)) {\n\t\t\tif (likely(rl->lcn == LCN_ENOENT))\n\t\t\t\terr = -ENOENT;\n\t\t\telse\n\t\t\t\terr = -EIO;\n\t\t}\n\t}\n\tif (!err && !is_retry) {\n\t\t/*\n\t\t * If the search context is invalid we cannot map the unmapped\n\t\t * region.\n\t\t */\n\t\tif (IS_ERR(ctx->mrec))\n\t\t\terr = PTR_ERR(ctx->mrec);\n\t\telse {\n\t\t\t/*\n\t\t\t * The @vcn is in an unmapped region, map the runlist\n\t\t\t * and retry.\n\t\t\t */\n\t\t\terr = ntfs_map_runlist_nolock(ni, vcn, ctx);\n\t\t\tif (likely(!err)) {\n\t\t\t\tis_retry = true;\n\t\t\t\tgoto retry_remap;\n\t\t\t}\n\t\t}\n\t\tif (err == -EINVAL)\n\t\t\terr = -EIO;\n\t} else if (!err)\n\t\terr = -EIO;\n\tif (err != -ENOENT)\n\t\tntfs_error(ni->vol->sb, \"Failed with error code %i.\", err);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "ntfs_attr_vcn_to_lcn_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "341-405",
    "snippet": "LCN ntfs_attr_vcn_to_lcn_nolock(ntfs_inode *ni, const VCN vcn,\n\t\tconst bool write_locked)\n{\n\tLCN lcn;\n\tunsigned long flags;\n\tbool is_retry = false;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, vcn 0x%llx, %s_locked.\",\n\t\t\tni->mft_no, (unsigned long long)vcn,\n\t\t\twrite_locked ? \"write\" : \"read\");\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(vcn < 0);\n\tif (!ni->runlist.rl) {\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tif (!ni->allocated_size) {\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\treturn LCN_ENOENT;\n\t\t}\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t}\nretry_remap:\n\t/* Convert vcn to lcn.  If that fails map the runlist and retry once. */\n\tlcn = ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn);\n\tif (likely(lcn >= LCN_HOLE)) {\n\t\tntfs_debug(\"Done, lcn 0x%llx.\", (long long)lcn);\n\t\treturn lcn;\n\t}\n\tif (lcn != LCN_RL_NOT_MAPPED) {\n\t\tif (lcn != LCN_ENOENT)\n\t\t\tlcn = LCN_EIO;\n\t} else if (!is_retry) {\n\t\tint err;\n\n\t\tif (!write_locked) {\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\tdown_write(&ni->runlist.lock);\n\t\t\tif (unlikely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) !=\n\t\t\t\t\tLCN_RL_NOT_MAPPED)) {\n\t\t\t\tup_write(&ni->runlist.lock);\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\tgoto retry_remap;\n\t\t\t}\n\t\t}\n\t\terr = ntfs_map_runlist_nolock(ni, vcn, NULL);\n\t\tif (!write_locked) {\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\tdown_read(&ni->runlist.lock);\n\t\t}\n\t\tif (likely(!err)) {\n\t\t\tis_retry = true;\n\t\t\tgoto retry_remap;\n\t\t}\n\t\tif (err == -ENOENT)\n\t\t\tlcn = LCN_ENOENT;\n\t\telse if (err == -ENOMEM)\n\t\t\tlcn = LCN_ENOMEM;\n\t\telse\n\t\t\tlcn = LCN_EIO;\n\t}\n\tif (lcn != LCN_ENOENT)\n\t\tntfs_error(ni->vol->sb, \"Failed with error code %lli.\",\n\t\t\t\t(long long)lcn);\n\treturn lcn;\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "ni->vol->sb",
            "\"Failed with error code %lli.\"",
            "(long long)lcn"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_runlist_nolock",
          "args": [
            "ni",
            "vcn",
            "NULL"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_runlist_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "84-281",
          "snippet": "int ntfs_map_runlist_nolock(ntfs_inode *ni, VCN vcn, ntfs_attr_search_ctx *ctx)\n{\n\tVCN end_vcn;\n\tunsigned long flags;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\trunlist_element *rl;\n\tstruct page *put_this_page = NULL;\n\tint err = 0;\n\tbool ctx_is_temporary, ctx_needs_reset;\n\tntfs_attr_search_ctx old_ctx = { NULL, };\n\n\tntfs_debug(\"Mapping runlist part containing vcn 0x%llx.\",\n\t\t\t(unsigned long long)vcn);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tif (!ctx) {\n\t\tctx_is_temporary = ctx_needs_reset = true;\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m))\n\t\t\treturn PTR_ERR(m);\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tVCN allocated_size_vcn;\n\n\t\tBUG_ON(IS_ERR(ctx->mrec));\n\t\ta = ctx->attr;\n\t\tBUG_ON(!a->non_resident);\n\t\tctx_is_temporary = false;\n\t\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size_vcn = ni->allocated_size >>\n\t\t\t\tni->vol->cluster_size_bits;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (!a->data.non_resident.lowest_vcn && end_vcn <= 0)\n\t\t\tend_vcn = allocated_size_vcn - 1;\n\t\t/*\n\t\t * If we already have the attribute extent containing @vcn in\n\t\t * @ctx, no need to look it up again.  We slightly cheat in\n\t\t * that if vcn exceeds the allocated size, we will refuse to\n\t\t * map the runlist below, so there is definitely no need to get\n\t\t * the right attribute extent.\n\t\t */\n\t\tif (vcn >= allocated_size_vcn || (a->type == ni->type &&\n\t\t\t\ta->name_length == ni->name_len &&\n\t\t\t\t!memcmp((u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\tni->name, ni->name_len) &&\n\t\t\t\tsle64_to_cpu(a->data.non_resident.lowest_vcn)\n\t\t\t\t<= vcn && end_vcn >= vcn))\n\t\t\tctx_needs_reset = false;\n\t\telse {\n\t\t\t/* Save the old search context. */\n\t\t\told_ctx = *ctx;\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * base inode we will unmap it when we reinitialize the\n\t\t\t * search context which means we need to get a\n\t\t\t * reference to the page containing the mapped mft\n\t\t\t * record so we do not accidentally drop changes to the\n\t\t\t * mft record when it has not been marked dirty yet.\n\t\t\t */\n\t\t\tif (old_ctx.base_ntfs_ino && old_ctx.ntfs_ino !=\n\t\t\t\t\told_ctx.base_ntfs_ino) {\n\t\t\t\tput_this_page = old_ctx.ntfs_ino->page;\n\t\t\t\tpage_cache_get(put_this_page);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reinitialize the search context so we can lookup the\n\t\t\t * needed attribute extent.\n\t\t\t */\n\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t\tctx_needs_reset = true;\n\t\t}\n\t}\n\tif (ctx_needs_reset) {\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tBUG_ON(!ctx->attr->non_resident);\n\t}\n\ta = ctx->attr;\n\t/*\n\t * Only decompress the mapping pairs if @vcn is inside it.  Otherwise\n\t * we get into problems when we try to map an out of bounds vcn because\n\t * we then try to map the already mapped runlist fragment and\n\t * ntfs_mapping_pairs_decompress() fails.\n\t */\n\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn) + 1;\n\tif (unlikely(vcn && vcn >= end_vcn)) {\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_mapping_pairs_decompress(ni->vol, a, ni->runlist.rl);\n\tif (IS_ERR(rl))\n\t\terr = PTR_ERR(rl);\n\telse\n\t\tni->runlist.rl = rl;\nerr_out:\n\tif (ctx_is_temporary) {\n\t\tif (likely(ctx))\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t} else if (ctx_needs_reset) {\n\t\t/*\n\t\t * If there is no attribute list, restoring the search context\n\t\t * is accomplished simply by copying the saved context back over\n\t\t * the caller supplied context.  If there is an attribute list,\n\t\t * things are more complicated as we need to deal with mapping\n\t\t * of mft records and resulting potential changes in pointers.\n\t\t */\n\t\tif (NInoAttrList(base_ni)) {\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * one we had before, we need to unmap it and map the\n\t\t\t * old one.\n\t\t\t */\n\t\t\tif (ctx->ntfs_ino != old_ctx.ntfs_ino) {\n\t\t\t\t/*\n\t\t\t\t * If the currently mapped inode is not the\n\t\t\t\t * base inode, unmap it.\n\t\t\t\t */\n\t\t\t\tif (ctx->base_ntfs_ino && ctx->ntfs_ino !=\n\t\t\t\t\t\tctx->base_ntfs_ino) {\n\t\t\t\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\t\t\t\t\tctx->mrec = ctx->base_mrec;\n\t\t\t\t\tBUG_ON(!ctx->mrec);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If the old mapped inode is not the base\n\t\t\t\t * inode, map it.\n\t\t\t\t */\n\t\t\t\tif (old_ctx.base_ntfs_ino &&\n\t\t\t\t\t\told_ctx.ntfs_ino !=\n\t\t\t\t\t\told_ctx.base_ntfs_ino) {\nretry_map:\n\t\t\t\t\tctx->mrec = map_mft_record(\n\t\t\t\t\t\t\told_ctx.ntfs_ino);\n\t\t\t\t\t/*\n\t\t\t\t\t * Something bad has happened.  If out\n\t\t\t\t\t * of memory retry till it succeeds.\n\t\t\t\t\t * Any other errors are fatal and we\n\t\t\t\t\t * return the error code in ctx->mrec.\n\t\t\t\t\t * Let the caller deal with it...  We\n\t\t\t\t\t * just need to fudge things so the\n\t\t\t\t\t * caller can reinit and/or put the\n\t\t\t\t\t * search context safely.\n\t\t\t\t\t */\n\t\t\t\t\tif (IS_ERR(ctx->mrec)) {\n\t\t\t\t\t\tif (PTR_ERR(ctx->mrec) ==\n\t\t\t\t\t\t\t\t-ENOMEM) {\n\t\t\t\t\t\t\tschedule();\n\t\t\t\t\t\t\tgoto retry_map;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\told_ctx.ntfs_ino =\n\t\t\t\t\t\t\t\told_ctx.\n\t\t\t\t\t\t\t\tbase_ntfs_ino;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Update the changed pointers in the saved context. */\n\t\t\tif (ctx->mrec != old_ctx.mrec) {\n\t\t\t\tif (!IS_ERR(ctx->mrec))\n\t\t\t\t\told_ctx.attr = (ATTR_RECORD*)(\n\t\t\t\t\t\t\t(u8*)ctx->mrec +\n\t\t\t\t\t\t\t((u8*)old_ctx.attr -\n\t\t\t\t\t\t\t(u8*)old_ctx.mrec));\n\t\t\t\told_ctx.mrec = ctx->mrec;\n\t\t\t}\n\t\t}\n\t\t/* Restore the search context to the saved one. */\n\t\t*ctx = old_ctx;\n\t\t/*\n\t\t * We drop the reference on the page we took earlier.  In the\n\t\t * case that IS_ERR(ctx->mrec) is true this means we might lose\n\t\t * some changes to the mft record that had been made between\n\t\t * the last time it was marked dirty/written out and now.  This\n\t\t * at this stage is not a problem as the mapping error is fatal\n\t\t * enough that the mft record cannot be written out anyway and\n\t\t * the caller is very likely to shutdown the whole inode\n\t\t * immediately and mark the volume dirty for chkdsk to pick up\n\t\t * the pieces anyway.\n\t\t */\n\t\tif (put_this_page)\n\t\t\tpage_cache_release(put_this_page);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_map_runlist_nolock(ntfs_inode *ni, VCN vcn, ntfs_attr_search_ctx *ctx)\n{\n\tVCN end_vcn;\n\tunsigned long flags;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\trunlist_element *rl;\n\tstruct page *put_this_page = NULL;\n\tint err = 0;\n\tbool ctx_is_temporary, ctx_needs_reset;\n\tntfs_attr_search_ctx old_ctx = { NULL, };\n\n\tntfs_debug(\"Mapping runlist part containing vcn 0x%llx.\",\n\t\t\t(unsigned long long)vcn);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tif (!ctx) {\n\t\tctx_is_temporary = ctx_needs_reset = true;\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m))\n\t\t\treturn PTR_ERR(m);\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tVCN allocated_size_vcn;\n\n\t\tBUG_ON(IS_ERR(ctx->mrec));\n\t\ta = ctx->attr;\n\t\tBUG_ON(!a->non_resident);\n\t\tctx_is_temporary = false;\n\t\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size_vcn = ni->allocated_size >>\n\t\t\t\tni->vol->cluster_size_bits;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (!a->data.non_resident.lowest_vcn && end_vcn <= 0)\n\t\t\tend_vcn = allocated_size_vcn - 1;\n\t\t/*\n\t\t * If we already have the attribute extent containing @vcn in\n\t\t * @ctx, no need to look it up again.  We slightly cheat in\n\t\t * that if vcn exceeds the allocated size, we will refuse to\n\t\t * map the runlist below, so there is definitely no need to get\n\t\t * the right attribute extent.\n\t\t */\n\t\tif (vcn >= allocated_size_vcn || (a->type == ni->type &&\n\t\t\t\ta->name_length == ni->name_len &&\n\t\t\t\t!memcmp((u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\tni->name, ni->name_len) &&\n\t\t\t\tsle64_to_cpu(a->data.non_resident.lowest_vcn)\n\t\t\t\t<= vcn && end_vcn >= vcn))\n\t\t\tctx_needs_reset = false;\n\t\telse {\n\t\t\t/* Save the old search context. */\n\t\t\told_ctx = *ctx;\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * base inode we will unmap it when we reinitialize the\n\t\t\t * search context which means we need to get a\n\t\t\t * reference to the page containing the mapped mft\n\t\t\t * record so we do not accidentally drop changes to the\n\t\t\t * mft record when it has not been marked dirty yet.\n\t\t\t */\n\t\t\tif (old_ctx.base_ntfs_ino && old_ctx.ntfs_ino !=\n\t\t\t\t\told_ctx.base_ntfs_ino) {\n\t\t\t\tput_this_page = old_ctx.ntfs_ino->page;\n\t\t\t\tpage_cache_get(put_this_page);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reinitialize the search context so we can lookup the\n\t\t\t * needed attribute extent.\n\t\t\t */\n\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t\tctx_needs_reset = true;\n\t\t}\n\t}\n\tif (ctx_needs_reset) {\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tBUG_ON(!ctx->attr->non_resident);\n\t}\n\ta = ctx->attr;\n\t/*\n\t * Only decompress the mapping pairs if @vcn is inside it.  Otherwise\n\t * we get into problems when we try to map an out of bounds vcn because\n\t * we then try to map the already mapped runlist fragment and\n\t * ntfs_mapping_pairs_decompress() fails.\n\t */\n\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn) + 1;\n\tif (unlikely(vcn && vcn >= end_vcn)) {\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_mapping_pairs_decompress(ni->vol, a, ni->runlist.rl);\n\tif (IS_ERR(rl))\n\t\terr = PTR_ERR(rl);\n\telse\n\t\tni->runlist.rl = rl;\nerr_out:\n\tif (ctx_is_temporary) {\n\t\tif (likely(ctx))\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t} else if (ctx_needs_reset) {\n\t\t/*\n\t\t * If there is no attribute list, restoring the search context\n\t\t * is accomplished simply by copying the saved context back over\n\t\t * the caller supplied context.  If there is an attribute list,\n\t\t * things are more complicated as we need to deal with mapping\n\t\t * of mft records and resulting potential changes in pointers.\n\t\t */\n\t\tif (NInoAttrList(base_ni)) {\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * one we had before, we need to unmap it and map the\n\t\t\t * old one.\n\t\t\t */\n\t\t\tif (ctx->ntfs_ino != old_ctx.ntfs_ino) {\n\t\t\t\t/*\n\t\t\t\t * If the currently mapped inode is not the\n\t\t\t\t * base inode, unmap it.\n\t\t\t\t */\n\t\t\t\tif (ctx->base_ntfs_ino && ctx->ntfs_ino !=\n\t\t\t\t\t\tctx->base_ntfs_ino) {\n\t\t\t\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\t\t\t\t\tctx->mrec = ctx->base_mrec;\n\t\t\t\t\tBUG_ON(!ctx->mrec);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If the old mapped inode is not the base\n\t\t\t\t * inode, map it.\n\t\t\t\t */\n\t\t\t\tif (old_ctx.base_ntfs_ino &&\n\t\t\t\t\t\told_ctx.ntfs_ino !=\n\t\t\t\t\t\told_ctx.base_ntfs_ino) {\nretry_map:\n\t\t\t\t\tctx->mrec = map_mft_record(\n\t\t\t\t\t\t\told_ctx.ntfs_ino);\n\t\t\t\t\t/*\n\t\t\t\t\t * Something bad has happened.  If out\n\t\t\t\t\t * of memory retry till it succeeds.\n\t\t\t\t\t * Any other errors are fatal and we\n\t\t\t\t\t * return the error code in ctx->mrec.\n\t\t\t\t\t * Let the caller deal with it...  We\n\t\t\t\t\t * just need to fudge things so the\n\t\t\t\t\t * caller can reinit and/or put the\n\t\t\t\t\t * search context safely.\n\t\t\t\t\t */\n\t\t\t\t\tif (IS_ERR(ctx->mrec)) {\n\t\t\t\t\t\tif (PTR_ERR(ctx->mrec) ==\n\t\t\t\t\t\t\t\t-ENOMEM) {\n\t\t\t\t\t\t\tschedule();\n\t\t\t\t\t\t\tgoto retry_map;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\told_ctx.ntfs_ino =\n\t\t\t\t\t\t\t\told_ctx.\n\t\t\t\t\t\t\t\tbase_ntfs_ino;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Update the changed pointers in the saved context. */\n\t\t\tif (ctx->mrec != old_ctx.mrec) {\n\t\t\t\tif (!IS_ERR(ctx->mrec))\n\t\t\t\t\told_ctx.attr = (ATTR_RECORD*)(\n\t\t\t\t\t\t\t(u8*)ctx->mrec +\n\t\t\t\t\t\t\t((u8*)old_ctx.attr -\n\t\t\t\t\t\t\t(u8*)old_ctx.mrec));\n\t\t\t\told_ctx.mrec = ctx->mrec;\n\t\t\t}\n\t\t}\n\t\t/* Restore the search context to the saved one. */\n\t\t*ctx = old_ctx;\n\t\t/*\n\t\t * We drop the reference on the page we took earlier.  In the\n\t\t * case that IS_ERR(ctx->mrec) is true this means we might lose\n\t\t * some changes to the mft record that had been made between\n\t\t * the last time it was marked dirty/written out and now.  This\n\t\t * at this stage is not a problem as the mapping error is fatal\n\t\t * enough that the mft record cannot be written out anyway and\n\t\t * the caller is very likely to shutdown the whole inode\n\t\t * immediately and mark the volume dirty for chkdsk to pick up\n\t\t * the pieces anyway.\n\t\t */\n\t\tif (put_this_page)\n\t\t\tpage_cache_release(put_this_page);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) !=\n\t\t\t\t\tLCN_RL_NOT_MAPPED"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_vcn_to_lcn",
          "args": [
            "ni->runlist.rl",
            "vcn"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_vcn_to_lcn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1004-1036",
          "snippet": "LCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nLCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done, lcn 0x%llx.\"",
            "(long long)lcn"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "lcn >= LCN_HOLE"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vcn < 0"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!NInoNonResident(ni)"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for i_ino 0x%lx, vcn 0x%llx, %s_locked.\"",
            "ni->mft_no",
            "(unsigned long long)vcn",
            "write_locked ? \"write\" : \"read\""
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ni"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nLCN ntfs_attr_vcn_to_lcn_nolock(ntfs_inode *ni, const VCN vcn,\n\t\tconst bool write_locked)\n{\n\tLCN lcn;\n\tunsigned long flags;\n\tbool is_retry = false;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, vcn 0x%llx, %s_locked.\",\n\t\t\tni->mft_no, (unsigned long long)vcn,\n\t\t\twrite_locked ? \"write\" : \"read\");\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(vcn < 0);\n\tif (!ni->runlist.rl) {\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tif (!ni->allocated_size) {\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\treturn LCN_ENOENT;\n\t\t}\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t}\nretry_remap:\n\t/* Convert vcn to lcn.  If that fails map the runlist and retry once. */\n\tlcn = ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn);\n\tif (likely(lcn >= LCN_HOLE)) {\n\t\tntfs_debug(\"Done, lcn 0x%llx.\", (long long)lcn);\n\t\treturn lcn;\n\t}\n\tif (lcn != LCN_RL_NOT_MAPPED) {\n\t\tif (lcn != LCN_ENOENT)\n\t\t\tlcn = LCN_EIO;\n\t} else if (!is_retry) {\n\t\tint err;\n\n\t\tif (!write_locked) {\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\tdown_write(&ni->runlist.lock);\n\t\t\tif (unlikely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) !=\n\t\t\t\t\tLCN_RL_NOT_MAPPED)) {\n\t\t\t\tup_write(&ni->runlist.lock);\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\tgoto retry_remap;\n\t\t\t}\n\t\t}\n\t\terr = ntfs_map_runlist_nolock(ni, vcn, NULL);\n\t\tif (!write_locked) {\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\tdown_read(&ni->runlist.lock);\n\t\t}\n\t\tif (likely(!err)) {\n\t\t\tis_retry = true;\n\t\t\tgoto retry_remap;\n\t\t}\n\t\tif (err == -ENOENT)\n\t\t\tlcn = LCN_ENOENT;\n\t\telse if (err == -ENOMEM)\n\t\t\tlcn = LCN_ENOMEM;\n\t\telse\n\t\t\tlcn = LCN_EIO;\n\t}\n\tif (lcn != LCN_ENOENT)\n\t\tntfs_error(ni->vol->sb, \"Failed with error code %lli.\",\n\t\t\t\t(long long)lcn);\n\treturn lcn;\n}"
  },
  {
    "function_name": "ntfs_map_runlist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "298-309",
    "snippet": "int ntfs_map_runlist(ntfs_inode *ni, VCN vcn)\n{\n\tint err = 0;\n\n\tdown_write(&ni->runlist.lock);\n\t/* Make sure someone else didn't do the work while we were sleeping. */\n\tif (likely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) <=\n\t\t\tLCN_RL_NOT_MAPPED))\n\t\terr = ntfs_map_runlist_nolock(ni, vcn, NULL);\n\tup_write(&ni->runlist.lock);\n\treturn err;\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_runlist_nolock",
          "args": [
            "ni",
            "vcn",
            "NULL"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_runlist_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "84-281",
          "snippet": "int ntfs_map_runlist_nolock(ntfs_inode *ni, VCN vcn, ntfs_attr_search_ctx *ctx)\n{\n\tVCN end_vcn;\n\tunsigned long flags;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\trunlist_element *rl;\n\tstruct page *put_this_page = NULL;\n\tint err = 0;\n\tbool ctx_is_temporary, ctx_needs_reset;\n\tntfs_attr_search_ctx old_ctx = { NULL, };\n\n\tntfs_debug(\"Mapping runlist part containing vcn 0x%llx.\",\n\t\t\t(unsigned long long)vcn);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tif (!ctx) {\n\t\tctx_is_temporary = ctx_needs_reset = true;\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m))\n\t\t\treturn PTR_ERR(m);\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tVCN allocated_size_vcn;\n\n\t\tBUG_ON(IS_ERR(ctx->mrec));\n\t\ta = ctx->attr;\n\t\tBUG_ON(!a->non_resident);\n\t\tctx_is_temporary = false;\n\t\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size_vcn = ni->allocated_size >>\n\t\t\t\tni->vol->cluster_size_bits;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (!a->data.non_resident.lowest_vcn && end_vcn <= 0)\n\t\t\tend_vcn = allocated_size_vcn - 1;\n\t\t/*\n\t\t * If we already have the attribute extent containing @vcn in\n\t\t * @ctx, no need to look it up again.  We slightly cheat in\n\t\t * that if vcn exceeds the allocated size, we will refuse to\n\t\t * map the runlist below, so there is definitely no need to get\n\t\t * the right attribute extent.\n\t\t */\n\t\tif (vcn >= allocated_size_vcn || (a->type == ni->type &&\n\t\t\t\ta->name_length == ni->name_len &&\n\t\t\t\t!memcmp((u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\tni->name, ni->name_len) &&\n\t\t\t\tsle64_to_cpu(a->data.non_resident.lowest_vcn)\n\t\t\t\t<= vcn && end_vcn >= vcn))\n\t\t\tctx_needs_reset = false;\n\t\telse {\n\t\t\t/* Save the old search context. */\n\t\t\told_ctx = *ctx;\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * base inode we will unmap it when we reinitialize the\n\t\t\t * search context which means we need to get a\n\t\t\t * reference to the page containing the mapped mft\n\t\t\t * record so we do not accidentally drop changes to the\n\t\t\t * mft record when it has not been marked dirty yet.\n\t\t\t */\n\t\t\tif (old_ctx.base_ntfs_ino && old_ctx.ntfs_ino !=\n\t\t\t\t\told_ctx.base_ntfs_ino) {\n\t\t\t\tput_this_page = old_ctx.ntfs_ino->page;\n\t\t\t\tpage_cache_get(put_this_page);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reinitialize the search context so we can lookup the\n\t\t\t * needed attribute extent.\n\t\t\t */\n\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t\tctx_needs_reset = true;\n\t\t}\n\t}\n\tif (ctx_needs_reset) {\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tBUG_ON(!ctx->attr->non_resident);\n\t}\n\ta = ctx->attr;\n\t/*\n\t * Only decompress the mapping pairs if @vcn is inside it.  Otherwise\n\t * we get into problems when we try to map an out of bounds vcn because\n\t * we then try to map the already mapped runlist fragment and\n\t * ntfs_mapping_pairs_decompress() fails.\n\t */\n\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn) + 1;\n\tif (unlikely(vcn && vcn >= end_vcn)) {\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_mapping_pairs_decompress(ni->vol, a, ni->runlist.rl);\n\tif (IS_ERR(rl))\n\t\terr = PTR_ERR(rl);\n\telse\n\t\tni->runlist.rl = rl;\nerr_out:\n\tif (ctx_is_temporary) {\n\t\tif (likely(ctx))\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t} else if (ctx_needs_reset) {\n\t\t/*\n\t\t * If there is no attribute list, restoring the search context\n\t\t * is accomplished simply by copying the saved context back over\n\t\t * the caller supplied context.  If there is an attribute list,\n\t\t * things are more complicated as we need to deal with mapping\n\t\t * of mft records and resulting potential changes in pointers.\n\t\t */\n\t\tif (NInoAttrList(base_ni)) {\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * one we had before, we need to unmap it and map the\n\t\t\t * old one.\n\t\t\t */\n\t\t\tif (ctx->ntfs_ino != old_ctx.ntfs_ino) {\n\t\t\t\t/*\n\t\t\t\t * If the currently mapped inode is not the\n\t\t\t\t * base inode, unmap it.\n\t\t\t\t */\n\t\t\t\tif (ctx->base_ntfs_ino && ctx->ntfs_ino !=\n\t\t\t\t\t\tctx->base_ntfs_ino) {\n\t\t\t\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\t\t\t\t\tctx->mrec = ctx->base_mrec;\n\t\t\t\t\tBUG_ON(!ctx->mrec);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If the old mapped inode is not the base\n\t\t\t\t * inode, map it.\n\t\t\t\t */\n\t\t\t\tif (old_ctx.base_ntfs_ino &&\n\t\t\t\t\t\told_ctx.ntfs_ino !=\n\t\t\t\t\t\told_ctx.base_ntfs_ino) {\nretry_map:\n\t\t\t\t\tctx->mrec = map_mft_record(\n\t\t\t\t\t\t\told_ctx.ntfs_ino);\n\t\t\t\t\t/*\n\t\t\t\t\t * Something bad has happened.  If out\n\t\t\t\t\t * of memory retry till it succeeds.\n\t\t\t\t\t * Any other errors are fatal and we\n\t\t\t\t\t * return the error code in ctx->mrec.\n\t\t\t\t\t * Let the caller deal with it...  We\n\t\t\t\t\t * just need to fudge things so the\n\t\t\t\t\t * caller can reinit and/or put the\n\t\t\t\t\t * search context safely.\n\t\t\t\t\t */\n\t\t\t\t\tif (IS_ERR(ctx->mrec)) {\n\t\t\t\t\t\tif (PTR_ERR(ctx->mrec) ==\n\t\t\t\t\t\t\t\t-ENOMEM) {\n\t\t\t\t\t\t\tschedule();\n\t\t\t\t\t\t\tgoto retry_map;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\told_ctx.ntfs_ino =\n\t\t\t\t\t\t\t\told_ctx.\n\t\t\t\t\t\t\t\tbase_ntfs_ino;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Update the changed pointers in the saved context. */\n\t\t\tif (ctx->mrec != old_ctx.mrec) {\n\t\t\t\tif (!IS_ERR(ctx->mrec))\n\t\t\t\t\told_ctx.attr = (ATTR_RECORD*)(\n\t\t\t\t\t\t\t(u8*)ctx->mrec +\n\t\t\t\t\t\t\t((u8*)old_ctx.attr -\n\t\t\t\t\t\t\t(u8*)old_ctx.mrec));\n\t\t\t\told_ctx.mrec = ctx->mrec;\n\t\t\t}\n\t\t}\n\t\t/* Restore the search context to the saved one. */\n\t\t*ctx = old_ctx;\n\t\t/*\n\t\t * We drop the reference on the page we took earlier.  In the\n\t\t * case that IS_ERR(ctx->mrec) is true this means we might lose\n\t\t * some changes to the mft record that had been made between\n\t\t * the last time it was marked dirty/written out and now.  This\n\t\t * at this stage is not a problem as the mapping error is fatal\n\t\t * enough that the mft record cannot be written out anyway and\n\t\t * the caller is very likely to shutdown the whole inode\n\t\t * immediately and mark the volume dirty for chkdsk to pick up\n\t\t * the pieces anyway.\n\t\t */\n\t\tif (put_this_page)\n\t\t\tpage_cache_release(put_this_page);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_map_runlist_nolock(ntfs_inode *ni, VCN vcn, ntfs_attr_search_ctx *ctx)\n{\n\tVCN end_vcn;\n\tunsigned long flags;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\trunlist_element *rl;\n\tstruct page *put_this_page = NULL;\n\tint err = 0;\n\tbool ctx_is_temporary, ctx_needs_reset;\n\tntfs_attr_search_ctx old_ctx = { NULL, };\n\n\tntfs_debug(\"Mapping runlist part containing vcn 0x%llx.\",\n\t\t\t(unsigned long long)vcn);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tif (!ctx) {\n\t\tctx_is_temporary = ctx_needs_reset = true;\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m))\n\t\t\treturn PTR_ERR(m);\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tVCN allocated_size_vcn;\n\n\t\tBUG_ON(IS_ERR(ctx->mrec));\n\t\ta = ctx->attr;\n\t\tBUG_ON(!a->non_resident);\n\t\tctx_is_temporary = false;\n\t\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size_vcn = ni->allocated_size >>\n\t\t\t\tni->vol->cluster_size_bits;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (!a->data.non_resident.lowest_vcn && end_vcn <= 0)\n\t\t\tend_vcn = allocated_size_vcn - 1;\n\t\t/*\n\t\t * If we already have the attribute extent containing @vcn in\n\t\t * @ctx, no need to look it up again.  We slightly cheat in\n\t\t * that if vcn exceeds the allocated size, we will refuse to\n\t\t * map the runlist below, so there is definitely no need to get\n\t\t * the right attribute extent.\n\t\t */\n\t\tif (vcn >= allocated_size_vcn || (a->type == ni->type &&\n\t\t\t\ta->name_length == ni->name_len &&\n\t\t\t\t!memcmp((u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\tni->name, ni->name_len) &&\n\t\t\t\tsle64_to_cpu(a->data.non_resident.lowest_vcn)\n\t\t\t\t<= vcn && end_vcn >= vcn))\n\t\t\tctx_needs_reset = false;\n\t\telse {\n\t\t\t/* Save the old search context. */\n\t\t\told_ctx = *ctx;\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * base inode we will unmap it when we reinitialize the\n\t\t\t * search context which means we need to get a\n\t\t\t * reference to the page containing the mapped mft\n\t\t\t * record so we do not accidentally drop changes to the\n\t\t\t * mft record when it has not been marked dirty yet.\n\t\t\t */\n\t\t\tif (old_ctx.base_ntfs_ino && old_ctx.ntfs_ino !=\n\t\t\t\t\told_ctx.base_ntfs_ino) {\n\t\t\t\tput_this_page = old_ctx.ntfs_ino->page;\n\t\t\t\tpage_cache_get(put_this_page);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reinitialize the search context so we can lookup the\n\t\t\t * needed attribute extent.\n\t\t\t */\n\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t\tctx_needs_reset = true;\n\t\t}\n\t}\n\tif (ctx_needs_reset) {\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tBUG_ON(!ctx->attr->non_resident);\n\t}\n\ta = ctx->attr;\n\t/*\n\t * Only decompress the mapping pairs if @vcn is inside it.  Otherwise\n\t * we get into problems when we try to map an out of bounds vcn because\n\t * we then try to map the already mapped runlist fragment and\n\t * ntfs_mapping_pairs_decompress() fails.\n\t */\n\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn) + 1;\n\tif (unlikely(vcn && vcn >= end_vcn)) {\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_mapping_pairs_decompress(ni->vol, a, ni->runlist.rl);\n\tif (IS_ERR(rl))\n\t\terr = PTR_ERR(rl);\n\telse\n\t\tni->runlist.rl = rl;\nerr_out:\n\tif (ctx_is_temporary) {\n\t\tif (likely(ctx))\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t} else if (ctx_needs_reset) {\n\t\t/*\n\t\t * If there is no attribute list, restoring the search context\n\t\t * is accomplished simply by copying the saved context back over\n\t\t * the caller supplied context.  If there is an attribute list,\n\t\t * things are more complicated as we need to deal with mapping\n\t\t * of mft records and resulting potential changes in pointers.\n\t\t */\n\t\tif (NInoAttrList(base_ni)) {\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * one we had before, we need to unmap it and map the\n\t\t\t * old one.\n\t\t\t */\n\t\t\tif (ctx->ntfs_ino != old_ctx.ntfs_ino) {\n\t\t\t\t/*\n\t\t\t\t * If the currently mapped inode is not the\n\t\t\t\t * base inode, unmap it.\n\t\t\t\t */\n\t\t\t\tif (ctx->base_ntfs_ino && ctx->ntfs_ino !=\n\t\t\t\t\t\tctx->base_ntfs_ino) {\n\t\t\t\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\t\t\t\t\tctx->mrec = ctx->base_mrec;\n\t\t\t\t\tBUG_ON(!ctx->mrec);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If the old mapped inode is not the base\n\t\t\t\t * inode, map it.\n\t\t\t\t */\n\t\t\t\tif (old_ctx.base_ntfs_ino &&\n\t\t\t\t\t\told_ctx.ntfs_ino !=\n\t\t\t\t\t\told_ctx.base_ntfs_ino) {\nretry_map:\n\t\t\t\t\tctx->mrec = map_mft_record(\n\t\t\t\t\t\t\told_ctx.ntfs_ino);\n\t\t\t\t\t/*\n\t\t\t\t\t * Something bad has happened.  If out\n\t\t\t\t\t * of memory retry till it succeeds.\n\t\t\t\t\t * Any other errors are fatal and we\n\t\t\t\t\t * return the error code in ctx->mrec.\n\t\t\t\t\t * Let the caller deal with it...  We\n\t\t\t\t\t * just need to fudge things so the\n\t\t\t\t\t * caller can reinit and/or put the\n\t\t\t\t\t * search context safely.\n\t\t\t\t\t */\n\t\t\t\t\tif (IS_ERR(ctx->mrec)) {\n\t\t\t\t\t\tif (PTR_ERR(ctx->mrec) ==\n\t\t\t\t\t\t\t\t-ENOMEM) {\n\t\t\t\t\t\t\tschedule();\n\t\t\t\t\t\t\tgoto retry_map;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\told_ctx.ntfs_ino =\n\t\t\t\t\t\t\t\told_ctx.\n\t\t\t\t\t\t\t\tbase_ntfs_ino;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Update the changed pointers in the saved context. */\n\t\t\tif (ctx->mrec != old_ctx.mrec) {\n\t\t\t\tif (!IS_ERR(ctx->mrec))\n\t\t\t\t\told_ctx.attr = (ATTR_RECORD*)(\n\t\t\t\t\t\t\t(u8*)ctx->mrec +\n\t\t\t\t\t\t\t((u8*)old_ctx.attr -\n\t\t\t\t\t\t\t(u8*)old_ctx.mrec));\n\t\t\t\told_ctx.mrec = ctx->mrec;\n\t\t\t}\n\t\t}\n\t\t/* Restore the search context to the saved one. */\n\t\t*ctx = old_ctx;\n\t\t/*\n\t\t * We drop the reference on the page we took earlier.  In the\n\t\t * case that IS_ERR(ctx->mrec) is true this means we might lose\n\t\t * some changes to the mft record that had been made between\n\t\t * the last time it was marked dirty/written out and now.  This\n\t\t * at this stage is not a problem as the mapping error is fatal\n\t\t * enough that the mft record cannot be written out anyway and\n\t\t * the caller is very likely to shutdown the whole inode\n\t\t * immediately and mark the volume dirty for chkdsk to pick up\n\t\t * the pieces anyway.\n\t\t */\n\t\tif (put_this_page)\n\t\t\tpage_cache_release(put_this_page);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) <=\n\t\t\tLCN_RL_NOT_MAPPED"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_vcn_to_lcn",
          "args": [
            "ni->runlist.rl",
            "vcn"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_vcn_to_lcn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1004-1036",
          "snippet": "LCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nLCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_map_runlist(ntfs_inode *ni, VCN vcn)\n{\n\tint err = 0;\n\n\tdown_write(&ni->runlist.lock);\n\t/* Make sure someone else didn't do the work while we were sleeping. */\n\tif (likely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) <=\n\t\t\tLCN_RL_NOT_MAPPED))\n\t\terr = ntfs_map_runlist_nolock(ni, vcn, NULL);\n\tup_write(&ni->runlist.lock);\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_map_runlist_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
    "lines": "84-281",
    "snippet": "int ntfs_map_runlist_nolock(ntfs_inode *ni, VCN vcn, ntfs_attr_search_ctx *ctx)\n{\n\tVCN end_vcn;\n\tunsigned long flags;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\trunlist_element *rl;\n\tstruct page *put_this_page = NULL;\n\tint err = 0;\n\tbool ctx_is_temporary, ctx_needs_reset;\n\tntfs_attr_search_ctx old_ctx = { NULL, };\n\n\tntfs_debug(\"Mapping runlist part containing vcn 0x%llx.\",\n\t\t\t(unsigned long long)vcn);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tif (!ctx) {\n\t\tctx_is_temporary = ctx_needs_reset = true;\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m))\n\t\t\treturn PTR_ERR(m);\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tVCN allocated_size_vcn;\n\n\t\tBUG_ON(IS_ERR(ctx->mrec));\n\t\ta = ctx->attr;\n\t\tBUG_ON(!a->non_resident);\n\t\tctx_is_temporary = false;\n\t\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size_vcn = ni->allocated_size >>\n\t\t\t\tni->vol->cluster_size_bits;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (!a->data.non_resident.lowest_vcn && end_vcn <= 0)\n\t\t\tend_vcn = allocated_size_vcn - 1;\n\t\t/*\n\t\t * If we already have the attribute extent containing @vcn in\n\t\t * @ctx, no need to look it up again.  We slightly cheat in\n\t\t * that if vcn exceeds the allocated size, we will refuse to\n\t\t * map the runlist below, so there is definitely no need to get\n\t\t * the right attribute extent.\n\t\t */\n\t\tif (vcn >= allocated_size_vcn || (a->type == ni->type &&\n\t\t\t\ta->name_length == ni->name_len &&\n\t\t\t\t!memcmp((u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\tni->name, ni->name_len) &&\n\t\t\t\tsle64_to_cpu(a->data.non_resident.lowest_vcn)\n\t\t\t\t<= vcn && end_vcn >= vcn))\n\t\t\tctx_needs_reset = false;\n\t\telse {\n\t\t\t/* Save the old search context. */\n\t\t\told_ctx = *ctx;\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * base inode we will unmap it when we reinitialize the\n\t\t\t * search context which means we need to get a\n\t\t\t * reference to the page containing the mapped mft\n\t\t\t * record so we do not accidentally drop changes to the\n\t\t\t * mft record when it has not been marked dirty yet.\n\t\t\t */\n\t\t\tif (old_ctx.base_ntfs_ino && old_ctx.ntfs_ino !=\n\t\t\t\t\told_ctx.base_ntfs_ino) {\n\t\t\t\tput_this_page = old_ctx.ntfs_ino->page;\n\t\t\t\tpage_cache_get(put_this_page);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reinitialize the search context so we can lookup the\n\t\t\t * needed attribute extent.\n\t\t\t */\n\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t\tctx_needs_reset = true;\n\t\t}\n\t}\n\tif (ctx_needs_reset) {\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tBUG_ON(!ctx->attr->non_resident);\n\t}\n\ta = ctx->attr;\n\t/*\n\t * Only decompress the mapping pairs if @vcn is inside it.  Otherwise\n\t * we get into problems when we try to map an out of bounds vcn because\n\t * we then try to map the already mapped runlist fragment and\n\t * ntfs_mapping_pairs_decompress() fails.\n\t */\n\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn) + 1;\n\tif (unlikely(vcn && vcn >= end_vcn)) {\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_mapping_pairs_decompress(ni->vol, a, ni->runlist.rl);\n\tif (IS_ERR(rl))\n\t\terr = PTR_ERR(rl);\n\telse\n\t\tni->runlist.rl = rl;\nerr_out:\n\tif (ctx_is_temporary) {\n\t\tif (likely(ctx))\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t} else if (ctx_needs_reset) {\n\t\t/*\n\t\t * If there is no attribute list, restoring the search context\n\t\t * is accomplished simply by copying the saved context back over\n\t\t * the caller supplied context.  If there is an attribute list,\n\t\t * things are more complicated as we need to deal with mapping\n\t\t * of mft records and resulting potential changes in pointers.\n\t\t */\n\t\tif (NInoAttrList(base_ni)) {\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * one we had before, we need to unmap it and map the\n\t\t\t * old one.\n\t\t\t */\n\t\t\tif (ctx->ntfs_ino != old_ctx.ntfs_ino) {\n\t\t\t\t/*\n\t\t\t\t * If the currently mapped inode is not the\n\t\t\t\t * base inode, unmap it.\n\t\t\t\t */\n\t\t\t\tif (ctx->base_ntfs_ino && ctx->ntfs_ino !=\n\t\t\t\t\t\tctx->base_ntfs_ino) {\n\t\t\t\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\t\t\t\t\tctx->mrec = ctx->base_mrec;\n\t\t\t\t\tBUG_ON(!ctx->mrec);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If the old mapped inode is not the base\n\t\t\t\t * inode, map it.\n\t\t\t\t */\n\t\t\t\tif (old_ctx.base_ntfs_ino &&\n\t\t\t\t\t\told_ctx.ntfs_ino !=\n\t\t\t\t\t\told_ctx.base_ntfs_ino) {\nretry_map:\n\t\t\t\t\tctx->mrec = map_mft_record(\n\t\t\t\t\t\t\told_ctx.ntfs_ino);\n\t\t\t\t\t/*\n\t\t\t\t\t * Something bad has happened.  If out\n\t\t\t\t\t * of memory retry till it succeeds.\n\t\t\t\t\t * Any other errors are fatal and we\n\t\t\t\t\t * return the error code in ctx->mrec.\n\t\t\t\t\t * Let the caller deal with it...  We\n\t\t\t\t\t * just need to fudge things so the\n\t\t\t\t\t * caller can reinit and/or put the\n\t\t\t\t\t * search context safely.\n\t\t\t\t\t */\n\t\t\t\t\tif (IS_ERR(ctx->mrec)) {\n\t\t\t\t\t\tif (PTR_ERR(ctx->mrec) ==\n\t\t\t\t\t\t\t\t-ENOMEM) {\n\t\t\t\t\t\t\tschedule();\n\t\t\t\t\t\t\tgoto retry_map;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\told_ctx.ntfs_ino =\n\t\t\t\t\t\t\t\told_ctx.\n\t\t\t\t\t\t\t\tbase_ntfs_ino;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Update the changed pointers in the saved context. */\n\t\t\tif (ctx->mrec != old_ctx.mrec) {\n\t\t\t\tif (!IS_ERR(ctx->mrec))\n\t\t\t\t\told_ctx.attr = (ATTR_RECORD*)(\n\t\t\t\t\t\t\t(u8*)ctx->mrec +\n\t\t\t\t\t\t\t((u8*)old_ctx.attr -\n\t\t\t\t\t\t\t(u8*)old_ctx.mrec));\n\t\t\t\told_ctx.mrec = ctx->mrec;\n\t\t\t}\n\t\t}\n\t\t/* Restore the search context to the saved one. */\n\t\t*ctx = old_ctx;\n\t\t/*\n\t\t * We drop the reference on the page we took earlier.  In the\n\t\t * case that IS_ERR(ctx->mrec) is true this means we might lose\n\t\t * some changes to the mft record that had been made between\n\t\t * the last time it was marked dirty/written out and now.  This\n\t\t * at this stage is not a problem as the mapping error is fatal\n\t\t * enough that the mft record cannot be written out anyway and\n\t\t * the caller is very likely to shutdown the whole inode\n\t\t * immediately and mark the volume dirty for chkdsk to pick up\n\t\t * the pieces anyway.\n\t\t */\n\t\tif (put_this_page)\n\t\t\tpage_cache_release(put_this_page);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"types.h\"",
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"layout.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "put_this_page"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ctx->mrec"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ctx->mrec"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ctx->mrec"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_mft_record",
          "args": [
            "old_ctx.ntfs_ino"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ctx->mrec"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_extent_mft_record",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_extent_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "38-42",
          "snippet": "static inline void unmap_extent_mft_record(ntfs_inode *ni)\n{\n\tunmap_mft_record(ni);\n\treturn;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void unmap_extent_mft_record(ntfs_inode *ni)\n{\n\tunmap_mft_record(ni);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoAttrList",
          "args": [
            "base_ni"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ctx"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rl"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_mapping_pairs_decompress",
          "args": [
            "ni->vol",
            "a",
            "ni->runlist.rl"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_mapping_pairs_decompress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "749-978",
          "snippet": "runlist_element *ntfs_mapping_pairs_decompress(const ntfs_volume *vol,\n\t\tconst ATTR_RECORD *attr, runlist_element *old_rl)\n{\n\tVCN vcn;\t\t/* Current vcn. */\n\tLCN lcn;\t\t/* Current lcn. */\n\ts64 deltaxcn;\t\t/* Change in [vl]cn. */\n\trunlist_element *rl;\t/* The output runlist. */\n\tu8 *buf;\t\t/* Current position in mapping pairs array. */\n\tu8 *attr_end;\t\t/* End of attribute. */\n\tint rlsize;\t\t/* Size of runlist buffer. */\n\tu16 rlpos;\t\t/* Current runlist position in units of\n\t\t\t\t   runlist_elements. */\n\tu8 b;\t\t\t/* Current byte offset in buf. */\n\n#ifdef DEBUG\n\t/* Make sure attr exists and is non-resident. */\n\tif (!attr || !attr->non_resident || sle64_to_cpu(\n\t\t\tattr->data.non_resident.lowest_vcn) < (VCN)0) {\n\t\tntfs_error(vol->sb, \"Invalid arguments.\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\t/* Start at vcn = lowest_vcn and lcn 0. */\n\tvcn = sle64_to_cpu(attr->data.non_resident.lowest_vcn);\n\tlcn = 0;\n\t/* Get start of the mapping pairs array. */\n\tbuf = (u8*)attr + le16_to_cpu(\n\t\t\tattr->data.non_resident.mapping_pairs_offset);\n\tattr_end = (u8*)attr + le32_to_cpu(attr->length);\n\tif (unlikely(buf < (u8*)attr || buf > attr_end)) {\n\t\tntfs_error(vol->sb, \"Corrupt attribute.\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\t/* If the mapping pairs array is valid but empty, nothing to do. */\n\tif (!vcn && !*buf)\n\t\treturn old_rl;\n\t/* Current position in runlist array. */\n\trlpos = 0;\n\t/* Allocate first page and set current runlist size to one page. */\n\trl = ntfs_malloc_nofs(rlsize = PAGE_SIZE);\n\tif (unlikely(!rl))\n\t\treturn ERR_PTR(-ENOMEM);\n\t/* Insert unmapped starting element if necessary. */\n\tif (vcn) {\n\t\trl->vcn = 0;\n\t\trl->lcn = LCN_RL_NOT_MAPPED;\n\t\trl->length = vcn;\n\t\trlpos++;\n\t}\n\twhile (buf < attr_end && *buf) {\n\t\t/*\n\t\t * Allocate more memory if needed, including space for the\n\t\t * not-mapped and terminator elements. ntfs_malloc_nofs()\n\t\t * operates on whole pages only.\n\t\t */\n\t\tif (((rlpos + 3) * sizeof(*old_rl)) > rlsize) {\n\t\t\trunlist_element *rl2;\n\n\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\tif (unlikely(!rl2)) {\n\t\t\t\tntfs_free(rl);\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t}\n\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\tntfs_free(rl);\n\t\t\trl = rl2;\n\t\t\trlsize += PAGE_SIZE;\n\t\t}\n\t\t/* Enter the current vcn into the current runlist element. */\n\t\trl[rlpos].vcn = vcn;\n\t\t/*\n\t\t * Get the change in vcn, i.e. the run length in clusters.\n\t\t * Doing it this way ensures that we signextend negative values.\n\t\t * A negative run length doesn't make any sense, but hey, I\n\t\t * didn't make up the NTFS specs and Windows NT4 treats the run\n\t\t * length as a signed value so that's how it is...\n\t\t */\n\t\tb = *buf & 0xf;\n\t\tif (b) {\n\t\t\tif (unlikely(buf + b > attr_end))\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t} else { /* The length entry is compulsory. */\n\t\t\tntfs_error(vol->sb, \"Missing length entry in mapping \"\n\t\t\t\t\t\"pairs array.\");\n\t\t\tdeltaxcn = (s64)-1;\n\t\t}\n\t\t/*\n\t\t * Assume a negative length to indicate data corruption and\n\t\t * hence clean-up and return NULL.\n\t\t */\n\t\tif (unlikely(deltaxcn < 0)) {\n\t\t\tntfs_error(vol->sb, \"Invalid length in mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\t/*\n\t\t * Enter the current run length into the current runlist\n\t\t * element.\n\t\t */\n\t\trl[rlpos].length = deltaxcn;\n\t\t/* Increment the current vcn by the current run length. */\n\t\tvcn += deltaxcn;\n\t\t/*\n\t\t * There might be no lcn change at all, as is the case for\n\t\t * sparse clusters on NTFS 3.0+, in which case we set the lcn\n\t\t * to LCN_HOLE.\n\t\t */\n\t\tif (!(*buf & 0xf0))\n\t\t\trl[rlpos].lcn = LCN_HOLE;\n\t\telse {\n\t\t\t/* Get the lcn change which really can be negative. */\n\t\t\tu8 b2 = *buf & 0xf;\n\t\t\tb = b2 + ((*buf >> 4) & 0xf);\n\t\t\tif (buf + b > attr_end)\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b > b2; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t\t/* Change the current lcn to its new value. */\n\t\t\tlcn += deltaxcn;\n#ifdef DEBUG\n\t\t\t/*\n\t\t\t * On NTFS 1.2-, apparently can have lcn == -1 to\n\t\t\t * indicate a hole. But we haven't verified ourselves\n\t\t\t * whether it is really the lcn or the deltaxcn that is\n\t\t\t * -1. So if either is found give us a message so we\n\t\t\t * can investigate it further!\n\t\t\t */\n\t\t\tif (vol->major_ver < 3) {\n\t\t\t\tif (unlikely(deltaxcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn delta == -1\");\n\t\t\t\tif (unlikely(lcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn == -1\");\n\t\t\t}\n#endif\n\t\t\t/* Check lcn is not below -1. */\n\t\t\tif (unlikely(lcn < (LCN)-1)) {\n\t\t\t\tntfs_error(vol->sb, \"Invalid LCN < -1 in \"\n\t\t\t\t\t\t\"mapping pairs array.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t/* Enter the current lcn into the runlist element. */\n\t\t\trl[rlpos].lcn = lcn;\n\t\t}\n\t\t/* Get to the next runlist element. */\n\t\trlpos++;\n\t\t/* Increment the buffer position to the next mapping pair. */\n\t\tbuf += (*buf & 0xf) + ((*buf >> 4) & 0xf) + 1;\n\t}\n\tif (unlikely(buf >= attr_end))\n\t\tgoto io_error;\n\t/*\n\t * If there is a highest_vcn specified, it must be equal to the final\n\t * vcn in the runlist - 1, or something has gone badly wrong.\n\t */\n\tdeltaxcn = sle64_to_cpu(attr->data.non_resident.highest_vcn);\n\tif (unlikely(deltaxcn && vcn - 1 != deltaxcn)) {\nmpa_err:\n\t\tntfs_error(vol->sb, \"Corrupt mapping pairs array in \"\n\t\t\t\t\"non-resident attribute.\");\n\t\tgoto err_out;\n\t}\n\t/* Setup not mapped runlist element if this is the base extent. */\n\tif (!attr->data.non_resident.lowest_vcn) {\n\t\tVCN max_cluster;\n\n\t\tmax_cluster = ((sle64_to_cpu(\n\t\t\t\tattr->data.non_resident.allocated_size) +\n\t\t\t\tvol->cluster_size - 1) >>\n\t\t\t\tvol->cluster_size_bits) - 1;\n\t\t/*\n\t\t * A highest_vcn of zero means this is a single extent\n\t\t * attribute so simply terminate the runlist with LCN_ENOENT).\n\t\t */\n\t\tif (deltaxcn) {\n\t\t\t/*\n\t\t\t * If there is a difference between the highest_vcn and\n\t\t\t * the highest cluster, the runlist is either corrupt\n\t\t\t * or, more likely, there are more extents following\n\t\t\t * this one.\n\t\t\t */\n\t\t\tif (deltaxcn < max_cluster) {\n\t\t\t\tntfs_debug(\"More extents to follow; deltaxcn \"\n\t\t\t\t\t\t\"= 0x%llx, max_cluster = \"\n\t\t\t\t\t\t\"0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\trl[rlpos].vcn = vcn;\n\t\t\t\tvcn += rl[rlpos].length = max_cluster -\n\t\t\t\t\t\tdeltaxcn;\n\t\t\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\trlpos++;\n\t\t\t} else if (unlikely(deltaxcn > max_cluster)) {\n\t\t\t\tntfs_error(vol->sb, \"Corrupt attribute.  \"\n\t\t\t\t\t\t\"deltaxcn = 0x%llx, \"\n\t\t\t\t\t\t\"max_cluster = 0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\tgoto mpa_err;\n\t\t\t}\n\t\t}\n\t\trl[rlpos].lcn = LCN_ENOENT;\n\t} else /* Not the base extent. There may be more extents to follow. */\n\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\n\t/* Setup terminating runlist element. */\n\trl[rlpos].vcn = vcn;\n\trl[rlpos].length = (s64)0;\n\t/* If no existing runlist was specified, we are done. */\n\tif (!old_rl) {\n\t\tntfs_debug(\"Mapping pairs array successfully decompressed:\");\n\t\tntfs_debug_dump_runlist(rl);\n\t\treturn rl;\n\t}\n\t/* Now combine the new and old runlists checking for overlaps. */\n\told_rl = ntfs_runlists_merge(old_rl, rl);\n\tif (likely(!IS_ERR(old_rl)))\n\t\treturn old_rl;\n\tntfs_free(rl);\n\tntfs_error(vol->sb, \"Failed to merge runlists.\");\n\treturn old_rl;\nio_error:\n\tntfs_error(vol->sb, \"Corrupt attribute.\");\nerr_out:\n\tntfs_free(rl);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nrunlist_element *ntfs_mapping_pairs_decompress(const ntfs_volume *vol,\n\t\tconst ATTR_RECORD *attr, runlist_element *old_rl)\n{\n\tVCN vcn;\t\t/* Current vcn. */\n\tLCN lcn;\t\t/* Current lcn. */\n\ts64 deltaxcn;\t\t/* Change in [vl]cn. */\n\trunlist_element *rl;\t/* The output runlist. */\n\tu8 *buf;\t\t/* Current position in mapping pairs array. */\n\tu8 *attr_end;\t\t/* End of attribute. */\n\tint rlsize;\t\t/* Size of runlist buffer. */\n\tu16 rlpos;\t\t/* Current runlist position in units of\n\t\t\t\t   runlist_elements. */\n\tu8 b;\t\t\t/* Current byte offset in buf. */\n\n#ifdef DEBUG\n\t/* Make sure attr exists and is non-resident. */\n\tif (!attr || !attr->non_resident || sle64_to_cpu(\n\t\t\tattr->data.non_resident.lowest_vcn) < (VCN)0) {\n\t\tntfs_error(vol->sb, \"Invalid arguments.\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\t/* Start at vcn = lowest_vcn and lcn 0. */\n\tvcn = sle64_to_cpu(attr->data.non_resident.lowest_vcn);\n\tlcn = 0;\n\t/* Get start of the mapping pairs array. */\n\tbuf = (u8*)attr + le16_to_cpu(\n\t\t\tattr->data.non_resident.mapping_pairs_offset);\n\tattr_end = (u8*)attr + le32_to_cpu(attr->length);\n\tif (unlikely(buf < (u8*)attr || buf > attr_end)) {\n\t\tntfs_error(vol->sb, \"Corrupt attribute.\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\t/* If the mapping pairs array is valid but empty, nothing to do. */\n\tif (!vcn && !*buf)\n\t\treturn old_rl;\n\t/* Current position in runlist array. */\n\trlpos = 0;\n\t/* Allocate first page and set current runlist size to one page. */\n\trl = ntfs_malloc_nofs(rlsize = PAGE_SIZE);\n\tif (unlikely(!rl))\n\t\treturn ERR_PTR(-ENOMEM);\n\t/* Insert unmapped starting element if necessary. */\n\tif (vcn) {\n\t\trl->vcn = 0;\n\t\trl->lcn = LCN_RL_NOT_MAPPED;\n\t\trl->length = vcn;\n\t\trlpos++;\n\t}\n\twhile (buf < attr_end && *buf) {\n\t\t/*\n\t\t * Allocate more memory if needed, including space for the\n\t\t * not-mapped and terminator elements. ntfs_malloc_nofs()\n\t\t * operates on whole pages only.\n\t\t */\n\t\tif (((rlpos + 3) * sizeof(*old_rl)) > rlsize) {\n\t\t\trunlist_element *rl2;\n\n\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\tif (unlikely(!rl2)) {\n\t\t\t\tntfs_free(rl);\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t}\n\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\tntfs_free(rl);\n\t\t\trl = rl2;\n\t\t\trlsize += PAGE_SIZE;\n\t\t}\n\t\t/* Enter the current vcn into the current runlist element. */\n\t\trl[rlpos].vcn = vcn;\n\t\t/*\n\t\t * Get the change in vcn, i.e. the run length in clusters.\n\t\t * Doing it this way ensures that we signextend negative values.\n\t\t * A negative run length doesn't make any sense, but hey, I\n\t\t * didn't make up the NTFS specs and Windows NT4 treats the run\n\t\t * length as a signed value so that's how it is...\n\t\t */\n\t\tb = *buf & 0xf;\n\t\tif (b) {\n\t\t\tif (unlikely(buf + b > attr_end))\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t} else { /* The length entry is compulsory. */\n\t\t\tntfs_error(vol->sb, \"Missing length entry in mapping \"\n\t\t\t\t\t\"pairs array.\");\n\t\t\tdeltaxcn = (s64)-1;\n\t\t}\n\t\t/*\n\t\t * Assume a negative length to indicate data corruption and\n\t\t * hence clean-up and return NULL.\n\t\t */\n\t\tif (unlikely(deltaxcn < 0)) {\n\t\t\tntfs_error(vol->sb, \"Invalid length in mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\t/*\n\t\t * Enter the current run length into the current runlist\n\t\t * element.\n\t\t */\n\t\trl[rlpos].length = deltaxcn;\n\t\t/* Increment the current vcn by the current run length. */\n\t\tvcn += deltaxcn;\n\t\t/*\n\t\t * There might be no lcn change at all, as is the case for\n\t\t * sparse clusters on NTFS 3.0+, in which case we set the lcn\n\t\t * to LCN_HOLE.\n\t\t */\n\t\tif (!(*buf & 0xf0))\n\t\t\trl[rlpos].lcn = LCN_HOLE;\n\t\telse {\n\t\t\t/* Get the lcn change which really can be negative. */\n\t\t\tu8 b2 = *buf & 0xf;\n\t\t\tb = b2 + ((*buf >> 4) & 0xf);\n\t\t\tif (buf + b > attr_end)\n\t\t\t\tgoto io_error;\n\t\t\tfor (deltaxcn = (s8)buf[b--]; b > b2; b--)\n\t\t\t\tdeltaxcn = (deltaxcn << 8) + buf[b];\n\t\t\t/* Change the current lcn to its new value. */\n\t\t\tlcn += deltaxcn;\n#ifdef DEBUG\n\t\t\t/*\n\t\t\t * On NTFS 1.2-, apparently can have lcn == -1 to\n\t\t\t * indicate a hole. But we haven't verified ourselves\n\t\t\t * whether it is really the lcn or the deltaxcn that is\n\t\t\t * -1. So if either is found give us a message so we\n\t\t\t * can investigate it further!\n\t\t\t */\n\t\t\tif (vol->major_ver < 3) {\n\t\t\t\tif (unlikely(deltaxcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn delta == -1\");\n\t\t\t\tif (unlikely(lcn == (LCN)-1))\n\t\t\t\t\tntfs_error(vol->sb, \"lcn == -1\");\n\t\t\t}\n#endif\n\t\t\t/* Check lcn is not below -1. */\n\t\t\tif (unlikely(lcn < (LCN)-1)) {\n\t\t\t\tntfs_error(vol->sb, \"Invalid LCN < -1 in \"\n\t\t\t\t\t\t\"mapping pairs array.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t/* Enter the current lcn into the runlist element. */\n\t\t\trl[rlpos].lcn = lcn;\n\t\t}\n\t\t/* Get to the next runlist element. */\n\t\trlpos++;\n\t\t/* Increment the buffer position to the next mapping pair. */\n\t\tbuf += (*buf & 0xf) + ((*buf >> 4) & 0xf) + 1;\n\t}\n\tif (unlikely(buf >= attr_end))\n\t\tgoto io_error;\n\t/*\n\t * If there is a highest_vcn specified, it must be equal to the final\n\t * vcn in the runlist - 1, or something has gone badly wrong.\n\t */\n\tdeltaxcn = sle64_to_cpu(attr->data.non_resident.highest_vcn);\n\tif (unlikely(deltaxcn && vcn - 1 != deltaxcn)) {\nmpa_err:\n\t\tntfs_error(vol->sb, \"Corrupt mapping pairs array in \"\n\t\t\t\t\"non-resident attribute.\");\n\t\tgoto err_out;\n\t}\n\t/* Setup not mapped runlist element if this is the base extent. */\n\tif (!attr->data.non_resident.lowest_vcn) {\n\t\tVCN max_cluster;\n\n\t\tmax_cluster = ((sle64_to_cpu(\n\t\t\t\tattr->data.non_resident.allocated_size) +\n\t\t\t\tvol->cluster_size - 1) >>\n\t\t\t\tvol->cluster_size_bits) - 1;\n\t\t/*\n\t\t * A highest_vcn of zero means this is a single extent\n\t\t * attribute so simply terminate the runlist with LCN_ENOENT).\n\t\t */\n\t\tif (deltaxcn) {\n\t\t\t/*\n\t\t\t * If there is a difference between the highest_vcn and\n\t\t\t * the highest cluster, the runlist is either corrupt\n\t\t\t * or, more likely, there are more extents following\n\t\t\t * this one.\n\t\t\t */\n\t\t\tif (deltaxcn < max_cluster) {\n\t\t\t\tntfs_debug(\"More extents to follow; deltaxcn \"\n\t\t\t\t\t\t\"= 0x%llx, max_cluster = \"\n\t\t\t\t\t\t\"0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\trl[rlpos].vcn = vcn;\n\t\t\t\tvcn += rl[rlpos].length = max_cluster -\n\t\t\t\t\t\tdeltaxcn;\n\t\t\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\trlpos++;\n\t\t\t} else if (unlikely(deltaxcn > max_cluster)) {\n\t\t\t\tntfs_error(vol->sb, \"Corrupt attribute.  \"\n\t\t\t\t\t\t\"deltaxcn = 0x%llx, \"\n\t\t\t\t\t\t\"max_cluster = 0x%llx\",\n\t\t\t\t\t\t(unsigned long long)deltaxcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tmax_cluster);\n\t\t\t\tgoto mpa_err;\n\t\t\t}\n\t\t}\n\t\trl[rlpos].lcn = LCN_ENOENT;\n\t} else /* Not the base extent. There may be more extents to follow. */\n\t\trl[rlpos].lcn = LCN_RL_NOT_MAPPED;\n\n\t/* Setup terminating runlist element. */\n\trl[rlpos].vcn = vcn;\n\trl[rlpos].length = (s64)0;\n\t/* If no existing runlist was specified, we are done. */\n\tif (!old_rl) {\n\t\tntfs_debug(\"Mapping pairs array successfully decompressed:\");\n\t\tntfs_debug_dump_runlist(rl);\n\t\treturn rl;\n\t}\n\t/* Now combine the new and old runlists checking for overlaps. */\n\told_rl = ntfs_runlists_merge(old_rl, rl);\n\tif (likely(!IS_ERR(old_rl)))\n\t\treturn old_rl;\n\tntfs_free(rl);\n\tntfs_error(vol->sb, \"Failed to merge runlists.\");\n\treturn old_rl;\nio_error:\n\tntfs_error(vol->sb, \"Corrupt attribute.\");\nerr_out:\n\tntfs_free(rl);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcn && vcn >= end_vcn"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "a->data.non_resident.highest_vcn"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ctx->attr->non_resident"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "ni->type",
            "ni->name",
            "ni->name_len",
            "CASE_SENSITIVE",
            "vcn",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_reinit_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_reinit_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1240-1259",
          "snippet": "void ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "put_this_page"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "(u8*)a + le16_to_cpu(a->name_offset)",
            "ni->name",
            "ni->name_len"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "a->name_offset"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!a->non_resident"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "IS_ERR(ctx->mrec)"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ctx->mrec"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "base_ni",
            "m"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Mapping runlist part containing vcn 0x%llx.\"",
            "(unsigned long long)vcn"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_map_runlist_nolock(ntfs_inode *ni, VCN vcn, ntfs_attr_search_ctx *ctx)\n{\n\tVCN end_vcn;\n\tunsigned long flags;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\trunlist_element *rl;\n\tstruct page *put_this_page = NULL;\n\tint err = 0;\n\tbool ctx_is_temporary, ctx_needs_reset;\n\tntfs_attr_search_ctx old_ctx = { NULL, };\n\n\tntfs_debug(\"Mapping runlist part containing vcn 0x%llx.\",\n\t\t\t(unsigned long long)vcn);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tif (!ctx) {\n\t\tctx_is_temporary = ctx_needs_reset = true;\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m))\n\t\t\treturn PTR_ERR(m);\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tVCN allocated_size_vcn;\n\n\t\tBUG_ON(IS_ERR(ctx->mrec));\n\t\ta = ctx->attr;\n\t\tBUG_ON(!a->non_resident);\n\t\tctx_is_temporary = false;\n\t\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size_vcn = ni->allocated_size >>\n\t\t\t\tni->vol->cluster_size_bits;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (!a->data.non_resident.lowest_vcn && end_vcn <= 0)\n\t\t\tend_vcn = allocated_size_vcn - 1;\n\t\t/*\n\t\t * If we already have the attribute extent containing @vcn in\n\t\t * @ctx, no need to look it up again.  We slightly cheat in\n\t\t * that if vcn exceeds the allocated size, we will refuse to\n\t\t * map the runlist below, so there is definitely no need to get\n\t\t * the right attribute extent.\n\t\t */\n\t\tif (vcn >= allocated_size_vcn || (a->type == ni->type &&\n\t\t\t\ta->name_length == ni->name_len &&\n\t\t\t\t!memcmp((u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\tni->name, ni->name_len) &&\n\t\t\t\tsle64_to_cpu(a->data.non_resident.lowest_vcn)\n\t\t\t\t<= vcn && end_vcn >= vcn))\n\t\t\tctx_needs_reset = false;\n\t\telse {\n\t\t\t/* Save the old search context. */\n\t\t\told_ctx = *ctx;\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * base inode we will unmap it when we reinitialize the\n\t\t\t * search context which means we need to get a\n\t\t\t * reference to the page containing the mapped mft\n\t\t\t * record so we do not accidentally drop changes to the\n\t\t\t * mft record when it has not been marked dirty yet.\n\t\t\t */\n\t\t\tif (old_ctx.base_ntfs_ino && old_ctx.ntfs_ino !=\n\t\t\t\t\told_ctx.base_ntfs_ino) {\n\t\t\t\tput_this_page = old_ctx.ntfs_ino->page;\n\t\t\t\tpage_cache_get(put_this_page);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reinitialize the search context so we can lookup the\n\t\t\t * needed attribute extent.\n\t\t\t */\n\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t\tctx_needs_reset = true;\n\t\t}\n\t}\n\tif (ctx_needs_reset) {\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tBUG_ON(!ctx->attr->non_resident);\n\t}\n\ta = ctx->attr;\n\t/*\n\t * Only decompress the mapping pairs if @vcn is inside it.  Otherwise\n\t * we get into problems when we try to map an out of bounds vcn because\n\t * we then try to map the already mapped runlist fragment and\n\t * ntfs_mapping_pairs_decompress() fails.\n\t */\n\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn) + 1;\n\tif (unlikely(vcn && vcn >= end_vcn)) {\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_mapping_pairs_decompress(ni->vol, a, ni->runlist.rl);\n\tif (IS_ERR(rl))\n\t\terr = PTR_ERR(rl);\n\telse\n\t\tni->runlist.rl = rl;\nerr_out:\n\tif (ctx_is_temporary) {\n\t\tif (likely(ctx))\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t} else if (ctx_needs_reset) {\n\t\t/*\n\t\t * If there is no attribute list, restoring the search context\n\t\t * is accomplished simply by copying the saved context back over\n\t\t * the caller supplied context.  If there is an attribute list,\n\t\t * things are more complicated as we need to deal with mapping\n\t\t * of mft records and resulting potential changes in pointers.\n\t\t */\n\t\tif (NInoAttrList(base_ni)) {\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * one we had before, we need to unmap it and map the\n\t\t\t * old one.\n\t\t\t */\n\t\t\tif (ctx->ntfs_ino != old_ctx.ntfs_ino) {\n\t\t\t\t/*\n\t\t\t\t * If the currently mapped inode is not the\n\t\t\t\t * base inode, unmap it.\n\t\t\t\t */\n\t\t\t\tif (ctx->base_ntfs_ino && ctx->ntfs_ino !=\n\t\t\t\t\t\tctx->base_ntfs_ino) {\n\t\t\t\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\t\t\t\t\tctx->mrec = ctx->base_mrec;\n\t\t\t\t\tBUG_ON(!ctx->mrec);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If the old mapped inode is not the base\n\t\t\t\t * inode, map it.\n\t\t\t\t */\n\t\t\t\tif (old_ctx.base_ntfs_ino &&\n\t\t\t\t\t\told_ctx.ntfs_ino !=\n\t\t\t\t\t\told_ctx.base_ntfs_ino) {\nretry_map:\n\t\t\t\t\tctx->mrec = map_mft_record(\n\t\t\t\t\t\t\told_ctx.ntfs_ino);\n\t\t\t\t\t/*\n\t\t\t\t\t * Something bad has happened.  If out\n\t\t\t\t\t * of memory retry till it succeeds.\n\t\t\t\t\t * Any other errors are fatal and we\n\t\t\t\t\t * return the error code in ctx->mrec.\n\t\t\t\t\t * Let the caller deal with it...  We\n\t\t\t\t\t * just need to fudge things so the\n\t\t\t\t\t * caller can reinit and/or put the\n\t\t\t\t\t * search context safely.\n\t\t\t\t\t */\n\t\t\t\t\tif (IS_ERR(ctx->mrec)) {\n\t\t\t\t\t\tif (PTR_ERR(ctx->mrec) ==\n\t\t\t\t\t\t\t\t-ENOMEM) {\n\t\t\t\t\t\t\tschedule();\n\t\t\t\t\t\t\tgoto retry_map;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\told_ctx.ntfs_ino =\n\t\t\t\t\t\t\t\told_ctx.\n\t\t\t\t\t\t\t\tbase_ntfs_ino;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Update the changed pointers in the saved context. */\n\t\t\tif (ctx->mrec != old_ctx.mrec) {\n\t\t\t\tif (!IS_ERR(ctx->mrec))\n\t\t\t\t\told_ctx.attr = (ATTR_RECORD*)(\n\t\t\t\t\t\t\t(u8*)ctx->mrec +\n\t\t\t\t\t\t\t((u8*)old_ctx.attr -\n\t\t\t\t\t\t\t(u8*)old_ctx.mrec));\n\t\t\t\told_ctx.mrec = ctx->mrec;\n\t\t\t}\n\t\t}\n\t\t/* Restore the search context to the saved one. */\n\t\t*ctx = old_ctx;\n\t\t/*\n\t\t * We drop the reference on the page we took earlier.  In the\n\t\t * case that IS_ERR(ctx->mrec) is true this means we might lose\n\t\t * some changes to the mft record that had been made between\n\t\t * the last time it was marked dirty/written out and now.  This\n\t\t * at this stage is not a problem as the mapping error is fatal\n\t\t * enough that the mft record cannot be written out anyway and\n\t\t * the caller is very likely to shutdown the whole inode\n\t\t * immediately and mark the volume dirty for chkdsk to pick up\n\t\t * the pieces anyway.\n\t\t */\n\t\tif (put_this_page)\n\t\t\tpage_cache_release(put_this_page);\n\t}\n\treturn err;\n}"
  }
]