[
  {
    "function_name": "autofs4_wait_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
    "lines": "539-564",
    "snippet": "int autofs4_wait_release(struct autofs_sb_info *sbi, autofs_wqt_t wait_queue_token, int status)\n{\n\tstruct autofs_wait_queue *wq, **wql;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tfor (wql = &sbi->queues; (wq = *wql) != NULL; wql = &wq->next) {\n\t\tif (wq->wait_queue_token == wait_queue_token)\n\t\t\tbreak;\n\t}\n\n\tif (!wq) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t*wql = wq->next;\t/* Unlink from chain */\n\tkfree(wq->name.name);\n\twq->name.name = NULL;\t/* Do not wait on this queue */\n\twq->status = status;\n\twake_up_interruptible(&wq->queue);\n\tif (!--wq->wait_ctr)\n\t\tkfree(wq);\n\tmutex_unlock(&sbi->wq_mutex);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/file.h>",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wq"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&wq->queue"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wq->name.name"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nint autofs4_wait_release(struct autofs_sb_info *sbi, autofs_wqt_t wait_queue_token, int status)\n{\n\tstruct autofs_wait_queue *wq, **wql;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tfor (wql = &sbi->queues; (wq = *wql) != NULL; wql = &wq->next) {\n\t\tif (wq->wait_queue_token == wait_queue_token)\n\t\t\tbreak;\n\t}\n\n\tif (!wq) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t*wql = wq->next;\t/* Unlink from chain */\n\tkfree(wq->name.name);\n\twq->name.name = NULL;\t/* Do not wait on this queue */\n\twq->status = status;\n\twake_up_interruptible(&wq->queue);\n\tif (!--wq->wait_ctr)\n\t\tkfree(wq);\n\tmutex_unlock(&sbi->wq_mutex);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "autofs4_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
    "lines": "343-536",
    "snippet": "int autofs4_wait(struct autofs_sb_info *sbi, struct dentry *dentry,\n\t\tenum autofs_notify notify)\n{\n\tstruct autofs_wait_queue *wq;\n\tstruct qstr qstr;\n\tchar *name;\n\tint status, ret, type;\n\tpid_t pid;\n\tpid_t tgid;\n\n\t/* In catatonic mode, we don't wait for nobody */\n\tif (sbi->catatonic)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Try translating pids to the namespace of the daemon.\n\t *\n\t * Zero means failure: we are in an unrelated pid namespace.\n\t */\n\tpid = task_pid_nr_ns(current, ns_of_pid(sbi->oz_pgrp));\n\ttgid = task_tgid_nr_ns(current, ns_of_pid(sbi->oz_pgrp));\n\tif (pid == 0 || tgid == 0)\n\t\treturn -ENOENT;\n\n\tif (!dentry->d_inode) {\n\t\t/*\n\t\t * A wait for a negative dentry is invalid for certain\n\t\t * cases. A direct or offset mount \"always\" has its mount\n\t\t * point directory created and so the request dentry must\n\t\t * be positive or the map key doesn't exist. The situation\n\t\t * is very similar for indirect mounts except only dentrys\n\t\t * in the root of the autofs file system may be negative.\n\t\t */\n\t\tif (autofs_type_trigger(sbi->type))\n\t\t\treturn -ENOENT;\n\t\telse if (!IS_ROOT(dentry->d_parent))\n\t\t\treturn -ENOENT;\n\t}\n\n\tname = kmalloc(NAME_MAX + 1, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\t/* If this is a direct mount request create a dummy name */\n\tif (IS_ROOT(dentry) && autofs_type_trigger(sbi->type))\n\t\tqstr.len = sprintf(name, \"%p\", dentry);\n\telse {\n\t\tqstr.len = autofs4_getpath(sbi, dentry, &name);\n\t\tif (!qstr.len) {\n\t\t\tkfree(name);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\tqstr.name = name;\n\tqstr.hash = full_name_hash(name, qstr.len);\n\n\tif (mutex_lock_interruptible(&sbi->wq_mutex)) {\n\t\tkfree(qstr.name);\n\t\treturn -EINTR;\n\t}\n\n\tret = validate_request(&wq, sbi, &qstr, dentry, notify);\n\tif (ret <= 0) {\n\t\tif (ret != -EINTR)\n\t\t\tmutex_unlock(&sbi->wq_mutex);\n\t\tkfree(qstr.name);\n\t\treturn ret;\n\t}\n\n\tif (!wq) {\n\t\t/* Create a new wait queue */\n\t\twq = kmalloc(sizeof(struct autofs_wait_queue),GFP_KERNEL);\n\t\tif (!wq) {\n\t\t\tkfree(qstr.name);\n\t\t\tmutex_unlock(&sbi->wq_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\twq->wait_queue_token = autofs4_next_wait_queue;\n\t\tif (++autofs4_next_wait_queue == 0)\n\t\t\tautofs4_next_wait_queue = 1;\n\t\twq->next = sbi->queues;\n\t\tsbi->queues = wq;\n\t\tinit_waitqueue_head(&wq->queue);\n\t\tmemcpy(&wq->name, &qstr, sizeof(struct qstr));\n\t\twq->dev = autofs4_get_dev(sbi);\n\t\twq->ino = autofs4_get_ino(sbi);\n\t\twq->uid = current_uid();\n\t\twq->gid = current_gid();\n\t\twq->pid = pid;\n\t\twq->tgid = tgid;\n\t\twq->status = -EINTR; /* Status return if interrupted */\n\t\twq->wait_ctr = 2;\n\n\t\tif (sbi->version < 5) {\n\t\t\tif (notify == NFY_MOUNT)\n\t\t\t\ttype = autofs_ptype_missing;\n\t\t\telse\n\t\t\t\ttype = autofs_ptype_expire_multi;\n\t\t} else {\n\t\t\tif (notify == NFY_MOUNT)\n\t\t\t\ttype = autofs_type_trigger(sbi->type) ?\n\t\t\t\t\tautofs_ptype_missing_direct :\n\t\t\t\t\t autofs_ptype_missing_indirect;\n\t\t\telse\n\t\t\t\ttype = autofs_type_trigger(sbi->type) ?\n\t\t\t\t\tautofs_ptype_expire_direct :\n\t\t\t\t\tautofs_ptype_expire_indirect;\n\t\t}\n\n\t\tDPRINTK(\"new wait id = 0x%08lx, name = %.*s, nfy=%d\\n\",\n\t\t\t(unsigned long) wq->wait_queue_token, wq->name.len,\n\t\t\twq->name.name, notify);\n\n\t\t/* autofs4_notify_daemon() may block; it will unlock ->wq_mutex */\n\t\tautofs4_notify_daemon(sbi, wq, type);\n\t} else {\n\t\twq->wait_ctr++;\n\t\tDPRINTK(\"existing wait id = 0x%08lx, name = %.*s, nfy=%d\",\n\t\t\t(unsigned long) wq->wait_queue_token, wq->name.len,\n\t\t\twq->name.name, notify);\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\tkfree(qstr.name);\n\t}\n\n\t/*\n\t * wq->name.name is NULL iff the lock is already released\n\t * or the mount has been made catatonic.\n\t */\n\tif (wq->name.name) {\n\t\t/* Block all but \"shutdown\" signals while waiting */\n\t\tsigset_t oldset;\n\t\tunsigned long irqflags;\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, irqflags);\n\t\toldset = current->blocked;\n\t\tsiginitsetinv(&current->blocked, SHUTDOWN_SIGS & ~oldset.sig[0]);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, irqflags);\n\n\t\twait_event_interruptible(wq->queue, wq->name.name == NULL);\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, irqflags);\n\t\tcurrent->blocked = oldset;\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, irqflags);\n\t} else {\n\t\tDPRINTK(\"skipped sleeping\");\n\t}\n\n\tstatus = wq->status;\n\n\t/*\n\t * For direct and offset mounts we need to track the requester's\n\t * uid and gid in the dentry info struct. This is so it can be\n\t * supplied, on request, by the misc device ioctl interface.\n\t * This is needed during daemon resatart when reconnecting\n\t * to existing, active, autofs mounts. The uid and gid (and\n\t * related string values) may be used for macro substitution\n\t * in autofs mount maps.\n\t */\n\tif (!status) {\n\t\tstruct autofs_info *ino;\n\t\tstruct dentry *de = NULL;\n\n\t\t/* direct mount or browsable map */\n\t\tino = autofs4_dentry_ino(dentry);\n\t\tif (!ino) {\n\t\t\t/* If not lookup actual dentry used */\n\t\t\tde = d_lookup(dentry->d_parent, &dentry->d_name);\n\t\t\tif (de)\n\t\t\t\tino = autofs4_dentry_ino(de);\n\t\t}\n\n\t\t/* Set mount requester */\n\t\tif (ino) {\n\t\t\tspin_lock(&sbi->fs_lock);\n\t\t\tino->uid = wq->uid;\n\t\t\tino->gid = wq->gid;\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t}\n\n\t\tif (de)\n\t\t\tdput(de);\n\t}\n\n\t/* Are we the last process to need status? */\n\tmutex_lock(&sbi->wq_mutex);\n\tif (!--wq->wait_ctr)\n\t\tkfree(wq);\n\tmutex_unlock(&sbi->wq_mutex);\n\n\treturn status;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/file.h>",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define SHUTDOWN_SIGS\t(sigmask(SIGKILL) | sigmask(SIGINT) | sigmask(SIGQUIT))"
    ],
    "globals_used": [
      "static autofs_wqt_t autofs4_next_wait_queue = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wq"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "de"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "de"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_lookup",
          "args": [
            "dentry->d_parent",
            "&dentry->d_name"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash_and_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2312-2326",
          "snippet": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"skipped sleeping\""
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&current->sighand->siglock",
            "irqflags"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&current->sighand->siglock",
            "irqflags"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "wq->queue",
            "wq->name.name == NULL"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&current->sighand->siglock",
            "irqflags"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "siginitsetinv",
          "args": [
            "&current->blocked",
            "SHUTDOWN_SIGS & ~oldset.sig[0]"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&current->sighand->siglock",
            "irqflags"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qstr.name"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"existing wait id = 0x%08lx, name = %.*s, nfy=%d\"",
            "(unsigned long) wq->wait_queue_token",
            "wq->name.len",
            "wq->name.name",
            "notify"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_notify_daemon",
          "args": [
            "sbi",
            "wq",
            "type"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_notify_daemon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
          "lines": "93-178",
          "snippet": "static void autofs4_notify_daemon(struct autofs_sb_info *sbi,\n\t\t\t\t struct autofs_wait_queue *wq,\n\t\t\t\t int type)\n{\n\tunion {\n\t\tstruct autofs_packet_hdr hdr;\n\t\tunion autofs_packet_union v4_pkt;\n\t\tunion autofs_v5_packet_union v5_pkt;\n\t} pkt;\n\tstruct file *pipe = NULL;\n\tsize_t pktsz;\n\n\tDPRINTK(\"wait id = 0x%08lx, name = %.*s, type=%d\",\n\t\t(unsigned long) wq->wait_queue_token, wq->name.len, wq->name.name, type);\n\n\tmemset(&pkt,0,sizeof pkt); /* For security reasons */\n\n\tpkt.hdr.proto_version = sbi->version;\n\tpkt.hdr.type = type;\n\n\tswitch (type) {\n\t/* Kernel protocol v4 missing and expire packets */\n\tcase autofs_ptype_missing:\n\t{\n\t\tstruct autofs_packet_missing *mp = &pkt.v4_pkt.missing;\n\n\t\tpktsz = sizeof(*mp);\n\n\t\tmp->wait_queue_token = wq->wait_queue_token;\n\t\tmp->len = wq->name.len;\n\t\tmemcpy(mp->name, wq->name.name, wq->name.len);\n\t\tmp->name[wq->name.len] = '\\0';\n\t\tbreak;\n\t}\n\tcase autofs_ptype_expire_multi:\n\t{\n\t\tstruct autofs_packet_expire_multi *ep = &pkt.v4_pkt.expire_multi;\n\n\t\tpktsz = sizeof(*ep);\n\n\t\tep->wait_queue_token = wq->wait_queue_token;\n\t\tep->len = wq->name.len;\n\t\tmemcpy(ep->name, wq->name.name, wq->name.len);\n\t\tep->name[wq->name.len] = '\\0';\n\t\tbreak;\n\t}\n\t/*\n\t * Kernel protocol v5 packet for handling indirect and direct\n\t * mount missing and expire requests\n\t */\n\tcase autofs_ptype_missing_indirect:\n\tcase autofs_ptype_expire_indirect:\n\tcase autofs_ptype_missing_direct:\n\tcase autofs_ptype_expire_direct:\n\t{\n\t\tstruct autofs_v5_packet *packet = &pkt.v5_pkt.v5_packet;\n\t\tstruct user_namespace *user_ns = sbi->pipe->f_cred->user_ns;\n\n\t\tpktsz = sizeof(*packet);\n\n\t\tpacket->wait_queue_token = wq->wait_queue_token;\n\t\tpacket->len = wq->name.len;\n\t\tmemcpy(packet->name, wq->name.name, wq->name.len);\n\t\tpacket->name[wq->name.len] = '\\0';\n\t\tpacket->dev = wq->dev;\n\t\tpacket->ino = wq->ino;\n\t\tpacket->uid = from_kuid_munged(user_ns, wq->uid);\n\t\tpacket->gid = from_kgid_munged(user_ns, wq->gid);\n\t\tpacket->pid = wq->pid;\n\t\tpacket->tgid = wq->tgid;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tprintk(\"autofs4_notify_daemon: bad type %d!\\n\", type);\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn;\n\t}\n\n\tpipe = get_file(sbi->pipe);\n\n\tmutex_unlock(&sbi->wq_mutex);\n\n\tif (autofs4_write(sbi, pipe, &pkt, pktsz))\n\t\tautofs4_catatonic_mode(sbi);\n\tfput(pipe);\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/file.h>",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nstatic void autofs4_notify_daemon(struct autofs_sb_info *sbi,\n\t\t\t\t struct autofs_wait_queue *wq,\n\t\t\t\t int type)\n{\n\tunion {\n\t\tstruct autofs_packet_hdr hdr;\n\t\tunion autofs_packet_union v4_pkt;\n\t\tunion autofs_v5_packet_union v5_pkt;\n\t} pkt;\n\tstruct file *pipe = NULL;\n\tsize_t pktsz;\n\n\tDPRINTK(\"wait id = 0x%08lx, name = %.*s, type=%d\",\n\t\t(unsigned long) wq->wait_queue_token, wq->name.len, wq->name.name, type);\n\n\tmemset(&pkt,0,sizeof pkt); /* For security reasons */\n\n\tpkt.hdr.proto_version = sbi->version;\n\tpkt.hdr.type = type;\n\n\tswitch (type) {\n\t/* Kernel protocol v4 missing and expire packets */\n\tcase autofs_ptype_missing:\n\t{\n\t\tstruct autofs_packet_missing *mp = &pkt.v4_pkt.missing;\n\n\t\tpktsz = sizeof(*mp);\n\n\t\tmp->wait_queue_token = wq->wait_queue_token;\n\t\tmp->len = wq->name.len;\n\t\tmemcpy(mp->name, wq->name.name, wq->name.len);\n\t\tmp->name[wq->name.len] = '\\0';\n\t\tbreak;\n\t}\n\tcase autofs_ptype_expire_multi:\n\t{\n\t\tstruct autofs_packet_expire_multi *ep = &pkt.v4_pkt.expire_multi;\n\n\t\tpktsz = sizeof(*ep);\n\n\t\tep->wait_queue_token = wq->wait_queue_token;\n\t\tep->len = wq->name.len;\n\t\tmemcpy(ep->name, wq->name.name, wq->name.len);\n\t\tep->name[wq->name.len] = '\\0';\n\t\tbreak;\n\t}\n\t/*\n\t * Kernel protocol v5 packet for handling indirect and direct\n\t * mount missing and expire requests\n\t */\n\tcase autofs_ptype_missing_indirect:\n\tcase autofs_ptype_expire_indirect:\n\tcase autofs_ptype_missing_direct:\n\tcase autofs_ptype_expire_direct:\n\t{\n\t\tstruct autofs_v5_packet *packet = &pkt.v5_pkt.v5_packet;\n\t\tstruct user_namespace *user_ns = sbi->pipe->f_cred->user_ns;\n\n\t\tpktsz = sizeof(*packet);\n\n\t\tpacket->wait_queue_token = wq->wait_queue_token;\n\t\tpacket->len = wq->name.len;\n\t\tmemcpy(packet->name, wq->name.name, wq->name.len);\n\t\tpacket->name[wq->name.len] = '\\0';\n\t\tpacket->dev = wq->dev;\n\t\tpacket->ino = wq->ino;\n\t\tpacket->uid = from_kuid_munged(user_ns, wq->uid);\n\t\tpacket->gid = from_kgid_munged(user_ns, wq->gid);\n\t\tpacket->pid = wq->pid;\n\t\tpacket->tgid = wq->tgid;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tprintk(\"autofs4_notify_daemon: bad type %d!\\n\", type);\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn;\n\t}\n\n\tpipe = get_file(sbi->pipe);\n\n\tmutex_unlock(&sbi->wq_mutex);\n\n\tif (autofs4_write(sbi, pipe, &pkt, pktsz))\n\t\tautofs4_catatonic_mode(sbi);\n\tfput(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"new wait id = 0x%08lx, name = %.*s, nfy=%d\\n\"",
            "(unsigned long) wq->wait_queue_token",
            "wq->name.len",
            "wq->name.name",
            "notify"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs_type_trigger",
          "args": [
            "sbi->type"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs_type_trigger",
          "args": [
            "sbi->type"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_gid",
          "args": [],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_get_ino",
          "args": [
            "sbi"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_get_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "236-239",
          "snippet": "static inline u64 autofs4_get_ino(struct autofs_sb_info *sbi)\n{\n\treturn sbi->sb->s_root->d_inode->i_ino;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\n\nstatic inline u64 autofs4_get_ino(struct autofs_sb_info *sbi)\n{\n\treturn sbi->sb->s_root->d_inode->i_ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_get_dev",
          "args": [
            "sbi"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_get_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "231-234",
          "snippet": "static inline u32 autofs4_get_dev(struct autofs_sb_info *sbi)\n{\n\treturn new_encode_dev(sbi->sb->s_dev);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\n\nstatic inline u32 autofs4_get_dev(struct autofs_sb_info *sbi)\n{\n\treturn new_encode_dev(sbi->sb->s_dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&wq->name",
            "&qstr",
            "sizeof(struct qstr)"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&wq->queue"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qstr.name"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct autofs_wait_queue)",
            "GFP_KERNEL"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qstr.name"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_request",
          "args": [
            "&wq",
            "sbi",
            "&qstr",
            "dentry",
            "notify"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "validate_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
          "lines": "248-341",
          "snippet": "static int validate_request(struct autofs_wait_queue **wait,\n\t\t\t    struct autofs_sb_info *sbi,\n\t\t\t    struct qstr *qstr,\n\t\t\t    struct dentry*dentry, enum autofs_notify notify)\n{\n\tstruct autofs_wait_queue *wq;\n\tstruct autofs_info *ino;\n\n\tif (sbi->catatonic)\n\t\treturn -ENOENT;\n\n\t/* Wait in progress, continue; */\n\twq = autofs4_find_wait(sbi, qstr);\n\tif (wq) {\n\t\t*wait = wq;\n\t\treturn 1;\n\t}\n\n\t*wait = NULL;\n\n\t/* If we don't yet have any info this is a new request */\n\tino = autofs4_dentry_ino(dentry);\n\tif (!ino)\n\t\treturn 1;\n\n\t/*\n\t * If we've been asked to wait on an existing expire (NFY_NONE)\n\t * but there is no wait in the queue ...\n\t */\n\tif (notify == NFY_NONE) {\n\t\t/*\n\t\t * Either we've betean the pending expire to post it's\n\t\t * wait or it finished while we waited on the mutex.\n\t\t * So we need to wait till either, the wait appears\n\t\t * or the expire finishes.\n\t\t */\n\n\t\twhile (ino->flags & AUTOFS_INF_EXPIRING) {\n\t\t\tmutex_unlock(&sbi->wq_mutex);\n\t\t\tschedule_timeout_interruptible(HZ/10);\n\t\t\tif (mutex_lock_interruptible(&sbi->wq_mutex))\n\t\t\t\treturn -EINTR;\n\n\t\t\tif (sbi->catatonic)\n\t\t\t\treturn -ENOENT;\n\n\t\t\twq = autofs4_find_wait(sbi, qstr);\n\t\t\tif (wq) {\n\t\t\t\t*wait = wq;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Not ideal but the status has already gone. Of the two\n\t\t * cases where we wait on NFY_NONE neither depend on the\n\t\t * return status of the wait.\n\t\t */\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we've been asked to trigger a mount and the request\n\t * completed while we waited on the mutex ...\n\t */\n\tif (notify == NFY_MOUNT) {\n\t\tstruct dentry *new = NULL;\n\t\tint valid = 1;\n\n\t\t/*\n\t\t * If the dentry was successfully mounted while we slept\n\t\t * on the wait queue mutex we can return success. If it\n\t\t * isn't mounted (doesn't have submounts for the case of\n\t\t * a multi-mount with no mount at it's base) we can\n\t\t * continue on and create a new request.\n\t\t */\n\t\tif (!IS_ROOT(dentry)) {\n\t\t\tif (dentry->d_inode && d_unhashed(dentry)) {\n\t\t\t\tstruct dentry *parent = dentry->d_parent;\n\t\t\t\tnew = d_lookup(parent, &dentry->d_name);\n\t\t\t\tif (new)\n\t\t\t\t\tdentry = new;\n\t\t\t}\n\t\t}\n\t\tif (have_submounts(dentry))\n\t\t\tvalid = 0;\n\n\t\tif (new)\n\t\t\tdput(new);\n\t\treturn valid;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/file.h>",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nstatic int validate_request(struct autofs_wait_queue **wait,\n\t\t\t    struct autofs_sb_info *sbi,\n\t\t\t    struct qstr *qstr,\n\t\t\t    struct dentry*dentry, enum autofs_notify notify)\n{\n\tstruct autofs_wait_queue *wq;\n\tstruct autofs_info *ino;\n\n\tif (sbi->catatonic)\n\t\treturn -ENOENT;\n\n\t/* Wait in progress, continue; */\n\twq = autofs4_find_wait(sbi, qstr);\n\tif (wq) {\n\t\t*wait = wq;\n\t\treturn 1;\n\t}\n\n\t*wait = NULL;\n\n\t/* If we don't yet have any info this is a new request */\n\tino = autofs4_dentry_ino(dentry);\n\tif (!ino)\n\t\treturn 1;\n\n\t/*\n\t * If we've been asked to wait on an existing expire (NFY_NONE)\n\t * but there is no wait in the queue ...\n\t */\n\tif (notify == NFY_NONE) {\n\t\t/*\n\t\t * Either we've betean the pending expire to post it's\n\t\t * wait or it finished while we waited on the mutex.\n\t\t * So we need to wait till either, the wait appears\n\t\t * or the expire finishes.\n\t\t */\n\n\t\twhile (ino->flags & AUTOFS_INF_EXPIRING) {\n\t\t\tmutex_unlock(&sbi->wq_mutex);\n\t\t\tschedule_timeout_interruptible(HZ/10);\n\t\t\tif (mutex_lock_interruptible(&sbi->wq_mutex))\n\t\t\t\treturn -EINTR;\n\n\t\t\tif (sbi->catatonic)\n\t\t\t\treturn -ENOENT;\n\n\t\t\twq = autofs4_find_wait(sbi, qstr);\n\t\t\tif (wq) {\n\t\t\t\t*wait = wq;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Not ideal but the status has already gone. Of the two\n\t\t * cases where we wait on NFY_NONE neither depend on the\n\t\t * return status of the wait.\n\t\t */\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we've been asked to trigger a mount and the request\n\t * completed while we waited on the mutex ...\n\t */\n\tif (notify == NFY_MOUNT) {\n\t\tstruct dentry *new = NULL;\n\t\tint valid = 1;\n\n\t\t/*\n\t\t * If the dentry was successfully mounted while we slept\n\t\t * on the wait queue mutex we can return success. If it\n\t\t * isn't mounted (doesn't have submounts for the case of\n\t\t * a multi-mount with no mount at it's base) we can\n\t\t * continue on and create a new request.\n\t\t */\n\t\tif (!IS_ROOT(dentry)) {\n\t\t\tif (dentry->d_inode && d_unhashed(dentry)) {\n\t\t\t\tstruct dentry *parent = dentry->d_parent;\n\t\t\t\tnew = d_lookup(parent, &dentry->d_name);\n\t\t\t\tif (new)\n\t\t\t\t\tdentry = new;\n\t\t\t}\n\t\t}\n\t\tif (have_submounts(dentry))\n\t\t\tvalid = 0;\n\n\t\tif (new)\n\t\t\tdput(new);\n\t\treturn valid;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qstr.name"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "full_name_hash",
          "args": [
            "name",
            "qstr.len"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "full_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1737-1743",
          "snippet": "unsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nunsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_getpath",
          "args": [
            "sbi",
            "dentry",
            "&name"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_getpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
          "lines": "180-223",
          "snippet": "static int autofs4_getpath(struct autofs_sb_info *sbi,\n\t\t\t   struct dentry *dentry, char **name)\n{\n\tstruct dentry *root = sbi->sb->s_root;\n\tstruct dentry *tmp;\n\tchar *buf;\n\tchar *p;\n\tint len;\n\tunsigned seq;\n\nrename_retry:\n\tbuf = *name;\n\tlen = 0;\n\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tspin_lock(&sbi->fs_lock);\n\tfor (tmp = dentry ; tmp != root ; tmp = tmp->d_parent)\n\t\tlen += tmp->d_name.len + 1;\n\n\tif (!len || --len > NAME_MAX) {\n\t\tspin_unlock(&sbi->fs_lock);\n\t\trcu_read_unlock();\n\t\tif (read_seqretry(&rename_lock, seq))\n\t\t\tgoto rename_retry;\n\t\treturn 0;\n\t}\n\n\t*(buf + len) = '\\0';\n\tp = buf + len - dentry->d_name.len;\n\tstrncpy(p, dentry->d_name.name, dentry->d_name.len);\n\n\tfor (tmp = dentry->d_parent; tmp != root ; tmp = tmp->d_parent) {\n\t\t*(--p) = '/';\n\t\tp -= tmp->d_name.len;\n\t\tstrncpy(p, tmp->d_name.name, tmp->d_name.len);\n\t}\n\tspin_unlock(&sbi->fs_lock);\n\trcu_read_unlock();\n\tif (read_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\n\n\treturn len;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/file.h>",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nstatic int autofs4_getpath(struct autofs_sb_info *sbi,\n\t\t\t   struct dentry *dentry, char **name)\n{\n\tstruct dentry *root = sbi->sb->s_root;\n\tstruct dentry *tmp;\n\tchar *buf;\n\tchar *p;\n\tint len;\n\tunsigned seq;\n\nrename_retry:\n\tbuf = *name;\n\tlen = 0;\n\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tspin_lock(&sbi->fs_lock);\n\tfor (tmp = dentry ; tmp != root ; tmp = tmp->d_parent)\n\t\tlen += tmp->d_name.len + 1;\n\n\tif (!len || --len > NAME_MAX) {\n\t\tspin_unlock(&sbi->fs_lock);\n\t\trcu_read_unlock();\n\t\tif (read_seqretry(&rename_lock, seq))\n\t\t\tgoto rename_retry;\n\t\treturn 0;\n\t}\n\n\t*(buf + len) = '\\0';\n\tp = buf + len - dentry->d_name.len;\n\tstrncpy(p, dentry->d_name.name, dentry->d_name.len);\n\n\tfor (tmp = dentry->d_parent; tmp != root ; tmp = tmp->d_parent) {\n\t\t*(--p) = '/';\n\t\tp -= tmp->d_name.len;\n\t\tstrncpy(p, tmp->d_name.name, tmp->d_name.len);\n\t}\n\tspin_unlock(&sbi->fs_lock);\n\trcu_read_unlock();\n\tif (read_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "name",
            "\"%p\"",
            "dentry"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs_type_trigger",
          "args": [
            "sbi->type"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry->d_parent"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs_type_trigger",
          "args": [
            "sbi->type"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_nr_ns",
          "args": [
            "current",
            "ns_of_pid(sbi->oz_pgrp)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_of_pid",
          "args": [
            "sbi->oz_pgrp"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "current",
            "ns_of_pid(sbi->oz_pgrp)"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_of_pid",
          "args": [
            "sbi->oz_pgrp"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\n#define SHUTDOWN_SIGS\t(sigmask(SIGKILL) | sigmask(SIGINT) | sigmask(SIGQUIT))\n\nstatic autofs_wqt_t autofs4_next_wait_queue = 1;\n\nint autofs4_wait(struct autofs_sb_info *sbi, struct dentry *dentry,\n\t\tenum autofs_notify notify)\n{\n\tstruct autofs_wait_queue *wq;\n\tstruct qstr qstr;\n\tchar *name;\n\tint status, ret, type;\n\tpid_t pid;\n\tpid_t tgid;\n\n\t/* In catatonic mode, we don't wait for nobody */\n\tif (sbi->catatonic)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Try translating pids to the namespace of the daemon.\n\t *\n\t * Zero means failure: we are in an unrelated pid namespace.\n\t */\n\tpid = task_pid_nr_ns(current, ns_of_pid(sbi->oz_pgrp));\n\ttgid = task_tgid_nr_ns(current, ns_of_pid(sbi->oz_pgrp));\n\tif (pid == 0 || tgid == 0)\n\t\treturn -ENOENT;\n\n\tif (!dentry->d_inode) {\n\t\t/*\n\t\t * A wait for a negative dentry is invalid for certain\n\t\t * cases. A direct or offset mount \"always\" has its mount\n\t\t * point directory created and so the request dentry must\n\t\t * be positive or the map key doesn't exist. The situation\n\t\t * is very similar for indirect mounts except only dentrys\n\t\t * in the root of the autofs file system may be negative.\n\t\t */\n\t\tif (autofs_type_trigger(sbi->type))\n\t\t\treturn -ENOENT;\n\t\telse if (!IS_ROOT(dentry->d_parent))\n\t\t\treturn -ENOENT;\n\t}\n\n\tname = kmalloc(NAME_MAX + 1, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\t/* If this is a direct mount request create a dummy name */\n\tif (IS_ROOT(dentry) && autofs_type_trigger(sbi->type))\n\t\tqstr.len = sprintf(name, \"%p\", dentry);\n\telse {\n\t\tqstr.len = autofs4_getpath(sbi, dentry, &name);\n\t\tif (!qstr.len) {\n\t\t\tkfree(name);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\tqstr.name = name;\n\tqstr.hash = full_name_hash(name, qstr.len);\n\n\tif (mutex_lock_interruptible(&sbi->wq_mutex)) {\n\t\tkfree(qstr.name);\n\t\treturn -EINTR;\n\t}\n\n\tret = validate_request(&wq, sbi, &qstr, dentry, notify);\n\tif (ret <= 0) {\n\t\tif (ret != -EINTR)\n\t\t\tmutex_unlock(&sbi->wq_mutex);\n\t\tkfree(qstr.name);\n\t\treturn ret;\n\t}\n\n\tif (!wq) {\n\t\t/* Create a new wait queue */\n\t\twq = kmalloc(sizeof(struct autofs_wait_queue),GFP_KERNEL);\n\t\tif (!wq) {\n\t\t\tkfree(qstr.name);\n\t\t\tmutex_unlock(&sbi->wq_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\twq->wait_queue_token = autofs4_next_wait_queue;\n\t\tif (++autofs4_next_wait_queue == 0)\n\t\t\tautofs4_next_wait_queue = 1;\n\t\twq->next = sbi->queues;\n\t\tsbi->queues = wq;\n\t\tinit_waitqueue_head(&wq->queue);\n\t\tmemcpy(&wq->name, &qstr, sizeof(struct qstr));\n\t\twq->dev = autofs4_get_dev(sbi);\n\t\twq->ino = autofs4_get_ino(sbi);\n\t\twq->uid = current_uid();\n\t\twq->gid = current_gid();\n\t\twq->pid = pid;\n\t\twq->tgid = tgid;\n\t\twq->status = -EINTR; /* Status return if interrupted */\n\t\twq->wait_ctr = 2;\n\n\t\tif (sbi->version < 5) {\n\t\t\tif (notify == NFY_MOUNT)\n\t\t\t\ttype = autofs_ptype_missing;\n\t\t\telse\n\t\t\t\ttype = autofs_ptype_expire_multi;\n\t\t} else {\n\t\t\tif (notify == NFY_MOUNT)\n\t\t\t\ttype = autofs_type_trigger(sbi->type) ?\n\t\t\t\t\tautofs_ptype_missing_direct :\n\t\t\t\t\t autofs_ptype_missing_indirect;\n\t\t\telse\n\t\t\t\ttype = autofs_type_trigger(sbi->type) ?\n\t\t\t\t\tautofs_ptype_expire_direct :\n\t\t\t\t\tautofs_ptype_expire_indirect;\n\t\t}\n\n\t\tDPRINTK(\"new wait id = 0x%08lx, name = %.*s, nfy=%d\\n\",\n\t\t\t(unsigned long) wq->wait_queue_token, wq->name.len,\n\t\t\twq->name.name, notify);\n\n\t\t/* autofs4_notify_daemon() may block; it will unlock ->wq_mutex */\n\t\tautofs4_notify_daemon(sbi, wq, type);\n\t} else {\n\t\twq->wait_ctr++;\n\t\tDPRINTK(\"existing wait id = 0x%08lx, name = %.*s, nfy=%d\",\n\t\t\t(unsigned long) wq->wait_queue_token, wq->name.len,\n\t\t\twq->name.name, notify);\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\tkfree(qstr.name);\n\t}\n\n\t/*\n\t * wq->name.name is NULL iff the lock is already released\n\t * or the mount has been made catatonic.\n\t */\n\tif (wq->name.name) {\n\t\t/* Block all but \"shutdown\" signals while waiting */\n\t\tsigset_t oldset;\n\t\tunsigned long irqflags;\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, irqflags);\n\t\toldset = current->blocked;\n\t\tsiginitsetinv(&current->blocked, SHUTDOWN_SIGS & ~oldset.sig[0]);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, irqflags);\n\n\t\twait_event_interruptible(wq->queue, wq->name.name == NULL);\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, irqflags);\n\t\tcurrent->blocked = oldset;\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, irqflags);\n\t} else {\n\t\tDPRINTK(\"skipped sleeping\");\n\t}\n\n\tstatus = wq->status;\n\n\t/*\n\t * For direct and offset mounts we need to track the requester's\n\t * uid and gid in the dentry info struct. This is so it can be\n\t * supplied, on request, by the misc device ioctl interface.\n\t * This is needed during daemon resatart when reconnecting\n\t * to existing, active, autofs mounts. The uid and gid (and\n\t * related string values) may be used for macro substitution\n\t * in autofs mount maps.\n\t */\n\tif (!status) {\n\t\tstruct autofs_info *ino;\n\t\tstruct dentry *de = NULL;\n\n\t\t/* direct mount or browsable map */\n\t\tino = autofs4_dentry_ino(dentry);\n\t\tif (!ino) {\n\t\t\t/* If not lookup actual dentry used */\n\t\t\tde = d_lookup(dentry->d_parent, &dentry->d_name);\n\t\t\tif (de)\n\t\t\t\tino = autofs4_dentry_ino(de);\n\t\t}\n\n\t\t/* Set mount requester */\n\t\tif (ino) {\n\t\t\tspin_lock(&sbi->fs_lock);\n\t\t\tino->uid = wq->uid;\n\t\t\tino->gid = wq->gid;\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t}\n\n\t\tif (de)\n\t\t\tdput(de);\n\t}\n\n\t/* Are we the last process to need status? */\n\tmutex_lock(&sbi->wq_mutex);\n\tif (!--wq->wait_ctr)\n\t\tkfree(wq);\n\tmutex_unlock(&sbi->wq_mutex);\n\n\treturn status;\n}"
  },
  {
    "function_name": "validate_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
    "lines": "248-341",
    "snippet": "static int validate_request(struct autofs_wait_queue **wait,\n\t\t\t    struct autofs_sb_info *sbi,\n\t\t\t    struct qstr *qstr,\n\t\t\t    struct dentry*dentry, enum autofs_notify notify)\n{\n\tstruct autofs_wait_queue *wq;\n\tstruct autofs_info *ino;\n\n\tif (sbi->catatonic)\n\t\treturn -ENOENT;\n\n\t/* Wait in progress, continue; */\n\twq = autofs4_find_wait(sbi, qstr);\n\tif (wq) {\n\t\t*wait = wq;\n\t\treturn 1;\n\t}\n\n\t*wait = NULL;\n\n\t/* If we don't yet have any info this is a new request */\n\tino = autofs4_dentry_ino(dentry);\n\tif (!ino)\n\t\treturn 1;\n\n\t/*\n\t * If we've been asked to wait on an existing expire (NFY_NONE)\n\t * but there is no wait in the queue ...\n\t */\n\tif (notify == NFY_NONE) {\n\t\t/*\n\t\t * Either we've betean the pending expire to post it's\n\t\t * wait or it finished while we waited on the mutex.\n\t\t * So we need to wait till either, the wait appears\n\t\t * or the expire finishes.\n\t\t */\n\n\t\twhile (ino->flags & AUTOFS_INF_EXPIRING) {\n\t\t\tmutex_unlock(&sbi->wq_mutex);\n\t\t\tschedule_timeout_interruptible(HZ/10);\n\t\t\tif (mutex_lock_interruptible(&sbi->wq_mutex))\n\t\t\t\treturn -EINTR;\n\n\t\t\tif (sbi->catatonic)\n\t\t\t\treturn -ENOENT;\n\n\t\t\twq = autofs4_find_wait(sbi, qstr);\n\t\t\tif (wq) {\n\t\t\t\t*wait = wq;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Not ideal but the status has already gone. Of the two\n\t\t * cases where we wait on NFY_NONE neither depend on the\n\t\t * return status of the wait.\n\t\t */\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we've been asked to trigger a mount and the request\n\t * completed while we waited on the mutex ...\n\t */\n\tif (notify == NFY_MOUNT) {\n\t\tstruct dentry *new = NULL;\n\t\tint valid = 1;\n\n\t\t/*\n\t\t * If the dentry was successfully mounted while we slept\n\t\t * on the wait queue mutex we can return success. If it\n\t\t * isn't mounted (doesn't have submounts for the case of\n\t\t * a multi-mount with no mount at it's base) we can\n\t\t * continue on and create a new request.\n\t\t */\n\t\tif (!IS_ROOT(dentry)) {\n\t\t\tif (dentry->d_inode && d_unhashed(dentry)) {\n\t\t\t\tstruct dentry *parent = dentry->d_parent;\n\t\t\t\tnew = d_lookup(parent, &dentry->d_name);\n\t\t\t\tif (new)\n\t\t\t\t\tdentry = new;\n\t\t\t}\n\t\t}\n\t\tif (have_submounts(dentry))\n\t\t\tvalid = 0;\n\n\t\tif (new)\n\t\t\tdput(new);\n\t\treturn valid;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/file.h>",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "new"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "have_submounts",
          "args": [
            "dentry"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "have_submounts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1262-1269",
          "snippet": "int have_submounts(struct dentry *parent)\n{\n\tint ret = 0;\n\n\td_walk(parent, &ret, check_mount, NULL);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint have_submounts(struct dentry *parent)\n{\n\tint ret = 0;\n\n\td_walk(parent, &ret, check_mount, NULL);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_lookup",
          "args": [
            "parent",
            "&dentry->d_name"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash_and_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2312-2326",
          "snippet": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_find_wait",
          "args": [
            "sbi",
            "qstr"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_find_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
          "lines": "225-238",
          "snippet": "static struct autofs_wait_queue *\nautofs4_find_wait(struct autofs_sb_info *sbi, struct qstr *qstr)\n{\n\tstruct autofs_wait_queue *wq;\n\n\tfor (wq = sbi->queues; wq; wq = wq->next) {\n\t\tif (wq->name.hash == qstr->hash &&\n\t\t    wq->name.len == qstr->len &&\n\t\t    wq->name.name &&\n\t\t\t !memcmp(wq->name.name, qstr->name, qstr->len))\n\t\t\tbreak;\n\t}\n\treturn wq;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/file.h>",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nstatic struct autofs_wait_queue *\nautofs4_find_wait(struct autofs_sb_info *sbi, struct qstr *qstr)\n{\n\tstruct autofs_wait_queue *wq;\n\n\tfor (wq = sbi->queues; wq; wq = wq->next) {\n\t\tif (wq->name.hash == qstr->hash &&\n\t\t    wq->name.len == qstr->len &&\n\t\t    wq->name.name &&\n\t\t\t !memcmp(wq->name.name, qstr->name, qstr->len))\n\t\t\tbreak;\n\t}\n\treturn wq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "HZ/10"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "dentry"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nstatic int validate_request(struct autofs_wait_queue **wait,\n\t\t\t    struct autofs_sb_info *sbi,\n\t\t\t    struct qstr *qstr,\n\t\t\t    struct dentry*dentry, enum autofs_notify notify)\n{\n\tstruct autofs_wait_queue *wq;\n\tstruct autofs_info *ino;\n\n\tif (sbi->catatonic)\n\t\treturn -ENOENT;\n\n\t/* Wait in progress, continue; */\n\twq = autofs4_find_wait(sbi, qstr);\n\tif (wq) {\n\t\t*wait = wq;\n\t\treturn 1;\n\t}\n\n\t*wait = NULL;\n\n\t/* If we don't yet have any info this is a new request */\n\tino = autofs4_dentry_ino(dentry);\n\tif (!ino)\n\t\treturn 1;\n\n\t/*\n\t * If we've been asked to wait on an existing expire (NFY_NONE)\n\t * but there is no wait in the queue ...\n\t */\n\tif (notify == NFY_NONE) {\n\t\t/*\n\t\t * Either we've betean the pending expire to post it's\n\t\t * wait or it finished while we waited on the mutex.\n\t\t * So we need to wait till either, the wait appears\n\t\t * or the expire finishes.\n\t\t */\n\n\t\twhile (ino->flags & AUTOFS_INF_EXPIRING) {\n\t\t\tmutex_unlock(&sbi->wq_mutex);\n\t\t\tschedule_timeout_interruptible(HZ/10);\n\t\t\tif (mutex_lock_interruptible(&sbi->wq_mutex))\n\t\t\t\treturn -EINTR;\n\n\t\t\tif (sbi->catatonic)\n\t\t\t\treturn -ENOENT;\n\n\t\t\twq = autofs4_find_wait(sbi, qstr);\n\t\t\tif (wq) {\n\t\t\t\t*wait = wq;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Not ideal but the status has already gone. Of the two\n\t\t * cases where we wait on NFY_NONE neither depend on the\n\t\t * return status of the wait.\n\t\t */\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we've been asked to trigger a mount and the request\n\t * completed while we waited on the mutex ...\n\t */\n\tif (notify == NFY_MOUNT) {\n\t\tstruct dentry *new = NULL;\n\t\tint valid = 1;\n\n\t\t/*\n\t\t * If the dentry was successfully mounted while we slept\n\t\t * on the wait queue mutex we can return success. If it\n\t\t * isn't mounted (doesn't have submounts for the case of\n\t\t * a multi-mount with no mount at it's base) we can\n\t\t * continue on and create a new request.\n\t\t */\n\t\tif (!IS_ROOT(dentry)) {\n\t\t\tif (dentry->d_inode && d_unhashed(dentry)) {\n\t\t\t\tstruct dentry *parent = dentry->d_parent;\n\t\t\t\tnew = d_lookup(parent, &dentry->d_name);\n\t\t\t\tif (new)\n\t\t\t\t\tdentry = new;\n\t\t\t}\n\t\t}\n\t\tif (have_submounts(dentry))\n\t\t\tvalid = 0;\n\n\t\tif (new)\n\t\t\tdput(new);\n\t\treturn valid;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "autofs4_find_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
    "lines": "225-238",
    "snippet": "static struct autofs_wait_queue *\nautofs4_find_wait(struct autofs_sb_info *sbi, struct qstr *qstr)\n{\n\tstruct autofs_wait_queue *wq;\n\n\tfor (wq = sbi->queues; wq; wq = wq->next) {\n\t\tif (wq->name.hash == qstr->hash &&\n\t\t    wq->name.len == qstr->len &&\n\t\t    wq->name.name &&\n\t\t\t !memcmp(wq->name.name, qstr->name, qstr->len))\n\t\t\tbreak;\n\t}\n\treturn wq;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/file.h>",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "wq->name.name",
            "qstr->name",
            "qstr->len"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nstatic struct autofs_wait_queue *\nautofs4_find_wait(struct autofs_sb_info *sbi, struct qstr *qstr)\n{\n\tstruct autofs_wait_queue *wq;\n\n\tfor (wq = sbi->queues; wq; wq = wq->next) {\n\t\tif (wq->name.hash == qstr->hash &&\n\t\t    wq->name.len == qstr->len &&\n\t\t    wq->name.name &&\n\t\t\t !memcmp(wq->name.name, qstr->name, qstr->len))\n\t\t\tbreak;\n\t}\n\treturn wq;\n}"
  },
  {
    "function_name": "autofs4_getpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
    "lines": "180-223",
    "snippet": "static int autofs4_getpath(struct autofs_sb_info *sbi,\n\t\t\t   struct dentry *dentry, char **name)\n{\n\tstruct dentry *root = sbi->sb->s_root;\n\tstruct dentry *tmp;\n\tchar *buf;\n\tchar *p;\n\tint len;\n\tunsigned seq;\n\nrename_retry:\n\tbuf = *name;\n\tlen = 0;\n\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tspin_lock(&sbi->fs_lock);\n\tfor (tmp = dentry ; tmp != root ; tmp = tmp->d_parent)\n\t\tlen += tmp->d_name.len + 1;\n\n\tif (!len || --len > NAME_MAX) {\n\t\tspin_unlock(&sbi->fs_lock);\n\t\trcu_read_unlock();\n\t\tif (read_seqretry(&rename_lock, seq))\n\t\t\tgoto rename_retry;\n\t\treturn 0;\n\t}\n\n\t*(buf + len) = '\\0';\n\tp = buf + len - dentry->d_name.len;\n\tstrncpy(p, dentry->d_name.name, dentry->d_name.len);\n\n\tfor (tmp = dentry->d_parent; tmp != root ; tmp = tmp->d_parent) {\n\t\t*(--p) = '/';\n\t\tp -= tmp->d_name.len;\n\t\tstrncpy(p, tmp->d_name.name, tmp->d_name.len);\n\t}\n\tspin_unlock(&sbi->fs_lock);\n\trcu_read_unlock();\n\tif (read_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\n\n\treturn len;\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/file.h>",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&rename_lock",
            "seq"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "p",
            "tmp->d_name.name",
            "tmp->d_name.len"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "p",
            "dentry->d_name.name",
            "dentry->d_name.len"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&rename_lock",
            "seq"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqbegin",
          "args": [
            "&rename_lock"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nstatic int autofs4_getpath(struct autofs_sb_info *sbi,\n\t\t\t   struct dentry *dentry, char **name)\n{\n\tstruct dentry *root = sbi->sb->s_root;\n\tstruct dentry *tmp;\n\tchar *buf;\n\tchar *p;\n\tint len;\n\tunsigned seq;\n\nrename_retry:\n\tbuf = *name;\n\tlen = 0;\n\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tspin_lock(&sbi->fs_lock);\n\tfor (tmp = dentry ; tmp != root ; tmp = tmp->d_parent)\n\t\tlen += tmp->d_name.len + 1;\n\n\tif (!len || --len > NAME_MAX) {\n\t\tspin_unlock(&sbi->fs_lock);\n\t\trcu_read_unlock();\n\t\tif (read_seqretry(&rename_lock, seq))\n\t\t\tgoto rename_retry;\n\t\treturn 0;\n\t}\n\n\t*(buf + len) = '\\0';\n\tp = buf + len - dentry->d_name.len;\n\tstrncpy(p, dentry->d_name.name, dentry->d_name.len);\n\n\tfor (tmp = dentry->d_parent; tmp != root ; tmp = tmp->d_parent) {\n\t\t*(--p) = '/';\n\t\tp -= tmp->d_name.len;\n\t\tstrncpy(p, tmp->d_name.name, tmp->d_name.len);\n\t}\n\tspin_unlock(&sbi->fs_lock);\n\trcu_read_unlock();\n\tif (read_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\n\n\treturn len;\n}"
  },
  {
    "function_name": "autofs4_notify_daemon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
    "lines": "93-178",
    "snippet": "static void autofs4_notify_daemon(struct autofs_sb_info *sbi,\n\t\t\t\t struct autofs_wait_queue *wq,\n\t\t\t\t int type)\n{\n\tunion {\n\t\tstruct autofs_packet_hdr hdr;\n\t\tunion autofs_packet_union v4_pkt;\n\t\tunion autofs_v5_packet_union v5_pkt;\n\t} pkt;\n\tstruct file *pipe = NULL;\n\tsize_t pktsz;\n\n\tDPRINTK(\"wait id = 0x%08lx, name = %.*s, type=%d\",\n\t\t(unsigned long) wq->wait_queue_token, wq->name.len, wq->name.name, type);\n\n\tmemset(&pkt,0,sizeof pkt); /* For security reasons */\n\n\tpkt.hdr.proto_version = sbi->version;\n\tpkt.hdr.type = type;\n\n\tswitch (type) {\n\t/* Kernel protocol v4 missing and expire packets */\n\tcase autofs_ptype_missing:\n\t{\n\t\tstruct autofs_packet_missing *mp = &pkt.v4_pkt.missing;\n\n\t\tpktsz = sizeof(*mp);\n\n\t\tmp->wait_queue_token = wq->wait_queue_token;\n\t\tmp->len = wq->name.len;\n\t\tmemcpy(mp->name, wq->name.name, wq->name.len);\n\t\tmp->name[wq->name.len] = '\\0';\n\t\tbreak;\n\t}\n\tcase autofs_ptype_expire_multi:\n\t{\n\t\tstruct autofs_packet_expire_multi *ep = &pkt.v4_pkt.expire_multi;\n\n\t\tpktsz = sizeof(*ep);\n\n\t\tep->wait_queue_token = wq->wait_queue_token;\n\t\tep->len = wq->name.len;\n\t\tmemcpy(ep->name, wq->name.name, wq->name.len);\n\t\tep->name[wq->name.len] = '\\0';\n\t\tbreak;\n\t}\n\t/*\n\t * Kernel protocol v5 packet for handling indirect and direct\n\t * mount missing and expire requests\n\t */\n\tcase autofs_ptype_missing_indirect:\n\tcase autofs_ptype_expire_indirect:\n\tcase autofs_ptype_missing_direct:\n\tcase autofs_ptype_expire_direct:\n\t{\n\t\tstruct autofs_v5_packet *packet = &pkt.v5_pkt.v5_packet;\n\t\tstruct user_namespace *user_ns = sbi->pipe->f_cred->user_ns;\n\n\t\tpktsz = sizeof(*packet);\n\n\t\tpacket->wait_queue_token = wq->wait_queue_token;\n\t\tpacket->len = wq->name.len;\n\t\tmemcpy(packet->name, wq->name.name, wq->name.len);\n\t\tpacket->name[wq->name.len] = '\\0';\n\t\tpacket->dev = wq->dev;\n\t\tpacket->ino = wq->ino;\n\t\tpacket->uid = from_kuid_munged(user_ns, wq->uid);\n\t\tpacket->gid = from_kgid_munged(user_ns, wq->gid);\n\t\tpacket->pid = wq->pid;\n\t\tpacket->tgid = wq->tgid;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tprintk(\"autofs4_notify_daemon: bad type %d!\\n\", type);\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn;\n\t}\n\n\tpipe = get_file(sbi->pipe);\n\n\tmutex_unlock(&sbi->wq_mutex);\n\n\tif (autofs4_write(sbi, pipe, &pkt, pktsz))\n\t\tautofs4_catatonic_mode(sbi);\n\tfput(pipe);\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/file.h>",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "pipe"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_catatonic_mode",
          "args": [
            "sbi"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_catatonic_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
          "lines": "27-55",
          "snippet": "void autofs4_catatonic_mode(struct autofs_sb_info *sbi)\n{\n\tstruct autofs_wait_queue *wq, *nwq;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tif (sbi->catatonic) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn;\n\t}\n\n\tDPRINTK(\"entering catatonic mode\");\n\n\tsbi->catatonic = 1;\n\twq = sbi->queues;\n\tsbi->queues = NULL;\t/* Erase all wait queues */\n\twhile (wq) {\n\t\tnwq = wq->next;\n\t\twq->status = -ENOENT; /* Magic is gone - report failure */\n\t\tkfree(wq->name.name);\n\t\twq->name.name = NULL;\n\t\twq->wait_ctr--;\n\t\twake_up_interruptible(&wq->queue);\n\t\twq = nwq;\n\t}\n\tfput(sbi->pipe);\t/* Close the pipe */\n\tsbi->pipe = NULL;\n\tsbi->pipefd = -1;\n\tmutex_unlock(&sbi->wq_mutex);\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/file.h>",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nvoid autofs4_catatonic_mode(struct autofs_sb_info *sbi)\n{\n\tstruct autofs_wait_queue *wq, *nwq;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tif (sbi->catatonic) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn;\n\t}\n\n\tDPRINTK(\"entering catatonic mode\");\n\n\tsbi->catatonic = 1;\n\twq = sbi->queues;\n\tsbi->queues = NULL;\t/* Erase all wait queues */\n\twhile (wq) {\n\t\tnwq = wq->next;\n\t\twq->status = -ENOENT; /* Magic is gone - report failure */\n\t\tkfree(wq->name.name);\n\t\twq->name.name = NULL;\n\t\twq->wait_ctr--;\n\t\twake_up_interruptible(&wq->queue);\n\t\twq = nwq;\n\t}\n\tfput(sbi->pipe);\t/* Close the pipe */\n\tsbi->pipe = NULL;\n\tsbi->pipefd = -1;\n\tmutex_unlock(&sbi->wq_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_write",
          "args": [
            "sbi",
            "pipe",
            "&pkt",
            "pktsz"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
          "lines": "57-91",
          "snippet": "static int autofs4_write(struct autofs_sb_info *sbi,\n\t\t\t struct file *file, const void *addr, int bytes)\n{\n\tunsigned long sigpipe, flags;\n\tmm_segment_t fs;\n\tconst char *data = (const char *)addr;\n\tssize_t wr = 0;\n\n\tsigpipe = sigismember(&current->pending.signal, SIGPIPE);\n\n\t/* Save pointer to user space and point back to kernel space */\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\tmutex_lock(&sbi->pipe_mutex);\n\twhile (bytes &&\n\t       (wr = file->f_op->write(file,data,bytes,&file->f_pos)) > 0) {\n\t\tdata += wr;\n\t\tbytes -= wr;\n\t}\n\tmutex_unlock(&sbi->pipe_mutex);\n\n\tset_fs(fs);\n\n\t/* Keep the currently executing process from receiving a\n\t   SIGPIPE unless it was already supposed to get one */\n\tif (wr == -EPIPE && !sigpipe) {\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\tsigdelset(&current->pending.signal, SIGPIPE);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t}\n\n\treturn (bytes > 0);\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/file.h>",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nstatic int autofs4_write(struct autofs_sb_info *sbi,\n\t\t\t struct file *file, const void *addr, int bytes)\n{\n\tunsigned long sigpipe, flags;\n\tmm_segment_t fs;\n\tconst char *data = (const char *)addr;\n\tssize_t wr = 0;\n\n\tsigpipe = sigismember(&current->pending.signal, SIGPIPE);\n\n\t/* Save pointer to user space and point back to kernel space */\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\tmutex_lock(&sbi->pipe_mutex);\n\twhile (bytes &&\n\t       (wr = file->f_op->write(file,data,bytes,&file->f_pos)) > 0) {\n\t\tdata += wr;\n\t\tbytes -= wr;\n\t}\n\tmutex_unlock(&sbi->pipe_mutex);\n\n\tset_fs(fs);\n\n\t/* Keep the currently executing process from receiving a\n\t   SIGPIPE unless it was already supposed to get one */\n\tif (wr == -EPIPE && !sigpipe) {\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\tsigdelset(&current->pending.signal, SIGPIPE);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t}\n\n\treturn (bytes > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "sbi->pipe"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "get_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "381-392",
          "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"autofs4_notify_daemon: bad type %d!\\n\"",
            "type"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "user_ns",
            "wq->gid"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "user_ns",
            "wq->uid"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "packet->name",
            "wq->name.name",
            "wq->name.len"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ep->name",
            "wq->name.name",
            "wq->name.len"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mp->name",
            "wq->name.name",
            "wq->name.len"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&pkt",
            "0",
            "sizeof pkt"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"wait id = 0x%08lx, name = %.*s, type=%d\"",
            "(unsigned long) wq->wait_queue_token",
            "wq->name.len",
            "wq->name.name",
            "type"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nstatic void autofs4_notify_daemon(struct autofs_sb_info *sbi,\n\t\t\t\t struct autofs_wait_queue *wq,\n\t\t\t\t int type)\n{\n\tunion {\n\t\tstruct autofs_packet_hdr hdr;\n\t\tunion autofs_packet_union v4_pkt;\n\t\tunion autofs_v5_packet_union v5_pkt;\n\t} pkt;\n\tstruct file *pipe = NULL;\n\tsize_t pktsz;\n\n\tDPRINTK(\"wait id = 0x%08lx, name = %.*s, type=%d\",\n\t\t(unsigned long) wq->wait_queue_token, wq->name.len, wq->name.name, type);\n\n\tmemset(&pkt,0,sizeof pkt); /* For security reasons */\n\n\tpkt.hdr.proto_version = sbi->version;\n\tpkt.hdr.type = type;\n\n\tswitch (type) {\n\t/* Kernel protocol v4 missing and expire packets */\n\tcase autofs_ptype_missing:\n\t{\n\t\tstruct autofs_packet_missing *mp = &pkt.v4_pkt.missing;\n\n\t\tpktsz = sizeof(*mp);\n\n\t\tmp->wait_queue_token = wq->wait_queue_token;\n\t\tmp->len = wq->name.len;\n\t\tmemcpy(mp->name, wq->name.name, wq->name.len);\n\t\tmp->name[wq->name.len] = '\\0';\n\t\tbreak;\n\t}\n\tcase autofs_ptype_expire_multi:\n\t{\n\t\tstruct autofs_packet_expire_multi *ep = &pkt.v4_pkt.expire_multi;\n\n\t\tpktsz = sizeof(*ep);\n\n\t\tep->wait_queue_token = wq->wait_queue_token;\n\t\tep->len = wq->name.len;\n\t\tmemcpy(ep->name, wq->name.name, wq->name.len);\n\t\tep->name[wq->name.len] = '\\0';\n\t\tbreak;\n\t}\n\t/*\n\t * Kernel protocol v5 packet for handling indirect and direct\n\t * mount missing and expire requests\n\t */\n\tcase autofs_ptype_missing_indirect:\n\tcase autofs_ptype_expire_indirect:\n\tcase autofs_ptype_missing_direct:\n\tcase autofs_ptype_expire_direct:\n\t{\n\t\tstruct autofs_v5_packet *packet = &pkt.v5_pkt.v5_packet;\n\t\tstruct user_namespace *user_ns = sbi->pipe->f_cred->user_ns;\n\n\t\tpktsz = sizeof(*packet);\n\n\t\tpacket->wait_queue_token = wq->wait_queue_token;\n\t\tpacket->len = wq->name.len;\n\t\tmemcpy(packet->name, wq->name.name, wq->name.len);\n\t\tpacket->name[wq->name.len] = '\\0';\n\t\tpacket->dev = wq->dev;\n\t\tpacket->ino = wq->ino;\n\t\tpacket->uid = from_kuid_munged(user_ns, wq->uid);\n\t\tpacket->gid = from_kgid_munged(user_ns, wq->gid);\n\t\tpacket->pid = wq->pid;\n\t\tpacket->tgid = wq->tgid;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tprintk(\"autofs4_notify_daemon: bad type %d!\\n\", type);\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn;\n\t}\n\n\tpipe = get_file(sbi->pipe);\n\n\tmutex_unlock(&sbi->wq_mutex);\n\n\tif (autofs4_write(sbi, pipe, &pkt, pktsz))\n\t\tautofs4_catatonic_mode(sbi);\n\tfput(pipe);\n}"
  },
  {
    "function_name": "autofs4_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
    "lines": "57-91",
    "snippet": "static int autofs4_write(struct autofs_sb_info *sbi,\n\t\t\t struct file *file, const void *addr, int bytes)\n{\n\tunsigned long sigpipe, flags;\n\tmm_segment_t fs;\n\tconst char *data = (const char *)addr;\n\tssize_t wr = 0;\n\n\tsigpipe = sigismember(&current->pending.signal, SIGPIPE);\n\n\t/* Save pointer to user space and point back to kernel space */\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\tmutex_lock(&sbi->pipe_mutex);\n\twhile (bytes &&\n\t       (wr = file->f_op->write(file,data,bytes,&file->f_pos)) > 0) {\n\t\tdata += wr;\n\t\tbytes -= wr;\n\t}\n\tmutex_unlock(&sbi->pipe_mutex);\n\n\tset_fs(fs);\n\n\t/* Keep the currently executing process from receiving a\n\t   SIGPIPE unless it was already supposed to get one */\n\tif (wr == -EPIPE && !sigpipe) {\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\tsigdelset(&current->pending.signal, SIGPIPE);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t}\n\n\treturn (bytes > 0);\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/file.h>",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&current->sighand->siglock",
            "flags"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&current->pending.signal",
            "SIGPIPE"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&current->sighand->siglock",
            "flags"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "fs"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->pipe_mutex"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->f_op->write",
          "args": [
            "file",
            "data",
            "bytes",
            "&file->f_pos"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->pipe_mutex"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "KERNEL_DS"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&current->pending.signal",
            "SIGPIPE"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nstatic int autofs4_write(struct autofs_sb_info *sbi,\n\t\t\t struct file *file, const void *addr, int bytes)\n{\n\tunsigned long sigpipe, flags;\n\tmm_segment_t fs;\n\tconst char *data = (const char *)addr;\n\tssize_t wr = 0;\n\n\tsigpipe = sigismember(&current->pending.signal, SIGPIPE);\n\n\t/* Save pointer to user space and point back to kernel space */\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\tmutex_lock(&sbi->pipe_mutex);\n\twhile (bytes &&\n\t       (wr = file->f_op->write(file,data,bytes,&file->f_pos)) > 0) {\n\t\tdata += wr;\n\t\tbytes -= wr;\n\t}\n\tmutex_unlock(&sbi->pipe_mutex);\n\n\tset_fs(fs);\n\n\t/* Keep the currently executing process from receiving a\n\t   SIGPIPE unless it was already supposed to get one */\n\tif (wr == -EPIPE && !sigpipe) {\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\tsigdelset(&current->pending.signal, SIGPIPE);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t}\n\n\treturn (bytes > 0);\n}"
  },
  {
    "function_name": "autofs4_catatonic_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
    "lines": "27-55",
    "snippet": "void autofs4_catatonic_mode(struct autofs_sb_info *sbi)\n{\n\tstruct autofs_wait_queue *wq, *nwq;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tif (sbi->catatonic) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn;\n\t}\n\n\tDPRINTK(\"entering catatonic mode\");\n\n\tsbi->catatonic = 1;\n\twq = sbi->queues;\n\tsbi->queues = NULL;\t/* Erase all wait queues */\n\twhile (wq) {\n\t\tnwq = wq->next;\n\t\twq->status = -ENOENT; /* Magic is gone - report failure */\n\t\tkfree(wq->name.name);\n\t\twq->name.name = NULL;\n\t\twq->wait_ctr--;\n\t\twake_up_interruptible(&wq->queue);\n\t\twq = nwq;\n\t}\n\tfput(sbi->pipe);\t/* Close the pipe */\n\tsbi->pipe = NULL;\n\tsbi->pipefd = -1;\n\tmutex_unlock(&sbi->wq_mutex);\n}",
    "includes": [
      "#include \"autofs_i.h\"",
      "#include <linux/file.h>",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "sbi->pipe"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&wq->queue"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wq->name.name"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"entering catatonic mode\""
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->wq_mutex"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nvoid autofs4_catatonic_mode(struct autofs_sb_info *sbi)\n{\n\tstruct autofs_wait_queue *wq, *nwq;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tif (sbi->catatonic) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn;\n\t}\n\n\tDPRINTK(\"entering catatonic mode\");\n\n\tsbi->catatonic = 1;\n\twq = sbi->queues;\n\tsbi->queues = NULL;\t/* Erase all wait queues */\n\twhile (wq) {\n\t\tnwq = wq->next;\n\t\twq->status = -ENOENT; /* Magic is gone - report failure */\n\t\tkfree(wq->name.name);\n\t\twq->name.name = NULL;\n\t\twq->wait_ctr--;\n\t\twake_up_interruptible(&wq->queue);\n\t\twq = nwq;\n\t}\n\tfput(sbi->pipe);\t/* Close the pipe */\n\tsbi->pipe = NULL;\n\tsbi->pipefd = -1;\n\tmutex_unlock(&sbi->wq_mutex);\n}"
  }
]