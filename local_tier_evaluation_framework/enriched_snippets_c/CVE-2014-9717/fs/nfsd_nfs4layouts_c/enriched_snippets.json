[
  {
    "function_name": "nfsd4_exit_pnfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "705-719",
    "snippet": "void\nnfsd4_exit_pnfs(void)\n{\n\tint i;\n\n\tkmem_cache_destroy(nfs4_layout_cache);\n\tkmem_cache_destroy(nfs4_layout_stateid_cache);\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++) {\n\t\tstruct nfsd4_deviceid_map *map, *n;\n\n\t\tlist_for_each_entry_safe(map, n, &nfsd_devid_hash[i], hash)\n\t\t\tkfree(map);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [
      "#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)"
    ],
    "globals_used": [
      "static struct kmem_cache *nfs4_layout_cache;",
      "static struct kmem_cache *nfs4_layout_stateid_cache;",
      "static struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "map"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "map",
            "n",
            "&nfsd_devid_hash[i]",
            "hash"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "nfs4_layout_stateid_cache"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "nfs4_layout_cache"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\n#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)\n\nstatic struct kmem_cache *nfs4_layout_cache;\nstatic struct kmem_cache *nfs4_layout_stateid_cache;\nstatic struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];\n\nvoid\nnfsd4_exit_pnfs(void)\n{\n\tint i;\n\n\tkmem_cache_destroy(nfs4_layout_cache);\n\tkmem_cache_destroy(nfs4_layout_stateid_cache);\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++) {\n\t\tstruct nfsd4_deviceid_map *map, *n;\n\n\t\tlist_for_each_entry_safe(map, n, &nfsd_devid_hash[i], hash)\n\t\t\tkfree(map);\n\t}\n}"
  },
  {
    "function_name": "nfsd4_init_pnfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "683-703",
    "snippet": "int\nnfsd4_init_pnfs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nfsd_devid_hash[i]);\n\n\tnfs4_layout_cache = kmem_cache_create(\"nfs4_layout\",\n\t\t\tsizeof(struct nfs4_layout), 0, 0, NULL);\n\tif (!nfs4_layout_cache)\n\t\treturn -ENOMEM;\n\n\tnfs4_layout_stateid_cache = kmem_cache_create(\"nfs4_layout_stateid\",\n\t\t\tsizeof(struct nfs4_layout_stateid), 0, 0, NULL);\n\tif (!nfs4_layout_stateid_cache) {\n\t\tkmem_cache_destroy(nfs4_layout_cache);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [
      "#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)"
    ],
    "globals_used": [
      "static struct kmem_cache *nfs4_layout_cache;",
      "static struct kmem_cache *nfs4_layout_stateid_cache;",
      "static struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "nfs4_layout_cache"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfs4_layout_stateid\"",
            "sizeof(struct nfs4_layout_stateid)",
            "0",
            "0",
            "NULL"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfs4_layout\"",
            "sizeof(struct nfs4_layout)",
            "0",
            "0",
            "NULL"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nfsd_devid_hash[i]"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\n#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)\n\nstatic struct kmem_cache *nfs4_layout_cache;\nstatic struct kmem_cache *nfs4_layout_stateid_cache;\nstatic struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];\n\nint\nnfsd4_init_pnfs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nfsd_devid_hash[i]);\n\n\tnfs4_layout_cache = kmem_cache_create(\"nfs4_layout\",\n\t\t\tsizeof(struct nfs4_layout), 0, 0, NULL);\n\tif (!nfs4_layout_cache)\n\t\treturn -ENOMEM;\n\n\tnfs4_layout_stateid_cache = kmem_cache_create(\"nfs4_layout_stateid\",\n\t\t\tsizeof(struct nfs4_layout_stateid), 0, 0, NULL);\n\tif (!nfs4_layout_stateid_cache) {\n\t\tkmem_cache_destroy(nfs4_layout_cache);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_layout_lm_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "670-676",
    "snippet": "static int\nnfsd4_layout_lm_change(struct file_lock *onlist, int arg,\n\t\tstruct list_head *dispose)\n{\n\tBUG_ON(!(arg & F_UNLCK));\n\treturn lease_modify(onlist, arg, dispose);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lease_modify",
          "args": [
            "onlist",
            "arg",
            "dispose"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "lease_modify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1303-1324",
          "snippet": "int lease_modify(struct file_lock *fl, int arg, struct list_head *dispose)\n{\n\tint error = assign_type(fl, arg);\n\n\tif (error)\n\t\treturn error;\n\tlease_clear_pending(fl, arg);\n\tlocks_wake_up_blocks(fl);\n\tif (arg == F_UNLCK) {\n\t\tstruct file *filp = fl->fl_file;\n\n\t\tf_delown(filp);\n\t\tfilp->f_owner.signum = 0;\n\t\tfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\n\t\tif (fl->fl_fasync != NULL) {\n\t\t\tprintk(KERN_ERR \"locks_delete_lock: fasync == %p\\n\", fl->fl_fasync);\n\t\t\tfl->fl_fasync = NULL;\n\t\t}\n\t\tlocks_delete_lock_ctx(fl, dispose);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint lease_modify(struct file_lock *fl, int arg, struct list_head *dispose)\n{\n\tint error = assign_type(fl, arg);\n\n\tif (error)\n\t\treturn error;\n\tlease_clear_pending(fl, arg);\n\tlocks_wake_up_blocks(fl);\n\tif (arg == F_UNLCK) {\n\t\tstruct file *filp = fl->fl_file;\n\n\t\tf_delown(filp);\n\t\tfilp->f_owner.signum = 0;\n\t\tfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\n\t\tif (fl->fl_fasync != NULL) {\n\t\t\tprintk(KERN_ERR \"locks_delete_lock: fasync == %p\\n\", fl->fl_fasync);\n\t\t\tfl->fl_fasync = NULL;\n\t\t}\n\t\tlocks_delete_lock_ctx(fl, dispose);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(arg & F_UNLCK)"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic int\nnfsd4_layout_lm_change(struct file_lock *onlist, int arg,\n\t\tstruct list_head *dispose)\n{\n\tBUG_ON(!(arg & F_UNLCK));\n\treturn lease_modify(onlist, arg, dispose);\n}"
  },
  {
    "function_name": "nfsd4_layout_lm_break",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "657-668",
    "snippet": "static bool\nnfsd4_layout_lm_break(struct file_lock *fl)\n{\n\t/*\n\t * We don't want the locks code to timeout the lease for us;\n\t * we'll remove it ourself if a layout isn't returned\n\t * in time:\n\t */\n\tfl->fl_break_time = 0;\n\tnfsd4_recall_file_layout(fl->fl_owner);\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_recall_file_layout",
          "args": [
            "fl->fl_owner"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_recall_file_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "283-304",
          "snippet": "static void\nnfsd4_recall_file_layout(struct nfs4_layout_stateid *ls)\n{\n\tspin_lock(&ls->ls_lock);\n\tif (ls->ls_recalled)\n\t\tgoto out_unlock;\n\n\tls->ls_recalled = true;\n\tatomic_inc(&ls->ls_stid.sc_file->fi_lo_recalls);\n\tif (list_empty(&ls->ls_layouts))\n\t\tgoto out_unlock;\n\n\ttrace_layout_recall(&ls->ls_stid.sc_stateid);\n\n\tatomic_inc(&ls->ls_stid.sc_count);\n\tupdate_stateid(&ls->ls_stid.sc_stateid);\n\tmemcpy(&ls->ls_recall_sid, &ls->ls_stid.sc_stateid, sizeof(stateid_t));\n\tnfsd4_run_cb(&ls->ls_recall);\n\nout_unlock:\n\tspin_unlock(&ls->ls_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic void\nnfsd4_recall_file_layout(struct nfs4_layout_stateid *ls)\n{\n\tspin_lock(&ls->ls_lock);\n\tif (ls->ls_recalled)\n\t\tgoto out_unlock;\n\n\tls->ls_recalled = true;\n\tatomic_inc(&ls->ls_stid.sc_file->fi_lo_recalls);\n\tif (list_empty(&ls->ls_layouts))\n\t\tgoto out_unlock;\n\n\ttrace_layout_recall(&ls->ls_stid.sc_stateid);\n\n\tatomic_inc(&ls->ls_stid.sc_count);\n\tupdate_stateid(&ls->ls_stid.sc_stateid);\n\tmemcpy(&ls->ls_recall_sid, &ls->ls_stid.sc_stateid, sizeof(stateid_t));\n\tnfsd4_run_cb(&ls->ls_recall);\n\nout_unlock:\n\tspin_unlock(&ls->ls_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic bool\nnfsd4_layout_lm_break(struct file_lock *fl)\n{\n\t/*\n\t * We don't want the locks code to timeout the lease for us;\n\t * we'll remove it ourself if a layout isn't returned\n\t * in time:\n\t */\n\tfl->fl_break_time = 0;\n\tnfsd4_recall_file_layout(fl->fl_owner);\n\treturn false;\n}"
  },
  {
    "function_name": "nfsd4_cb_layout_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "638-650",
    "snippet": "static void\nnfsd4_cb_layout_release(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_layout_stateid *ls =\n\t\tcontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\n\tLIST_HEAD(reaplist);\n\n\ttrace_layout_recall_release(&ls->ls_stid.sc_stateid);\n\n\tnfsd4_return_all_layouts(ls, &reaplist);\n\tnfsd4_free_layouts(&reaplist);\n\tnfs4_put_stid(&ls->ls_stid);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&ls->ls_stid"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_free_layouts",
          "args": [
            "&reaplist"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_free_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "418-429",
          "snippet": "static void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nfs4_layout_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic struct kmem_cache *nfs4_layout_cache;\n\nstatic void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_return_all_layouts",
          "args": [
            "ls",
            "&reaplist"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "535-542",
          "snippet": "static void\nnfsd4_return_all_layouts(struct nfs4_layout_stateid *ls,\n\t\tstruct list_head *reaplist)\n{\n\tspin_lock(&ls->ls_lock);\n\tlist_splice_init(&ls->ls_layouts, reaplist);\n\tspin_unlock(&ls->ls_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic void\nnfsd4_return_all_layouts(struct nfs4_layout_stateid *ls,\n\t\tstruct list_head *reaplist)\n{\n\tspin_lock(&ls->ls_lock);\n\tlist_splice_init(&ls->ls_layouts, reaplist);\n\tspin_unlock(&ls->ls_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_layout_recall_release",
          "args": [
            "&ls->ls_stid.sc_stateid"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cb",
            "structnfs4_layout_stateid",
            "ls_recall"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic void\nnfsd4_cb_layout_release(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_layout_stateid *ls =\n\t\tcontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\n\tLIST_HEAD(reaplist);\n\n\ttrace_layout_recall_release(&ls->ls_stid.sc_stateid);\n\n\tnfsd4_return_all_layouts(ls, &reaplist);\n\tnfsd4_free_layouts(&reaplist);\n\tnfs4_put_stid(&ls->ls_stid);\n}"
  },
  {
    "function_name": "nfsd4_cb_layout_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "606-636",
    "snippet": "static int\nnfsd4_cb_layout_done(struct nfsd4_callback *cb, struct rpc_task *task)\n{\n\tstruct nfs4_layout_stateid *ls =\n\t\tcontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\n\tLIST_HEAD(reaplist);\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\treturn 1;\n\tcase -NFS4ERR_NOMATCHING_LAYOUT:\n\t\ttrace_layout_recall_done(&ls->ls_stid.sc_stateid);\n\t\ttask->tk_status = 0;\n\t\treturn 1;\n\tcase -NFS4ERR_DELAY:\n\t\t/* Poll the client until it's done with the layout */\n\t\t/* FIXME: cap number of retries.\n\t\t * The pnfs standard states that we need to only expire\n\t\t * the client after at-least \"lease time\" .eg lease-time * 2\n\t\t * when failing to communicate a recall\n\t\t */\n\t\trpc_delay(task, HZ/100); /* 10 mili-seconds */\n\t\treturn 0;\n\tdefault:\n\t\t/*\n\t\t * Unknown error or non-responding client, we'll need to fence.\n\t\t */\n\t\tnfsd4_cb_layout_fail(ls);\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_cb_layout_fail",
          "args": [
            "ls"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cb_layout_fail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "574-604",
          "snippet": "static void\nnfsd4_cb_layout_fail(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_client *clp = ls->ls_stid.sc_client;\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\tchar *argv[8];\n\tint error;\n\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, addr_str, sizeof(addr_str));\n\n\tprintk(KERN_WARNING\n\t\t\"nfsd: client %s failed to respond to layout recall. \"\n\t\t\"  Fencing..\\n\", addr_str);\n\n\targv[0] = \"/sbin/nfsd-recall-failed\";\n\targv[1] = addr_str;\n\targv[2] = ls->ls_file->f_path.mnt->mnt_sb->s_id;\n\targv[3] = NULL;\n\n\terror = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (error) {\n\t\tprintk(KERN_ERR \"nfsd: fence failed for client %s: %d!\\n\",\n\t\t\taddr_str, error);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic void\nnfsd4_cb_layout_fail(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_client *clp = ls->ls_stid.sc_client;\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\tchar *argv[8];\n\tint error;\n\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, addr_str, sizeof(addr_str));\n\n\tprintk(KERN_WARNING\n\t\t\"nfsd: client %s failed to respond to layout recall. \"\n\t\t\"  Fencing..\\n\", addr_str);\n\n\targv[0] = \"/sbin/nfsd-recall-failed\";\n\targv[1] = addr_str;\n\targv[2] = ls->ls_file->f_path.mnt->mnt_sb->s_id;\n\targv[3] = NULL;\n\n\terror = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (error) {\n\t\tprintk(KERN_ERR \"nfsd: fence failed for client %s: %d!\\n\",\n\t\t\taddr_str, error);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_delay",
          "args": [
            "task",
            "HZ/100"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_layout_recall_done",
          "args": [
            "&ls->ls_stid.sc_stateid"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cb",
            "structnfs4_layout_stateid",
            "ls_recall"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic int\nnfsd4_cb_layout_done(struct nfsd4_callback *cb, struct rpc_task *task)\n{\n\tstruct nfs4_layout_stateid *ls =\n\t\tcontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\n\tLIST_HEAD(reaplist);\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\treturn 1;\n\tcase -NFS4ERR_NOMATCHING_LAYOUT:\n\t\ttrace_layout_recall_done(&ls->ls_stid.sc_stateid);\n\t\ttask->tk_status = 0;\n\t\treturn 1;\n\tcase -NFS4ERR_DELAY:\n\t\t/* Poll the client until it's done with the layout */\n\t\t/* FIXME: cap number of retries.\n\t\t * The pnfs standard states that we need to only expire\n\t\t * the client after at-least \"lease time\" .eg lease-time * 2\n\t\t * when failing to communicate a recall\n\t\t */\n\t\trpc_delay(task, HZ/100); /* 10 mili-seconds */\n\t\treturn 0;\n\tdefault:\n\t\t/*\n\t\t * Unknown error or non-responding client, we'll need to fence.\n\t\t */\n\t\tnfsd4_cb_layout_fail(ls);\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "nfsd4_cb_layout_fail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "574-604",
    "snippet": "static void\nnfsd4_cb_layout_fail(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_client *clp = ls->ls_stid.sc_client;\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\tchar *argv[8];\n\tint error;\n\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, addr_str, sizeof(addr_str));\n\n\tprintk(KERN_WARNING\n\t\t\"nfsd: client %s failed to respond to layout recall. \"\n\t\t\"  Fencing..\\n\", addr_str);\n\n\targv[0] = \"/sbin/nfsd-recall-failed\";\n\targv[1] = addr_str;\n\targv[2] = ls->ls_file->f_path.mnt->mnt_sb->s_id;\n\targv[3] = NULL;\n\n\terror = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (error) {\n\t\tprintk(KERN_ERR \"nfsd: fence failed for client %s: %d!\\n\",\n\t\t\taddr_str, error);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"nfsd: fence failed for client %s: %d!\\n\"",
            "addr_str",
            "error"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_usermodehelper",
          "args": [
            "argv[0]",
            "argv",
            "envp",
            "UMH_WAIT_PROC"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_ntop",
          "args": [
            "(struct sockaddr *)&clp->cl_addr",
            "addr_str",
            "sizeof(addr_str)"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic void\nnfsd4_cb_layout_fail(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_client *clp = ls->ls_stid.sc_client;\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\tchar *argv[8];\n\tint error;\n\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, addr_str, sizeof(addr_str));\n\n\tprintk(KERN_WARNING\n\t\t\"nfsd: client %s failed to respond to layout recall. \"\n\t\t\"  Fencing..\\n\", addr_str);\n\n\targv[0] = \"/sbin/nfsd-recall-failed\";\n\targv[1] = addr_str;\n\targv[2] = ls->ls_file->f_path.mnt->mnt_sb->s_id;\n\targv[3] = NULL;\n\n\terror = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (error) {\n\t\tprintk(KERN_ERR \"nfsd: fence failed for client %s: %d!\\n\",\n\t\t\taddr_str, error);\n\t}\n}"
  },
  {
    "function_name": "nfsd4_return_all_file_layouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "558-572",
    "snippet": "void\nnfsd4_return_all_file_layouts(struct nfs4_client *clp, struct nfs4_file *fp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry_safe(ls, n, &fp->fi_lo_states, ls_perfile) {\n\t\tif (ls->ls_stid.sc_client == clp)\n\t\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_free_layouts",
          "args": [
            "&reaplist"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_free_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "418-429",
          "snippet": "static void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nfs4_layout_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic struct kmem_cache *nfs4_layout_cache;\n\nstatic void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_return_all_layouts",
          "args": [
            "ls",
            "&reaplist"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "535-542",
          "snippet": "static void\nnfsd4_return_all_layouts(struct nfs4_layout_stateid *ls,\n\t\tstruct list_head *reaplist)\n{\n\tspin_lock(&ls->ls_lock);\n\tlist_splice_init(&ls->ls_layouts, reaplist);\n\tspin_unlock(&ls->ls_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic void\nnfsd4_return_all_layouts(struct nfs4_layout_stateid *ls,\n\t\tstruct list_head *reaplist)\n{\n\tspin_lock(&ls->ls_lock);\n\tlist_splice_init(&ls->ls_layouts, reaplist);\n\tspin_unlock(&ls->ls_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ls",
            "n",
            "&fp->fi_lo_states",
            "ls_perfile"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_file_layouts(struct nfs4_client *clp, struct nfs4_file *fp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry_safe(ls, n, &fp->fi_lo_states, ls_perfile) {\n\t\tif (ls->ls_stid.sc_client == clp)\n\t\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
  },
  {
    "function_name": "nfsd4_return_all_client_layouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "544-556",
    "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_free_layouts",
          "args": [
            "&reaplist"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_free_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "418-429",
          "snippet": "static void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nfs4_layout_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic struct kmem_cache *nfs4_layout_cache;\n\nstatic void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_return_all_layouts",
          "args": [
            "ls",
            "&reaplist"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "535-542",
          "snippet": "static void\nnfsd4_return_all_layouts(struct nfs4_layout_stateid *ls,\n\t\tstruct list_head *reaplist)\n{\n\tspin_lock(&ls->ls_lock);\n\tlist_splice_init(&ls->ls_layouts, reaplist);\n\tspin_unlock(&ls->ls_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic void\nnfsd4_return_all_layouts(struct nfs4_layout_stateid *ls,\n\t\tstruct list_head *reaplist)\n{\n\tspin_lock(&ls->ls_lock);\n\tlist_splice_init(&ls->ls_layouts, reaplist);\n\tspin_unlock(&ls->ls_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ls",
            "n",
            "&clp->cl_lo_states",
            "ls_perclnt"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
  },
  {
    "function_name": "nfsd4_return_all_layouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "535-542",
    "snippet": "static void\nnfsd4_return_all_layouts(struct nfs4_layout_stateid *ls,\n\t\tstruct list_head *reaplist)\n{\n\tspin_lock(&ls->ls_lock);\n\tlist_splice_init(&ls->ls_layouts, reaplist);\n\tspin_unlock(&ls->ls_lock);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&ls->ls_layouts",
            "reaplist"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic void\nnfsd4_return_all_layouts(struct nfs4_layout_stateid *ls,\n\t\tstruct list_head *reaplist)\n{\n\tspin_lock(&ls->ls_lock);\n\tlist_splice_init(&ls->ls_layouts, reaplist);\n\tspin_unlock(&ls->ls_lock);\n}"
  },
  {
    "function_name": "nfsd4_return_client_layouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "502-533",
    "snippet": "__be32\nnfsd4_return_client_layouts(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_layout *lp, *t;\n\tLIST_HEAD(reaplist);\n\n\tlrp->lrs_present = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt) {\n\t\tif (lrp->lr_return_type == RETURN_FSID &&\n\t\t    !fh_fsid_match(&ls->ls_stid.sc_file->fi_fhandle,\n\t\t\t\t   &cstate->current_fh.fh_handle))\n\t\t\tcontinue;\n\n\t\tspin_lock(&ls->ls_lock);\n\t\tlist_for_each_entry_safe(lp, t, &ls->ls_layouts, lo_perstate) {\n\t\t\tif (lrp->lr_seg.iomode == IOMODE_ANY ||\n\t\t\t    lrp->lr_seg.iomode == lp->lo_seg.iomode)\n\t\t\t\tlist_move_tail(&lp->lo_perstate, &reaplist);\n\t\t}\n\t\tspin_unlock(&ls->ls_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_free_layouts",
          "args": [
            "&reaplist"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_free_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "418-429",
          "snippet": "static void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nfs4_layout_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic struct kmem_cache *nfs4_layout_cache;\n\nstatic void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&lp->lo_perstate",
            "&reaplist"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lp",
            "t",
            "&ls->ls_layouts",
            "lo_perstate"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_fsid_match",
          "args": [
            "&ls->ls_stid.sc_file->fi_fhandle",
            "&cstate->current_fh.fh_handle"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "fh_fsid_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "199-206",
          "snippet": "static inline bool fh_fsid_match(struct knfsd_fh *fh1, struct knfsd_fh *fh2)\n{\n\tif (fh1->fh_fsid_type != fh2->fh_fsid_type)\n\t\treturn false;\n\tif (memcmp(fh1->fh_fsid, fh2->fh_fsid, key_len(fh1->fh_fsid_type)) != 0)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline bool fh_fsid_match(struct knfsd_fh *fh1, struct knfsd_fh *fh2)\n{\n\tif (fh1->fh_fsid_type != fh2->fh_fsid_type)\n\t\treturn false;\n\tif (memcmp(fh1->fh_fsid, fh2->fh_fsid, key_len(fh1->fh_fsid_type)) != 0)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ls",
            "n",
            "&clp->cl_lo_states",
            "ls_perclnt"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\n__be32\nnfsd4_return_client_layouts(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_layout *lp, *t;\n\tLIST_HEAD(reaplist);\n\n\tlrp->lrs_present = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt) {\n\t\tif (lrp->lr_return_type == RETURN_FSID &&\n\t\t    !fh_fsid_match(&ls->ls_stid.sc_file->fi_fhandle,\n\t\t\t\t   &cstate->current_fh.fh_handle))\n\t\t\tcontinue;\n\n\t\tspin_lock(&ls->ls_lock);\n\t\tlist_for_each_entry_safe(lp, t, &ls->ls_layouts, lo_perstate) {\n\t\t\tif (lrp->lr_seg.iomode == IOMODE_ANY ||\n\t\t\t    lrp->lr_seg.iomode == lp->lo_seg.iomode)\n\t\t\t\tlist_move_tail(&lp->lo_perstate, &reaplist);\n\t\t}\n\t\tspin_unlock(&ls->ls_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_return_file_layouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "457-500",
    "snippet": "__be32\nnfsd4_return_file_layouts(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_layout *lp, *n;\n\tLIST_HEAD(reaplist);\n\t__be32 nfserr;\n\tint found = 0;\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lrp->lr_sid,\n\t\t\t\t\t\tfalse, lrp->lr_layout_type,\n\t\t\t\t\t\t&ls);\n\tif (nfserr) {\n\t\ttrace_layout_return_lookup_fail(&lrp->lr_sid);\n\t\treturn nfserr;\n\t}\n\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry_safe(lp, n, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_overlapping(lp, &lrp->lr_seg)) {\n\t\t\tnfsd4_return_file_layout(lp, &lrp->lr_seg, &reaplist);\n\t\t\tfound++;\n\t\t}\n\t}\n\tif (!list_empty(&ls->ls_layouts)) {\n\t\tif (found) {\n\t\t\tupdate_stateid(&ls->ls_stid.sc_stateid);\n\t\t\tmemcpy(&lrp->lr_sid, &ls->ls_stid.sc_stateid,\n\t\t\t\tsizeof(stateid_t));\n\t\t}\n\t\tlrp->lrs_present = 1;\n\t} else {\n\t\ttrace_layoutstate_unhash(&ls->ls_stid.sc_stateid);\n\t\tnfs4_unhash_stid(&ls->ls_stid);\n\t\tlrp->lrs_present = 0;\n\t}\n\tspin_unlock(&ls->ls_lock);\n\n\tnfs4_put_stid(&ls->ls_stid);\n\tnfsd4_free_layouts(&reaplist);\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_free_layouts",
          "args": [
            "&reaplist"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_free_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "418-429",
          "snippet": "static void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nfs4_layout_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic struct kmem_cache *nfs4_layout_cache;\n\nstatic void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&ls->ls_stid"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_unhash_stid",
          "args": [
            "&ls->ls_stid"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_unhash_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "678-681",
          "snippet": "void nfs4_unhash_stid(struct nfs4_stid *s)\n{\n\ts->sc_type = 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfs4_unhash_stid(struct nfs4_stid *s)\n{\n\ts->sc_type = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_layoutstate_unhash",
          "args": [
            "&ls->ls_stid.sc_stateid"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lrp->lr_sid",
            "&ls->ls_stid.sc_stateid",
            "sizeof(stateid_t)"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_stateid",
          "args": [
            "&ls->ls_stid.sc_stateid"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "update_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "366-373",
          "snippet": "static inline void\nupdate_stateid(stateid_t *stateid)\n{\n\tstateid->si_generation++;\n\t/* Wraparound recommendation from 3530bis-13 9.1.3.2: */\n\tif (stateid->si_generation == 0)\n\t\tstateid->si_generation = 1;\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void\nupdate_stateid(stateid_t *stateid)\n{\n\tstateid->si_generation++;\n\t/* Wraparound recommendation from 3530bis-13 9.1.3.2: */\n\tif (stateid->si_generation == 0)\n\t\tstateid->si_generation = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ls->ls_layouts"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_return_file_layout",
          "args": [
            "lp",
            "&lrp->lr_seg",
            "&reaplist"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_file_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "457-500",
          "snippet": "__be32\nnfsd4_return_file_layouts(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_layout *lp, *n;\n\tLIST_HEAD(reaplist);\n\t__be32 nfserr;\n\tint found = 0;\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lrp->lr_sid,\n\t\t\t\t\t\tfalse, lrp->lr_layout_type,\n\t\t\t\t\t\t&ls);\n\tif (nfserr) {\n\t\ttrace_layout_return_lookup_fail(&lrp->lr_sid);\n\t\treturn nfserr;\n\t}\n\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry_safe(lp, n, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_overlapping(lp, &lrp->lr_seg)) {\n\t\t\tnfsd4_return_file_layout(lp, &lrp->lr_seg, &reaplist);\n\t\t\tfound++;\n\t\t}\n\t}\n\tif (!list_empty(&ls->ls_layouts)) {\n\t\tif (found) {\n\t\t\tupdate_stateid(&ls->ls_stid.sc_stateid);\n\t\t\tmemcpy(&lrp->lr_sid, &ls->ls_stid.sc_stateid,\n\t\t\t\tsizeof(stateid_t));\n\t\t}\n\t\tlrp->lrs_present = 1;\n\t} else {\n\t\ttrace_layoutstate_unhash(&ls->ls_stid.sc_stateid);\n\t\tnfs4_unhash_stid(&ls->ls_stid);\n\t\tlrp->lrs_present = 0;\n\t}\n\tspin_unlock(&ls->ls_lock);\n\n\tnfs4_put_stid(&ls->ls_stid);\n\tnfsd4_free_layouts(&reaplist);\n\treturn nfs_ok;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "layouts_overlapping",
          "args": [
            "lp",
            "&lrp->lr_seg"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "layouts_overlapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "322-332",
          "snippet": "static bool\nlayouts_overlapping(struct nfs4_layout *lo, struct nfsd4_layout_seg *s)\n{\n\tif (s->iomode != IOMODE_ANY && s->iomode != lo->lo_seg.iomode)\n\t\treturn false;\n\tif (layout_end(&lo->lo_seg) <= s->offset)\n\t\treturn false;\n\tif (layout_end(s) <= lo->lo_seg.offset)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic bool\nlayouts_overlapping(struct nfs4_layout *lo, struct nfsd4_layout_seg *s)\n{\n\tif (s->iomode != IOMODE_ANY && s->iomode != lo->lo_seg.iomode)\n\t\treturn false;\n\tif (layout_end(&lo->lo_seg) <= s->offset)\n\t\treturn false;\n\tif (layout_end(s) <= lo->lo_seg.offset)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lp",
            "n",
            "&ls->ls_layouts",
            "lo_perstate"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_layout_return_lookup_fail",
          "args": [
            "&lrp->lr_sid"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_preprocess_layout_stateid",
          "args": [
            "rqstp",
            "cstate",
            "&lrp->lr_sid",
            "false",
            "lrp->lr_layout_type",
            "&ls"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_preprocess_layout_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "233-281",
          "snippet": "__be32\nnfsd4_preprocess_layout_stateid(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, stateid_t *stateid,\n\t\tbool create, u32 layout_type, struct nfs4_layout_stateid **lsp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stid;\n\tunsigned char typemask = NFS4_LAYOUT_STID;\n\t__be32 status;\n\n\tif (create)\n\t\ttypemask |= (NFS4_OPEN_STID | NFS4_LOCK_STID | NFS4_DELEG_STID);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &stid,\n\t\t\tnet_generic(SVC_NET(rqstp), nfsd_net_id));\n\tif (status)\n\t\tgoto out;\n\n\tif (!fh_match(&cstate->current_fh.fh_handle,\n\t\t      &stid->sc_file->fi_fhandle)) {\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out_put_stid;\n\t}\n\n\tif (stid->sc_type != NFS4_LAYOUT_STID) {\n\t\tls = nfsd4_alloc_layout_stateid(cstate, stid, layout_type);\n\t\tnfs4_put_stid(stid);\n\n\t\tstatus = nfserr_jukebox;\n\t\tif (!ls)\n\t\t\tgoto out;\n\t} else {\n\t\tls = container_of(stid, struct nfs4_layout_stateid, ls_stid);\n\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (stateid->si_generation > stid->sc_stateid.si_generation)\n\t\t\tgoto out_put_stid;\n\t\tif (layout_type != ls->ls_layout_type)\n\t\t\tgoto out_put_stid;\n\t}\n\n\t*lsp = ls;\n\treturn 0;\n\nout_put_stid:\n\tnfs4_put_stid(stid);\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\n__be32\nnfsd4_preprocess_layout_stateid(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, stateid_t *stateid,\n\t\tbool create, u32 layout_type, struct nfs4_layout_stateid **lsp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stid;\n\tunsigned char typemask = NFS4_LAYOUT_STID;\n\t__be32 status;\n\n\tif (create)\n\t\ttypemask |= (NFS4_OPEN_STID | NFS4_LOCK_STID | NFS4_DELEG_STID);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &stid,\n\t\t\tnet_generic(SVC_NET(rqstp), nfsd_net_id));\n\tif (status)\n\t\tgoto out;\n\n\tif (!fh_match(&cstate->current_fh.fh_handle,\n\t\t      &stid->sc_file->fi_fhandle)) {\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out_put_stid;\n\t}\n\n\tif (stid->sc_type != NFS4_LAYOUT_STID) {\n\t\tls = nfsd4_alloc_layout_stateid(cstate, stid, layout_type);\n\t\tnfs4_put_stid(stid);\n\n\t\tstatus = nfserr_jukebox;\n\t\tif (!ls)\n\t\t\tgoto out;\n\t} else {\n\t\tls = container_of(stid, struct nfs4_layout_stateid, ls_stid);\n\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (stateid->si_generation > stid->sc_stateid.si_generation)\n\t\t\tgoto out_put_stid;\n\t\tif (layout_type != ls->ls_layout_type)\n\t\t\tgoto out_put_stid;\n\t}\n\n\t*lsp = ls;\n\treturn 0;\n\nout_put_stid:\n\tnfs4_put_stid(stid);\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\n__be32\nnfsd4_return_file_layouts(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_layout *lp, *n;\n\tLIST_HEAD(reaplist);\n\t__be32 nfserr;\n\tint found = 0;\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lrp->lr_sid,\n\t\t\t\t\t\tfalse, lrp->lr_layout_type,\n\t\t\t\t\t\t&ls);\n\tif (nfserr) {\n\t\ttrace_layout_return_lookup_fail(&lrp->lr_sid);\n\t\treturn nfserr;\n\t}\n\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry_safe(lp, n, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_overlapping(lp, &lrp->lr_seg)) {\n\t\t\tnfsd4_return_file_layout(lp, &lrp->lr_seg, &reaplist);\n\t\t\tfound++;\n\t\t}\n\t}\n\tif (!list_empty(&ls->ls_layouts)) {\n\t\tif (found) {\n\t\t\tupdate_stateid(&ls->ls_stid.sc_stateid);\n\t\t\tmemcpy(&lrp->lr_sid, &ls->ls_stid.sc_stateid,\n\t\t\t\tsizeof(stateid_t));\n\t\t}\n\t\tlrp->lrs_present = 1;\n\t} else {\n\t\ttrace_layoutstate_unhash(&ls->ls_stid.sc_stateid);\n\t\tnfs4_unhash_stid(&ls->ls_stid);\n\t\tlrp->lrs_present = 0;\n\t}\n\tspin_unlock(&ls->ls_lock);\n\n\tnfs4_put_stid(&ls->ls_stid);\n\tnfsd4_free_layouts(&reaplist);\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_return_file_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "431-455",
    "snippet": "static void\nnfsd4_return_file_layout(struct nfs4_layout *lp, struct nfsd4_layout_seg *seg,\n\t\tstruct list_head *reaplist)\n{\n\tstruct nfsd4_layout_seg *lo = &lp->lo_seg;\n\tu64 end = layout_end(lo);\n\n\tif (seg->offset <= lo->offset) {\n\t\tif (layout_end(seg) >= end) {\n\t\t\tlist_move_tail(&lp->lo_perstate, reaplist);\n\t\t\treturn;\n\t\t}\n\t\tend = seg->offset;\n\t} else {\n\t\t/* retain the whole layout segment on a split. */\n\t\tif (layout_end(seg) < end) {\n\t\t\tdprintk(\"%s: split not supported\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\n\t\tlo->offset = layout_end(seg);\n\t}\n\n\tlayout_update_len(lo, end);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "layout_update_len",
          "args": [
            "lo",
            "end"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "layout_update_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "313-320",
          "snippet": "static void\nlayout_update_len(struct nfsd4_layout_seg *lo, u64 end)\n{\n\tif (end == NFS4_MAX_UINT64)\n\t\tlo->length = NFS4_MAX_UINT64;\n\telse\n\t\tlo->length = end - lo->offset;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic void\nlayout_update_len(struct nfsd4_layout_seg *lo, u64 end)\n{\n\tif (end == NFS4_MAX_UINT64)\n\t\tlo->length = NFS4_MAX_UINT64;\n\telse\n\t\tlo->length = end - lo->offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "layout_end",
          "args": [
            "seg"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "layout_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "306-311",
          "snippet": "static inline u64\nlayout_end(struct nfsd4_layout_seg *seg)\n{\n\tu64 end = seg->offset + seg->length;\n\treturn end >= seg->offset ? end : NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic inline u64\nlayout_end(struct nfsd4_layout_seg *seg)\n{\n\tu64 end = seg->offset + seg->length;\n\treturn end >= seg->offset ? end : NFS4_MAX_UINT64;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: split not supported\\n\"",
            "__func__"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&lp->lo_perstate",
            "reaplist"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic void\nnfsd4_return_file_layout(struct nfs4_layout *lp, struct nfsd4_layout_seg *seg,\n\t\tstruct list_head *reaplist)\n{\n\tstruct nfsd4_layout_seg *lo = &lp->lo_seg;\n\tu64 end = layout_end(lo);\n\n\tif (seg->offset <= lo->offset) {\n\t\tif (layout_end(seg) >= end) {\n\t\t\tlist_move_tail(&lp->lo_perstate, reaplist);\n\t\t\treturn;\n\t\t}\n\t\tend = seg->offset;\n\t} else {\n\t\t/* retain the whole layout segment on a split. */\n\t\tif (layout_end(seg) < end) {\n\t\t\tdprintk(\"%s: split not supported\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\n\t\tlo->offset = layout_end(seg);\n\t}\n\n\tlayout_update_len(lo, end);\n}"
  },
  {
    "function_name": "nfsd4_free_layouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "418-429",
    "snippet": "static void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nfs4_layout_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nfs4_layout_cache",
            "lp"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&lp->lo_state->ls_stid"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&lp->lo_perstate"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "reaplist",
            "structnfs4_layout",
            "lo_perstate"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "reaplist"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic struct kmem_cache *nfs4_layout_cache;\n\nstatic void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}"
  },
  {
    "function_name": "nfsd4_insert_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "368-416",
    "snippet": "__be32\nnfsd4_insert_layout(struct nfsd4_layoutget *lgp, struct nfs4_layout_stateid *ls)\n{\n\tstruct nfsd4_layout_seg *seg = &lgp->lg_seg;\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\tstruct nfs4_layout *lp, *new = NULL;\n\t__be32 nfserr;\n\n\tspin_lock(&fp->fi_lock);\n\tnfserr = nfsd4_recall_conflict(ls);\n\tif (nfserr)\n\t\tgoto out;\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry(lp, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_try_merge(&lp->lo_seg, seg))\n\t\t\tgoto done;\n\t}\n\tspin_unlock(&ls->ls_lock);\n\tspin_unlock(&fp->fi_lock);\n\n\tnew = kmem_cache_alloc(nfs4_layout_cache, GFP_KERNEL);\n\tif (!new)\n\t\treturn nfserr_jukebox;\n\tmemcpy(&new->lo_seg, seg, sizeof(lp->lo_seg));\n\tnew->lo_state = ls;\n\n\tspin_lock(&fp->fi_lock);\n\tnfserr = nfsd4_recall_conflict(ls);\n\tif (nfserr)\n\t\tgoto out;\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry(lp, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_try_merge(&lp->lo_seg, seg))\n\t\t\tgoto done;\n\t}\n\n\tatomic_inc(&ls->ls_stid.sc_count);\n\tlist_add_tail(&new->lo_perstate, &ls->ls_layouts);\n\tnew = NULL;\ndone:\n\tupdate_stateid(&ls->ls_stid.sc_stateid);\n\tmemcpy(&lgp->lg_sid, &ls->ls_stid.sc_stateid, sizeof(stateid_t));\n\tspin_unlock(&ls->ls_lock);\nout:\n\tspin_unlock(&fp->fi_lock);\n\tif (new)\n\t\tkmem_cache_free(nfs4_layout_cache, new);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nfs4_layout_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nfs4_layout_cache",
            "new"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lgp->lg_sid",
            "&ls->ls_stid.sc_stateid",
            "sizeof(stateid_t)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_stateid",
          "args": [
            "&ls->ls_stid.sc_stateid"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "update_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "366-373",
          "snippet": "static inline void\nupdate_stateid(stateid_t *stateid)\n{\n\tstateid->si_generation++;\n\t/* Wraparound recommendation from 3530bis-13 9.1.3.2: */\n\tif (stateid->si_generation == 0)\n\t\tstateid->si_generation = 1;\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void\nupdate_stateid(stateid_t *stateid)\n{\n\tstateid->si_generation++;\n\t/* Wraparound recommendation from 3530bis-13 9.1.3.2: */\n\tif (stateid->si_generation == 0)\n\t\tstateid->si_generation = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new->lo_perstate",
            "&ls->ls_layouts"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ls->ls_stid.sc_count"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layouts_try_merge",
          "args": [
            "&lp->lo_seg",
            "seg"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "layouts_try_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "334-347",
          "snippet": "static bool\nlayouts_try_merge(struct nfsd4_layout_seg *lo, struct nfsd4_layout_seg *new)\n{\n\tif (lo->iomode != new->iomode)\n\t\treturn false;\n\tif (layout_end(new) < lo->offset)\n\t\treturn false;\n\tif (layout_end(lo) < new->offset)\n\t\treturn false;\n\n\tlo->offset = min(lo->offset, new->offset);\n\tlayout_update_len(lo, max(layout_end(lo), layout_end(new)));\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic bool\nlayouts_try_merge(struct nfsd4_layout_seg *lo, struct nfsd4_layout_seg *new)\n{\n\tif (lo->iomode != new->iomode)\n\t\treturn false;\n\tif (layout_end(new) < lo->offset)\n\t\treturn false;\n\tif (layout_end(lo) < new->offset)\n\t\treturn false;\n\n\tlo->offset = min(lo->offset, new->offset);\n\tlayout_update_len(lo, max(layout_end(lo), layout_end(new)));\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lp",
            "&ls->ls_layouts",
            "lo_perstate"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_recall_conflict",
          "args": [
            "ls"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_recall_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "349-366",
          "snippet": "static __be32\nnfsd4_recall_conflict(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\tstruct nfs4_layout_stateid *l, *n;\n\t__be32 nfserr = nfs_ok;\n\n\tassert_spin_locked(&fp->fi_lock);\n\n\tlist_for_each_entry_safe(l, n, &fp->fi_lo_states, ls_perfile) {\n\t\tif (l != ls) {\n\t\t\tnfsd4_recall_file_layout(l);\n\t\t\tnfserr = nfserr_recallconflict;\n\t\t}\n\t}\n\n\treturn nfserr;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic __be32\nnfsd4_recall_conflict(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\tstruct nfs4_layout_stateid *l, *n;\n\t__be32 nfserr = nfs_ok;\n\n\tassert_spin_locked(&fp->fi_lock);\n\n\tlist_for_each_entry_safe(l, n, &fp->fi_lo_states, ls_perfile) {\n\t\tif (l != ls) {\n\t\t\tnfsd4_recall_file_layout(l);\n\t\t\tnfserr = nfserr_recallconflict;\n\t\t}\n\t}\n\n\treturn nfserr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&new->lo_seg",
            "seg",
            "sizeof(lp->lo_seg)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "nfs4_layout_cache",
            "GFP_KERNEL"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lp",
            "&ls->ls_layouts",
            "lo_perstate"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic struct kmem_cache *nfs4_layout_cache;\n\n__be32\nnfsd4_insert_layout(struct nfsd4_layoutget *lgp, struct nfs4_layout_stateid *ls)\n{\n\tstruct nfsd4_layout_seg *seg = &lgp->lg_seg;\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\tstruct nfs4_layout *lp, *new = NULL;\n\t__be32 nfserr;\n\n\tspin_lock(&fp->fi_lock);\n\tnfserr = nfsd4_recall_conflict(ls);\n\tif (nfserr)\n\t\tgoto out;\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry(lp, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_try_merge(&lp->lo_seg, seg))\n\t\t\tgoto done;\n\t}\n\tspin_unlock(&ls->ls_lock);\n\tspin_unlock(&fp->fi_lock);\n\n\tnew = kmem_cache_alloc(nfs4_layout_cache, GFP_KERNEL);\n\tif (!new)\n\t\treturn nfserr_jukebox;\n\tmemcpy(&new->lo_seg, seg, sizeof(lp->lo_seg));\n\tnew->lo_state = ls;\n\n\tspin_lock(&fp->fi_lock);\n\tnfserr = nfsd4_recall_conflict(ls);\n\tif (nfserr)\n\t\tgoto out;\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry(lp, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_try_merge(&lp->lo_seg, seg))\n\t\t\tgoto done;\n\t}\n\n\tatomic_inc(&ls->ls_stid.sc_count);\n\tlist_add_tail(&new->lo_perstate, &ls->ls_layouts);\n\tnew = NULL;\ndone:\n\tupdate_stateid(&ls->ls_stid.sc_stateid);\n\tmemcpy(&lgp->lg_sid, &ls->ls_stid.sc_stateid, sizeof(stateid_t));\n\tspin_unlock(&ls->ls_lock);\nout:\n\tspin_unlock(&fp->fi_lock);\n\tif (new)\n\t\tkmem_cache_free(nfs4_layout_cache, new);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_recall_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "349-366",
    "snippet": "static __be32\nnfsd4_recall_conflict(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\tstruct nfs4_layout_stateid *l, *n;\n\t__be32 nfserr = nfs_ok;\n\n\tassert_spin_locked(&fp->fi_lock);\n\n\tlist_for_each_entry_safe(l, n, &fp->fi_lo_states, ls_perfile) {\n\t\tif (l != ls) {\n\t\t\tnfsd4_recall_file_layout(l);\n\t\t\tnfserr = nfserr_recallconflict;\n\t\t}\n\t}\n\n\treturn nfserr;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_recall_file_layout",
          "args": [
            "l"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_recall_file_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "283-304",
          "snippet": "static void\nnfsd4_recall_file_layout(struct nfs4_layout_stateid *ls)\n{\n\tspin_lock(&ls->ls_lock);\n\tif (ls->ls_recalled)\n\t\tgoto out_unlock;\n\n\tls->ls_recalled = true;\n\tatomic_inc(&ls->ls_stid.sc_file->fi_lo_recalls);\n\tif (list_empty(&ls->ls_layouts))\n\t\tgoto out_unlock;\n\n\ttrace_layout_recall(&ls->ls_stid.sc_stateid);\n\n\tatomic_inc(&ls->ls_stid.sc_count);\n\tupdate_stateid(&ls->ls_stid.sc_stateid);\n\tmemcpy(&ls->ls_recall_sid, &ls->ls_stid.sc_stateid, sizeof(stateid_t));\n\tnfsd4_run_cb(&ls->ls_recall);\n\nout_unlock:\n\tspin_unlock(&ls->ls_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic void\nnfsd4_recall_file_layout(struct nfs4_layout_stateid *ls)\n{\n\tspin_lock(&ls->ls_lock);\n\tif (ls->ls_recalled)\n\t\tgoto out_unlock;\n\n\tls->ls_recalled = true;\n\tatomic_inc(&ls->ls_stid.sc_file->fi_lo_recalls);\n\tif (list_empty(&ls->ls_layouts))\n\t\tgoto out_unlock;\n\n\ttrace_layout_recall(&ls->ls_stid.sc_stateid);\n\n\tatomic_inc(&ls->ls_stid.sc_count);\n\tupdate_stateid(&ls->ls_stid.sc_stateid);\n\tmemcpy(&ls->ls_recall_sid, &ls->ls_stid.sc_stateid, sizeof(stateid_t));\n\tnfsd4_run_cb(&ls->ls_recall);\n\nout_unlock:\n\tspin_unlock(&ls->ls_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "l",
            "n",
            "&fp->fi_lo_states",
            "ls_perfile"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic __be32\nnfsd4_recall_conflict(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\tstruct nfs4_layout_stateid *l, *n;\n\t__be32 nfserr = nfs_ok;\n\n\tassert_spin_locked(&fp->fi_lock);\n\n\tlist_for_each_entry_safe(l, n, &fp->fi_lo_states, ls_perfile) {\n\t\tif (l != ls) {\n\t\t\tnfsd4_recall_file_layout(l);\n\t\t\tnfserr = nfserr_recallconflict;\n\t\t}\n\t}\n\n\treturn nfserr;\n}"
  },
  {
    "function_name": "layouts_try_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "334-347",
    "snippet": "static bool\nlayouts_try_merge(struct nfsd4_layout_seg *lo, struct nfsd4_layout_seg *new)\n{\n\tif (lo->iomode != new->iomode)\n\t\treturn false;\n\tif (layout_end(new) < lo->offset)\n\t\treturn false;\n\tif (layout_end(lo) < new->offset)\n\t\treturn false;\n\n\tlo->offset = min(lo->offset, new->offset);\n\tlayout_update_len(lo, max(layout_end(lo), layout_end(new)));\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "layout_update_len",
          "args": [
            "lo",
            "max(layout_end(lo), layout_end(new))"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "layout_update_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "313-320",
          "snippet": "static void\nlayout_update_len(struct nfsd4_layout_seg *lo, u64 end)\n{\n\tif (end == NFS4_MAX_UINT64)\n\t\tlo->length = NFS4_MAX_UINT64;\n\telse\n\t\tlo->length = end - lo->offset;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic void\nlayout_update_len(struct nfsd4_layout_seg *lo, u64 end)\n{\n\tif (end == NFS4_MAX_UINT64)\n\t\tlo->length = NFS4_MAX_UINT64;\n\telse\n\t\tlo->length = end - lo->offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "layout_end(lo)",
            "layout_end(new)"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_max_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "2299-2309",
          "snippet": "int nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tstruct nfsd4_operation *opdesc;\n\tnfsd4op_rsize estimator;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\topdesc = OPDESC(op);\n\testimator = opdesc->op_rsize_bop;\n\treturn estimator ? estimator(rqstp, op) : PAGE_SIZE;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define op_encode_hdr_size\t\t(2)"
          ],
          "globals_used": [
            "static const char *nfsd4_op_name(unsigned opnum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_hdr_size\t\t(2)\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nint nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tstruct nfsd4_operation *opdesc;\n\tnfsd4op_rsize estimator;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\topdesc = OPDESC(op);\n\testimator = opdesc->op_rsize_bop;\n\treturn estimator ? estimator(rqstp, op) : PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "layout_end",
          "args": [
            "new"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "layout_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "306-311",
          "snippet": "static inline u64\nlayout_end(struct nfsd4_layout_seg *seg)\n{\n\tu64 end = seg->offset + seg->length;\n\treturn end >= seg->offset ? end : NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic inline u64\nlayout_end(struct nfsd4_layout_seg *seg)\n{\n\tu64 end = seg->offset + seg->length;\n\treturn end >= seg->offset ? end : NFS4_MAX_UINT64;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "lo->offset",
            "new->offset"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "152-169",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic bool\nlayouts_try_merge(struct nfsd4_layout_seg *lo, struct nfsd4_layout_seg *new)\n{\n\tif (lo->iomode != new->iomode)\n\t\treturn false;\n\tif (layout_end(new) < lo->offset)\n\t\treturn false;\n\tif (layout_end(lo) < new->offset)\n\t\treturn false;\n\n\tlo->offset = min(lo->offset, new->offset);\n\tlayout_update_len(lo, max(layout_end(lo), layout_end(new)));\n\treturn true;\n}"
  },
  {
    "function_name": "layouts_overlapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "322-332",
    "snippet": "static bool\nlayouts_overlapping(struct nfs4_layout *lo, struct nfsd4_layout_seg *s)\n{\n\tif (s->iomode != IOMODE_ANY && s->iomode != lo->lo_seg.iomode)\n\t\treturn false;\n\tif (layout_end(&lo->lo_seg) <= s->offset)\n\t\treturn false;\n\tif (layout_end(s) <= lo->lo_seg.offset)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "layout_end",
          "args": [
            "s"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "layout_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "306-311",
          "snippet": "static inline u64\nlayout_end(struct nfsd4_layout_seg *seg)\n{\n\tu64 end = seg->offset + seg->length;\n\treturn end >= seg->offset ? end : NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic inline u64\nlayout_end(struct nfsd4_layout_seg *seg)\n{\n\tu64 end = seg->offset + seg->length;\n\treturn end >= seg->offset ? end : NFS4_MAX_UINT64;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic bool\nlayouts_overlapping(struct nfs4_layout *lo, struct nfsd4_layout_seg *s)\n{\n\tif (s->iomode != IOMODE_ANY && s->iomode != lo->lo_seg.iomode)\n\t\treturn false;\n\tif (layout_end(&lo->lo_seg) <= s->offset)\n\t\treturn false;\n\tif (layout_end(s) <= lo->lo_seg.offset)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "layout_update_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "313-320",
    "snippet": "static void\nlayout_update_len(struct nfsd4_layout_seg *lo, u64 end)\n{\n\tif (end == NFS4_MAX_UINT64)\n\t\tlo->length = NFS4_MAX_UINT64;\n\telse\n\t\tlo->length = end - lo->offset;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic void\nlayout_update_len(struct nfsd4_layout_seg *lo, u64 end)\n{\n\tif (end == NFS4_MAX_UINT64)\n\t\tlo->length = NFS4_MAX_UINT64;\n\telse\n\t\tlo->length = end - lo->offset;\n}"
  },
  {
    "function_name": "layout_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "306-311",
    "snippet": "static inline u64\nlayout_end(struct nfsd4_layout_seg *seg)\n{\n\tu64 end = seg->offset + seg->length;\n\treturn end >= seg->offset ? end : NFS4_MAX_UINT64;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic inline u64\nlayout_end(struct nfsd4_layout_seg *seg)\n{\n\tu64 end = seg->offset + seg->length;\n\treturn end >= seg->offset ? end : NFS4_MAX_UINT64;\n}"
  },
  {
    "function_name": "nfsd4_recall_file_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "283-304",
    "snippet": "static void\nnfsd4_recall_file_layout(struct nfs4_layout_stateid *ls)\n{\n\tspin_lock(&ls->ls_lock);\n\tif (ls->ls_recalled)\n\t\tgoto out_unlock;\n\n\tls->ls_recalled = true;\n\tatomic_inc(&ls->ls_stid.sc_file->fi_lo_recalls);\n\tif (list_empty(&ls->ls_layouts))\n\t\tgoto out_unlock;\n\n\ttrace_layout_recall(&ls->ls_stid.sc_stateid);\n\n\tatomic_inc(&ls->ls_stid.sc_count);\n\tupdate_stateid(&ls->ls_stid.sc_stateid);\n\tmemcpy(&ls->ls_recall_sid, &ls->ls_stid.sc_stateid, sizeof(stateid_t));\n\tnfsd4_run_cb(&ls->ls_recall);\n\nout_unlock:\n\tspin_unlock(&ls->ls_lock);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_run_cb",
          "args": [
            "&ls->ls_recall"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_run_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "1105-1108",
          "snippet": "void nfsd4_run_cb(struct nfsd4_callback *cb)\n{\n\tqueue_work(callback_wq, &cb->cb_work);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_run_cb(struct nfsd4_callback *cb)\n{\n\tqueue_work(callback_wq, &cb->cb_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&ls->ls_recall_sid",
            "&ls->ls_stid.sc_stateid",
            "sizeof(stateid_t)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_stateid",
          "args": [
            "&ls->ls_stid.sc_stateid"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "update_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "366-373",
          "snippet": "static inline void\nupdate_stateid(stateid_t *stateid)\n{\n\tstateid->si_generation++;\n\t/* Wraparound recommendation from 3530bis-13 9.1.3.2: */\n\tif (stateid->si_generation == 0)\n\t\tstateid->si_generation = 1;\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void\nupdate_stateid(stateid_t *stateid)\n{\n\tstateid->si_generation++;\n\t/* Wraparound recommendation from 3530bis-13 9.1.3.2: */\n\tif (stateid->si_generation == 0)\n\t\tstateid->si_generation = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ls->ls_stid.sc_count"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_layout_recall",
          "args": [
            "&ls->ls_stid.sc_stateid"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ls->ls_layouts"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ls->ls_stid.sc_file->fi_lo_recalls"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic void\nnfsd4_recall_file_layout(struct nfs4_layout_stateid *ls)\n{\n\tspin_lock(&ls->ls_lock);\n\tif (ls->ls_recalled)\n\t\tgoto out_unlock;\n\n\tls->ls_recalled = true;\n\tatomic_inc(&ls->ls_stid.sc_file->fi_lo_recalls);\n\tif (list_empty(&ls->ls_layouts))\n\t\tgoto out_unlock;\n\n\ttrace_layout_recall(&ls->ls_stid.sc_stateid);\n\n\tatomic_inc(&ls->ls_stid.sc_count);\n\tupdate_stateid(&ls->ls_stid.sc_stateid);\n\tmemcpy(&ls->ls_recall_sid, &ls->ls_stid.sc_stateid, sizeof(stateid_t));\n\tnfsd4_run_cb(&ls->ls_recall);\n\nout_unlock:\n\tspin_unlock(&ls->ls_lock);\n}"
  },
  {
    "function_name": "nfsd4_preprocess_layout_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "233-281",
    "snippet": "__be32\nnfsd4_preprocess_layout_stateid(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, stateid_t *stateid,\n\t\tbool create, u32 layout_type, struct nfs4_layout_stateid **lsp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stid;\n\tunsigned char typemask = NFS4_LAYOUT_STID;\n\t__be32 status;\n\n\tif (create)\n\t\ttypemask |= (NFS4_OPEN_STID | NFS4_LOCK_STID | NFS4_DELEG_STID);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &stid,\n\t\t\tnet_generic(SVC_NET(rqstp), nfsd_net_id));\n\tif (status)\n\t\tgoto out;\n\n\tif (!fh_match(&cstate->current_fh.fh_handle,\n\t\t      &stid->sc_file->fi_fhandle)) {\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out_put_stid;\n\t}\n\n\tif (stid->sc_type != NFS4_LAYOUT_STID) {\n\t\tls = nfsd4_alloc_layout_stateid(cstate, stid, layout_type);\n\t\tnfs4_put_stid(stid);\n\n\t\tstatus = nfserr_jukebox;\n\t\tif (!ls)\n\t\t\tgoto out;\n\t} else {\n\t\tls = container_of(stid, struct nfs4_layout_stateid, ls_stid);\n\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (stateid->si_generation > stid->sc_stateid.si_generation)\n\t\t\tgoto out_put_stid;\n\t\tif (layout_type != ls->ls_layout_type)\n\t\t\tgoto out_put_stid;\n\t}\n\n\t*lsp = ls;\n\treturn 0;\n\nout_put_stid:\n\tnfs4_put_stid(stid);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "stid"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "stid",
            "structnfs4_layout_stateid",
            "ls_stid"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_alloc_layout_stateid",
          "args": [
            "cstate",
            "stid",
            "layout_type"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_alloc_layout_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "183-231",
          "snippet": "static struct nfs4_layout_stateid *\nnfsd4_alloc_layout_stateid(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stid *parent, u32 layout_type)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_file *fp = parent->sc_file;\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stp;\n\n\tstp = nfs4_alloc_stid(cstate->clp, nfs4_layout_stateid_cache);\n\tif (!stp)\n\t\treturn NULL;\n\tstp->sc_free = nfsd4_free_layout_stateid;\n\tget_nfs4_file(fp);\n\tstp->sc_file = fp;\n\n\tls = layoutstateid(stp);\n\tINIT_LIST_HEAD(&ls->ls_perclnt);\n\tINIT_LIST_HEAD(&ls->ls_perfile);\n\tspin_lock_init(&ls->ls_lock);\n\tINIT_LIST_HEAD(&ls->ls_layouts);\n\tls->ls_layout_type = layout_type;\n\tnfsd4_init_cb(&ls->ls_recall, clp, &nfsd4_cb_layout_ops,\n\t\t\tNFSPROC4_CLNT_CB_LAYOUT);\n\n\tif (parent->sc_type == NFS4_DELEG_STID)\n\t\tls->ls_file = get_file(fp->fi_deleg_file);\n\telse\n\t\tls->ls_file = find_any_file(fp);\n\tBUG_ON(!ls->ls_file);\n\n\tif (nfsd4_layout_setlease(ls)) {\n\t\tput_nfs4_file(fp);\n\t\tkmem_cache_free(nfs4_layout_stateid_cache, ls);\n\t\treturn NULL;\n\t}\n\n\tspin_lock(&clp->cl_lock);\n\tstp->sc_type = NFS4_LAYOUT_STID;\n\tlist_add(&ls->ls_perclnt, &clp->cl_lo_states);\n\tspin_unlock(&clp->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&ls->ls_perfile, &fp->fi_lo_states);\n\tspin_unlock(&fp->fi_lock);\n\n\ttrace_layoutstate_alloc(&ls->ls_stid.sc_stateid);\n\treturn ls;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nfs4_layout_stateid_cache;",
            "static struct nfsd4_callback_ops nfsd4_cb_layout_ops;",
            "static struct nfsd4_callback_ops nfsd4_cb_layout_ops = {\n\t.done\t\t= nfsd4_cb_layout_done,\n\t.release\t= nfsd4_cb_layout_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic struct kmem_cache *nfs4_layout_stateid_cache;\nstatic struct nfsd4_callback_ops nfsd4_cb_layout_ops;\nstatic struct nfsd4_callback_ops nfsd4_cb_layout_ops = {\n\t.done\t\t= nfsd4_cb_layout_done,\n\t.release\t= nfsd4_cb_layout_release,\n};\n\nstatic struct nfs4_layout_stateid *\nnfsd4_alloc_layout_stateid(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stid *parent, u32 layout_type)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_file *fp = parent->sc_file;\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stp;\n\n\tstp = nfs4_alloc_stid(cstate->clp, nfs4_layout_stateid_cache);\n\tif (!stp)\n\t\treturn NULL;\n\tstp->sc_free = nfsd4_free_layout_stateid;\n\tget_nfs4_file(fp);\n\tstp->sc_file = fp;\n\n\tls = layoutstateid(stp);\n\tINIT_LIST_HEAD(&ls->ls_perclnt);\n\tINIT_LIST_HEAD(&ls->ls_perfile);\n\tspin_lock_init(&ls->ls_lock);\n\tINIT_LIST_HEAD(&ls->ls_layouts);\n\tls->ls_layout_type = layout_type;\n\tnfsd4_init_cb(&ls->ls_recall, clp, &nfsd4_cb_layout_ops,\n\t\t\tNFSPROC4_CLNT_CB_LAYOUT);\n\n\tif (parent->sc_type == NFS4_DELEG_STID)\n\t\tls->ls_file = get_file(fp->fi_deleg_file);\n\telse\n\t\tls->ls_file = find_any_file(fp);\n\tBUG_ON(!ls->ls_file);\n\n\tif (nfsd4_layout_setlease(ls)) {\n\t\tput_nfs4_file(fp);\n\t\tkmem_cache_free(nfs4_layout_stateid_cache, ls);\n\t\treturn NULL;\n\t}\n\n\tspin_lock(&clp->cl_lock);\n\tstp->sc_type = NFS4_LAYOUT_STID;\n\tlist_add(&ls->ls_perclnt, &clp->cl_lo_states);\n\tspin_unlock(&clp->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&ls->ls_perfile, &fp->fi_lo_states);\n\tspin_unlock(&fp->fi_lock);\n\n\ttrace_layoutstate_alloc(&ls->ls_stid.sc_stateid);\n\treturn ls;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_match",
          "args": [
            "&cstate->current_fh.fh_handle",
            "&stid->sc_file->fi_fhandle"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "fh_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "190-197",
          "snippet": "static inline bool fh_match(struct knfsd_fh *fh1, struct knfsd_fh *fh2)\n{\n\tif (fh1->fh_size != fh2->fh_size)\n\t\treturn false;\n\tif (memcmp(fh1->fh_base.fh_pad, fh2->fh_base.fh_pad, fh1->fh_size) != 0)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline bool fh_match(struct knfsd_fh *fh1, struct knfsd_fh *fh2)\n{\n\tif (fh1->fh_size != fh2->fh_size)\n\t\treturn false;\n\tif (memcmp(fh1->fh_base.fh_pad, fh2->fh_base.fh_pad, fh1->fh_size) != 0)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_lookup_stateid",
          "args": [
            "cstate",
            "stateid",
            "typemask",
            "&stid",
            "net_generic(SVC_NET(rqstp), nfsd_net_id)"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_lookup_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4442-4463",
          "snippet": "__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\n__be32\nnfsd4_preprocess_layout_stateid(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, stateid_t *stateid,\n\t\tbool create, u32 layout_type, struct nfs4_layout_stateid **lsp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stid;\n\tunsigned char typemask = NFS4_LAYOUT_STID;\n\t__be32 status;\n\n\tif (create)\n\t\ttypemask |= (NFS4_OPEN_STID | NFS4_LOCK_STID | NFS4_DELEG_STID);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &stid,\n\t\t\tnet_generic(SVC_NET(rqstp), nfsd_net_id));\n\tif (status)\n\t\tgoto out;\n\n\tif (!fh_match(&cstate->current_fh.fh_handle,\n\t\t      &stid->sc_file->fi_fhandle)) {\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out_put_stid;\n\t}\n\n\tif (stid->sc_type != NFS4_LAYOUT_STID) {\n\t\tls = nfsd4_alloc_layout_stateid(cstate, stid, layout_type);\n\t\tnfs4_put_stid(stid);\n\n\t\tstatus = nfserr_jukebox;\n\t\tif (!ls)\n\t\t\tgoto out;\n\t} else {\n\t\tls = container_of(stid, struct nfs4_layout_stateid, ls_stid);\n\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (stateid->si_generation > stid->sc_stateid.si_generation)\n\t\t\tgoto out_put_stid;\n\t\tif (layout_type != ls->ls_layout_type)\n\t\t\tgoto out_put_stid;\n\t}\n\n\t*lsp = ls;\n\treturn 0;\n\nout_put_stid:\n\tnfs4_put_stid(stid);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_alloc_layout_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "183-231",
    "snippet": "static struct nfs4_layout_stateid *\nnfsd4_alloc_layout_stateid(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stid *parent, u32 layout_type)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_file *fp = parent->sc_file;\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stp;\n\n\tstp = nfs4_alloc_stid(cstate->clp, nfs4_layout_stateid_cache);\n\tif (!stp)\n\t\treturn NULL;\n\tstp->sc_free = nfsd4_free_layout_stateid;\n\tget_nfs4_file(fp);\n\tstp->sc_file = fp;\n\n\tls = layoutstateid(stp);\n\tINIT_LIST_HEAD(&ls->ls_perclnt);\n\tINIT_LIST_HEAD(&ls->ls_perfile);\n\tspin_lock_init(&ls->ls_lock);\n\tINIT_LIST_HEAD(&ls->ls_layouts);\n\tls->ls_layout_type = layout_type;\n\tnfsd4_init_cb(&ls->ls_recall, clp, &nfsd4_cb_layout_ops,\n\t\t\tNFSPROC4_CLNT_CB_LAYOUT);\n\n\tif (parent->sc_type == NFS4_DELEG_STID)\n\t\tls->ls_file = get_file(fp->fi_deleg_file);\n\telse\n\t\tls->ls_file = find_any_file(fp);\n\tBUG_ON(!ls->ls_file);\n\n\tif (nfsd4_layout_setlease(ls)) {\n\t\tput_nfs4_file(fp);\n\t\tkmem_cache_free(nfs4_layout_stateid_cache, ls);\n\t\treturn NULL;\n\t}\n\n\tspin_lock(&clp->cl_lock);\n\tstp->sc_type = NFS4_LAYOUT_STID;\n\tlist_add(&ls->ls_perclnt, &clp->cl_lo_states);\n\tspin_unlock(&clp->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&ls->ls_perfile, &fp->fi_lo_states);\n\tspin_unlock(&fp->fi_lock);\n\n\ttrace_layoutstate_alloc(&ls->ls_stid.sc_stateid);\n\treturn ls;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nfs4_layout_stateid_cache;",
      "static struct nfsd4_callback_ops nfsd4_cb_layout_ops;",
      "static struct nfsd4_callback_ops nfsd4_cb_layout_ops = {\n\t.done\t\t= nfsd4_cb_layout_done,\n\t.release\t= nfsd4_cb_layout_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_layoutstate_alloc",
          "args": [
            "&ls->ls_stid.sc_stateid"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ls->ls_perfile",
            "&fp->fi_lo_states"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nfs4_layout_stateid_cache",
            "ls"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_nfs4_file",
          "args": [
            "fp"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "276-287",
          "snippet": "void\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nvoid\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_layout_setlease",
          "args": [
            "ls"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_layout_setlease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "156-181",
          "snippet": "static int\nnfsd4_layout_setlease(struct nfs4_layout_stateid *ls)\n{\n\tstruct file_lock *fl;\n\tint status;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn -ENOMEM;\n\tlocks_init_lock(fl);\n\tfl->fl_lmops = &nfsd4_layouts_lm_ops;\n\tfl->fl_flags = FL_LAYOUT;\n\tfl->fl_type = F_RDLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = ls;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = ls->ls_file;\n\n\tstatus = vfs_setlease(fl->fl_file, fl->fl_type, &fl, NULL);\n\tif (status) {\n\t\tlocks_free_lock(fl);\n\t\treturn status;\n\t}\n\tBUG_ON(fl != NULL);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct lock_manager_operations nfsd4_layouts_lm_ops;",
            "static const struct lock_manager_operations nfsd4_layouts_lm_ops = {\n\t.lm_break\t= nfsd4_layout_lm_break,\n\t.lm_change\t= nfsd4_layout_lm_change,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic const struct lock_manager_operations nfsd4_layouts_lm_ops;\nstatic const struct lock_manager_operations nfsd4_layouts_lm_ops = {\n\t.lm_break\t= nfsd4_layout_lm_break,\n\t.lm_change\t= nfsd4_layout_lm_change,\n};\n\nstatic int\nnfsd4_layout_setlease(struct nfs4_layout_stateid *ls)\n{\n\tstruct file_lock *fl;\n\tint status;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn -ENOMEM;\n\tlocks_init_lock(fl);\n\tfl->fl_lmops = &nfsd4_layouts_lm_ops;\n\tfl->fl_flags = FL_LAYOUT;\n\tfl->fl_type = F_RDLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = ls;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = ls->ls_file;\n\n\tstatus = vfs_setlease(fl->fl_file, fl->fl_type, &fl, NULL);\n\tif (status) {\n\t\tlocks_free_lock(fl);\n\t\treturn status;\n\t}\n\tBUG_ON(fl != NULL);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ls->ls_file"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_any_file",
          "args": [
            "fp"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "find_any_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "346-360",
          "snippet": "struct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "fp->fi_deleg_file"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "get_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "381-392",
          "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_init_cb",
          "args": [
            "&ls->ls_recall",
            "clp",
            "&nfsd4_cb_layout_ops",
            "NFSPROC4_CLNT_CB_LAYOUT"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_init_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "1092-1103",
          "snippet": "void nfsd4_init_cb(struct nfsd4_callback *cb, struct nfs4_client *clp,\n\t\tstruct nfsd4_callback_ops *ops, enum nfsd4_cb_op op)\n{\n\tcb->cb_clp = clp;\n\tcb->cb_msg.rpc_proc = &nfs4_cb_procedures[op];\n\tcb->cb_msg.rpc_argp = cb;\n\tcb->cb_msg.rpc_resp = cb;\n\tcb->cb_ops = ops;\n\tINIT_WORK(&cb->cb_work, nfsd4_run_cb_work);\n\tINIT_LIST_HEAD(&cb->cb_per_client);\n\tcb->cb_done = true;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rpc_procinfo nfs4_cb_procedures[] = {\n\tPROC(CB_NULL,\tNULL,\t\tcb_null,\tcb_null),\n\tPROC(CB_RECALL,\tCOMPOUND,\tcb_recall,\tcb_recall),\n#ifdef CONFIG_NFSD_PNFS\n\tPROC(CB_LAYOUT,\tCOMPOUND,\tcb_layout,\tcb_layout),\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct rpc_procinfo nfs4_cb_procedures[] = {\n\tPROC(CB_NULL,\tNULL,\t\tcb_null,\tcb_null),\n\tPROC(CB_RECALL,\tCOMPOUND,\tcb_recall,\tcb_recall),\n#ifdef CONFIG_NFSD_PNFS\n\tPROC(CB_LAYOUT,\tCOMPOUND,\tcb_layout,\tcb_layout),\n#endif\n};\n\nvoid nfsd4_init_cb(struct nfsd4_callback *cb, struct nfs4_client *clp,\n\t\tstruct nfsd4_callback_ops *ops, enum nfsd4_cb_op op)\n{\n\tcb->cb_clp = clp;\n\tcb->cb_msg.rpc_proc = &nfs4_cb_procedures[op];\n\tcb->cb_msg.rpc_argp = cb;\n\tcb->cb_msg.rpc_resp = cb;\n\tcb->cb_ops = ops;\n\tINIT_WORK(&cb->cb_work, nfsd4_run_cb_work);\n\tINIT_LIST_HEAD(&cb->cb_per_client);\n\tcb->cb_done = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ls->ls_layouts"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ls->ls_perfile"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ls->ls_perclnt"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layoutstateid",
          "args": [
            "stp"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "layoutstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "552-555",
          "snippet": "static inline struct nfs4_layout_stateid *layoutstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_layout_stateid, ls_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_layout_stateid *layoutstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_layout_stateid, ls_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nfs4_file",
          "args": [
            "fp"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "get_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "605-608",
          "snippet": "static inline void get_nfs4_file(struct nfs4_file *fi)\n{\n\tatomic_inc(&fi->fi_ref);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void get_nfs4_file(struct nfs4_file *fi)\n{\n\tatomic_inc(&fi->fi_ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_alloc_stid",
          "args": [
            "cstate->clp",
            "nfs4_layout_stateid_cache"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "474-510",
          "snippet": "struct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nstruct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic struct kmem_cache *nfs4_layout_stateid_cache;\nstatic struct nfsd4_callback_ops nfsd4_cb_layout_ops;\nstatic struct nfsd4_callback_ops nfsd4_cb_layout_ops = {\n\t.done\t\t= nfsd4_cb_layout_done,\n\t.release\t= nfsd4_cb_layout_release,\n};\n\nstatic struct nfs4_layout_stateid *\nnfsd4_alloc_layout_stateid(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stid *parent, u32 layout_type)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_file *fp = parent->sc_file;\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stp;\n\n\tstp = nfs4_alloc_stid(cstate->clp, nfs4_layout_stateid_cache);\n\tif (!stp)\n\t\treturn NULL;\n\tstp->sc_free = nfsd4_free_layout_stateid;\n\tget_nfs4_file(fp);\n\tstp->sc_file = fp;\n\n\tls = layoutstateid(stp);\n\tINIT_LIST_HEAD(&ls->ls_perclnt);\n\tINIT_LIST_HEAD(&ls->ls_perfile);\n\tspin_lock_init(&ls->ls_lock);\n\tINIT_LIST_HEAD(&ls->ls_layouts);\n\tls->ls_layout_type = layout_type;\n\tnfsd4_init_cb(&ls->ls_recall, clp, &nfsd4_cb_layout_ops,\n\t\t\tNFSPROC4_CLNT_CB_LAYOUT);\n\n\tif (parent->sc_type == NFS4_DELEG_STID)\n\t\tls->ls_file = get_file(fp->fi_deleg_file);\n\telse\n\t\tls->ls_file = find_any_file(fp);\n\tBUG_ON(!ls->ls_file);\n\n\tif (nfsd4_layout_setlease(ls)) {\n\t\tput_nfs4_file(fp);\n\t\tkmem_cache_free(nfs4_layout_stateid_cache, ls);\n\t\treturn NULL;\n\t}\n\n\tspin_lock(&clp->cl_lock);\n\tstp->sc_type = NFS4_LAYOUT_STID;\n\tlist_add(&ls->ls_perclnt, &clp->cl_lo_states);\n\tspin_unlock(&clp->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&ls->ls_perfile, &fp->fi_lo_states);\n\tspin_unlock(&fp->fi_lock);\n\n\ttrace_layoutstate_alloc(&ls->ls_stid.sc_stateid);\n\treturn ls;\n}"
  },
  {
    "function_name": "nfsd4_layout_setlease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "156-181",
    "snippet": "static int\nnfsd4_layout_setlease(struct nfs4_layout_stateid *ls)\n{\n\tstruct file_lock *fl;\n\tint status;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn -ENOMEM;\n\tlocks_init_lock(fl);\n\tfl->fl_lmops = &nfsd4_layouts_lm_ops;\n\tfl->fl_flags = FL_LAYOUT;\n\tfl->fl_type = F_RDLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = ls;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = ls->ls_file;\n\n\tstatus = vfs_setlease(fl->fl_file, fl->fl_type, &fl, NULL);\n\tif (status) {\n\t\tlocks_free_lock(fl);\n\t\treturn status;\n\t}\n\tBUG_ON(fl != NULL);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct lock_manager_operations nfsd4_layouts_lm_ops;",
      "static const struct lock_manager_operations nfsd4_layouts_lm_ops = {\n\t.lm_break\t= nfsd4_layout_lm_break,\n\t.lm_change\t= nfsd4_layout_lm_change,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "fl != NULL"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "fl"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "287-296",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_setlease",
          "args": [
            "fl->fl_file",
            "fl->fl_type",
            "&fl",
            "NULL"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setlease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1799-1806",
          "snippet": "int\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_init_lock",
          "args": [
            "fl"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "locks_init_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "311-315",
          "snippet": "void locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "259-267",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic const struct lock_manager_operations nfsd4_layouts_lm_ops;\nstatic const struct lock_manager_operations nfsd4_layouts_lm_ops = {\n\t.lm_break\t= nfsd4_layout_lm_break,\n\t.lm_change\t= nfsd4_layout_lm_change,\n};\n\nstatic int\nnfsd4_layout_setlease(struct nfs4_layout_stateid *ls)\n{\n\tstruct file_lock *fl;\n\tint status;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn -ENOMEM;\n\tlocks_init_lock(fl);\n\tfl->fl_lmops = &nfsd4_layouts_lm_ops;\n\tfl->fl_flags = FL_LAYOUT;\n\tfl->fl_type = F_RDLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = ls;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = ls->ls_file;\n\n\tstatus = vfs_setlease(fl->fl_file, fl->fl_type, &fl, NULL);\n\tif (status) {\n\t\tlocks_free_lock(fl);\n\t\treturn status;\n\t}\n\tBUG_ON(fl != NULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_free_layout_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "130-154",
    "snippet": "static void\nnfsd4_free_layout_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_layout_stateid *ls = layoutstateid(stid);\n\tstruct nfs4_client *clp = ls->ls_stid.sc_client;\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\n\ttrace_layoutstate_free(&ls->ls_stid.sc_stateid);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_del_init(&ls->ls_perclnt);\n\tspin_unlock(&clp->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&ls->ls_perfile);\n\tspin_unlock(&fp->fi_lock);\n\n\tvfs_setlease(ls->ls_file, F_UNLCK, NULL, (void **)&ls);\n\tfput(ls->ls_file);\n\n\tif (ls->ls_recalled)\n\t\tatomic_dec(&ls->ls_stid.sc_file->fi_lo_recalls);\n\n\tkmem_cache_free(nfs4_layout_stateid_cache, ls);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nfs4_layout_stateid_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nfs4_layout_stateid_cache",
            "ls"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&ls->ls_stid.sc_file->fi_lo_recalls"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "ls->ls_file"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_setlease",
          "args": [
            "ls->ls_file",
            "F_UNLCK",
            "NULL",
            "(void **)&ls"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setlease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1799-1806",
          "snippet": "int\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ls->ls_perfile"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ls->ls_perclnt"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_layoutstate_free",
          "args": [
            "&ls->ls_stid.sc_stateid"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layoutstateid",
          "args": [
            "stid"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "layoutstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/state.h",
          "lines": "552-555",
          "snippet": "static inline struct nfs4_layout_stateid *layoutstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_layout_stateid, ls_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_layout_stateid *layoutstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_layout_stateid, ls_stid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic struct kmem_cache *nfs4_layout_stateid_cache;\n\nstatic void\nnfsd4_free_layout_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_layout_stateid *ls = layoutstateid(stid);\n\tstruct nfs4_client *clp = ls->ls_stid.sc_client;\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\n\ttrace_layoutstate_free(&ls->ls_stid.sc_stateid);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_del_init(&ls->ls_perclnt);\n\tspin_unlock(&clp->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&ls->ls_perfile);\n\tspin_unlock(&fp->fi_lock);\n\n\tvfs_setlease(ls->ls_file, F_UNLCK, NULL, (void **)&ls);\n\tfput(ls->ls_file);\n\n\tif (ls->ls_recalled)\n\t\tatomic_dec(&ls->ls_stid.sc_file->fi_lo_recalls);\n\n\tkmem_cache_free(nfs4_layout_stateid_cache, ls);\n}"
  },
  {
    "function_name": "nfsd4_setup_layout_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "117-128",
    "snippet": "void nfsd4_setup_layout_type(struct svc_export *exp)\n{\n\tstruct super_block *sb = exp->ex_path.mnt->mnt_sb;\n\n\tif (exp->ex_flags & NFSEXP_NOPNFS)\n\t\treturn;\n\n\tif (sb->s_export_op->get_uuid &&\n\t    sb->s_export_op->map_blocks &&\n\t    sb->s_export_op->commit_blocks)\n\t\texp->ex_layout_type = LAYOUT_BLOCK_VOLUME;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid nfsd4_setup_layout_type(struct svc_export *exp)\n{\n\tstruct super_block *sb = exp->ex_path.mnt->mnt_sb;\n\n\tif (exp->ex_flags & NFSEXP_NOPNFS)\n\t\treturn;\n\n\tif (sb->s_export_op->get_uuid &&\n\t    sb->s_export_op->map_blocks &&\n\t    sb->s_export_op->commit_blocks)\n\t\texp->ex_layout_type = LAYOUT_BLOCK_VOLUME;\n}"
  },
  {
    "function_name": "nfsd4_set_deviceid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "101-115",
    "snippet": "int\nnfsd4_set_deviceid(struct nfsd4_deviceid *id, const struct svc_fh *fhp,\n\t\tu32 device_generation)\n{\n\tif (!fhp->fh_export->ex_devid_map) {\n\t\tnfsd4_alloc_devid_map(fhp);\n\t\tif (!fhp->fh_export->ex_devid_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tid->fsid_idx = fhp->fh_export->ex_devid_map->idx;\n\tid->generation = device_generation;\n\tid->pad = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_alloc_devid_map",
          "args": [
            "fhp"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_alloc_devid_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "45-85",
          "snippet": "static void\nnfsd4_alloc_devid_map(const struct svc_fh *fhp)\n{\n\tconst struct knfsd_fh *fh = &fhp->fh_handle;\n\tsize_t fsid_len = key_len(fh->fh_fsid_type);\n\tstruct nfsd4_deviceid_map *map, *old;\n\tint i;\n\n\tmap = kzalloc(sizeof(*map) + fsid_len, GFP_KERNEL);\n\tif (!map)\n\t\treturn;\n\n\tmap->fsid_type = fh->fh_fsid_type;\n\tmemcpy(&map->fsid, fh->fh_fsid, fsid_len);\n\n\tspin_lock(&nfsd_devid_lock);\n\tif (fhp->fh_export->ex_devid_map)\n\t\tgoto out_unlock;\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++) {\n\t\tlist_for_each_entry(old, &nfsd_devid_hash[i], hash) {\n\t\t\tif (old->fsid_type != fh->fh_fsid_type)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(old->fsid, fh->fh_fsid,\n\t\t\t\t\tkey_len(old->fsid_type)))\n\t\t\t\tcontinue;\n\n\t\t\tfhp->fh_export->ex_devid_map = old;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tmap->idx = nfsd_devid_seq++;\n\tlist_add_tail_rcu(&map->hash, &nfsd_devid_hash[devid_hashfn(map->idx)]);\n\tfhp->fh_export->ex_devid_map = map;\n\tmap = NULL;\n\nout_unlock:\n\tspin_unlock(&nfsd_devid_lock);\n\tkfree(map);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [
            "#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)"
          ],
          "globals_used": [
            "static u64 nfsd_devid_seq = 1;",
            "static struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];",
            "static DEFINE_SPINLOCK(nfsd_devid_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\n#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)\n\nstatic u64 nfsd_devid_seq = 1;\nstatic struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];\nstatic DEFINE_SPINLOCK(nfsd_devid_lock);\n\nstatic void\nnfsd4_alloc_devid_map(const struct svc_fh *fhp)\n{\n\tconst struct knfsd_fh *fh = &fhp->fh_handle;\n\tsize_t fsid_len = key_len(fh->fh_fsid_type);\n\tstruct nfsd4_deviceid_map *map, *old;\n\tint i;\n\n\tmap = kzalloc(sizeof(*map) + fsid_len, GFP_KERNEL);\n\tif (!map)\n\t\treturn;\n\n\tmap->fsid_type = fh->fh_fsid_type;\n\tmemcpy(&map->fsid, fh->fh_fsid, fsid_len);\n\n\tspin_lock(&nfsd_devid_lock);\n\tif (fhp->fh_export->ex_devid_map)\n\t\tgoto out_unlock;\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++) {\n\t\tlist_for_each_entry(old, &nfsd_devid_hash[i], hash) {\n\t\t\tif (old->fsid_type != fh->fh_fsid_type)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(old->fsid, fh->fh_fsid,\n\t\t\t\t\tkey_len(old->fsid_type)))\n\t\t\t\tcontinue;\n\n\t\t\tfhp->fh_export->ex_devid_map = old;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tmap->idx = nfsd_devid_seq++;\n\tlist_add_tail_rcu(&map->hash, &nfsd_devid_hash[devid_hashfn(map->idx)]);\n\tfhp->fh_export->ex_devid_map = map;\n\tmap = NULL;\n\nout_unlock:\n\tspin_unlock(&nfsd_devid_lock);\n\tkfree(map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nint\nnfsd4_set_deviceid(struct nfsd4_deviceid *id, const struct svc_fh *fhp,\n\t\tu32 device_generation)\n{\n\tif (!fhp->fh_export->ex_devid_map) {\n\t\tnfsd4_alloc_devid_map(fhp);\n\t\tif (!fhp->fh_export->ex_devid_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tid->fsid_idx = fhp->fh_export->ex_devid_map->idx;\n\tid->generation = device_generation;\n\tid->pad = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_find_devid_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "87-99",
    "snippet": "struct nfsd4_deviceid_map *\nnfsd4_find_devid_map(int idx)\n{\n\tstruct nfsd4_deviceid_map *map, *ret = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(map, &nfsd_devid_hash[devid_hashfn(idx)], hash)\n\t\tif (map->idx == idx)\n\t\t\tret = map;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "map",
            "&nfsd_devid_hash[devid_hashfn(idx)]",
            "hash"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devid_hashfn",
          "args": [
            "idx"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "devid_hashfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "40-43",
          "snippet": "static inline u32 devid_hashfn(u64 idx)\n{\n\treturn jhash_2words(idx, idx >> 32, 0) & DEVID_HASH_MASK;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [
            "#define DEVID_HASH_MASK\t(DEVID_HASH_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\n#define DEVID_HASH_MASK\t(DEVID_HASH_SIZE - 1)\n\nstatic inline u32 devid_hashfn(u64 idx)\n{\n\treturn jhash_2words(idx, idx >> 32, 0) & DEVID_HASH_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];\n\nstruct nfsd4_deviceid_map *\nnfsd4_find_devid_map(int idx)\n{\n\tstruct nfsd4_deviceid_map *map, *ret = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(map, &nfsd_devid_hash[devid_hashfn(idx)], hash)\n\t\tif (map->idx == idx)\n\t\t\tret = map;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd4_alloc_devid_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "45-85",
    "snippet": "static void\nnfsd4_alloc_devid_map(const struct svc_fh *fhp)\n{\n\tconst struct knfsd_fh *fh = &fhp->fh_handle;\n\tsize_t fsid_len = key_len(fh->fh_fsid_type);\n\tstruct nfsd4_deviceid_map *map, *old;\n\tint i;\n\n\tmap = kzalloc(sizeof(*map) + fsid_len, GFP_KERNEL);\n\tif (!map)\n\t\treturn;\n\n\tmap->fsid_type = fh->fh_fsid_type;\n\tmemcpy(&map->fsid, fh->fh_fsid, fsid_len);\n\n\tspin_lock(&nfsd_devid_lock);\n\tif (fhp->fh_export->ex_devid_map)\n\t\tgoto out_unlock;\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++) {\n\t\tlist_for_each_entry(old, &nfsd_devid_hash[i], hash) {\n\t\t\tif (old->fsid_type != fh->fh_fsid_type)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(old->fsid, fh->fh_fsid,\n\t\t\t\t\tkey_len(old->fsid_type)))\n\t\t\t\tcontinue;\n\n\t\t\tfhp->fh_export->ex_devid_map = old;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tmap->idx = nfsd_devid_seq++;\n\tlist_add_tail_rcu(&map->hash, &nfsd_devid_hash[devid_hashfn(map->idx)]);\n\tfhp->fh_export->ex_devid_map = map;\n\tmap = NULL;\n\nout_unlock:\n\tspin_unlock(&nfsd_devid_lock);\n\tkfree(map);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [
      "#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)"
    ],
    "globals_used": [
      "static u64 nfsd_devid_seq = 1;",
      "static struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];",
      "static DEFINE_SPINLOCK(nfsd_devid_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "map"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nfsd_devid_lock"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&map->hash",
            "&nfsd_devid_hash[devid_hashfn(map->idx)]"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devid_hashfn",
          "args": [
            "map->idx"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "devid_hashfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "40-43",
          "snippet": "static inline u32 devid_hashfn(u64 idx)\n{\n\treturn jhash_2words(idx, idx >> 32, 0) & DEVID_HASH_MASK;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [
            "#define DEVID_HASH_MASK\t(DEVID_HASH_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\n#define DEVID_HASH_MASK\t(DEVID_HASH_SIZE - 1)\n\nstatic inline u32 devid_hashfn(u64 idx)\n{\n\treturn jhash_2words(idx, idx >> 32, 0) & DEVID_HASH_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "old->fsid",
            "fh->fh_fsid",
            "key_len(old->fsid_type)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_len",
          "args": [
            "old->fsid_type"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "key_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "138-151",
          "snippet": "static inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "old",
            "&nfsd_devid_hash[i]",
            "hash"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nfsd_devid_lock"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&map->fsid",
            "fh->fh_fsid",
            "fsid_len"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*map) + fsid_len",
            "GFP_KERNEL"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\n#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)\n\nstatic u64 nfsd_devid_seq = 1;\nstatic struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];\nstatic DEFINE_SPINLOCK(nfsd_devid_lock);\n\nstatic void\nnfsd4_alloc_devid_map(const struct svc_fh *fhp)\n{\n\tconst struct knfsd_fh *fh = &fhp->fh_handle;\n\tsize_t fsid_len = key_len(fh->fh_fsid_type);\n\tstruct nfsd4_deviceid_map *map, *old;\n\tint i;\n\n\tmap = kzalloc(sizeof(*map) + fsid_len, GFP_KERNEL);\n\tif (!map)\n\t\treturn;\n\n\tmap->fsid_type = fh->fh_fsid_type;\n\tmemcpy(&map->fsid, fh->fh_fsid, fsid_len);\n\n\tspin_lock(&nfsd_devid_lock);\n\tif (fhp->fh_export->ex_devid_map)\n\t\tgoto out_unlock;\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++) {\n\t\tlist_for_each_entry(old, &nfsd_devid_hash[i], hash) {\n\t\t\tif (old->fsid_type != fh->fh_fsid_type)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(old->fsid, fh->fh_fsid,\n\t\t\t\t\tkey_len(old->fsid_type)))\n\t\t\t\tcontinue;\n\n\t\t\tfhp->fh_export->ex_devid_map = old;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tmap->idx = nfsd_devid_seq++;\n\tlist_add_tail_rcu(&map->hash, &nfsd_devid_hash[devid_hashfn(map->idx)]);\n\tfhp->fh_export->ex_devid_map = map;\n\tmap = NULL;\n\nout_unlock:\n\tspin_unlock(&nfsd_devid_lock);\n\tkfree(map);\n}"
  },
  {
    "function_name": "devid_hashfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
    "lines": "40-43",
    "snippet": "static inline u32 devid_hashfn(u64 idx)\n{\n\treturn jhash_2words(idx, idx >> 32, 0) & DEVID_HASH_MASK;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [
      "#define DEVID_HASH_MASK\t(DEVID_HASH_SIZE - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jhash_2words",
          "args": [
            "idx",
            "idx >> 32",
            "0"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\n#define DEVID_HASH_MASK\t(DEVID_HASH_SIZE - 1)\n\nstatic inline u32 devid_hashfn(u64 idx)\n{\n\treturn jhash_2words(idx, idx >> 32, 0) & DEVID_HASH_MASK;\n}"
  }
]