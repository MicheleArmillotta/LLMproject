[
  {
    "function_name": "logMOUNT",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
    "lines": "494-507",
    "snippet": "static int logMOUNT(struct super_block *sb)\n{\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\tstruct lrd lrd;\n\n\tlrd.logtid = 0;\n\tlrd.backchain = 0;\n\tlrd.type = cpu_to_le16(LOG_MOUNT);\n\tlrd.length = 0;\n\tlrd.aggregate = cpu_to_le32(new_encode_dev(sb->s_bdev->bd_dev));\n\tlmLog(log, NULL, &lrd, NULL);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int chkSuper(struct super_block *);",
      "static int logMOUNT(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lmLog",
          "args": [
            "log",
            "NULL",
            "&lrd",
            "NULL"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "lmLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "238-343",
          "snippet": "int lmLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t  struct tlock * tlck)\n{\n\tint lsn;\n\tint diffp, difft;\n\tstruct metapage *mp = NULL;\n\tunsigned long flags;\n\n\tjfs_info(\"lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p\",\n\t\t log, tblk, lrd, tlck);\n\n\tLOG_LOCK(log);\n\n\t/* log by (out-of-transaction) JFS ? */\n\tif (tblk == NULL)\n\t\tgoto writeRecord;\n\n\t/* log from page ? */\n\tif (tlck == NULL ||\n\t    tlck->type & tlckBTROOT || (mp = tlck->mp) == NULL)\n\t\tgoto writeRecord;\n\n\t/*\n\t *\tinitialize/update page/transaction recovery lsn\n\t */\n\tlsn = log->lsn;\n\n\tLOGSYNC_LOCK(log, flags);\n\n\t/*\n\t * initialize page lsn if first log write of the page\n\t */\n\tif (mp->lsn == 0) {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\tlog->count++;\n\n\t\t/* insert page at tail of logsynclist */\n\t\tlist_add_tail(&mp->synclist, &log->synclist);\n\t}\n\n\t/*\n\t *\tinitialize/update lsn of tblock of the page\n\t *\n\t * transaction inherits oldest lsn of pages associated\n\t * with allocation/deallocation of resources (their\n\t * log records are used to reconstruct allocation map\n\t * at recovery time: inode for inode allocation map,\n\t * B+-tree index of extent descriptors for block\n\t * allocation map);\n\t * allocation map pages inherit transaction lsn at\n\t * commit time to allow forwarding log syncpt past log\n\t * records associated with allocation/deallocation of\n\t * resources only after persistent map of these map pages\n\t * have been updated and propagated to home.\n\t */\n\t/*\n\t * initialize transaction lsn:\n\t */\n\tif (tblk->lsn == 0) {\n\t\t/* inherit lsn of its first page logged */\n\t\ttblk->lsn = mp->lsn;\n\t\tlog->count++;\n\n\t\t/* insert tblock after the page on logsynclist */\n\t\tlist_add(&tblk->synclist, &mp->synclist);\n\t}\n\t/*\n\t * update transaction lsn:\n\t */\n\telse {\n\t\t/* inherit oldest/smallest lsn of page */\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tlogdiff(difft, tblk->lsn, log);\n\t\tif (diffp < difft) {\n\t\t\t/* update tblock lsn with page lsn */\n\t\t\ttblk->lsn = mp->lsn;\n\n\t\t\t/* move tblock after page on logsynclist */\n\t\t\tlist_move(&tblk->synclist, &mp->synclist);\n\t\t}\n\t}\n\n\tLOGSYNC_UNLOCK(log, flags);\n\n\t/*\n\t *\twrite the log record\n\t */\n      writeRecord:\n\tlsn = lmWriteRecord(log, tblk, lrd, tlck);\n\n\t/*\n\t * forward log syncpt if log reached next syncpt trigger\n\t */\n\tlogdiff(diffp, lsn, log);\n\tif (diffp >= log->nextsync)\n\t\tlsn = lmLogSync(log, 0);\n\n\t/* update end-of-log lsn */\n\tlog->lsn = lsn;\n\n\tLOG_UNLOCK(log);\n\n\t/* return end-of-log address */\n\treturn lsn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);",
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nint lmLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t  struct tlock * tlck)\n{\n\tint lsn;\n\tint diffp, difft;\n\tstruct metapage *mp = NULL;\n\tunsigned long flags;\n\n\tjfs_info(\"lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p\",\n\t\t log, tblk, lrd, tlck);\n\n\tLOG_LOCK(log);\n\n\t/* log by (out-of-transaction) JFS ? */\n\tif (tblk == NULL)\n\t\tgoto writeRecord;\n\n\t/* log from page ? */\n\tif (tlck == NULL ||\n\t    tlck->type & tlckBTROOT || (mp = tlck->mp) == NULL)\n\t\tgoto writeRecord;\n\n\t/*\n\t *\tinitialize/update page/transaction recovery lsn\n\t */\n\tlsn = log->lsn;\n\n\tLOGSYNC_LOCK(log, flags);\n\n\t/*\n\t * initialize page lsn if first log write of the page\n\t */\n\tif (mp->lsn == 0) {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\tlog->count++;\n\n\t\t/* insert page at tail of logsynclist */\n\t\tlist_add_tail(&mp->synclist, &log->synclist);\n\t}\n\n\t/*\n\t *\tinitialize/update lsn of tblock of the page\n\t *\n\t * transaction inherits oldest lsn of pages associated\n\t * with allocation/deallocation of resources (their\n\t * log records are used to reconstruct allocation map\n\t * at recovery time: inode for inode allocation map,\n\t * B+-tree index of extent descriptors for block\n\t * allocation map);\n\t * allocation map pages inherit transaction lsn at\n\t * commit time to allow forwarding log syncpt past log\n\t * records associated with allocation/deallocation of\n\t * resources only after persistent map of these map pages\n\t * have been updated and propagated to home.\n\t */\n\t/*\n\t * initialize transaction lsn:\n\t */\n\tif (tblk->lsn == 0) {\n\t\t/* inherit lsn of its first page logged */\n\t\ttblk->lsn = mp->lsn;\n\t\tlog->count++;\n\n\t\t/* insert tblock after the page on logsynclist */\n\t\tlist_add(&tblk->synclist, &mp->synclist);\n\t}\n\t/*\n\t * update transaction lsn:\n\t */\n\telse {\n\t\t/* inherit oldest/smallest lsn of page */\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tlogdiff(difft, tblk->lsn, log);\n\t\tif (diffp < difft) {\n\t\t\t/* update tblock lsn with page lsn */\n\t\t\ttblk->lsn = mp->lsn;\n\n\t\t\t/* move tblock after page on logsynclist */\n\t\t\tlist_move(&tblk->synclist, &mp->synclist);\n\t\t}\n\t}\n\n\tLOGSYNC_UNLOCK(log, flags);\n\n\t/*\n\t *\twrite the log record\n\t */\n      writeRecord:\n\tlsn = lmWriteRecord(log, tblk, lrd, tlck);\n\n\t/*\n\t * forward log syncpt if log reached next syncpt trigger\n\t */\n\tlogdiff(diffp, lsn, log);\n\tif (diffp >= log->nextsync)\n\t\tlsn = lmLogSync(log, 0);\n\n\t/* update end-of-log lsn */\n\tlog->lsn = lsn;\n\n\tLOG_UNLOCK(log);\n\n\t/* return end-of-log address */\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_encode_dev(sb->s_bdev->bd_dev)"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "sb->s_bdev->bd_dev"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_MOUNT"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nstatic int logMOUNT(struct super_block *sb)\n{\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\tstruct lrd lrd;\n\n\tlrd.logtid = 0;\n\tlrd.backchain = 0;\n\tlrd.type = cpu_to_le16(LOG_MOUNT);\n\tlrd.length = 0;\n\tlrd.aggregate = cpu_to_le32(new_encode_dev(sb->s_bdev->bd_dev));\n\tlmLog(log, NULL, &lrd, NULL);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "readSuper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
    "lines": "464-477",
    "snippet": "int readSuper(struct super_block *sb, struct buffer_head **bpp)\n{\n\t/* read in primary superblock */\n\t*bpp = sb_bread(sb, SUPER1_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\t/* read in secondary/replicated superblock */\n\t*bpp = sb_bread(sb, SUPER2_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\treturn -EIO;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int chkSuper(struct super_block *);",
      "static int logMOUNT(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "SUPER2_OFF >> sb->s_blocksize_bits"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "SUPER1_OFF >> sb->s_blocksize_bits"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nint readSuper(struct super_block *sb, struct buffer_head **bpp)\n{\n\t/* read in primary superblock */\n\t*bpp = sb_bread(sb, SUPER1_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\t/* read in secondary/replicated superblock */\n\t*bpp = sb_bread(sb, SUPER2_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\treturn -EIO;\n}"
  },
  {
    "function_name": "updateSuper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
    "lines": "409-456",
    "snippet": "int updateSuper(struct super_block *sb, uint state)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct buffer_head *bh;\n\tint rc;\n\n\tif (sbi->flag & JFS_NOINTEGRITY) {\n\t\tif (state == FM_DIRTY) {\n\t\t\tsbi->p_state = state;\n\t\t\treturn 0;\n\t\t} else if (state == FM_MOUNT) {\n\t\t\tsbi->p_state = sbi->state;\n\t\t\tstate = FM_DIRTY;\n\t\t} else if (state == FM_CLEAN) {\n\t\t\tstate = sbi->p_state;\n\t\t} else\n\t\t\tjfs_err(\"updateSuper: bad state\");\n\t} else if (sbi->state == FM_DIRTY)\n\t\treturn 0;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\tj_sb->s_state = cpu_to_le32(state);\n\tsbi->state = state;\n\n\tif (state == FM_MOUNT) {\n\t\t/* record log's dev_t and mount serial number */\n\t\tj_sb->s_logdev = cpu_to_le32(new_encode_dev(sbi->log->bdev->bd_dev));\n\t\tj_sb->s_logserial = cpu_to_le32(sbi->log->serial);\n\t} else if (state == FM_CLEAN) {\n\t\t/*\n\t\t * If this volume is shared with OS/2, OS/2 will need to\n\t\t * recalculate DASD usage, since we don't deal with it.\n\t\t */\n\t\tif (j_sb->s_flag & cpu_to_le32(JFS_DASD_ENABLED))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_DASD_PRIME);\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int chkSuper(struct super_block *);",
      "static int logMOUNT(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "JFS_DASD_PRIME"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "JFS_DASD_ENABLED"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sbi->log->serial"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_encode_dev(sbi->log->bdev->bd_dev)"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "sbi->log->bdev->bd_dev"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "state"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readSuper",
          "args": [
            "sb",
            "&bh"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "readSuper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
          "lines": "464-477",
          "snippet": "int readSuper(struct super_block *sb, struct buffer_head **bpp)\n{\n\t/* read in primary superblock */\n\t*bpp = sb_bread(sb, SUPER1_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\t/* read in secondary/replicated superblock */\n\t*bpp = sb_bread(sb, SUPER2_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\treturn -EIO;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int chkSuper(struct super_block *);",
            "static int logMOUNT(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nint readSuper(struct super_block *sb, struct buffer_head **bpp)\n{\n\t/* read in primary superblock */\n\t*bpp = sb_bread(sb, SUPER1_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\t/* read in secondary/replicated superblock */\n\t*bpp = sb_bread(sb, SUPER2_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"updateSuper: bad state\""
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nint updateSuper(struct super_block *sb, uint state)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct buffer_head *bh;\n\tint rc;\n\n\tif (sbi->flag & JFS_NOINTEGRITY) {\n\t\tif (state == FM_DIRTY) {\n\t\t\tsbi->p_state = state;\n\t\t\treturn 0;\n\t\t} else if (state == FM_MOUNT) {\n\t\t\tsbi->p_state = sbi->state;\n\t\t\tstate = FM_DIRTY;\n\t\t} else if (state == FM_CLEAN) {\n\t\t\tstate = sbi->p_state;\n\t\t} else\n\t\t\tjfs_err(\"updateSuper: bad state\");\n\t} else if (sbi->state == FM_DIRTY)\n\t\treturn 0;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\tj_sb->s_state = cpu_to_le32(state);\n\tsbi->state = state;\n\n\tif (state == FM_MOUNT) {\n\t\t/* record log's dev_t and mount serial number */\n\t\tj_sb->s_logdev = cpu_to_le32(new_encode_dev(sbi->log->bdev->bd_dev));\n\t\tj_sb->s_logserial = cpu_to_le32(sbi->log->serial);\n\t} else if (state == FM_CLEAN) {\n\t\t/*\n\t\t * If this volume is shared with OS/2, OS/2 will need to\n\t\t * recalculate DASD usage, since we don't deal with it.\n\t\t */\n\t\tif (j_sb->s_flag & cpu_to_le32(JFS_DASD_ENABLED))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_DASD_PRIME);\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "chkSuper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
    "lines": "301-401",
    "snippet": "static int chkSuper(struct super_block *sb)\n{\n\tint rc = 0;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_superblock *j_sb;\n\tstruct buffer_head *bh;\n\tint AIM_bytesize, AIT_bytesize;\n\tint expected_AIM_bytesize, expected_AIT_bytesize;\n\ts64 AIM_byte_addr, AIT_byte_addr, fsckwsp_addr;\n\ts64 byte_addr_diff0, byte_addr_diff1;\n\ts32 bsize;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\t/*\n\t * validate superblock\n\t */\n\t/* validate fs signature */\n\tif (strncmp(j_sb->s_magic, JFS_MAGIC, 4) ||\n\t    le32_to_cpu(j_sb->s_version) > JFS_VERSION) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbsize = le32_to_cpu(j_sb->s_bsize);\n#ifdef _JFS_4K\n\tif (bsize != PSIZE) {\n\t\tjfs_err(\"Currently only 4K block size supported!\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n#endif\t\t\t\t/* _JFS_4K */\n\n\tjfs_info(\"superblock: flag:0x%08x state:0x%08x size:0x%Lx\",\n\t\t le32_to_cpu(j_sb->s_flag), le32_to_cpu(j_sb->s_state),\n\t\t (unsigned long long) le64_to_cpu(j_sb->s_size));\n\n\t/* validate the descriptors for Secondary AIM and AIT */\n\tif ((j_sb->s_flag & cpu_to_le32(JFS_BAD_SAIT)) !=\n\t    cpu_to_le32(JFS_BAD_SAIT)) {\n\t\texpected_AIM_bytesize = 2 * PSIZE;\n\t\tAIM_bytesize = lengthPXD(&(j_sb->s_aim2)) * bsize;\n\t\texpected_AIT_bytesize = 4 * PSIZE;\n\t\tAIT_bytesize = lengthPXD(&(j_sb->s_ait2)) * bsize;\n\t\tAIM_byte_addr = addressPXD(&(j_sb->s_aim2)) * bsize;\n\t\tAIT_byte_addr = addressPXD(&(j_sb->s_ait2)) * bsize;\n\t\tbyte_addr_diff0 = AIT_byte_addr - AIM_byte_addr;\n\t\tfsckwsp_addr = addressPXD(&(j_sb->s_fsckpxd)) * bsize;\n\t\tbyte_addr_diff1 = fsckwsp_addr - AIT_byte_addr;\n\t\tif ((AIM_bytesize != expected_AIM_bytesize) ||\n\t\t    (AIT_bytesize != expected_AIT_bytesize) ||\n\t\t    (byte_addr_diff0 != AIM_bytesize) ||\n\t\t    (byte_addr_diff1 <= AIT_bytesize))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_BAD_SAIT);\n\t}\n\n\tif ((j_sb->s_flag & cpu_to_le32(JFS_GROUPCOMMIT)) !=\n\t    cpu_to_le32(JFS_GROUPCOMMIT))\n\t\tj_sb->s_flag |= cpu_to_le32(JFS_GROUPCOMMIT);\n\n\t/* validate fs state */\n\tif (j_sb->s_state != cpu_to_le32(FM_CLEAN) &&\n\t    !(sb->s_flags & MS_RDONLY)) {\n\t\tjfs_err(\"jfs_mount: Mount Failure: File System Dirty.\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsbi->state = le32_to_cpu(j_sb->s_state);\n\tsbi->mntflag = le32_to_cpu(j_sb->s_flag);\n\n\t/*\n\t * JFS always does I/O by 4K pages.  Don't tell the buffer cache\n\t * that we use anything else (leave s_blocksize alone).\n\t */\n\tsbi->bsize = bsize;\n\tsbi->l2bsize = le16_to_cpu(j_sb->s_l2bsize);\n\n\t/*\n\t * For now, ignore s_pbsize, l2bfactor.  All I/O going through buffer\n\t * cache.\n\t */\n\tsbi->nbperpage = PSIZE >> sbi->l2bsize;\n\tsbi->l2nbperpage = L2PSIZE - sbi->l2bsize;\n\tsbi->l2niperblk = sbi->l2bsize - L2DISIZE;\n\tif (sbi->mntflag & JFS_INLINELOG)\n\t\tsbi->logpxd = j_sb->s_logpxd;\n\telse {\n\t\tsbi->logdev = new_decode_dev(le32_to_cpu(j_sb->s_logdev));\n\t\tmemcpy(sbi->uuid, j_sb->s_uuid, sizeof(sbi->uuid));\n\t\tmemcpy(sbi->loguuid, j_sb->s_loguuid, sizeof(sbi->uuid));\n\t}\n\tsbi->fsckpxd = j_sb->s_fsckpxd;\n\tsbi->ait2 = j_sb->s_ait2;\n\n      out:\n\tbrelse(bh);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int chkSuper(struct super_block *);",
      "static int logMOUNT(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sbi->loguuid",
            "j_sb->s_loguuid",
            "sizeof(sbi->uuid)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sbi->uuid",
            "j_sb->s_uuid",
            "sizeof(sbi->uuid)"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "le32_to_cpu(j_sb->s_logdev)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "j_sb->s_logdev"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "j_sb->s_l2bsize"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_mount: Mount Failure: File System Dirty.\""
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "FM_CLEAN"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "JFS_GROUPCOMMIT"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "JFS_GROUPCOMMIT"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "JFS_GROUPCOMMIT"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "JFS_BAD_SAIT"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "&(j_sb->s_fsckpxd)"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "&(j_sb->s_ait2)"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "JFS_BAD_SAIT"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "JFS_BAD_SAIT"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"superblock: flag:0x%08x state:0x%08x size:0x%Lx\"",
            "le32_to_cpu(j_sb->s_flag)",
            "le32_to_cpu(j_sb->s_state)",
            "(unsigned long long) le64_to_cpu(j_sb->s_size)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "j_sb->s_size"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"Currently only 4K block size supported!\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "j_sb->s_magic",
            "JFS_MAGIC",
            "4"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readSuper",
          "args": [
            "sb",
            "&bh"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "readSuper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
          "lines": "464-477",
          "snippet": "int readSuper(struct super_block *sb, struct buffer_head **bpp)\n{\n\t/* read in primary superblock */\n\t*bpp = sb_bread(sb, SUPER1_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\t/* read in secondary/replicated superblock */\n\t*bpp = sb_bread(sb, SUPER2_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\treturn -EIO;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int chkSuper(struct super_block *);",
            "static int logMOUNT(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nint readSuper(struct super_block *sb, struct buffer_head **bpp)\n{\n\t/* read in primary superblock */\n\t*bpp = sb_bread(sb, SUPER1_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\t/* read in secondary/replicated superblock */\n\t*bpp = sb_bread(sb, SUPER2_OFF >> sb->s_blocksize_bits);\n\tif (*bpp)\n\t\treturn 0;\n\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nstatic int chkSuper(struct super_block *sb)\n{\n\tint rc = 0;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_superblock *j_sb;\n\tstruct buffer_head *bh;\n\tint AIM_bytesize, AIT_bytesize;\n\tint expected_AIM_bytesize, expected_AIT_bytesize;\n\ts64 AIM_byte_addr, AIT_byte_addr, fsckwsp_addr;\n\ts64 byte_addr_diff0, byte_addr_diff1;\n\ts32 bsize;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\t/*\n\t * validate superblock\n\t */\n\t/* validate fs signature */\n\tif (strncmp(j_sb->s_magic, JFS_MAGIC, 4) ||\n\t    le32_to_cpu(j_sb->s_version) > JFS_VERSION) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbsize = le32_to_cpu(j_sb->s_bsize);\n#ifdef _JFS_4K\n\tif (bsize != PSIZE) {\n\t\tjfs_err(\"Currently only 4K block size supported!\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n#endif\t\t\t\t/* _JFS_4K */\n\n\tjfs_info(\"superblock: flag:0x%08x state:0x%08x size:0x%Lx\",\n\t\t le32_to_cpu(j_sb->s_flag), le32_to_cpu(j_sb->s_state),\n\t\t (unsigned long long) le64_to_cpu(j_sb->s_size));\n\n\t/* validate the descriptors for Secondary AIM and AIT */\n\tif ((j_sb->s_flag & cpu_to_le32(JFS_BAD_SAIT)) !=\n\t    cpu_to_le32(JFS_BAD_SAIT)) {\n\t\texpected_AIM_bytesize = 2 * PSIZE;\n\t\tAIM_bytesize = lengthPXD(&(j_sb->s_aim2)) * bsize;\n\t\texpected_AIT_bytesize = 4 * PSIZE;\n\t\tAIT_bytesize = lengthPXD(&(j_sb->s_ait2)) * bsize;\n\t\tAIM_byte_addr = addressPXD(&(j_sb->s_aim2)) * bsize;\n\t\tAIT_byte_addr = addressPXD(&(j_sb->s_ait2)) * bsize;\n\t\tbyte_addr_diff0 = AIT_byte_addr - AIM_byte_addr;\n\t\tfsckwsp_addr = addressPXD(&(j_sb->s_fsckpxd)) * bsize;\n\t\tbyte_addr_diff1 = fsckwsp_addr - AIT_byte_addr;\n\t\tif ((AIM_bytesize != expected_AIM_bytesize) ||\n\t\t    (AIT_bytesize != expected_AIT_bytesize) ||\n\t\t    (byte_addr_diff0 != AIM_bytesize) ||\n\t\t    (byte_addr_diff1 <= AIT_bytesize))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_BAD_SAIT);\n\t}\n\n\tif ((j_sb->s_flag & cpu_to_le32(JFS_GROUPCOMMIT)) !=\n\t    cpu_to_le32(JFS_GROUPCOMMIT))\n\t\tj_sb->s_flag |= cpu_to_le32(JFS_GROUPCOMMIT);\n\n\t/* validate fs state */\n\tif (j_sb->s_state != cpu_to_le32(FM_CLEAN) &&\n\t    !(sb->s_flags & MS_RDONLY)) {\n\t\tjfs_err(\"jfs_mount: Mount Failure: File System Dirty.\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsbi->state = le32_to_cpu(j_sb->s_state);\n\tsbi->mntflag = le32_to_cpu(j_sb->s_flag);\n\n\t/*\n\t * JFS always does I/O by 4K pages.  Don't tell the buffer cache\n\t * that we use anything else (leave s_blocksize alone).\n\t */\n\tsbi->bsize = bsize;\n\tsbi->l2bsize = le16_to_cpu(j_sb->s_l2bsize);\n\n\t/*\n\t * For now, ignore s_pbsize, l2bfactor.  All I/O going through buffer\n\t * cache.\n\t */\n\tsbi->nbperpage = PSIZE >> sbi->l2bsize;\n\tsbi->l2nbperpage = L2PSIZE - sbi->l2bsize;\n\tsbi->l2niperblk = sbi->l2bsize - L2DISIZE;\n\tif (sbi->mntflag & JFS_INLINELOG)\n\t\tsbi->logpxd = j_sb->s_logpxd;\n\telse {\n\t\tsbi->logdev = new_decode_dev(le32_to_cpu(j_sb->s_logdev));\n\t\tmemcpy(sbi->uuid, j_sb->s_uuid, sizeof(sbi->uuid));\n\t\tmemcpy(sbi->loguuid, j_sb->s_loguuid, sizeof(sbi->uuid));\n\t}\n\tsbi->fsckpxd = j_sb->s_fsckpxd;\n\tsbi->ait2 = j_sb->s_ait2;\n\n      out:\n\tbrelse(bh);\n\treturn rc;\n}"
  },
  {
    "function_name": "jfs_mount_rw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
    "lines": "239-289",
    "snippet": "int jfs_mount_rw(struct super_block *sb, int remount)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint rc;\n\n\t/*\n\t * If we are re-mounting a previously read-only volume, we want to\n\t * re-read the inode and block maps, since fsck.jfs may have updated\n\t * them.\n\t */\n\tif (remount) {\n\t\tif (chkSuper(sb) || (sbi->state != FM_CLEAN))\n\t\t\treturn -EINVAL;\n\n\t\ttruncate_inode_pages(sbi->ipimap->i_mapping, 0);\n\t\ttruncate_inode_pages(sbi->ipbmap->i_mapping, 0);\n\t\tdiUnmount(sbi->ipimap, 1);\n\t\tif ((rc = diMount(sbi->ipimap))) {\n\t\t\tjfs_err(\"jfs_mount_rw: diMount failed!\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tdbUnmount(sbi->ipbmap, 1);\n\t\tif ((rc = dbMount(sbi->ipbmap))) {\n\t\t\tjfs_err(\"jfs_mount_rw: dbMount failed!\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/*\n\t * open/initialize log\n\t */\n\tif ((rc = lmLogOpen(sb)))\n\t\treturn rc;\n\n\t/*\n\t * update file system superblock;\n\t */\n\tif ((rc = updateSuper(sb, FM_MOUNT))) {\n\t\tjfs_err(\"jfs_mount: updateSuper failed w/rc = %d\", rc);\n\t\tlmLogClose(sb);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * write MOUNT log record of the file system\n\t */\n\tlogMOUNT(sb);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int chkSuper(struct super_block *);",
      "static int logMOUNT(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logMOUNT",
          "args": [
            "sb"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "logMOUNT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
          "lines": "494-507",
          "snippet": "static int logMOUNT(struct super_block *sb)\n{\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\tstruct lrd lrd;\n\n\tlrd.logtid = 0;\n\tlrd.backchain = 0;\n\tlrd.type = cpu_to_le16(LOG_MOUNT);\n\tlrd.length = 0;\n\tlrd.aggregate = cpu_to_le32(new_encode_dev(sb->s_bdev->bd_dev));\n\tlmLog(log, NULL, &lrd, NULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int chkSuper(struct super_block *);",
            "static int logMOUNT(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nstatic int logMOUNT(struct super_block *sb)\n{\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\tstruct lrd lrd;\n\n\tlrd.logtid = 0;\n\tlrd.backchain = 0;\n\tlrd.type = cpu_to_le16(LOG_MOUNT);\n\tlrd.length = 0;\n\tlrd.aggregate = cpu_to_le32(new_encode_dev(sb->s_bdev->bd_dev));\n\tlmLog(log, NULL, &lrd, NULL);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmLogClose",
          "args": [
            "sb"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "lmLogClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1458-1519",
          "snippet": "int lmLogClose(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\tstruct block_device *bdev;\n\tint rc = 0;\n\n\tjfs_info(\"lmLogClose: log:0x%p\", log);\n\n\tmutex_lock(&jfs_log_mutex);\n\tLOG_LOCK(log);\n\tlist_del(&sbi->log_list);\n\tLOG_UNLOCK(log);\n\tsbi->log = NULL;\n\n\t/*\n\t * We need to make sure all of the \"written\" metapages\n\t * actually make it to disk\n\t */\n\tsync_blockdev(sb->s_bdev);\n\n\tif (test_bit(log_INLINELOG, &log->flag)) {\n\t\t/*\n\t\t *\tin-line log in host file system\n\t\t */\n\t\trc = lmLogShutdown(log);\n\t\tkfree(log);\n\t\tgoto out;\n\t}\n\n\tif (!log->no_integrity)\n\t\tlmLogFileSystem(log, sbi, 0);\n\n\tif (!list_empty(&log->sb_list))\n\t\tgoto out;\n\n\t/*\n\t * TODO: ensure that the dummy_log is in a state to allow\n\t * lbmLogShutdown to deallocate all the buffers and call\n\t * kfree against dummy_log.  For now, leave dummy_log & its\n\t * buffers in memory, and resuse if another no-integrity mount\n\t * is requested.\n\t */\n\tif (log->no_integrity)\n\t\tgoto out;\n\n\t/*\n\t *\texternal log as separate logical volume\n\t */\n\tlist_del(&log->journal_list);\n\tbdev = log->bdev;\n\trc = lmLogShutdown(log);\n\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n\n\tkfree(log);\n\n      out:\n\tmutex_unlock(&jfs_log_mutex);\n\tjfs_info(\"lmLogClose: exit(%d)\", rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct jfs_log *dummy_log;",
            "static DEFINE_MUTEX(jfs_log_mutex);",
            "static int lmNextPage(struct jfs_log * log);",
            "static int open_inline_log(struct super_block *sb);",
            "static int open_dummy_log(struct super_block *sb);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct jfs_log *dummy_log;\nstatic DEFINE_MUTEX(jfs_log_mutex);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int open_inline_log(struct super_block *sb);\nstatic int open_dummy_log(struct super_block *sb);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nint lmLogClose(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\tstruct block_device *bdev;\n\tint rc = 0;\n\n\tjfs_info(\"lmLogClose: log:0x%p\", log);\n\n\tmutex_lock(&jfs_log_mutex);\n\tLOG_LOCK(log);\n\tlist_del(&sbi->log_list);\n\tLOG_UNLOCK(log);\n\tsbi->log = NULL;\n\n\t/*\n\t * We need to make sure all of the \"written\" metapages\n\t * actually make it to disk\n\t */\n\tsync_blockdev(sb->s_bdev);\n\n\tif (test_bit(log_INLINELOG, &log->flag)) {\n\t\t/*\n\t\t *\tin-line log in host file system\n\t\t */\n\t\trc = lmLogShutdown(log);\n\t\tkfree(log);\n\t\tgoto out;\n\t}\n\n\tif (!log->no_integrity)\n\t\tlmLogFileSystem(log, sbi, 0);\n\n\tif (!list_empty(&log->sb_list))\n\t\tgoto out;\n\n\t/*\n\t * TODO: ensure that the dummy_log is in a state to allow\n\t * lbmLogShutdown to deallocate all the buffers and call\n\t * kfree against dummy_log.  For now, leave dummy_log & its\n\t * buffers in memory, and resuse if another no-integrity mount\n\t * is requested.\n\t */\n\tif (log->no_integrity)\n\t\tgoto out;\n\n\t/*\n\t *\texternal log as separate logical volume\n\t */\n\tlist_del(&log->journal_list);\n\tbdev = log->bdev;\n\trc = lmLogShutdown(log);\n\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n\n\tkfree(log);\n\n      out:\n\tmutex_unlock(&jfs_log_mutex);\n\tjfs_info(\"lmLogClose: exit(%d)\", rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_mount: updateSuper failed w/rc = %d\"",
            "rc"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "updateSuper",
          "args": [
            "sb",
            "FM_MOUNT"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "updateSuper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
          "lines": "409-456",
          "snippet": "int updateSuper(struct super_block *sb, uint state)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct buffer_head *bh;\n\tint rc;\n\n\tif (sbi->flag & JFS_NOINTEGRITY) {\n\t\tif (state == FM_DIRTY) {\n\t\t\tsbi->p_state = state;\n\t\t\treturn 0;\n\t\t} else if (state == FM_MOUNT) {\n\t\t\tsbi->p_state = sbi->state;\n\t\t\tstate = FM_DIRTY;\n\t\t} else if (state == FM_CLEAN) {\n\t\t\tstate = sbi->p_state;\n\t\t} else\n\t\t\tjfs_err(\"updateSuper: bad state\");\n\t} else if (sbi->state == FM_DIRTY)\n\t\treturn 0;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\tj_sb->s_state = cpu_to_le32(state);\n\tsbi->state = state;\n\n\tif (state == FM_MOUNT) {\n\t\t/* record log's dev_t and mount serial number */\n\t\tj_sb->s_logdev = cpu_to_le32(new_encode_dev(sbi->log->bdev->bd_dev));\n\t\tj_sb->s_logserial = cpu_to_le32(sbi->log->serial);\n\t} else if (state == FM_CLEAN) {\n\t\t/*\n\t\t * If this volume is shared with OS/2, OS/2 will need to\n\t\t * recalculate DASD usage, since we don't deal with it.\n\t\t */\n\t\tif (j_sb->s_flag & cpu_to_le32(JFS_DASD_ENABLED))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_DASD_PRIME);\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int chkSuper(struct super_block *);",
            "static int logMOUNT(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nint updateSuper(struct super_block *sb, uint state)\n{\n\tstruct jfs_superblock *j_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct buffer_head *bh;\n\tint rc;\n\n\tif (sbi->flag & JFS_NOINTEGRITY) {\n\t\tif (state == FM_DIRTY) {\n\t\t\tsbi->p_state = state;\n\t\t\treturn 0;\n\t\t} else if (state == FM_MOUNT) {\n\t\t\tsbi->p_state = sbi->state;\n\t\t\tstate = FM_DIRTY;\n\t\t} else if (state == FM_CLEAN) {\n\t\t\tstate = sbi->p_state;\n\t\t} else\n\t\t\tjfs_err(\"updateSuper: bad state\");\n\t} else if (sbi->state == FM_DIRTY)\n\t\treturn 0;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\tj_sb->s_state = cpu_to_le32(state);\n\tsbi->state = state;\n\n\tif (state == FM_MOUNT) {\n\t\t/* record log's dev_t and mount serial number */\n\t\tj_sb->s_logdev = cpu_to_le32(new_encode_dev(sbi->log->bdev->bd_dev));\n\t\tj_sb->s_logserial = cpu_to_le32(sbi->log->serial);\n\t} else if (state == FM_CLEAN) {\n\t\t/*\n\t\t * If this volume is shared with OS/2, OS/2 will need to\n\t\t * recalculate DASD usage, since we don't deal with it.\n\t\t */\n\t\tif (j_sb->s_flag & cpu_to_le32(JFS_DASD_ENABLED))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_DASD_PRIME);\n\t}\n\n\tmark_buffer_dirty(bh);\n\tsync_dirty_buffer(bh);\n\tbrelse(bh);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmLogOpen",
          "args": [
            "sb"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "lmLogOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1079-1174",
          "snippet": "int lmLogOpen(struct super_block *sb)\n{\n\tint rc;\n\tstruct block_device *bdev;\n\tstruct jfs_log *log;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\n\tif (sbi->flag & JFS_NOINTEGRITY)\n\t\treturn open_dummy_log(sb);\n\n\tif (sbi->mntflag & JFS_INLINELOG)\n\t\treturn open_inline_log(sb);\n\n\tmutex_lock(&jfs_log_mutex);\n\tlist_for_each_entry(log, &jfs_external_logs, journal_list) {\n\t\tif (log->bdev->bd_dev == sbi->logdev) {\n\t\t\tif (memcmp(log->uuid, sbi->loguuid,\n\t\t\t\t   sizeof(log->uuid))) {\n\t\t\t\tjfs_warn(\"wrong uuid on JFS journal\\n\");\n\t\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/*\n\t\t\t * add file system to log active file system list\n\t\t\t */\n\t\t\tif ((rc = lmLogFileSystem(log, sbi, 1))) {\n\t\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tgoto journal_found;\n\t\t}\n\t}\n\n\tif (!(log = kzalloc(sizeof(struct jfs_log), GFP_KERNEL))) {\n\t\tmutex_unlock(&jfs_log_mutex);\n\t\treturn -ENOMEM;\n\t}\n\tINIT_LIST_HEAD(&log->sb_list);\n\tinit_waitqueue_head(&log->syncwait);\n\n\t/*\n\t *\texternal log as separate logical volume\n\t *\n\t * file systems to log may have n-to-1 relationship;\n\t */\n\n\tbdev = blkdev_get_by_dev(sbi->logdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL,\n\t\t\t\t log);\n\tif (IS_ERR(bdev)) {\n\t\trc = PTR_ERR(bdev);\n\t\tgoto free;\n\t}\n\n\tlog->bdev = bdev;\n\tmemcpy(log->uuid, sbi->loguuid, sizeof(log->uuid));\n\n\t/*\n\t * initialize log:\n\t */\n\tif ((rc = lmLogInit(log)))\n\t\tgoto close;\n\n\tlist_add(&log->journal_list, &jfs_external_logs);\n\n\t/*\n\t * add file system to log active file system list\n\t */\n\tif ((rc = lmLogFileSystem(log, sbi, 1)))\n\t\tgoto shutdown;\n\njournal_found:\n\tLOG_LOCK(log);\n\tlist_add(&sbi->log_list, &log->sb_list);\n\tsbi->log = log;\n\tLOG_UNLOCK(log);\n\n\tmutex_unlock(&jfs_log_mutex);\n\treturn 0;\n\n\t/*\n\t *\tunwind on error\n\t */\n      shutdown:\t\t/* unwind lbmLogInit() */\n\tlist_del(&log->journal_list);\n\tlbmLogShutdown(log);\n\n      close:\t\t/* close external log device */\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n\n      free:\t\t/* free log descriptor */\n\tmutex_unlock(&jfs_log_mutex);\n\tkfree(log);\n\n\tjfs_warn(\"lmLogOpen: exit(%d)\", rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(jfs_external_logs);",
            "static DEFINE_MUTEX(jfs_log_mutex);",
            "static int lmNextPage(struct jfs_log * log);",
            "static int open_inline_log(struct super_block *sb);",
            "static int open_dummy_log(struct super_block *sb);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic LIST_HEAD(jfs_external_logs);\nstatic DEFINE_MUTEX(jfs_log_mutex);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int open_inline_log(struct super_block *sb);\nstatic int open_dummy_log(struct super_block *sb);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nint lmLogOpen(struct super_block *sb)\n{\n\tint rc;\n\tstruct block_device *bdev;\n\tstruct jfs_log *log;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\n\tif (sbi->flag & JFS_NOINTEGRITY)\n\t\treturn open_dummy_log(sb);\n\n\tif (sbi->mntflag & JFS_INLINELOG)\n\t\treturn open_inline_log(sb);\n\n\tmutex_lock(&jfs_log_mutex);\n\tlist_for_each_entry(log, &jfs_external_logs, journal_list) {\n\t\tif (log->bdev->bd_dev == sbi->logdev) {\n\t\t\tif (memcmp(log->uuid, sbi->loguuid,\n\t\t\t\t   sizeof(log->uuid))) {\n\t\t\t\tjfs_warn(\"wrong uuid on JFS journal\\n\");\n\t\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/*\n\t\t\t * add file system to log active file system list\n\t\t\t */\n\t\t\tif ((rc = lmLogFileSystem(log, sbi, 1))) {\n\t\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tgoto journal_found;\n\t\t}\n\t}\n\n\tif (!(log = kzalloc(sizeof(struct jfs_log), GFP_KERNEL))) {\n\t\tmutex_unlock(&jfs_log_mutex);\n\t\treturn -ENOMEM;\n\t}\n\tINIT_LIST_HEAD(&log->sb_list);\n\tinit_waitqueue_head(&log->syncwait);\n\n\t/*\n\t *\texternal log as separate logical volume\n\t *\n\t * file systems to log may have n-to-1 relationship;\n\t */\n\n\tbdev = blkdev_get_by_dev(sbi->logdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL,\n\t\t\t\t log);\n\tif (IS_ERR(bdev)) {\n\t\trc = PTR_ERR(bdev);\n\t\tgoto free;\n\t}\n\n\tlog->bdev = bdev;\n\tmemcpy(log->uuid, sbi->loguuid, sizeof(log->uuid));\n\n\t/*\n\t * initialize log:\n\t */\n\tif ((rc = lmLogInit(log)))\n\t\tgoto close;\n\n\tlist_add(&log->journal_list, &jfs_external_logs);\n\n\t/*\n\t * add file system to log active file system list\n\t */\n\tif ((rc = lmLogFileSystem(log, sbi, 1)))\n\t\tgoto shutdown;\n\njournal_found:\n\tLOG_LOCK(log);\n\tlist_add(&sbi->log_list, &log->sb_list);\n\tsbi->log = log;\n\tLOG_UNLOCK(log);\n\n\tmutex_unlock(&jfs_log_mutex);\n\treturn 0;\n\n\t/*\n\t *\tunwind on error\n\t */\n      shutdown:\t\t/* unwind lbmLogInit() */\n\tlist_del(&log->journal_list);\n\tlbmLogShutdown(log);\n\n      close:\t\t/* close external log device */\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n\n      free:\t\t/* free log descriptor */\n\tmutex_unlock(&jfs_log_mutex);\n\tkfree(log);\n\n\tjfs_warn(\"lmLogOpen: exit(%d)\", rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_mount_rw: dbMount failed!\""
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbMount",
          "args": [
            "sbi->ipbmap"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "dbMount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "165-223",
          "snippet": "int dbMount(struct inode *ipbmap)\n{\n\tstruct bmap *bmp;\n\tstruct dbmap_disk *dbmp_le;\n\tstruct metapage *mp;\n\tint i;\n\n\t/*\n\t * allocate/initialize the in-memory bmap descriptor\n\t */\n\t/* allocate memory for the in-memory bmap descriptor */\n\tbmp = kmalloc(sizeof(struct bmap), GFP_KERNEL);\n\tif (bmp == NULL)\n\t\treturn -ENOMEM;\n\n\t/* read the on-disk bmap descriptor. */\n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tkfree(bmp);\n\t\treturn -EIO;\n\t}\n\n\t/* copy the on-disk bmap descriptor to its in-memory version. */\n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tbmp->db_mapsize = le64_to_cpu(dbmp_le->dn_mapsize);\n\tbmp->db_nfree = le64_to_cpu(dbmp_le->dn_nfree);\n\tbmp->db_l2nbperpage = le32_to_cpu(dbmp_le->dn_l2nbperpage);\n\tbmp->db_numag = le32_to_cpu(dbmp_le->dn_numag);\n\tbmp->db_maxlevel = le32_to_cpu(dbmp_le->dn_maxlevel);\n\tbmp->db_maxag = le32_to_cpu(dbmp_le->dn_maxag);\n\tbmp->db_agpref = le32_to_cpu(dbmp_le->dn_agpref);\n\tbmp->db_aglevel = le32_to_cpu(dbmp_le->dn_aglevel);\n\tbmp->db_agheight = le32_to_cpu(dbmp_le->dn_agheight);\n\tbmp->db_agwidth = le32_to_cpu(dbmp_le->dn_agwidth);\n\tbmp->db_agstart = le32_to_cpu(dbmp_le->dn_agstart);\n\tbmp->db_agl2size = le32_to_cpu(dbmp_le->dn_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tbmp->db_agfree[i] = le64_to_cpu(dbmp_le->dn_agfree[i]);\n\tbmp->db_agsize = le64_to_cpu(dbmp_le->dn_agsize);\n\tbmp->db_maxfreebud = dbmp_le->dn_maxfreebud;\n\n\t/* release the buffer. */\n\trelease_metapage(mp);\n\n\t/* bind the bmap inode and the bmap descriptor to each other. */\n\tbmp->db_ipbmap = ipbmap;\n\tJFS_SBI(ipbmap->i_sb)->bmap = bmp;\n\n\tmemset(bmp->db_active, 0, sizeof(bmp->db_active));\n\n\t/*\n\t * allocate/initialize the bmap lock\n\t */\n\tBMAP_LOCK_INIT(bmp);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nint dbMount(struct inode *ipbmap)\n{\n\tstruct bmap *bmp;\n\tstruct dbmap_disk *dbmp_le;\n\tstruct metapage *mp;\n\tint i;\n\n\t/*\n\t * allocate/initialize the in-memory bmap descriptor\n\t */\n\t/* allocate memory for the in-memory bmap descriptor */\n\tbmp = kmalloc(sizeof(struct bmap), GFP_KERNEL);\n\tif (bmp == NULL)\n\t\treturn -ENOMEM;\n\n\t/* read the on-disk bmap descriptor. */\n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tkfree(bmp);\n\t\treturn -EIO;\n\t}\n\n\t/* copy the on-disk bmap descriptor to its in-memory version. */\n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tbmp->db_mapsize = le64_to_cpu(dbmp_le->dn_mapsize);\n\tbmp->db_nfree = le64_to_cpu(dbmp_le->dn_nfree);\n\tbmp->db_l2nbperpage = le32_to_cpu(dbmp_le->dn_l2nbperpage);\n\tbmp->db_numag = le32_to_cpu(dbmp_le->dn_numag);\n\tbmp->db_maxlevel = le32_to_cpu(dbmp_le->dn_maxlevel);\n\tbmp->db_maxag = le32_to_cpu(dbmp_le->dn_maxag);\n\tbmp->db_agpref = le32_to_cpu(dbmp_le->dn_agpref);\n\tbmp->db_aglevel = le32_to_cpu(dbmp_le->dn_aglevel);\n\tbmp->db_agheight = le32_to_cpu(dbmp_le->dn_agheight);\n\tbmp->db_agwidth = le32_to_cpu(dbmp_le->dn_agwidth);\n\tbmp->db_agstart = le32_to_cpu(dbmp_le->dn_agstart);\n\tbmp->db_agl2size = le32_to_cpu(dbmp_le->dn_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tbmp->db_agfree[i] = le64_to_cpu(dbmp_le->dn_agfree[i]);\n\tbmp->db_agsize = le64_to_cpu(dbmp_le->dn_agsize);\n\tbmp->db_maxfreebud = dbmp_le->dn_maxfreebud;\n\n\t/* release the buffer. */\n\trelease_metapage(mp);\n\n\t/* bind the bmap inode and the bmap descriptor to each other. */\n\tbmp->db_ipbmap = ipbmap;\n\tJFS_SBI(ipbmap->i_sb)->bmap = bmp;\n\n\tmemset(bmp->db_active, 0, sizeof(bmp->db_active));\n\n\t/*\n\t * allocate/initialize the bmap lock\n\t */\n\tBMAP_LOCK_INIT(bmp);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbUnmount",
          "args": [
            "sbi->ipbmap",
            "1"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "dbUnmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "242-258",
          "snippet": "int dbUnmount(struct inode *ipbmap, int mounterror)\n{\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tif (!(mounterror || isReadOnly(ipbmap)))\n\t\tdbSync(ipbmap);\n\n\t/*\n\t * Invalidate the page cache buffers\n\t */\n\ttruncate_inode_pages(ipbmap->i_mapping, 0);\n\n\t/* free the memory for the in-memory bmap. */\n\tkfree(bmp);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint dbUnmount(struct inode *ipbmap, int mounterror)\n{\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tif (!(mounterror || isReadOnly(ipbmap)))\n\t\tdbSync(ipbmap);\n\n\t/*\n\t * Invalidate the page cache buffers\n\t */\n\ttruncate_inode_pages(ipbmap->i_mapping, 0);\n\n\t/* free the memory for the in-memory bmap. */\n\tkfree(bmp);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_mount_rw: diMount failed!\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diMount",
          "args": [
            "sbi->ipimap"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "diMount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "107-174",
          "snippet": "int diMount(struct inode *ipimap)\n{\n\tstruct inomap *imap;\n\tstruct metapage *mp;\n\tint index;\n\tstruct dinomap_disk *dinom_le;\n\n\t/*\n\t * allocate/initialize the in-memory inode map control structure\n\t */\n\t/* allocate the in-memory inode map control structure. */\n\timap = kmalloc(sizeof(struct inomap), GFP_KERNEL);\n\tif (imap == NULL) {\n\t\tjfs_err(\"diMount: kmalloc returned NULL!\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* read the on-disk inode map control structure. */\n\n\tmp = read_metapage(ipimap,\n\t\t\t   IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tkfree(imap);\n\t\treturn -EIO;\n\t}\n\n\t/* copy the on-disk version to the in-memory version. */\n\tdinom_le = (struct dinomap_disk *) mp->data;\n\timap->im_freeiag = le32_to_cpu(dinom_le->in_freeiag);\n\timap->im_nextiag = le32_to_cpu(dinom_le->in_nextiag);\n\tatomic_set(&imap->im_numinos, le32_to_cpu(dinom_le->in_numinos));\n\tatomic_set(&imap->im_numfree, le32_to_cpu(dinom_le->in_numfree));\n\timap->im_nbperiext = le32_to_cpu(dinom_le->in_nbperiext);\n\timap->im_l2nbperiext = le32_to_cpu(dinom_le->in_l2nbperiext);\n\tfor (index = 0; index < MAXAG; index++) {\n\t\timap->im_agctl[index].inofree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].inofree);\n\t\timap->im_agctl[index].extfree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].extfree);\n\t\timap->im_agctl[index].numinos =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].numinos);\n\t\timap->im_agctl[index].numfree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].numfree);\n\t}\n\n\t/* release the buffer. */\n\trelease_metapage(mp);\n\n\t/*\n\t * allocate/initialize inode allocation map locks\n\t */\n\t/* allocate and init iag free list lock */\n\tIAGFREE_LOCK_INIT(imap);\n\n\t/* allocate and init ag list locks */\n\tfor (index = 0; index < MAXAG; index++) {\n\t\tAG_LOCK_INIT(imap, index);\n\t}\n\n\t/* bind the inode map inode and inode map control structure\n\t * to each other.\n\t */\n\timap->im_ipimap = ipimap;\n\tJFS_IP(ipimap)->i_imap = imap;\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diMount(struct inode *ipimap)\n{\n\tstruct inomap *imap;\n\tstruct metapage *mp;\n\tint index;\n\tstruct dinomap_disk *dinom_le;\n\n\t/*\n\t * allocate/initialize the in-memory inode map control structure\n\t */\n\t/* allocate the in-memory inode map control structure. */\n\timap = kmalloc(sizeof(struct inomap), GFP_KERNEL);\n\tif (imap == NULL) {\n\t\tjfs_err(\"diMount: kmalloc returned NULL!\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* read the on-disk inode map control structure. */\n\n\tmp = read_metapage(ipimap,\n\t\t\t   IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tkfree(imap);\n\t\treturn -EIO;\n\t}\n\n\t/* copy the on-disk version to the in-memory version. */\n\tdinom_le = (struct dinomap_disk *) mp->data;\n\timap->im_freeiag = le32_to_cpu(dinom_le->in_freeiag);\n\timap->im_nextiag = le32_to_cpu(dinom_le->in_nextiag);\n\tatomic_set(&imap->im_numinos, le32_to_cpu(dinom_le->in_numinos));\n\tatomic_set(&imap->im_numfree, le32_to_cpu(dinom_le->in_numfree));\n\timap->im_nbperiext = le32_to_cpu(dinom_le->in_nbperiext);\n\timap->im_l2nbperiext = le32_to_cpu(dinom_le->in_l2nbperiext);\n\tfor (index = 0; index < MAXAG; index++) {\n\t\timap->im_agctl[index].inofree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].inofree);\n\t\timap->im_agctl[index].extfree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].extfree);\n\t\timap->im_agctl[index].numinos =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].numinos);\n\t\timap->im_agctl[index].numfree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].numfree);\n\t}\n\n\t/* release the buffer. */\n\trelease_metapage(mp);\n\n\t/*\n\t * allocate/initialize inode allocation map locks\n\t */\n\t/* allocate and init iag free list lock */\n\tIAGFREE_LOCK_INIT(imap);\n\n\t/* allocate and init ag list locks */\n\tfor (index = 0; index < MAXAG; index++) {\n\t\tAG_LOCK_INIT(imap, index);\n\t}\n\n\t/* bind the inode map inode and inode map control structure\n\t * to each other.\n\t */\n\timap->im_ipimap = ipimap;\n\tJFS_IP(ipimap)->i_imap = imap;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diUnmount",
          "args": [
            "sbi->ipimap",
            "1"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "diUnmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "191-213",
          "snippet": "int diUnmount(struct inode *ipimap, int mounterror)\n{\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\n\t/*\n\t * update the on-disk inode map control structure\n\t */\n\n\tif (!(mounterror || isReadOnly(ipimap)))\n\t\tdiSync(ipimap);\n\n\t/*\n\t * Invalidate the page cache buffers\n\t */\n\ttruncate_inode_pages(ipimap->i_mapping, 0);\n\n\t/*\n\t * free in-memory control structure\n\t */\n\tkfree(imap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diUnmount(struct inode *ipimap, int mounterror)\n{\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\n\t/*\n\t * update the on-disk inode map control structure\n\t */\n\n\tif (!(mounterror || isReadOnly(ipimap)))\n\t\tdiSync(ipimap);\n\n\t/*\n\t * Invalidate the page cache buffers\n\t */\n\ttruncate_inode_pages(ipimap->i_mapping, 0);\n\n\t/*\n\t * free in-memory control structure\n\t */\n\tkfree(imap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "sbi->ipbmap->i_mapping",
            "0"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "sbi->ipimap->i_mapping",
            "0"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chkSuper",
          "args": [
            "sb"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "chkSuper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
          "lines": "301-401",
          "snippet": "static int chkSuper(struct super_block *sb)\n{\n\tint rc = 0;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_superblock *j_sb;\n\tstruct buffer_head *bh;\n\tint AIM_bytesize, AIT_bytesize;\n\tint expected_AIM_bytesize, expected_AIT_bytesize;\n\ts64 AIM_byte_addr, AIT_byte_addr, fsckwsp_addr;\n\ts64 byte_addr_diff0, byte_addr_diff1;\n\ts32 bsize;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\t/*\n\t * validate superblock\n\t */\n\t/* validate fs signature */\n\tif (strncmp(j_sb->s_magic, JFS_MAGIC, 4) ||\n\t    le32_to_cpu(j_sb->s_version) > JFS_VERSION) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbsize = le32_to_cpu(j_sb->s_bsize);\n#ifdef _JFS_4K\n\tif (bsize != PSIZE) {\n\t\tjfs_err(\"Currently only 4K block size supported!\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n#endif\t\t\t\t/* _JFS_4K */\n\n\tjfs_info(\"superblock: flag:0x%08x state:0x%08x size:0x%Lx\",\n\t\t le32_to_cpu(j_sb->s_flag), le32_to_cpu(j_sb->s_state),\n\t\t (unsigned long long) le64_to_cpu(j_sb->s_size));\n\n\t/* validate the descriptors for Secondary AIM and AIT */\n\tif ((j_sb->s_flag & cpu_to_le32(JFS_BAD_SAIT)) !=\n\t    cpu_to_le32(JFS_BAD_SAIT)) {\n\t\texpected_AIM_bytesize = 2 * PSIZE;\n\t\tAIM_bytesize = lengthPXD(&(j_sb->s_aim2)) * bsize;\n\t\texpected_AIT_bytesize = 4 * PSIZE;\n\t\tAIT_bytesize = lengthPXD(&(j_sb->s_ait2)) * bsize;\n\t\tAIM_byte_addr = addressPXD(&(j_sb->s_aim2)) * bsize;\n\t\tAIT_byte_addr = addressPXD(&(j_sb->s_ait2)) * bsize;\n\t\tbyte_addr_diff0 = AIT_byte_addr - AIM_byte_addr;\n\t\tfsckwsp_addr = addressPXD(&(j_sb->s_fsckpxd)) * bsize;\n\t\tbyte_addr_diff1 = fsckwsp_addr - AIT_byte_addr;\n\t\tif ((AIM_bytesize != expected_AIM_bytesize) ||\n\t\t    (AIT_bytesize != expected_AIT_bytesize) ||\n\t\t    (byte_addr_diff0 != AIM_bytesize) ||\n\t\t    (byte_addr_diff1 <= AIT_bytesize))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_BAD_SAIT);\n\t}\n\n\tif ((j_sb->s_flag & cpu_to_le32(JFS_GROUPCOMMIT)) !=\n\t    cpu_to_le32(JFS_GROUPCOMMIT))\n\t\tj_sb->s_flag |= cpu_to_le32(JFS_GROUPCOMMIT);\n\n\t/* validate fs state */\n\tif (j_sb->s_state != cpu_to_le32(FM_CLEAN) &&\n\t    !(sb->s_flags & MS_RDONLY)) {\n\t\tjfs_err(\"jfs_mount: Mount Failure: File System Dirty.\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsbi->state = le32_to_cpu(j_sb->s_state);\n\tsbi->mntflag = le32_to_cpu(j_sb->s_flag);\n\n\t/*\n\t * JFS always does I/O by 4K pages.  Don't tell the buffer cache\n\t * that we use anything else (leave s_blocksize alone).\n\t */\n\tsbi->bsize = bsize;\n\tsbi->l2bsize = le16_to_cpu(j_sb->s_l2bsize);\n\n\t/*\n\t * For now, ignore s_pbsize, l2bfactor.  All I/O going through buffer\n\t * cache.\n\t */\n\tsbi->nbperpage = PSIZE >> sbi->l2bsize;\n\tsbi->l2nbperpage = L2PSIZE - sbi->l2bsize;\n\tsbi->l2niperblk = sbi->l2bsize - L2DISIZE;\n\tif (sbi->mntflag & JFS_INLINELOG)\n\t\tsbi->logpxd = j_sb->s_logpxd;\n\telse {\n\t\tsbi->logdev = new_decode_dev(le32_to_cpu(j_sb->s_logdev));\n\t\tmemcpy(sbi->uuid, j_sb->s_uuid, sizeof(sbi->uuid));\n\t\tmemcpy(sbi->loguuid, j_sb->s_loguuid, sizeof(sbi->uuid));\n\t}\n\tsbi->fsckpxd = j_sb->s_fsckpxd;\n\tsbi->ait2 = j_sb->s_ait2;\n\n      out:\n\tbrelse(bh);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int chkSuper(struct super_block *);",
            "static int logMOUNT(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nstatic int chkSuper(struct super_block *sb)\n{\n\tint rc = 0;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_superblock *j_sb;\n\tstruct buffer_head *bh;\n\tint AIM_bytesize, AIT_bytesize;\n\tint expected_AIM_bytesize, expected_AIT_bytesize;\n\ts64 AIM_byte_addr, AIT_byte_addr, fsckwsp_addr;\n\ts64 byte_addr_diff0, byte_addr_diff1;\n\ts32 bsize;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\t/*\n\t * validate superblock\n\t */\n\t/* validate fs signature */\n\tif (strncmp(j_sb->s_magic, JFS_MAGIC, 4) ||\n\t    le32_to_cpu(j_sb->s_version) > JFS_VERSION) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbsize = le32_to_cpu(j_sb->s_bsize);\n#ifdef _JFS_4K\n\tif (bsize != PSIZE) {\n\t\tjfs_err(\"Currently only 4K block size supported!\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n#endif\t\t\t\t/* _JFS_4K */\n\n\tjfs_info(\"superblock: flag:0x%08x state:0x%08x size:0x%Lx\",\n\t\t le32_to_cpu(j_sb->s_flag), le32_to_cpu(j_sb->s_state),\n\t\t (unsigned long long) le64_to_cpu(j_sb->s_size));\n\n\t/* validate the descriptors for Secondary AIM and AIT */\n\tif ((j_sb->s_flag & cpu_to_le32(JFS_BAD_SAIT)) !=\n\t    cpu_to_le32(JFS_BAD_SAIT)) {\n\t\texpected_AIM_bytesize = 2 * PSIZE;\n\t\tAIM_bytesize = lengthPXD(&(j_sb->s_aim2)) * bsize;\n\t\texpected_AIT_bytesize = 4 * PSIZE;\n\t\tAIT_bytesize = lengthPXD(&(j_sb->s_ait2)) * bsize;\n\t\tAIM_byte_addr = addressPXD(&(j_sb->s_aim2)) * bsize;\n\t\tAIT_byte_addr = addressPXD(&(j_sb->s_ait2)) * bsize;\n\t\tbyte_addr_diff0 = AIT_byte_addr - AIM_byte_addr;\n\t\tfsckwsp_addr = addressPXD(&(j_sb->s_fsckpxd)) * bsize;\n\t\tbyte_addr_diff1 = fsckwsp_addr - AIT_byte_addr;\n\t\tif ((AIM_bytesize != expected_AIM_bytesize) ||\n\t\t    (AIT_bytesize != expected_AIT_bytesize) ||\n\t\t    (byte_addr_diff0 != AIM_bytesize) ||\n\t\t    (byte_addr_diff1 <= AIT_bytesize))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_BAD_SAIT);\n\t}\n\n\tif ((j_sb->s_flag & cpu_to_le32(JFS_GROUPCOMMIT)) !=\n\t    cpu_to_le32(JFS_GROUPCOMMIT))\n\t\tj_sb->s_flag |= cpu_to_le32(JFS_GROUPCOMMIT);\n\n\t/* validate fs state */\n\tif (j_sb->s_state != cpu_to_le32(FM_CLEAN) &&\n\t    !(sb->s_flags & MS_RDONLY)) {\n\t\tjfs_err(\"jfs_mount: Mount Failure: File System Dirty.\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsbi->state = le32_to_cpu(j_sb->s_state);\n\tsbi->mntflag = le32_to_cpu(j_sb->s_flag);\n\n\t/*\n\t * JFS always does I/O by 4K pages.  Don't tell the buffer cache\n\t * that we use anything else (leave s_blocksize alone).\n\t */\n\tsbi->bsize = bsize;\n\tsbi->l2bsize = le16_to_cpu(j_sb->s_l2bsize);\n\n\t/*\n\t * For now, ignore s_pbsize, l2bfactor.  All I/O going through buffer\n\t * cache.\n\t */\n\tsbi->nbperpage = PSIZE >> sbi->l2bsize;\n\tsbi->l2nbperpage = L2PSIZE - sbi->l2bsize;\n\tsbi->l2niperblk = sbi->l2bsize - L2DISIZE;\n\tif (sbi->mntflag & JFS_INLINELOG)\n\t\tsbi->logpxd = j_sb->s_logpxd;\n\telse {\n\t\tsbi->logdev = new_decode_dev(le32_to_cpu(j_sb->s_logdev));\n\t\tmemcpy(sbi->uuid, j_sb->s_uuid, sizeof(sbi->uuid));\n\t\tmemcpy(sbi->loguuid, j_sb->s_loguuid, sizeof(sbi->uuid));\n\t}\n\tsbi->fsckpxd = j_sb->s_fsckpxd;\n\tsbi->ait2 = j_sb->s_ait2;\n\n      out:\n\tbrelse(bh);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nint jfs_mount_rw(struct super_block *sb, int remount)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tint rc;\n\n\t/*\n\t * If we are re-mounting a previously read-only volume, we want to\n\t * re-read the inode and block maps, since fsck.jfs may have updated\n\t * them.\n\t */\n\tif (remount) {\n\t\tif (chkSuper(sb) || (sbi->state != FM_CLEAN))\n\t\t\treturn -EINVAL;\n\n\t\ttruncate_inode_pages(sbi->ipimap->i_mapping, 0);\n\t\ttruncate_inode_pages(sbi->ipbmap->i_mapping, 0);\n\t\tdiUnmount(sbi->ipimap, 1);\n\t\tif ((rc = diMount(sbi->ipimap))) {\n\t\t\tjfs_err(\"jfs_mount_rw: diMount failed!\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tdbUnmount(sbi->ipbmap, 1);\n\t\tif ((rc = dbMount(sbi->ipbmap))) {\n\t\t\tjfs_err(\"jfs_mount_rw: dbMount failed!\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/*\n\t * open/initialize log\n\t */\n\tif ((rc = lmLogOpen(sb)))\n\t\treturn rc;\n\n\t/*\n\t * update file system superblock;\n\t */\n\tif ((rc = updateSuper(sb, FM_MOUNT))) {\n\t\tjfs_err(\"jfs_mount: updateSuper failed w/rc = %d\", rc);\n\t\tlmLogClose(sb);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * write MOUNT log record of the file system\n\t */\n\tlogMOUNT(sb);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "jfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
    "lines": "81-231",
    "snippet": "int jfs_mount(struct super_block *sb)\n{\n\tint rc = 0;\t\t/* Return code */\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct inode *ipaimap = NULL;\n\tstruct inode *ipaimap2 = NULL;\n\tstruct inode *ipimap = NULL;\n\tstruct inode *ipbmap = NULL;\n\n\t/*\n\t * read/validate superblock\n\t * (initialize mount inode from the superblock)\n\t */\n\tif ((rc = chkSuper(sb))) {\n\t\tgoto errout20;\n\t}\n\n\tipaimap = diReadSpecial(sb, AGGREGATE_I, 0);\n\tif (ipaimap == NULL) {\n\t\tjfs_err(\"jfs_mount: Failed to read AGGREGATE_I\");\n\t\trc = -EIO;\n\t\tgoto errout20;\n\t}\n\tsbi->ipaimap = ipaimap;\n\n\tjfs_info(\"jfs_mount: ipaimap:0x%p\", ipaimap);\n\n\t/*\n\t * initialize aggregate inode allocation map\n\t */\n\tif ((rc = diMount(ipaimap))) {\n\t\tjfs_err(\"jfs_mount: diMount(ipaimap) failed w/rc = %d\", rc);\n\t\tgoto errout21;\n\t}\n\n\t/*\n\t * open aggregate block allocation map\n\t */\n\tipbmap = diReadSpecial(sb, BMAP_I, 0);\n\tif (ipbmap == NULL) {\n\t\trc = -EIO;\n\t\tgoto errout22;\n\t}\n\n\tjfs_info(\"jfs_mount: ipbmap:0x%p\", ipbmap);\n\n\tsbi->ipbmap = ipbmap;\n\n\t/*\n\t * initialize aggregate block allocation map\n\t */\n\tif ((rc = dbMount(ipbmap))) {\n\t\tjfs_err(\"jfs_mount: dbMount failed w/rc = %d\", rc);\n\t\tgoto errout22;\n\t}\n\n\t/*\n\t * open the secondary aggregate inode allocation map\n\t *\n\t * This is a duplicate of the aggregate inode allocation map.\n\t *\n\t * hand craft a vfs in the same fashion as we did to read ipaimap.\n\t * By adding INOSPEREXT (32) to the inode number, we are telling\n\t * diReadSpecial that we are reading from the secondary aggregate\n\t * inode table.  This also creates a unique entry in the inode hash\n\t * table.\n\t */\n\tif ((sbi->mntflag & JFS_BAD_SAIT) == 0) {\n\t\tipaimap2 = diReadSpecial(sb, AGGREGATE_I, 1);\n\t\tif (!ipaimap2) {\n\t\t\tjfs_err(\"jfs_mount: Failed to read AGGREGATE_I\");\n\t\t\trc = -EIO;\n\t\t\tgoto errout35;\n\t\t}\n\t\tsbi->ipaimap2 = ipaimap2;\n\n\t\tjfs_info(\"jfs_mount: ipaimap2:0x%p\", ipaimap2);\n\n\t\t/*\n\t\t * initialize secondary aggregate inode allocation map\n\t\t */\n\t\tif ((rc = diMount(ipaimap2))) {\n\t\t\tjfs_err(\"jfs_mount: diMount(ipaimap2) failed, rc = %d\",\n\t\t\t\trc);\n\t\t\tgoto errout35;\n\t\t}\n\t} else\n\t\t/* Secondary aggregate inode table is not valid */\n\t\tsbi->ipaimap2 = NULL;\n\n\t/*\n\t *\tmount (the only/single) fileset\n\t */\n\t/*\n\t * open fileset inode allocation map (aka fileset inode)\n\t */\n\tipimap = diReadSpecial(sb, FILESYSTEM_I, 0);\n\tif (ipimap == NULL) {\n\t\tjfs_err(\"jfs_mount: Failed to read FILESYSTEM_I\");\n\t\t/* open fileset secondary inode allocation map */\n\t\trc = -EIO;\n\t\tgoto errout40;\n\t}\n\tjfs_info(\"jfs_mount: ipimap:0x%p\", ipimap);\n\n\t/* map further access of per fileset inodes by the fileset inode */\n\tsbi->ipimap = ipimap;\n\n\t/* initialize fileset inode allocation map */\n\tif ((rc = diMount(ipimap))) {\n\t\tjfs_err(\"jfs_mount: diMount failed w/rc = %d\", rc);\n\t\tgoto errout41;\n\t}\n\n\tgoto out;\n\n\t/*\n\t *\tunwind on error\n\t */\n      errout41:\t\t/* close fileset inode allocation map inode */\n\tdiFreeSpecial(ipimap);\n\n      errout40:\t\t/* fileset closed */\n\n\t/* close secondary aggregate inode allocation map */\n\tif (ipaimap2) {\n\t\tdiUnmount(ipaimap2, 1);\n\t\tdiFreeSpecial(ipaimap2);\n\t}\n\n      errout35:\n\n\t/* close aggregate block allocation map */\n\tdbUnmount(ipbmap, 1);\n\tdiFreeSpecial(ipbmap);\n\n      errout22:\t\t/* close aggregate inode allocation map */\n\n\tdiUnmount(ipaimap, 1);\n\n      errout21:\t\t/* close aggregate inodes */\n\tdiFreeSpecial(ipaimap);\n      errout20:\t\t/* aggregate closed */\n\n      out:\n\n\tif (rc)\n\t\tjfs_err(\"Mount JFS Failure: %d\", rc);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int chkSuper(struct super_block *);",
      "static int logMOUNT(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"Mount JFS Failure: %d\"",
            "rc"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diFreeSpecial",
          "args": [
            "ipaimap"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "diFreeSpecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "562-571",
          "snippet": "void diFreeSpecial(struct inode *ip)\n{\n\tif (ip == NULL) {\n\t\tjfs_err(\"diFreeSpecial called with NULL ip!\");\n\t\treturn;\n\t}\n\tfilemap_write_and_wait(ip->i_mapping);\n\ttruncate_inode_pages(ip->i_mapping, 0);\n\tiput(ip);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nvoid diFreeSpecial(struct inode *ip)\n{\n\tif (ip == NULL) {\n\t\tjfs_err(\"diFreeSpecial called with NULL ip!\");\n\t\treturn;\n\t}\n\tfilemap_write_and_wait(ip->i_mapping);\n\ttruncate_inode_pages(ip->i_mapping, 0);\n\tiput(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diUnmount",
          "args": [
            "ipaimap",
            "1"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "diUnmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "191-213",
          "snippet": "int diUnmount(struct inode *ipimap, int mounterror)\n{\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\n\t/*\n\t * update the on-disk inode map control structure\n\t */\n\n\tif (!(mounterror || isReadOnly(ipimap)))\n\t\tdiSync(ipimap);\n\n\t/*\n\t * Invalidate the page cache buffers\n\t */\n\ttruncate_inode_pages(ipimap->i_mapping, 0);\n\n\t/*\n\t * free in-memory control structure\n\t */\n\tkfree(imap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diUnmount(struct inode *ipimap, int mounterror)\n{\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\n\t/*\n\t * update the on-disk inode map control structure\n\t */\n\n\tif (!(mounterror || isReadOnly(ipimap)))\n\t\tdiSync(ipimap);\n\n\t/*\n\t * Invalidate the page cache buffers\n\t */\n\ttruncate_inode_pages(ipimap->i_mapping, 0);\n\n\t/*\n\t * free in-memory control structure\n\t */\n\tkfree(imap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbUnmount",
          "args": [
            "ipbmap",
            "1"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "dbUnmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "242-258",
          "snippet": "int dbUnmount(struct inode *ipbmap, int mounterror)\n{\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tif (!(mounterror || isReadOnly(ipbmap)))\n\t\tdbSync(ipbmap);\n\n\t/*\n\t * Invalidate the page cache buffers\n\t */\n\ttruncate_inode_pages(ipbmap->i_mapping, 0);\n\n\t/* free the memory for the in-memory bmap. */\n\tkfree(bmp);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint dbUnmount(struct inode *ipbmap, int mounterror)\n{\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tif (!(mounterror || isReadOnly(ipbmap)))\n\t\tdbSync(ipbmap);\n\n\t/*\n\t * Invalidate the page cache buffers\n\t */\n\ttruncate_inode_pages(ipbmap->i_mapping, 0);\n\n\t/* free the memory for the in-memory bmap. */\n\tkfree(bmp);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diMount",
          "args": [
            "ipimap"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "diMount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "107-174",
          "snippet": "int diMount(struct inode *ipimap)\n{\n\tstruct inomap *imap;\n\tstruct metapage *mp;\n\tint index;\n\tstruct dinomap_disk *dinom_le;\n\n\t/*\n\t * allocate/initialize the in-memory inode map control structure\n\t */\n\t/* allocate the in-memory inode map control structure. */\n\timap = kmalloc(sizeof(struct inomap), GFP_KERNEL);\n\tif (imap == NULL) {\n\t\tjfs_err(\"diMount: kmalloc returned NULL!\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* read the on-disk inode map control structure. */\n\n\tmp = read_metapage(ipimap,\n\t\t\t   IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tkfree(imap);\n\t\treturn -EIO;\n\t}\n\n\t/* copy the on-disk version to the in-memory version. */\n\tdinom_le = (struct dinomap_disk *) mp->data;\n\timap->im_freeiag = le32_to_cpu(dinom_le->in_freeiag);\n\timap->im_nextiag = le32_to_cpu(dinom_le->in_nextiag);\n\tatomic_set(&imap->im_numinos, le32_to_cpu(dinom_le->in_numinos));\n\tatomic_set(&imap->im_numfree, le32_to_cpu(dinom_le->in_numfree));\n\timap->im_nbperiext = le32_to_cpu(dinom_le->in_nbperiext);\n\timap->im_l2nbperiext = le32_to_cpu(dinom_le->in_l2nbperiext);\n\tfor (index = 0; index < MAXAG; index++) {\n\t\timap->im_agctl[index].inofree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].inofree);\n\t\timap->im_agctl[index].extfree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].extfree);\n\t\timap->im_agctl[index].numinos =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].numinos);\n\t\timap->im_agctl[index].numfree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].numfree);\n\t}\n\n\t/* release the buffer. */\n\trelease_metapage(mp);\n\n\t/*\n\t * allocate/initialize inode allocation map locks\n\t */\n\t/* allocate and init iag free list lock */\n\tIAGFREE_LOCK_INIT(imap);\n\n\t/* allocate and init ag list locks */\n\tfor (index = 0; index < MAXAG; index++) {\n\t\tAG_LOCK_INIT(imap, index);\n\t}\n\n\t/* bind the inode map inode and inode map control structure\n\t * to each other.\n\t */\n\timap->im_ipimap = ipimap;\n\tJFS_IP(ipimap)->i_imap = imap;\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diMount(struct inode *ipimap)\n{\n\tstruct inomap *imap;\n\tstruct metapage *mp;\n\tint index;\n\tstruct dinomap_disk *dinom_le;\n\n\t/*\n\t * allocate/initialize the in-memory inode map control structure\n\t */\n\t/* allocate the in-memory inode map control structure. */\n\timap = kmalloc(sizeof(struct inomap), GFP_KERNEL);\n\tif (imap == NULL) {\n\t\tjfs_err(\"diMount: kmalloc returned NULL!\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* read the on-disk inode map control structure. */\n\n\tmp = read_metapage(ipimap,\n\t\t\t   IMAPBLKNO << JFS_SBI(ipimap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tkfree(imap);\n\t\treturn -EIO;\n\t}\n\n\t/* copy the on-disk version to the in-memory version. */\n\tdinom_le = (struct dinomap_disk *) mp->data;\n\timap->im_freeiag = le32_to_cpu(dinom_le->in_freeiag);\n\timap->im_nextiag = le32_to_cpu(dinom_le->in_nextiag);\n\tatomic_set(&imap->im_numinos, le32_to_cpu(dinom_le->in_numinos));\n\tatomic_set(&imap->im_numfree, le32_to_cpu(dinom_le->in_numfree));\n\timap->im_nbperiext = le32_to_cpu(dinom_le->in_nbperiext);\n\timap->im_l2nbperiext = le32_to_cpu(dinom_le->in_l2nbperiext);\n\tfor (index = 0; index < MAXAG; index++) {\n\t\timap->im_agctl[index].inofree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].inofree);\n\t\timap->im_agctl[index].extfree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].extfree);\n\t\timap->im_agctl[index].numinos =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].numinos);\n\t\timap->im_agctl[index].numfree =\n\t\t    le32_to_cpu(dinom_le->in_agctl[index].numfree);\n\t}\n\n\t/* release the buffer. */\n\trelease_metapage(mp);\n\n\t/*\n\t * allocate/initialize inode allocation map locks\n\t */\n\t/* allocate and init iag free list lock */\n\tIAGFREE_LOCK_INIT(imap);\n\n\t/* allocate and init ag list locks */\n\tfor (index = 0; index < MAXAG; index++) {\n\t\tAG_LOCK_INIT(imap, index);\n\t}\n\n\t/* bind the inode map inode and inode map control structure\n\t * to each other.\n\t */\n\timap->im_ipimap = ipimap;\n\tJFS_IP(ipimap)->i_imap = imap;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_mount: ipimap:0x%p\"",
            "ipimap"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_mount: Failed to read FILESYSTEM_I\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diReadSpecial",
          "args": [
            "sb",
            "FILESYSTEM_I",
            "0"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "diReadSpecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "429-503",
          "snippet": "struct inode *diReadSpecial(struct super_block *sb, ino_t inum, int secondary)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tuint address;\n\tstruct dinode *dp;\n\tstruct inode *ip;\n\tstruct metapage *mp;\n\n\tip = new_inode(sb);\n\tif (ip == NULL) {\n\t\tjfs_err(\"diReadSpecial: new_inode returned NULL!\");\n\t\treturn ip;\n\t}\n\n\tif (secondary) {\n\t\taddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\n\t\tJFS_IP(ip)->ipimap = sbi->ipaimap2;\n\t} else {\n\t\taddress = AITBL_OFF >> L2PSIZE;\n\t\tJFS_IP(ip)->ipimap = sbi->ipaimap;\n\t}\n\n\tASSERT(inum < INOSPEREXT);\n\n\tip->i_ino = inum;\n\n\taddress += inum >> 3;\t/* 8 inodes per 4K page */\n\n\t/* read the page of fixed disk inode (AIT) in raw mode */\n\tmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\n\tif (mp == NULL) {\n\t\tset_nlink(ip, 1);\t/* Don't want iput() deleting it */\n\t\tiput(ip);\n\t\treturn (NULL);\n\t}\n\n\t/* get the pointer to the disk inode of interest */\n\tdp = (struct dinode *) (mp->data);\n\tdp += inum % 8;\t\t/* 8 inodes per 4K page */\n\n\t/* copy on-disk inode to in-memory inode */\n\tif ((copy_from_dinode(dp, ip)) != 0) {\n\t\t/* handle bad return by returning NULL for ip */\n\t\tset_nlink(ip, 1);\t/* Don't want iput() deleting it */\n\t\tiput(ip);\n\t\t/* release the page */\n\t\trelease_metapage(mp);\n\t\treturn (NULL);\n\n\t}\n\n\tip->i_mapping->a_ops = &jfs_metapage_aops;\n\tmapping_set_gfp_mask(ip->i_mapping, GFP_NOFS);\n\n\t/* Allocations to metadata inodes should not affect quotas */\n\tip->i_flags |= S_NOQUOTA;\n\n\tif ((inum == FILESYSTEM_I) && (JFS_IP(ip)->ipimap == sbi->ipaimap)) {\n\t\tsbi->gengen = le32_to_cpu(dp->di_gengen);\n\t\tsbi->inostamp = le32_to_cpu(dp->di_inostamp);\n\t}\n\n\t/* release the page */\n\trelease_metapage(mp);\n\n\t/*\n\t * __mark_inode_dirty expects inodes to be hashed.  Since we don't\n\t * want special inodes in the fileset inode space, we make them\n\t * appear hashed, but do not put on any lists.  hlist_del()\n\t * will work fine and require no locking.\n\t */\n\thlist_add_fake(&ip->i_hash);\n\n\treturn (ip);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstruct inode *diReadSpecial(struct super_block *sb, ino_t inum, int secondary)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tuint address;\n\tstruct dinode *dp;\n\tstruct inode *ip;\n\tstruct metapage *mp;\n\n\tip = new_inode(sb);\n\tif (ip == NULL) {\n\t\tjfs_err(\"diReadSpecial: new_inode returned NULL!\");\n\t\treturn ip;\n\t}\n\n\tif (secondary) {\n\t\taddress = addressPXD(&sbi->ait2) >> sbi->l2nbperpage;\n\t\tJFS_IP(ip)->ipimap = sbi->ipaimap2;\n\t} else {\n\t\taddress = AITBL_OFF >> L2PSIZE;\n\t\tJFS_IP(ip)->ipimap = sbi->ipaimap;\n\t}\n\n\tASSERT(inum < INOSPEREXT);\n\n\tip->i_ino = inum;\n\n\taddress += inum >> 3;\t/* 8 inodes per 4K page */\n\n\t/* read the page of fixed disk inode (AIT) in raw mode */\n\tmp = read_metapage(ip, address << sbi->l2nbperpage, PSIZE, 1);\n\tif (mp == NULL) {\n\t\tset_nlink(ip, 1);\t/* Don't want iput() deleting it */\n\t\tiput(ip);\n\t\treturn (NULL);\n\t}\n\n\t/* get the pointer to the disk inode of interest */\n\tdp = (struct dinode *) (mp->data);\n\tdp += inum % 8;\t\t/* 8 inodes per 4K page */\n\n\t/* copy on-disk inode to in-memory inode */\n\tif ((copy_from_dinode(dp, ip)) != 0) {\n\t\t/* handle bad return by returning NULL for ip */\n\t\tset_nlink(ip, 1);\t/* Don't want iput() deleting it */\n\t\tiput(ip);\n\t\t/* release the page */\n\t\trelease_metapage(mp);\n\t\treturn (NULL);\n\n\t}\n\n\tip->i_mapping->a_ops = &jfs_metapage_aops;\n\tmapping_set_gfp_mask(ip->i_mapping, GFP_NOFS);\n\n\t/* Allocations to metadata inodes should not affect quotas */\n\tip->i_flags |= S_NOQUOTA;\n\n\tif ((inum == FILESYSTEM_I) && (JFS_IP(ip)->ipimap == sbi->ipaimap)) {\n\t\tsbi->gengen = le32_to_cpu(dp->di_gengen);\n\t\tsbi->inostamp = le32_to_cpu(dp->di_inostamp);\n\t}\n\n\t/* release the page */\n\trelease_metapage(mp);\n\n\t/*\n\t * __mark_inode_dirty expects inodes to be hashed.  Since we don't\n\t * want special inodes in the fileset inode space, we make them\n\t * appear hashed, but do not put on any lists.  hlist_del()\n\t * will work fine and require no locking.\n\t */\n\thlist_add_fake(&ip->i_hash);\n\n\treturn (ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_mount: ipaimap2:0x%p\"",
            "ipaimap2"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_mount: Failed to read AGGREGATE_I\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbMount",
          "args": [
            "ipbmap"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "dbMount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "165-223",
          "snippet": "int dbMount(struct inode *ipbmap)\n{\n\tstruct bmap *bmp;\n\tstruct dbmap_disk *dbmp_le;\n\tstruct metapage *mp;\n\tint i;\n\n\t/*\n\t * allocate/initialize the in-memory bmap descriptor\n\t */\n\t/* allocate memory for the in-memory bmap descriptor */\n\tbmp = kmalloc(sizeof(struct bmap), GFP_KERNEL);\n\tif (bmp == NULL)\n\t\treturn -ENOMEM;\n\n\t/* read the on-disk bmap descriptor. */\n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tkfree(bmp);\n\t\treturn -EIO;\n\t}\n\n\t/* copy the on-disk bmap descriptor to its in-memory version. */\n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tbmp->db_mapsize = le64_to_cpu(dbmp_le->dn_mapsize);\n\tbmp->db_nfree = le64_to_cpu(dbmp_le->dn_nfree);\n\tbmp->db_l2nbperpage = le32_to_cpu(dbmp_le->dn_l2nbperpage);\n\tbmp->db_numag = le32_to_cpu(dbmp_le->dn_numag);\n\tbmp->db_maxlevel = le32_to_cpu(dbmp_le->dn_maxlevel);\n\tbmp->db_maxag = le32_to_cpu(dbmp_le->dn_maxag);\n\tbmp->db_agpref = le32_to_cpu(dbmp_le->dn_agpref);\n\tbmp->db_aglevel = le32_to_cpu(dbmp_le->dn_aglevel);\n\tbmp->db_agheight = le32_to_cpu(dbmp_le->dn_agheight);\n\tbmp->db_agwidth = le32_to_cpu(dbmp_le->dn_agwidth);\n\tbmp->db_agstart = le32_to_cpu(dbmp_le->dn_agstart);\n\tbmp->db_agl2size = le32_to_cpu(dbmp_le->dn_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tbmp->db_agfree[i] = le64_to_cpu(dbmp_le->dn_agfree[i]);\n\tbmp->db_agsize = le64_to_cpu(dbmp_le->dn_agsize);\n\tbmp->db_maxfreebud = dbmp_le->dn_maxfreebud;\n\n\t/* release the buffer. */\n\trelease_metapage(mp);\n\n\t/* bind the bmap inode and the bmap descriptor to each other. */\n\tbmp->db_ipbmap = ipbmap;\n\tJFS_SBI(ipbmap->i_sb)->bmap = bmp;\n\n\tmemset(bmp->db_active, 0, sizeof(bmp->db_active));\n\n\t/*\n\t * allocate/initialize the bmap lock\n\t */\n\tBMAP_LOCK_INIT(bmp);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\n\nint dbMount(struct inode *ipbmap)\n{\n\tstruct bmap *bmp;\n\tstruct dbmap_disk *dbmp_le;\n\tstruct metapage *mp;\n\tint i;\n\n\t/*\n\t * allocate/initialize the in-memory bmap descriptor\n\t */\n\t/* allocate memory for the in-memory bmap descriptor */\n\tbmp = kmalloc(sizeof(struct bmap), GFP_KERNEL);\n\tif (bmp == NULL)\n\t\treturn -ENOMEM;\n\n\t/* read the on-disk bmap descriptor. */\n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tkfree(bmp);\n\t\treturn -EIO;\n\t}\n\n\t/* copy the on-disk bmap descriptor to its in-memory version. */\n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tbmp->db_mapsize = le64_to_cpu(dbmp_le->dn_mapsize);\n\tbmp->db_nfree = le64_to_cpu(dbmp_le->dn_nfree);\n\tbmp->db_l2nbperpage = le32_to_cpu(dbmp_le->dn_l2nbperpage);\n\tbmp->db_numag = le32_to_cpu(dbmp_le->dn_numag);\n\tbmp->db_maxlevel = le32_to_cpu(dbmp_le->dn_maxlevel);\n\tbmp->db_maxag = le32_to_cpu(dbmp_le->dn_maxag);\n\tbmp->db_agpref = le32_to_cpu(dbmp_le->dn_agpref);\n\tbmp->db_aglevel = le32_to_cpu(dbmp_le->dn_aglevel);\n\tbmp->db_agheight = le32_to_cpu(dbmp_le->dn_agheight);\n\tbmp->db_agwidth = le32_to_cpu(dbmp_le->dn_agwidth);\n\tbmp->db_agstart = le32_to_cpu(dbmp_le->dn_agstart);\n\tbmp->db_agl2size = le32_to_cpu(dbmp_le->dn_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tbmp->db_agfree[i] = le64_to_cpu(dbmp_le->dn_agfree[i]);\n\tbmp->db_agsize = le64_to_cpu(dbmp_le->dn_agsize);\n\tbmp->db_maxfreebud = dbmp_le->dn_maxfreebud;\n\n\t/* release the buffer. */\n\trelease_metapage(mp);\n\n\t/* bind the bmap inode and the bmap descriptor to each other. */\n\tbmp->db_ipbmap = ipbmap;\n\tJFS_SBI(ipbmap->i_sb)->bmap = bmp;\n\n\tmemset(bmp->db_active, 0, sizeof(bmp->db_active));\n\n\t/*\n\t * allocate/initialize the bmap lock\n\t */\n\tBMAP_LOCK_INIT(bmp);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_mount: ipbmap:0x%p\"",
            "ipbmap"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_mount: ipaimap:0x%p\"",
            "ipaimap"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_mount: Failed to read AGGREGATE_I\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chkSuper",
          "args": [
            "sb"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "chkSuper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_mount.c",
          "lines": "301-401",
          "snippet": "static int chkSuper(struct super_block *sb)\n{\n\tint rc = 0;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_superblock *j_sb;\n\tstruct buffer_head *bh;\n\tint AIM_bytesize, AIT_bytesize;\n\tint expected_AIM_bytesize, expected_AIT_bytesize;\n\ts64 AIM_byte_addr, AIT_byte_addr, fsckwsp_addr;\n\ts64 byte_addr_diff0, byte_addr_diff1;\n\ts32 bsize;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\t/*\n\t * validate superblock\n\t */\n\t/* validate fs signature */\n\tif (strncmp(j_sb->s_magic, JFS_MAGIC, 4) ||\n\t    le32_to_cpu(j_sb->s_version) > JFS_VERSION) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbsize = le32_to_cpu(j_sb->s_bsize);\n#ifdef _JFS_4K\n\tif (bsize != PSIZE) {\n\t\tjfs_err(\"Currently only 4K block size supported!\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n#endif\t\t\t\t/* _JFS_4K */\n\n\tjfs_info(\"superblock: flag:0x%08x state:0x%08x size:0x%Lx\",\n\t\t le32_to_cpu(j_sb->s_flag), le32_to_cpu(j_sb->s_state),\n\t\t (unsigned long long) le64_to_cpu(j_sb->s_size));\n\n\t/* validate the descriptors for Secondary AIM and AIT */\n\tif ((j_sb->s_flag & cpu_to_le32(JFS_BAD_SAIT)) !=\n\t    cpu_to_le32(JFS_BAD_SAIT)) {\n\t\texpected_AIM_bytesize = 2 * PSIZE;\n\t\tAIM_bytesize = lengthPXD(&(j_sb->s_aim2)) * bsize;\n\t\texpected_AIT_bytesize = 4 * PSIZE;\n\t\tAIT_bytesize = lengthPXD(&(j_sb->s_ait2)) * bsize;\n\t\tAIM_byte_addr = addressPXD(&(j_sb->s_aim2)) * bsize;\n\t\tAIT_byte_addr = addressPXD(&(j_sb->s_ait2)) * bsize;\n\t\tbyte_addr_diff0 = AIT_byte_addr - AIM_byte_addr;\n\t\tfsckwsp_addr = addressPXD(&(j_sb->s_fsckpxd)) * bsize;\n\t\tbyte_addr_diff1 = fsckwsp_addr - AIT_byte_addr;\n\t\tif ((AIM_bytesize != expected_AIM_bytesize) ||\n\t\t    (AIT_bytesize != expected_AIT_bytesize) ||\n\t\t    (byte_addr_diff0 != AIM_bytesize) ||\n\t\t    (byte_addr_diff1 <= AIT_bytesize))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_BAD_SAIT);\n\t}\n\n\tif ((j_sb->s_flag & cpu_to_le32(JFS_GROUPCOMMIT)) !=\n\t    cpu_to_le32(JFS_GROUPCOMMIT))\n\t\tj_sb->s_flag |= cpu_to_le32(JFS_GROUPCOMMIT);\n\n\t/* validate fs state */\n\tif (j_sb->s_state != cpu_to_le32(FM_CLEAN) &&\n\t    !(sb->s_flags & MS_RDONLY)) {\n\t\tjfs_err(\"jfs_mount: Mount Failure: File System Dirty.\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsbi->state = le32_to_cpu(j_sb->s_state);\n\tsbi->mntflag = le32_to_cpu(j_sb->s_flag);\n\n\t/*\n\t * JFS always does I/O by 4K pages.  Don't tell the buffer cache\n\t * that we use anything else (leave s_blocksize alone).\n\t */\n\tsbi->bsize = bsize;\n\tsbi->l2bsize = le16_to_cpu(j_sb->s_l2bsize);\n\n\t/*\n\t * For now, ignore s_pbsize, l2bfactor.  All I/O going through buffer\n\t * cache.\n\t */\n\tsbi->nbperpage = PSIZE >> sbi->l2bsize;\n\tsbi->l2nbperpage = L2PSIZE - sbi->l2bsize;\n\tsbi->l2niperblk = sbi->l2bsize - L2DISIZE;\n\tif (sbi->mntflag & JFS_INLINELOG)\n\t\tsbi->logpxd = j_sb->s_logpxd;\n\telse {\n\t\tsbi->logdev = new_decode_dev(le32_to_cpu(j_sb->s_logdev));\n\t\tmemcpy(sbi->uuid, j_sb->s_uuid, sizeof(sbi->uuid));\n\t\tmemcpy(sbi->loguuid, j_sb->s_loguuid, sizeof(sbi->uuid));\n\t}\n\tsbi->fsckpxd = j_sb->s_fsckpxd;\n\tsbi->ait2 = j_sb->s_ait2;\n\n      out:\n\tbrelse(bh);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int chkSuper(struct super_block *);",
            "static int logMOUNT(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nstatic int chkSuper(struct super_block *sb)\n{\n\tint rc = 0;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_superblock *j_sb;\n\tstruct buffer_head *bh;\n\tint AIM_bytesize, AIT_bytesize;\n\tint expected_AIM_bytesize, expected_AIT_bytesize;\n\ts64 AIM_byte_addr, AIT_byte_addr, fsckwsp_addr;\n\ts64 byte_addr_diff0, byte_addr_diff1;\n\ts32 bsize;\n\n\tif ((rc = readSuper(sb, &bh)))\n\t\treturn rc;\n\tj_sb = (struct jfs_superblock *)bh->b_data;\n\n\t/*\n\t * validate superblock\n\t */\n\t/* validate fs signature */\n\tif (strncmp(j_sb->s_magic, JFS_MAGIC, 4) ||\n\t    le32_to_cpu(j_sb->s_version) > JFS_VERSION) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbsize = le32_to_cpu(j_sb->s_bsize);\n#ifdef _JFS_4K\n\tif (bsize != PSIZE) {\n\t\tjfs_err(\"Currently only 4K block size supported!\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n#endif\t\t\t\t/* _JFS_4K */\n\n\tjfs_info(\"superblock: flag:0x%08x state:0x%08x size:0x%Lx\",\n\t\t le32_to_cpu(j_sb->s_flag), le32_to_cpu(j_sb->s_state),\n\t\t (unsigned long long) le64_to_cpu(j_sb->s_size));\n\n\t/* validate the descriptors for Secondary AIM and AIT */\n\tif ((j_sb->s_flag & cpu_to_le32(JFS_BAD_SAIT)) !=\n\t    cpu_to_le32(JFS_BAD_SAIT)) {\n\t\texpected_AIM_bytesize = 2 * PSIZE;\n\t\tAIM_bytesize = lengthPXD(&(j_sb->s_aim2)) * bsize;\n\t\texpected_AIT_bytesize = 4 * PSIZE;\n\t\tAIT_bytesize = lengthPXD(&(j_sb->s_ait2)) * bsize;\n\t\tAIM_byte_addr = addressPXD(&(j_sb->s_aim2)) * bsize;\n\t\tAIT_byte_addr = addressPXD(&(j_sb->s_ait2)) * bsize;\n\t\tbyte_addr_diff0 = AIT_byte_addr - AIM_byte_addr;\n\t\tfsckwsp_addr = addressPXD(&(j_sb->s_fsckpxd)) * bsize;\n\t\tbyte_addr_diff1 = fsckwsp_addr - AIT_byte_addr;\n\t\tif ((AIM_bytesize != expected_AIM_bytesize) ||\n\t\t    (AIT_bytesize != expected_AIT_bytesize) ||\n\t\t    (byte_addr_diff0 != AIM_bytesize) ||\n\t\t    (byte_addr_diff1 <= AIT_bytesize))\n\t\t\tj_sb->s_flag |= cpu_to_le32(JFS_BAD_SAIT);\n\t}\n\n\tif ((j_sb->s_flag & cpu_to_le32(JFS_GROUPCOMMIT)) !=\n\t    cpu_to_le32(JFS_GROUPCOMMIT))\n\t\tj_sb->s_flag |= cpu_to_le32(JFS_GROUPCOMMIT);\n\n\t/* validate fs state */\n\tif (j_sb->s_state != cpu_to_le32(FM_CLEAN) &&\n\t    !(sb->s_flags & MS_RDONLY)) {\n\t\tjfs_err(\"jfs_mount: Mount Failure: File System Dirty.\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsbi->state = le32_to_cpu(j_sb->s_state);\n\tsbi->mntflag = le32_to_cpu(j_sb->s_flag);\n\n\t/*\n\t * JFS always does I/O by 4K pages.  Don't tell the buffer cache\n\t * that we use anything else (leave s_blocksize alone).\n\t */\n\tsbi->bsize = bsize;\n\tsbi->l2bsize = le16_to_cpu(j_sb->s_l2bsize);\n\n\t/*\n\t * For now, ignore s_pbsize, l2bfactor.  All I/O going through buffer\n\t * cache.\n\t */\n\tsbi->nbperpage = PSIZE >> sbi->l2bsize;\n\tsbi->l2nbperpage = L2PSIZE - sbi->l2bsize;\n\tsbi->l2niperblk = sbi->l2bsize - L2DISIZE;\n\tif (sbi->mntflag & JFS_INLINELOG)\n\t\tsbi->logpxd = j_sb->s_logpxd;\n\telse {\n\t\tsbi->logdev = new_decode_dev(le32_to_cpu(j_sb->s_logdev));\n\t\tmemcpy(sbi->uuid, j_sb->s_uuid, sizeof(sbi->uuid));\n\t\tmemcpy(sbi->loguuid, j_sb->s_loguuid, sizeof(sbi->uuid));\n\t}\n\tsbi->fsckpxd = j_sb->s_fsckpxd;\n\tsbi->ait2 = j_sb->s_ait2;\n\n      out:\n\tbrelse(bh);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int chkSuper(struct super_block *);\nstatic int logMOUNT(struct super_block *sb);\n\nint jfs_mount(struct super_block *sb)\n{\n\tint rc = 0;\t\t/* Return code */\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct inode *ipaimap = NULL;\n\tstruct inode *ipaimap2 = NULL;\n\tstruct inode *ipimap = NULL;\n\tstruct inode *ipbmap = NULL;\n\n\t/*\n\t * read/validate superblock\n\t * (initialize mount inode from the superblock)\n\t */\n\tif ((rc = chkSuper(sb))) {\n\t\tgoto errout20;\n\t}\n\n\tipaimap = diReadSpecial(sb, AGGREGATE_I, 0);\n\tif (ipaimap == NULL) {\n\t\tjfs_err(\"jfs_mount: Failed to read AGGREGATE_I\");\n\t\trc = -EIO;\n\t\tgoto errout20;\n\t}\n\tsbi->ipaimap = ipaimap;\n\n\tjfs_info(\"jfs_mount: ipaimap:0x%p\", ipaimap);\n\n\t/*\n\t * initialize aggregate inode allocation map\n\t */\n\tif ((rc = diMount(ipaimap))) {\n\t\tjfs_err(\"jfs_mount: diMount(ipaimap) failed w/rc = %d\", rc);\n\t\tgoto errout21;\n\t}\n\n\t/*\n\t * open aggregate block allocation map\n\t */\n\tipbmap = diReadSpecial(sb, BMAP_I, 0);\n\tif (ipbmap == NULL) {\n\t\trc = -EIO;\n\t\tgoto errout22;\n\t}\n\n\tjfs_info(\"jfs_mount: ipbmap:0x%p\", ipbmap);\n\n\tsbi->ipbmap = ipbmap;\n\n\t/*\n\t * initialize aggregate block allocation map\n\t */\n\tif ((rc = dbMount(ipbmap))) {\n\t\tjfs_err(\"jfs_mount: dbMount failed w/rc = %d\", rc);\n\t\tgoto errout22;\n\t}\n\n\t/*\n\t * open the secondary aggregate inode allocation map\n\t *\n\t * This is a duplicate of the aggregate inode allocation map.\n\t *\n\t * hand craft a vfs in the same fashion as we did to read ipaimap.\n\t * By adding INOSPEREXT (32) to the inode number, we are telling\n\t * diReadSpecial that we are reading from the secondary aggregate\n\t * inode table.  This also creates a unique entry in the inode hash\n\t * table.\n\t */\n\tif ((sbi->mntflag & JFS_BAD_SAIT) == 0) {\n\t\tipaimap2 = diReadSpecial(sb, AGGREGATE_I, 1);\n\t\tif (!ipaimap2) {\n\t\t\tjfs_err(\"jfs_mount: Failed to read AGGREGATE_I\");\n\t\t\trc = -EIO;\n\t\t\tgoto errout35;\n\t\t}\n\t\tsbi->ipaimap2 = ipaimap2;\n\n\t\tjfs_info(\"jfs_mount: ipaimap2:0x%p\", ipaimap2);\n\n\t\t/*\n\t\t * initialize secondary aggregate inode allocation map\n\t\t */\n\t\tif ((rc = diMount(ipaimap2))) {\n\t\t\tjfs_err(\"jfs_mount: diMount(ipaimap2) failed, rc = %d\",\n\t\t\t\trc);\n\t\t\tgoto errout35;\n\t\t}\n\t} else\n\t\t/* Secondary aggregate inode table is not valid */\n\t\tsbi->ipaimap2 = NULL;\n\n\t/*\n\t *\tmount (the only/single) fileset\n\t */\n\t/*\n\t * open fileset inode allocation map (aka fileset inode)\n\t */\n\tipimap = diReadSpecial(sb, FILESYSTEM_I, 0);\n\tif (ipimap == NULL) {\n\t\tjfs_err(\"jfs_mount: Failed to read FILESYSTEM_I\");\n\t\t/* open fileset secondary inode allocation map */\n\t\trc = -EIO;\n\t\tgoto errout40;\n\t}\n\tjfs_info(\"jfs_mount: ipimap:0x%p\", ipimap);\n\n\t/* map further access of per fileset inodes by the fileset inode */\n\tsbi->ipimap = ipimap;\n\n\t/* initialize fileset inode allocation map */\n\tif ((rc = diMount(ipimap))) {\n\t\tjfs_err(\"jfs_mount: diMount failed w/rc = %d\", rc);\n\t\tgoto errout41;\n\t}\n\n\tgoto out;\n\n\t/*\n\t *\tunwind on error\n\t */\n      errout41:\t\t/* close fileset inode allocation map inode */\n\tdiFreeSpecial(ipimap);\n\n      errout40:\t\t/* fileset closed */\n\n\t/* close secondary aggregate inode allocation map */\n\tif (ipaimap2) {\n\t\tdiUnmount(ipaimap2, 1);\n\t\tdiFreeSpecial(ipaimap2);\n\t}\n\n      errout35:\n\n\t/* close aggregate block allocation map */\n\tdbUnmount(ipbmap, 1);\n\tdiFreeSpecial(ipbmap);\n\n      errout22:\t\t/* close aggregate inode allocation map */\n\n\tdiUnmount(ipaimap, 1);\n\n      errout21:\t\t/* close aggregate inodes */\n\tdiFreeSpecial(ipaimap);\n      errout20:\t\t/* aggregate closed */\n\n      out:\n\n\tif (rc)\n\t\tjfs_err(\"Mount JFS Failure: %d\", rc);\n\n\treturn rc;\n}"
  }
]