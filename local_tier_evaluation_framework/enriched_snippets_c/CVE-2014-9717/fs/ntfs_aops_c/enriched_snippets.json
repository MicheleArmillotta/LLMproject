[
  {
    "function_name": "mark_ntfs_record_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.c",
    "lines": "1729-1775",
    "snippet": "void mark_ntfs_record_dirty(struct page *page, const unsigned int ofs) {\n\tstruct address_space *mapping = page->mapping;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tstruct buffer_head *bh, *head, *buffers_to_free = NULL;\n\tunsigned int end, bh_size, bh_ofs;\n\n\tBUG_ON(!PageUptodate(page));\n\tend = ofs + ni->itype.index.block_size;\n\tbh_size = VFS_I(ni)->i_sb->s_blocksize;\n\tspin_lock(&mapping->private_lock);\n\tif (unlikely(!page_has_buffers(page))) {\n\t\tspin_unlock(&mapping->private_lock);\n\t\tbh = head = alloc_page_buffers(page, bh_size, 1);\n\t\tspin_lock(&mapping->private_lock);\n\t\tif (likely(!page_has_buffers(page))) {\n\t\t\tstruct buffer_head *tail;\n\n\t\t\tdo {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\ttail = bh;\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t} while (bh);\n\t\t\ttail->b_this_page = head;\n\t\t\tattach_page_buffers(page, head);\n\t\t} else\n\t\t\tbuffers_to_free = bh;\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\tdo {\n\t\tbh_ofs = bh_offset(bh);\n\t\tif (bh_ofs + bh_size <= ofs)\n\t\t\tcontinue;\n\t\tif (unlikely(bh_ofs >= end))\n\t\t\tbreak;\n\t\tset_buffer_dirty(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\tspin_unlock(&mapping->private_lock);\n\t__set_page_dirty_nobuffers(page);\n\tif (unlikely(buffers_to_free)) {\n\t\tdo {\n\t\t\tbh = buffers_to_free->b_this_page;\n\t\t\tfree_buffer_head(buffers_to_free);\n\t\t\tbuffers_to_free = bh;\n\t\t} while (buffers_to_free);\n\t}\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"types.h\"",
      "#include \"runlist.h\"",
      "#include \"mft.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_buffer_head",
          "args": [
            "buffers_to_free"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "buffers_to_free"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "page"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bh_ofs >= end"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bh"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_page_buffers",
          "args": [
            "page",
            "head"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!page_has_buffers(page)"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page_buffers",
          "args": [
            "page",
            "bh_size",
            "1"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "855-908",
          "snippet": "struct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tint retry)\n{\n\tstruct buffer_head *bh, *head;\n\tlong offset;\n\ntry_again:\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(GFP_NOFS);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\t/*\n\t * Return failure for non-async IO requests.  Async IO requests\n\t * are not allowed to fail, so we have to wait until buffer heads\n\t * become available.  But we don't want tasks sleeping with \n\t * partially complete buffers, so all were released above.\n\t */\n\tif (!retry)\n\t\treturn NULL;\n\n\t/* We're _really_ low on memory. Now we just\n\t * wait for old buffer heads to become free due to\n\t * finishing IO.  Since this is an async request and\n\t * the reserve list is empty, we're sure there are \n\t * async buffer heads in use.\n\t */\n\tfree_more_memory();\n\tgoto try_again;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nstruct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tint retry)\n{\n\tstruct buffer_head *bh, *head;\n\tlong offset;\n\ntry_again:\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(GFP_NOFS);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\t/*\n\t * Return failure for non-async IO requests.  Async IO requests\n\t * are not allowed to fail, so we have to wait until buffer heads\n\t * become available.  But we don't want tasks sleeping with \n\t * partially complete buffers, so all were released above.\n\t */\n\tif (!retry)\n\t\treturn NULL;\n\n\t/* We're _really_ low on memory. Now we just\n\t * wait for old buffer heads to become free due to\n\t * finishing IO.  Since this is an async request and\n\t * the reserve list is empty, we're sure there are \n\t * async buffer heads in use.\n\t */\n\tfree_more_memory();\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_has_buffers(page)"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ni"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "245-248",
          "snippet": "static inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "mapping->host"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"types.h\"\n#include \"runlist.h\"\n#include \"mft.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nvoid mark_ntfs_record_dirty(struct page *page, const unsigned int ofs) {\n\tstruct address_space *mapping = page->mapping;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tstruct buffer_head *bh, *head, *buffers_to_free = NULL;\n\tunsigned int end, bh_size, bh_ofs;\n\n\tBUG_ON(!PageUptodate(page));\n\tend = ofs + ni->itype.index.block_size;\n\tbh_size = VFS_I(ni)->i_sb->s_blocksize;\n\tspin_lock(&mapping->private_lock);\n\tif (unlikely(!page_has_buffers(page))) {\n\t\tspin_unlock(&mapping->private_lock);\n\t\tbh = head = alloc_page_buffers(page, bh_size, 1);\n\t\tspin_lock(&mapping->private_lock);\n\t\tif (likely(!page_has_buffers(page))) {\n\t\t\tstruct buffer_head *tail;\n\n\t\t\tdo {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\ttail = bh;\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t} while (bh);\n\t\t\ttail->b_this_page = head;\n\t\t\tattach_page_buffers(page, head);\n\t\t} else\n\t\t\tbuffers_to_free = bh;\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\tdo {\n\t\tbh_ofs = bh_offset(bh);\n\t\tif (bh_ofs + bh_size <= ofs)\n\t\t\tcontinue;\n\t\tif (unlikely(bh_ofs >= end))\n\t\t\tbreak;\n\t\tset_buffer_dirty(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\tspin_unlock(&mapping->private_lock);\n\t__set_page_dirty_nobuffers(page);\n\tif (unlikely(buffers_to_free)) {\n\t\tdo {\n\t\t\tbh = buffers_to_free->b_this_page;\n\t\t\tfree_buffer_head(buffers_to_free);\n\t\t\tbuffers_to_free = bh;\n\t\t} while (buffers_to_free);\n\t}\n}"
  },
  {
    "function_name": "ntfs_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.c",
    "lines": "1563-1661",
    "snippet": "static sector_t ntfs_bmap(struct address_space *mapping, sector_t block)\n{\n\ts64 ofs, size;\n\tloff_t i_size;\n\tLCN lcn;\n\tunsigned long blocksize, flags;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tntfs_volume *vol = ni->vol;\n\tunsigned delta;\n\tunsigned char blocksize_bits, cluster_size_shift;\n\n\tntfs_debug(\"Entering for mft_no 0x%lx, logical block 0x%llx.\",\n\t\t\tni->mft_no, (unsigned long long)block);\n\tif (ni->type != AT_DATA || !NInoNonResident(ni) || NInoEncrypted(ni)) {\n\t\tntfs_error(vol->sb, \"BMAP does not make sense for %s \"\n\t\t\t\t\"attributes, returning 0.\",\n\t\t\t\t(ni->type != AT_DATA) ? \"non-data\" :\n\t\t\t\t(!NInoNonResident(ni) ? \"resident\" :\n\t\t\t\t\"encrypted\"));\n\t\treturn 0;\n\t}\n\t/* None of these can happen. */\n\tBUG_ON(NInoCompressed(ni));\n\tBUG_ON(NInoMstProtected(ni));\n\tblocksize = vol->sb->s_blocksize;\n\tblocksize_bits = vol->sb->s_blocksize_bits;\n\tofs = (s64)block << blocksize_bits;\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tsize = ni->initialized_size;\n\ti_size = i_size_read(VFS_I(ni));\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t/*\n\t * If the offset is outside the initialized size or the block straddles\n\t * the initialized size then pretend it is a hole unless the\n\t * initialized size equals the file size.\n\t */\n\tif (unlikely(ofs >= size || (ofs + blocksize > size && size < i_size)))\n\t\tgoto hole;\n\tcluster_size_shift = vol->cluster_size_bits;\n\tdown_read(&ni->runlist.lock);\n\tlcn = ntfs_attr_vcn_to_lcn_nolock(ni, ofs >> cluster_size_shift, false);\n\tup_read(&ni->runlist.lock);\n\tif (unlikely(lcn < LCN_HOLE)) {\n\t\t/*\n\t\t * Step down to an integer to avoid gcc doing a long long\n\t\t * comparision in the switch when we know @lcn is between\n\t\t * LCN_HOLE and LCN_EIO (i.e. -1 to -5).\n\t\t *\n\t\t * Otherwise older gcc (at least on some architectures) will\n\t\t * try to use __cmpdi2() which is of course not available in\n\t\t * the kernel.\n\t\t */\n\t\tswitch ((int)lcn) {\n\t\tcase LCN_ENOENT:\n\t\t\t/*\n\t\t\t * If the offset is out of bounds then pretend it is a\n\t\t\t * hole.\n\t\t\t */\n\t\t\tgoto hole;\n\t\tcase LCN_ENOMEM:\n\t\t\tntfs_error(vol->sb, \"Not enough memory to complete \"\n\t\t\t\t\t\"mapping for inode 0x%lx.  \"\n\t\t\t\t\t\"Returning 0.\", ni->mft_no);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tntfs_error(vol->sb, \"Failed to complete mapping for \"\n\t\t\t\t\t\"inode 0x%lx.  Run chkdsk.  \"\n\t\t\t\t\t\"Returning 0.\", ni->mft_no);\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (lcn < 0) {\n\t\t/* It is a hole. */\nhole:\n\t\tntfs_debug(\"Done (returning hole).\");\n\t\treturn 0;\n\t}\n\t/*\n\t * The block is really allocated and fullfils all our criteria.\n\t * Convert the cluster to units of block size and return the result.\n\t */\n\tdelta = ofs & vol->cluster_size_mask;\n\tif (unlikely(sizeof(block) < sizeof(lcn))) {\n\t\tblock = lcn = ((lcn << cluster_size_shift) + delta) >>\n\t\t\t\tblocksize_bits;\n\t\t/* If the block number was truncated return 0. */\n\t\tif (unlikely(block != lcn)) {\n\t\t\tntfs_error(vol->sb, \"Physical block 0x%llx is too \"\n\t\t\t\t\t\"large to be returned, returning 0.\",\n\t\t\t\t\t(long long)lcn);\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tblock = ((lcn << cluster_size_shift) + delta) >>\n\t\t\t\tblocksize_bits;\n\tntfs_debug(\"Done (returning block 0x%llx).\", (unsigned long long)lcn);\n\treturn block;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"types.h\"",
      "#include \"runlist.h\"",
      "#include \"mft.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done (returning block 0x%llx).\"",
            "(unsigned long long)lcn"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Physical block 0x%llx is too \"\n\t\t\t\t\t\"large to be returned, returning 0.\"",
            "(long long)lcn"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "block != lcn"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sizeof(block) < sizeof(lcn)"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done (returning hole).\""
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "lcn < LCN_HOLE"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_vcn_to_lcn_nolock",
          "args": [
            "ni",
            "ofs >> cluster_size_shift",
            "false"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_vcn_to_lcn_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "341-405",
          "snippet": "LCN ntfs_attr_vcn_to_lcn_nolock(ntfs_inode *ni, const VCN vcn,\n\t\tconst bool write_locked)\n{\n\tLCN lcn;\n\tunsigned long flags;\n\tbool is_retry = false;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, vcn 0x%llx, %s_locked.\",\n\t\t\tni->mft_no, (unsigned long long)vcn,\n\t\t\twrite_locked ? \"write\" : \"read\");\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(vcn < 0);\n\tif (!ni->runlist.rl) {\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tif (!ni->allocated_size) {\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\treturn LCN_ENOENT;\n\t\t}\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t}\nretry_remap:\n\t/* Convert vcn to lcn.  If that fails map the runlist and retry once. */\n\tlcn = ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn);\n\tif (likely(lcn >= LCN_HOLE)) {\n\t\tntfs_debug(\"Done, lcn 0x%llx.\", (long long)lcn);\n\t\treturn lcn;\n\t}\n\tif (lcn != LCN_RL_NOT_MAPPED) {\n\t\tif (lcn != LCN_ENOENT)\n\t\t\tlcn = LCN_EIO;\n\t} else if (!is_retry) {\n\t\tint err;\n\n\t\tif (!write_locked) {\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\tdown_write(&ni->runlist.lock);\n\t\t\tif (unlikely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) !=\n\t\t\t\t\tLCN_RL_NOT_MAPPED)) {\n\t\t\t\tup_write(&ni->runlist.lock);\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\tgoto retry_remap;\n\t\t\t}\n\t\t}\n\t\terr = ntfs_map_runlist_nolock(ni, vcn, NULL);\n\t\tif (!write_locked) {\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\tdown_read(&ni->runlist.lock);\n\t\t}\n\t\tif (likely(!err)) {\n\t\t\tis_retry = true;\n\t\t\tgoto retry_remap;\n\t\t}\n\t\tif (err == -ENOENT)\n\t\t\tlcn = LCN_ENOENT;\n\t\telse if (err == -ENOMEM)\n\t\t\tlcn = LCN_ENOMEM;\n\t\telse\n\t\t\tlcn = LCN_EIO;\n\t}\n\tif (lcn != LCN_ENOENT)\n\t\tntfs_error(ni->vol->sb, \"Failed with error code %lli.\",\n\t\t\t\t(long long)lcn);\n\treturn lcn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nLCN ntfs_attr_vcn_to_lcn_nolock(ntfs_inode *ni, const VCN vcn,\n\t\tconst bool write_locked)\n{\n\tLCN lcn;\n\tunsigned long flags;\n\tbool is_retry = false;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, vcn 0x%llx, %s_locked.\",\n\t\t\tni->mft_no, (unsigned long long)vcn,\n\t\t\twrite_locked ? \"write\" : \"read\");\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(vcn < 0);\n\tif (!ni->runlist.rl) {\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tif (!ni->allocated_size) {\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\treturn LCN_ENOENT;\n\t\t}\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t}\nretry_remap:\n\t/* Convert vcn to lcn.  If that fails map the runlist and retry once. */\n\tlcn = ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn);\n\tif (likely(lcn >= LCN_HOLE)) {\n\t\tntfs_debug(\"Done, lcn 0x%llx.\", (long long)lcn);\n\t\treturn lcn;\n\t}\n\tif (lcn != LCN_RL_NOT_MAPPED) {\n\t\tif (lcn != LCN_ENOENT)\n\t\t\tlcn = LCN_EIO;\n\t} else if (!is_retry) {\n\t\tint err;\n\n\t\tif (!write_locked) {\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\tdown_write(&ni->runlist.lock);\n\t\t\tif (unlikely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) !=\n\t\t\t\t\tLCN_RL_NOT_MAPPED)) {\n\t\t\t\tup_write(&ni->runlist.lock);\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\tgoto retry_remap;\n\t\t\t}\n\t\t}\n\t\terr = ntfs_map_runlist_nolock(ni, vcn, NULL);\n\t\tif (!write_locked) {\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\tdown_read(&ni->runlist.lock);\n\t\t}\n\t\tif (likely(!err)) {\n\t\t\tis_retry = true;\n\t\t\tgoto retry_remap;\n\t\t}\n\t\tif (err == -ENOENT)\n\t\t\tlcn = LCN_ENOENT;\n\t\telse if (err == -ENOMEM)\n\t\t\tlcn = LCN_ENOMEM;\n\t\telse\n\t\t\tlcn = LCN_EIO;\n\t}\n\tif (lcn != LCN_ENOENT)\n\t\tntfs_error(ni->vol->sb, \"Failed with error code %lli.\",\n\t\t\t\t(long long)lcn);\n\treturn lcn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ofs >= size || (ofs + blocksize > size && size < i_size)"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "VFS_I(ni)"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ni"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "245-248",
          "snippet": "static inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoMstProtected(ni)"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoMstProtected",
          "args": [
            "ni"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoCompressed(ni)"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoEncrypted",
          "args": [
            "ni"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for mft_no 0x%lx, logical block 0x%llx.\"",
            "ni->mft_no",
            "(unsigned long long)block"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "mapping->host"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"types.h\"\n#include \"runlist.h\"\n#include \"mft.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic sector_t ntfs_bmap(struct address_space *mapping, sector_t block)\n{\n\ts64 ofs, size;\n\tloff_t i_size;\n\tLCN lcn;\n\tunsigned long blocksize, flags;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tntfs_volume *vol = ni->vol;\n\tunsigned delta;\n\tunsigned char blocksize_bits, cluster_size_shift;\n\n\tntfs_debug(\"Entering for mft_no 0x%lx, logical block 0x%llx.\",\n\t\t\tni->mft_no, (unsigned long long)block);\n\tif (ni->type != AT_DATA || !NInoNonResident(ni) || NInoEncrypted(ni)) {\n\t\tntfs_error(vol->sb, \"BMAP does not make sense for %s \"\n\t\t\t\t\"attributes, returning 0.\",\n\t\t\t\t(ni->type != AT_DATA) ? \"non-data\" :\n\t\t\t\t(!NInoNonResident(ni) ? \"resident\" :\n\t\t\t\t\"encrypted\"));\n\t\treturn 0;\n\t}\n\t/* None of these can happen. */\n\tBUG_ON(NInoCompressed(ni));\n\tBUG_ON(NInoMstProtected(ni));\n\tblocksize = vol->sb->s_blocksize;\n\tblocksize_bits = vol->sb->s_blocksize_bits;\n\tofs = (s64)block << blocksize_bits;\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tsize = ni->initialized_size;\n\ti_size = i_size_read(VFS_I(ni));\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t/*\n\t * If the offset is outside the initialized size or the block straddles\n\t * the initialized size then pretend it is a hole unless the\n\t * initialized size equals the file size.\n\t */\n\tif (unlikely(ofs >= size || (ofs + blocksize > size && size < i_size)))\n\t\tgoto hole;\n\tcluster_size_shift = vol->cluster_size_bits;\n\tdown_read(&ni->runlist.lock);\n\tlcn = ntfs_attr_vcn_to_lcn_nolock(ni, ofs >> cluster_size_shift, false);\n\tup_read(&ni->runlist.lock);\n\tif (unlikely(lcn < LCN_HOLE)) {\n\t\t/*\n\t\t * Step down to an integer to avoid gcc doing a long long\n\t\t * comparision in the switch when we know @lcn is between\n\t\t * LCN_HOLE and LCN_EIO (i.e. -1 to -5).\n\t\t *\n\t\t * Otherwise older gcc (at least on some architectures) will\n\t\t * try to use __cmpdi2() which is of course not available in\n\t\t * the kernel.\n\t\t */\n\t\tswitch ((int)lcn) {\n\t\tcase LCN_ENOENT:\n\t\t\t/*\n\t\t\t * If the offset is out of bounds then pretend it is a\n\t\t\t * hole.\n\t\t\t */\n\t\t\tgoto hole;\n\t\tcase LCN_ENOMEM:\n\t\t\tntfs_error(vol->sb, \"Not enough memory to complete \"\n\t\t\t\t\t\"mapping for inode 0x%lx.  \"\n\t\t\t\t\t\"Returning 0.\", ni->mft_no);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tntfs_error(vol->sb, \"Failed to complete mapping for \"\n\t\t\t\t\t\"inode 0x%lx.  Run chkdsk.  \"\n\t\t\t\t\t\"Returning 0.\", ni->mft_no);\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (lcn < 0) {\n\t\t/* It is a hole. */\nhole:\n\t\tntfs_debug(\"Done (returning hole).\");\n\t\treturn 0;\n\t}\n\t/*\n\t * The block is really allocated and fullfils all our criteria.\n\t * Convert the cluster to units of block size and return the result.\n\t */\n\tdelta = ofs & vol->cluster_size_mask;\n\tif (unlikely(sizeof(block) < sizeof(lcn))) {\n\t\tblock = lcn = ((lcn << cluster_size_shift) + delta) >>\n\t\t\t\tblocksize_bits;\n\t\t/* If the block number was truncated return 0. */\n\t\tif (unlikely(block != lcn)) {\n\t\t\tntfs_error(vol->sb, \"Physical block 0x%llx is too \"\n\t\t\t\t\t\"large to be returned, returning 0.\",\n\t\t\t\t\t(long long)lcn);\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tblock = ((lcn << cluster_size_shift) + delta) >>\n\t\t\t\tblocksize_bits;\n\tntfs_debug(\"Done (returning block 0x%llx).\", (unsigned long long)lcn);\n\treturn block;\n}"
  },
  {
    "function_name": "ntfs_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.c",
    "lines": "1353-1536",
    "snippet": "static int ntfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tloff_t i_size;\n\tstruct inode *vi = page->mapping->host;\n\tntfs_inode *base_ni = NULL, *ni = NTFS_I(vi);\n\tchar *addr;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tMFT_RECORD *m = NULL;\n\tu32 attr_len;\n\tint err;\n\nretry_writepage:\n\tBUG_ON(!PageLocked(page));\n\ti_size = i_size_read(vi);\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\tif (unlikely(page->index >= (i_size + PAGE_CACHE_SIZE - 1) >>\n\t\t\tPAGE_CACHE_SHIFT)) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tblock_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\tntfs_debug(\"Write outside i_size - truncated?\");\n\t\treturn 0;\n\t}\n\t/*\n\t * Only $DATA attributes can be encrypted and only unnamed $DATA\n\t * attributes can be compressed.  Index root can have the flags set but\n\t * this means to create compressed/encrypted files, not that the\n\t * attribute is compressed/encrypted.  Note we need to check for\n\t * AT_INDEX_ALLOCATION since this is the type of both directory and\n\t * index inodes.\n\t */\n\tif (ni->type != AT_INDEX_ALLOCATION) {\n\t\t/* If file is encrypted, deny access, just like NT4. */\n\t\tif (NInoEncrypted(ni)) {\n\t\t\tunlock_page(page);\n\t\t\tBUG_ON(ni->type != AT_DATA);\n\t\t\tntfs_debug(\"Denying write access to encrypted file.\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* Compressed data streams are handled in compress.c. */\n\t\tif (NInoNonResident(ni) && NInoCompressed(ni)) {\n\t\t\tBUG_ON(ni->type != AT_DATA);\n\t\t\tBUG_ON(ni->name_len);\n\t\t\t// TODO: Implement and replace this with\n\t\t\t// return ntfs_write_compressed_block(page);\n\t\t\tunlock_page(page);\n\t\t\tntfs_error(vi->i_sb, \"Writing to compressed files is \"\n\t\t\t\t\t\"not supported yet.  Sorry.\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\t// TODO: Implement and remove this check.\n\t\tif (NInoNonResident(ni) && NInoSparse(ni)) {\n\t\t\tunlock_page(page);\n\t\t\tntfs_error(vi->i_sb, \"Writing to sparse files is not \"\n\t\t\t\t\t\"supported yet.  Sorry.\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\t/* NInoNonResident() == NInoIndexAllocPresent() */\n\tif (NInoNonResident(ni)) {\n\t\t/* We have to zero every time due to mmap-at-end-of-file. */\n\t\tif (page->index >= (i_size >> PAGE_CACHE_SHIFT)) {\n\t\t\t/* The page straddles i_size. */\n\t\t\tunsigned int ofs = i_size & ~PAGE_CACHE_MASK;\n\t\t\tzero_user_segment(page, ofs, PAGE_CACHE_SIZE);\n\t\t}\n\t\t/* Handle mst protected attributes. */\n\t\tif (NInoMstProtected(ni))\n\t\t\treturn ntfs_write_mst_block(page, wbc);\n\t\t/* Normal, non-resident data stream. */\n\t\treturn ntfs_write_block(page, wbc);\n\t}\n\t/*\n\t * Attribute is resident, implying it is not compressed, encrypted, or\n\t * mst protected.  This also means the attribute is smaller than an mft\n\t * record and hence smaller than a page, so can simply return error on\n\t * any pages with index above 0.  Note the attribute can actually be\n\t * marked compressed but if it is resident the actual data is not\n\t * compressed so we are ok to ignore the compressed flag here.\n\t */\n\tBUG_ON(page_has_buffers(page));\n\tBUG_ON(!PageUptodate(page));\n\tif (unlikely(page->index > 0)) {\n\t\tntfs_error(vi->i_sb, \"BUG()! page->index (0x%lx) > 0.  \"\n\t\t\t\t\"Aborting write.\", page->index);\n\t\tBUG_ON(PageWriteback(page));\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t\tend_page_writeback(page);\n\t\treturn -EIO;\n\t}\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t/* Map, pin, and lock the mft record. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\t/*\n\t * If a parallel write made the attribute non-resident, drop the mft\n\t * record and retry the writepage.\n\t */\n\tif (unlikely(NInoNonResident(ni))) {\n\t\tunmap_mft_record(base_ni);\n\t\tgoto retry_writepage;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\t/*\n\t * Keep the VM happy.  This must be done otherwise the radix-tree tag\n\t * PAGECACHE_TAG_DIRTY remains set even though the page is clean.\n\t */\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tattr_len = le32_to_cpu(ctx->attr->data.resident.value_length);\n\ti_size = i_size_read(vi);\n\tif (unlikely(attr_len > i_size)) {\n\t\t/* Race with shrinking truncate or a failed truncate. */\n\t\tattr_len = i_size;\n\t\t/*\n\t\t * If the truncate failed, fix it up now.  If a concurrent\n\t\t * truncate, we do its job, so it does not have to do anything.\n\t\t */\n\t\terr = ntfs_resident_attr_value_resize(ctx->mrec, ctx->attr,\n\t\t\t\tattr_len);\n\t\t/* Shrinking cannot fail. */\n\t\tBUG_ON(err);\n\t}\n\taddr = kmap_atomic(page);\n\t/* Copy the data from the page to the mft record. */\n\tmemcpy((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset),\n\t\t\taddr, attr_len);\n\t/* Zero out of bounds area in the page cache page. */\n\tmemset(addr + attr_len, 0, PAGE_CACHE_SIZE - attr_len);\n\tkunmap_atomic(addr);\n\tflush_dcache_page(page);\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t/* We are done with the page. */\n\tend_page_writeback(page);\n\t/* Finally, mark the mft record dirty, so it gets written back. */\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\treturn 0;\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Error allocating memory. Redirtying \"\n\t\t\t\t\"page so we try again later.\");\n\t\t/*\n\t\t * Put the page back on mapping->dirty_pages, but leave its\n\t\t * buffers' dirty state as-is.\n\t\t */\n\t\tredirty_page_for_writepage(wbc, page);\n\t\terr = 0;\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Resident attribute write failed with \"\n\t\t\t\t\"error %i.\", err);\n\t\tSetPageError(page);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\tunlock_page(page);\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"types.h\"",
      "#include \"runlist.h\"",
      "#include \"mft.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "base_ni"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "ni->vol"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Resident attribute write failed with \"\n\t\t\t\t\"error %i.\"",
            "err"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vi->i_sb",
            "\"Error allocating memory. Redirtying \"\n\t\t\t\t\"page so we try again later.\""
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_mft_record_dirty",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_mft_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "395-410",
          "snippet": "void __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_mft_record_page",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "flush_dcache_mft_record_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "55-58",
          "snippet": "static inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "addr"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "addr + attr_len",
            "0",
            "PAGE_CACHE_SIZE - attr_len"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset)",
            "addr",
            "attr_len"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ctx->attr->data.resident.value_offset"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_resident_attr_value_resize",
          "args": [
            "ctx->mrec",
            "ctx->attr",
            "attr_len"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_resident_attr_value_resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1479-1499",
          "snippet": "int ntfs_resident_attr_value_resize(MFT_RECORD *m, ATTR_RECORD *a,\n\t\tconst u32 new_size)\n{\n\tu32 old_size;\n\n\t/* Resize the resident part of the attribute record. */\n\tif (ntfs_attr_record_resize(m, a,\n\t\t\tle16_to_cpu(a->data.resident.value_offset) + new_size))\n\t\treturn -ENOSPC;\n\t/*\n\t * The resize succeeded!  If we made the attribute value bigger, clear\n\t * the area between the old size and @new_size.\n\t */\n\told_size = le32_to_cpu(a->data.resident.value_length);\n\tif (new_size > old_size)\n\t\tmemset((u8*)a + le16_to_cpu(a->data.resident.value_offset) +\n\t\t\t\told_size, 0, new_size - old_size);\n\t/* Finally update the length of the attribute value. */\n\ta->data.resident.value_length = cpu_to_le32(new_size);\n\treturn 0;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_resident_attr_value_resize(MFT_RECORD *m, ATTR_RECORD *a,\n\t\tconst u32 new_size)\n{\n\tu32 old_size;\n\n\t/* Resize the resident part of the attribute record. */\n\tif (ntfs_attr_record_resize(m, a,\n\t\t\tle16_to_cpu(a->data.resident.value_offset) + new_size))\n\t\treturn -ENOSPC;\n\t/*\n\t * The resize succeeded!  If we made the attribute value bigger, clear\n\t * the area between the old size and @new_size.\n\t */\n\told_size = le32_to_cpu(a->data.resident.value_length);\n\tif (new_size > old_size)\n\t\tmemset((u8*)a + le16_to_cpu(a->data.resident.value_offset) +\n\t\t\t\told_size, 0, new_size - old_size);\n\t/* Finally update the length of the attribute value. */\n\ta->data.resident.value_length = cpu_to_le32(new_size);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "attr_len > i_size"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ctx->attr->data.resident.value_length"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "ni->type",
            "ni->name",
            "ni->name_len",
            "CASE_SENSITIVE",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "base_ni",
            "m"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "NInoNonResident(ni)"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->index > 0"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page_has_buffers(page)"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_write_block",
          "args": [
            "page",
            "wbc"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_write_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.c",
          "lines": "550-893",
          "snippet": "static int ntfs_write_block(struct page *page, struct writeback_control *wbc)\n{\n\tVCN vcn;\n\tLCN lcn;\n\ts64 initialized_size;\n\tloff_t i_size;\n\tsector_t block, dblock, iblock;\n\tstruct inode *vi;\n\tntfs_inode *ni;\n\tntfs_volume *vol;\n\trunlist_element *rl;\n\tstruct buffer_head *bh, *head;\n\tunsigned long flags;\n\tunsigned int blocksize, vcn_ofs;\n\tint err;\n\tbool need_end_writeback;\n\tunsigned char blocksize_bits;\n\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\tvol = ni->vol;\n\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, page index \"\n\t\t\t\"0x%lx.\", ni->mft_no, ni->type, page->index);\n\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(NInoMstProtected(ni));\n\tblocksize = vol->sb->s_blocksize;\n\tblocksize_bits = vol->sb->s_blocksize_bits;\n\tif (!page_has_buffers(page)) {\n\t\tBUG_ON(!PageUptodate(page));\n\t\tcreate_empty_buffers(page, blocksize,\n\t\t\t\t(1 << BH_Uptodate) | (1 << BH_Dirty));\n\t\tif (unlikely(!page_has_buffers(page))) {\n\t\t\tntfs_warning(vol->sb, \"Error allocating page \"\n\t\t\t\t\t\"buffers.  Redirtying page so we try \"\n\t\t\t\t\t\"again later.\");\n\t\t\t/*\n\t\t\t * Put the page back on mapping->dirty_pages, but leave\n\t\t\t * its buffers' dirty state as-is.\n\t\t\t */\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\n\t/* NOTE: Different naming scheme to ntfs_read_block()! */\n\n\t/* The first block in the page. */\n\tblock = (s64)page->index << (PAGE_CACHE_SHIFT - blocksize_bits);\n\n\tread_lock_irqsave(&ni->size_lock, flags);\n\ti_size = i_size_read(vi);\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\n\t/* The first out of bounds block for the data size. */\n\tdblock = (i_size + blocksize - 1) >> blocksize_bits;\n\n\t/* The last (fully or partially) initialized block. */\n\tiblock = initialized_size >> blocksize_bits;\n\n\t/*\n\t * Be very careful.  We have no exclusion from __set_page_dirty_buffers\n\t * here, and the (potentially unmapped) buffers may become dirty at\n\t * any time.  If a buffer becomes dirty here after we've inspected it\n\t * then we just miss that fact, and the page stays dirty.\n\t *\n\t * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;\n\t * handle that here by just cleaning them.\n\t */\n\n\t/*\n\t * Loop through all the buffers in the page, mapping all the dirty\n\t * buffers to disk addresses and handling any aliases from the\n\t * underlying block device's mapping.\n\t */\n\trl = NULL;\n\terr = 0;\n\tdo {\n\t\tbool is_retry = false;\n\n\t\tif (unlikely(block >= dblock)) {\n\t\t\t/*\n\t\t\t * Mapped buffers outside i_size will occur, because\n\t\t\t * this page can be outside i_size when there is a\n\t\t\t * truncate in progress. The contents of such buffers\n\t\t\t * were zeroed by ntfs_writepage().\n\t\t\t *\n\t\t\t * FIXME: What about the small race window where\n\t\t\t * ntfs_writepage() has not done any clearing because\n\t\t\t * the page was within i_size but before we get here,\n\t\t\t * vmtruncate() modifies i_size?\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Clean buffers are not written out, so no need to map them. */\n\t\tif (!buffer_dirty(bh))\n\t\t\tcontinue;\n\n\t\t/* Make sure we have enough initialized size. */\n\t\tif (unlikely((block >= iblock) &&\n\t\t\t\t(initialized_size < i_size))) {\n\t\t\t/*\n\t\t\t * If this page is fully outside initialized size, zero\n\t\t\t * out all pages between the current initialized size\n\t\t\t * and the current page. Just use ntfs_readpage() to do\n\t\t\t * the zeroing transparently.\n\t\t\t */\n\t\t\tif (block > iblock) {\n\t\t\t\t// TODO:\n\t\t\t\t// For each page do:\n\t\t\t\t// - read_cache_page()\n\t\t\t\t// Again for each page do:\n\t\t\t\t// - wait_on_page_locked()\n\t\t\t\t// - Check (PageUptodate(page) &&\n\t\t\t\t//\t\t\t!PageError(page))\n\t\t\t\t// Update initialized size in the attribute and\n\t\t\t\t// in the inode.\n\t\t\t\t// Again, for each page do:\n\t\t\t\t//\t__set_page_dirty_buffers();\n\t\t\t\t// page_cache_release()\n\t\t\t\t// We don't need to wait on the writes.\n\t\t\t\t// Update iblock.\n\t\t\t}\n\t\t\t/*\n\t\t\t * The current page straddles initialized size. Zero\n\t\t\t * all non-uptodate buffers and set them uptodate (and\n\t\t\t * dirty?). Note, there aren't any non-uptodate buffers\n\t\t\t * if the page is uptodate.\n\t\t\t * FIXME: For an uptodate page, the buffers may need to\n\t\t\t * be written out because they were not initialized on\n\t\t\t * disk before.\n\t\t\t */\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t// TODO:\n\t\t\t\t// Zero any non-uptodate buffers up to i_size.\n\t\t\t\t// Set them uptodate and dirty.\n\t\t\t}\n\t\t\t// TODO:\n\t\t\t// Update initialized size in the attribute and in the\n\t\t\t// inode (up to i_size).\n\t\t\t// Update iblock.\n\t\t\t// FIXME: This is inefficient. Try to batch the two\n\t\t\t// size changes to happen in one go.\n\t\t\tntfs_error(vol->sb, \"Writing beyond initialized size \"\n\t\t\t\t\t\"is not supported yet. Sorry.\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t\t// Do NOT set_buffer_new() BUT DO clear buffer range\n\t\t\t// outside write request range.\n\t\t\t// set_buffer_uptodate() on complete buffers as well as\n\t\t\t// set_buffer_dirty().\n\t\t}\n\n\t\t/* No need to map buffers that are already mapped. */\n\t\tif (buffer_mapped(bh))\n\t\t\tcontinue;\n\n\t\t/* Unmapped, dirty buffer. Need to map it. */\n\t\tbh->b_bdev = vol->sb->s_bdev;\n\n\t\t/* Convert block into corresponding vcn and offset. */\n\t\tvcn = (VCN)block << blocksize_bits;\n\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\tvcn >>= vol->cluster_size_bits;\n\t\tif (!rl) {\nlock_retry_remap:\n\t\t\tdown_read(&ni->runlist.lock);\n\t\t\trl = ni->runlist.rl;\n\t\t}\n\t\tif (likely(rl != NULL)) {\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t} else\n\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t/* Successful remap. */\n\t\tif (lcn >= 0) {\n\t\t\t/* Setup buffer head to point to correct block. */\n\t\t\tbh->b_blocknr = ((lcn << vol->cluster_size_bits) +\n\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\tset_buffer_mapped(bh);\n\t\t\tcontinue;\n\t\t}\n\t\t/* It is a hole, need to instantiate it. */\n\t\tif (lcn == LCN_HOLE) {\n\t\t\tu8 *kaddr;\n\t\t\tunsigned long *bpos, *bend;\n\n\t\t\t/* Check if the buffer is zero. */\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tbpos = (unsigned long *)(kaddr + bh_offset(bh));\n\t\t\tbend = (unsigned long *)((u8*)bpos + blocksize);\n\t\t\tdo {\n\t\t\t\tif (unlikely(*bpos))\n\t\t\t\t\tbreak;\n\t\t\t} while (likely(++bpos < bend));\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tif (bpos == bend) {\n\t\t\t\t/*\n\t\t\t\t * Buffer is zero and sparse, no need to write\n\t\t\t\t * it.\n\t\t\t\t */\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// TODO: Instantiate the hole.\n\t\t\t// clear_buffer_new(bh);\n\t\t\t// unmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);\n\t\t\tntfs_error(vol->sb, \"Writing into sparse regions is \"\n\t\t\t\t\t\"not supported yet. Sorry.\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\t/* If first try and runlist unmapped, map and retry. */\n\t\tif (!is_retry && lcn == LCN_RL_NOT_MAPPED) {\n\t\t\tis_retry = true;\n\t\t\t/*\n\t\t\t * Attempt to map runlist, dropping lock for\n\t\t\t * the duration.\n\t\t\t */\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\terr = ntfs_map_runlist(ni, vcn);\n\t\t\tif (likely(!err))\n\t\t\t\tgoto lock_retry_remap;\n\t\t\trl = NULL;\n\t\t} else if (!rl)\n\t\t\tup_read(&ni->runlist.lock);\n\t\t/*\n\t\t * If buffer is outside the runlist, truncate has cut it out\n\t\t * of the runlist.  Just clean and clear the buffer and set it\n\t\t * uptodate so it can get discarded by the VM.\n\t\t */\n\t\tif (err == -ENOENT || lcn == LCN_ENOENT) {\n\t\t\tbh->b_blocknr = -1;\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tzero_user(page, bh_offset(bh), blocksize);\n\t\t\tset_buffer_uptodate(bh);\n\t\t\terr = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Failed to map the buffer, even after retrying. */\n\t\tif (!err)\n\t\t\terr = -EIO;\n\t\tbh->b_blocknr = -1;\n\t\tntfs_error(vol->sb, \"Failed to write to inode 0x%lx, \"\n\t\t\t\t\"attribute type 0x%x, vcn 0x%llx, offset 0x%x \"\n\t\t\t\t\"because its location on disk could not be \"\n\t\t\t\t\"determined%s (error code %i).\", ni->mft_no,\n\t\t\t\tni->type, (unsigned long long)vcn,\n\t\t\t\tvcn_ofs, is_retry ? \" even after \"\n\t\t\t\t\"retrying\" : \"\", err);\n\t\tbreak;\n\t} while (block++, (bh = bh->b_this_page) != head);\n\n\t/* Release the lock if we took it. */\n\tif (rl)\n\t\tup_read(&ni->runlist.lock);\n\n\t/* For the error case, need to reset bh to the beginning. */\n\tbh = head;\n\n\t/* Just an optimization, so ->readpage() is not called later. */\n\tif (unlikely(!PageUptodate(page))) {\n\t\tint uptodate = 1;\n\t\tdo {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tuptodate = 0;\n\t\t\t\tbh = head;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while ((bh = bh->b_this_page) != head);\n\t\tif (uptodate)\n\t\t\tSetPageUptodate(page);\n\t}\n\n\t/* Setup all mapped, dirty buffers for async write i/o. */\n\tdo {\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh)) {\n\t\t\tlock_buffer(bh);\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tBUG_ON(!buffer_uptodate(bh));\n\t\t\t\tmark_buffer_async_write(bh);\n\t\t\t} else\n\t\t\t\tunlock_buffer(bh);\n\t\t} else if (unlikely(err)) {\n\t\t\t/*\n\t\t\t * For the error case. The buffer may have been set\n\t\t\t * dirty during attachment to a dirty page.\n\t\t\t */\n\t\t\tif (err != -ENOMEM)\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\tif (unlikely(err)) {\n\t\t// TODO: Remove the -EOPNOTSUPP check later on...\n\t\tif (unlikely(err == -EOPNOTSUPP))\n\t\t\terr = 0;\n\t\telse if (err == -ENOMEM) {\n\t\t\tntfs_warning(vol->sb, \"Error allocating memory. \"\n\t\t\t\t\t\"Redirtying page so we try again \"\n\t\t\t\t\t\"later.\");\n\t\t\t/*\n\t\t\t * Put the page back on mapping->dirty_pages, but\n\t\t\t * leave its buffer's dirty state as-is.\n\t\t\t */\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\terr = 0;\n\t\t} else\n\t\t\tSetPageError(page);\n\t}\n\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\t/* Keeps try_to_free_buffers() away. */\n\n\t/* Submit the prepared buffers for i/o. */\n\tneed_end_writeback = true;\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh(WRITE, bh);\n\t\t\tneed_end_writeback = false;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\n\t/* If no i/o was started, need to end_page_writeback(). */\n\tif (unlikely(need_end_writeback))\n\t\tend_page_writeback(page);\n\n\tntfs_debug(\"Done.\");\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"types.h\"",
            "#include \"runlist.h\"",
            "#include \"mft.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"types.h\"\n#include \"runlist.h\"\n#include \"mft.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int ntfs_write_block(struct page *page, struct writeback_control *wbc)\n{\n\tVCN vcn;\n\tLCN lcn;\n\ts64 initialized_size;\n\tloff_t i_size;\n\tsector_t block, dblock, iblock;\n\tstruct inode *vi;\n\tntfs_inode *ni;\n\tntfs_volume *vol;\n\trunlist_element *rl;\n\tstruct buffer_head *bh, *head;\n\tunsigned long flags;\n\tunsigned int blocksize, vcn_ofs;\n\tint err;\n\tbool need_end_writeback;\n\tunsigned char blocksize_bits;\n\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\tvol = ni->vol;\n\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, page index \"\n\t\t\t\"0x%lx.\", ni->mft_no, ni->type, page->index);\n\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(NInoMstProtected(ni));\n\tblocksize = vol->sb->s_blocksize;\n\tblocksize_bits = vol->sb->s_blocksize_bits;\n\tif (!page_has_buffers(page)) {\n\t\tBUG_ON(!PageUptodate(page));\n\t\tcreate_empty_buffers(page, blocksize,\n\t\t\t\t(1 << BH_Uptodate) | (1 << BH_Dirty));\n\t\tif (unlikely(!page_has_buffers(page))) {\n\t\t\tntfs_warning(vol->sb, \"Error allocating page \"\n\t\t\t\t\t\"buffers.  Redirtying page so we try \"\n\t\t\t\t\t\"again later.\");\n\t\t\t/*\n\t\t\t * Put the page back on mapping->dirty_pages, but leave\n\t\t\t * its buffers' dirty state as-is.\n\t\t\t */\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\n\t/* NOTE: Different naming scheme to ntfs_read_block()! */\n\n\t/* The first block in the page. */\n\tblock = (s64)page->index << (PAGE_CACHE_SHIFT - blocksize_bits);\n\n\tread_lock_irqsave(&ni->size_lock, flags);\n\ti_size = i_size_read(vi);\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\n\t/* The first out of bounds block for the data size. */\n\tdblock = (i_size + blocksize - 1) >> blocksize_bits;\n\n\t/* The last (fully or partially) initialized block. */\n\tiblock = initialized_size >> blocksize_bits;\n\n\t/*\n\t * Be very careful.  We have no exclusion from __set_page_dirty_buffers\n\t * here, and the (potentially unmapped) buffers may become dirty at\n\t * any time.  If a buffer becomes dirty here after we've inspected it\n\t * then we just miss that fact, and the page stays dirty.\n\t *\n\t * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;\n\t * handle that here by just cleaning them.\n\t */\n\n\t/*\n\t * Loop through all the buffers in the page, mapping all the dirty\n\t * buffers to disk addresses and handling any aliases from the\n\t * underlying block device's mapping.\n\t */\n\trl = NULL;\n\terr = 0;\n\tdo {\n\t\tbool is_retry = false;\n\n\t\tif (unlikely(block >= dblock)) {\n\t\t\t/*\n\t\t\t * Mapped buffers outside i_size will occur, because\n\t\t\t * this page can be outside i_size when there is a\n\t\t\t * truncate in progress. The contents of such buffers\n\t\t\t * were zeroed by ntfs_writepage().\n\t\t\t *\n\t\t\t * FIXME: What about the small race window where\n\t\t\t * ntfs_writepage() has not done any clearing because\n\t\t\t * the page was within i_size but before we get here,\n\t\t\t * vmtruncate() modifies i_size?\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Clean buffers are not written out, so no need to map them. */\n\t\tif (!buffer_dirty(bh))\n\t\t\tcontinue;\n\n\t\t/* Make sure we have enough initialized size. */\n\t\tif (unlikely((block >= iblock) &&\n\t\t\t\t(initialized_size < i_size))) {\n\t\t\t/*\n\t\t\t * If this page is fully outside initialized size, zero\n\t\t\t * out all pages between the current initialized size\n\t\t\t * and the current page. Just use ntfs_readpage() to do\n\t\t\t * the zeroing transparently.\n\t\t\t */\n\t\t\tif (block > iblock) {\n\t\t\t\t// TODO:\n\t\t\t\t// For each page do:\n\t\t\t\t// - read_cache_page()\n\t\t\t\t// Again for each page do:\n\t\t\t\t// - wait_on_page_locked()\n\t\t\t\t// - Check (PageUptodate(page) &&\n\t\t\t\t//\t\t\t!PageError(page))\n\t\t\t\t// Update initialized size in the attribute and\n\t\t\t\t// in the inode.\n\t\t\t\t// Again, for each page do:\n\t\t\t\t//\t__set_page_dirty_buffers();\n\t\t\t\t// page_cache_release()\n\t\t\t\t// We don't need to wait on the writes.\n\t\t\t\t// Update iblock.\n\t\t\t}\n\t\t\t/*\n\t\t\t * The current page straddles initialized size. Zero\n\t\t\t * all non-uptodate buffers and set them uptodate (and\n\t\t\t * dirty?). Note, there aren't any non-uptodate buffers\n\t\t\t * if the page is uptodate.\n\t\t\t * FIXME: For an uptodate page, the buffers may need to\n\t\t\t * be written out because they were not initialized on\n\t\t\t * disk before.\n\t\t\t */\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t// TODO:\n\t\t\t\t// Zero any non-uptodate buffers up to i_size.\n\t\t\t\t// Set them uptodate and dirty.\n\t\t\t}\n\t\t\t// TODO:\n\t\t\t// Update initialized size in the attribute and in the\n\t\t\t// inode (up to i_size).\n\t\t\t// Update iblock.\n\t\t\t// FIXME: This is inefficient. Try to batch the two\n\t\t\t// size changes to happen in one go.\n\t\t\tntfs_error(vol->sb, \"Writing beyond initialized size \"\n\t\t\t\t\t\"is not supported yet. Sorry.\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t\t// Do NOT set_buffer_new() BUT DO clear buffer range\n\t\t\t// outside write request range.\n\t\t\t// set_buffer_uptodate() on complete buffers as well as\n\t\t\t// set_buffer_dirty().\n\t\t}\n\n\t\t/* No need to map buffers that are already mapped. */\n\t\tif (buffer_mapped(bh))\n\t\t\tcontinue;\n\n\t\t/* Unmapped, dirty buffer. Need to map it. */\n\t\tbh->b_bdev = vol->sb->s_bdev;\n\n\t\t/* Convert block into corresponding vcn and offset. */\n\t\tvcn = (VCN)block << blocksize_bits;\n\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\tvcn >>= vol->cluster_size_bits;\n\t\tif (!rl) {\nlock_retry_remap:\n\t\t\tdown_read(&ni->runlist.lock);\n\t\t\trl = ni->runlist.rl;\n\t\t}\n\t\tif (likely(rl != NULL)) {\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t} else\n\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t/* Successful remap. */\n\t\tif (lcn >= 0) {\n\t\t\t/* Setup buffer head to point to correct block. */\n\t\t\tbh->b_blocknr = ((lcn << vol->cluster_size_bits) +\n\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\tset_buffer_mapped(bh);\n\t\t\tcontinue;\n\t\t}\n\t\t/* It is a hole, need to instantiate it. */\n\t\tif (lcn == LCN_HOLE) {\n\t\t\tu8 *kaddr;\n\t\t\tunsigned long *bpos, *bend;\n\n\t\t\t/* Check if the buffer is zero. */\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tbpos = (unsigned long *)(kaddr + bh_offset(bh));\n\t\t\tbend = (unsigned long *)((u8*)bpos + blocksize);\n\t\t\tdo {\n\t\t\t\tif (unlikely(*bpos))\n\t\t\t\t\tbreak;\n\t\t\t} while (likely(++bpos < bend));\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tif (bpos == bend) {\n\t\t\t\t/*\n\t\t\t\t * Buffer is zero and sparse, no need to write\n\t\t\t\t * it.\n\t\t\t\t */\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// TODO: Instantiate the hole.\n\t\t\t// clear_buffer_new(bh);\n\t\t\t// unmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);\n\t\t\tntfs_error(vol->sb, \"Writing into sparse regions is \"\n\t\t\t\t\t\"not supported yet. Sorry.\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\t/* If first try and runlist unmapped, map and retry. */\n\t\tif (!is_retry && lcn == LCN_RL_NOT_MAPPED) {\n\t\t\tis_retry = true;\n\t\t\t/*\n\t\t\t * Attempt to map runlist, dropping lock for\n\t\t\t * the duration.\n\t\t\t */\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\terr = ntfs_map_runlist(ni, vcn);\n\t\t\tif (likely(!err))\n\t\t\t\tgoto lock_retry_remap;\n\t\t\trl = NULL;\n\t\t} else if (!rl)\n\t\t\tup_read(&ni->runlist.lock);\n\t\t/*\n\t\t * If buffer is outside the runlist, truncate has cut it out\n\t\t * of the runlist.  Just clean and clear the buffer and set it\n\t\t * uptodate so it can get discarded by the VM.\n\t\t */\n\t\tif (err == -ENOENT || lcn == LCN_ENOENT) {\n\t\t\tbh->b_blocknr = -1;\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tzero_user(page, bh_offset(bh), blocksize);\n\t\t\tset_buffer_uptodate(bh);\n\t\t\terr = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Failed to map the buffer, even after retrying. */\n\t\tif (!err)\n\t\t\terr = -EIO;\n\t\tbh->b_blocknr = -1;\n\t\tntfs_error(vol->sb, \"Failed to write to inode 0x%lx, \"\n\t\t\t\t\"attribute type 0x%x, vcn 0x%llx, offset 0x%x \"\n\t\t\t\t\"because its location on disk could not be \"\n\t\t\t\t\"determined%s (error code %i).\", ni->mft_no,\n\t\t\t\tni->type, (unsigned long long)vcn,\n\t\t\t\tvcn_ofs, is_retry ? \" even after \"\n\t\t\t\t\"retrying\" : \"\", err);\n\t\tbreak;\n\t} while (block++, (bh = bh->b_this_page) != head);\n\n\t/* Release the lock if we took it. */\n\tif (rl)\n\t\tup_read(&ni->runlist.lock);\n\n\t/* For the error case, need to reset bh to the beginning. */\n\tbh = head;\n\n\t/* Just an optimization, so ->readpage() is not called later. */\n\tif (unlikely(!PageUptodate(page))) {\n\t\tint uptodate = 1;\n\t\tdo {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tuptodate = 0;\n\t\t\t\tbh = head;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while ((bh = bh->b_this_page) != head);\n\t\tif (uptodate)\n\t\t\tSetPageUptodate(page);\n\t}\n\n\t/* Setup all mapped, dirty buffers for async write i/o. */\n\tdo {\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh)) {\n\t\t\tlock_buffer(bh);\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tBUG_ON(!buffer_uptodate(bh));\n\t\t\t\tmark_buffer_async_write(bh);\n\t\t\t} else\n\t\t\t\tunlock_buffer(bh);\n\t\t} else if (unlikely(err)) {\n\t\t\t/*\n\t\t\t * For the error case. The buffer may have been set\n\t\t\t * dirty during attachment to a dirty page.\n\t\t\t */\n\t\t\tif (err != -ENOMEM)\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\tif (unlikely(err)) {\n\t\t// TODO: Remove the -EOPNOTSUPP check later on...\n\t\tif (unlikely(err == -EOPNOTSUPP))\n\t\t\terr = 0;\n\t\telse if (err == -ENOMEM) {\n\t\t\tntfs_warning(vol->sb, \"Error allocating memory. \"\n\t\t\t\t\t\"Redirtying page so we try again \"\n\t\t\t\t\t\"later.\");\n\t\t\t/*\n\t\t\t * Put the page back on mapping->dirty_pages, but\n\t\t\t * leave its buffer's dirty state as-is.\n\t\t\t */\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\terr = 0;\n\t\t} else\n\t\t\tSetPageError(page);\n\t}\n\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\t/* Keeps try_to_free_buffers() away. */\n\n\t/* Submit the prepared buffers for i/o. */\n\tneed_end_writeback = true;\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh(WRITE, bh);\n\t\t\tneed_end_writeback = false;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\n\t/* If no i/o was started, need to end_page_writeback(). */\n\tif (unlikely(need_end_writeback))\n\t\tend_page_writeback(page);\n\n\tntfs_debug(\"Done.\");\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_write_mst_block",
          "args": [
            "page",
            "wbc"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_write_mst_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.c",
          "lines": "919-1328",
          "snippet": "static int ntfs_write_mst_block(struct page *page,\n\t\tstruct writeback_control *wbc)\n{\n\tsector_t block, dblock, rec_block;\n\tstruct inode *vi = page->mapping->host;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_volume *vol = ni->vol;\n\tu8 *kaddr;\n\tunsigned int rec_size = ni->itype.index.block_size;\n\tntfs_inode *locked_nis[PAGE_CACHE_SIZE / rec_size];\n\tstruct buffer_head *bh, *head, *tbh, *rec_start_bh;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\trunlist_element *rl;\n\tint i, nr_locked_nis, nr_recs, nr_bhs, max_bhs, bhs_per_rec, err, err2;\n\tunsigned bh_size, rec_size_bits;\n\tbool sync, is_mft, page_is_dirty, rec_is_dirty;\n\tunsigned char bh_size_bits;\n\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, page index \"\n\t\t\t\"0x%lx.\", vi->i_ino, ni->type, page->index);\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(!NInoMstProtected(ni));\n\tis_mft = (S_ISREG(vi->i_mode) && !vi->i_ino);\n\t/*\n\t * NOTE: ntfs_write_mst_block() would be called for $MFTMirr if a page\n\t * in its page cache were to be marked dirty.  However this should\n\t * never happen with the current driver and considering we do not\n\t * handle this case here we do want to BUG(), at least for now.\n\t */\n\tBUG_ON(!(is_mft || S_ISDIR(vi->i_mode) ||\n\t\t\t(NInoAttr(ni) && ni->type == AT_INDEX_ALLOCATION)));\n\tbh_size = vol->sb->s_blocksize;\n\tbh_size_bits = vol->sb->s_blocksize_bits;\n\tmax_bhs = PAGE_CACHE_SIZE / bh_size;\n\tBUG_ON(!max_bhs);\n\tBUG_ON(max_bhs > MAX_BUF_PER_PAGE);\n\n\t/* Were we called for sync purposes? */\n\tsync = (wbc->sync_mode == WB_SYNC_ALL);\n\n\t/* Make sure we have mapped buffers. */\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\n\trec_size_bits = ni->itype.index.block_size_bits;\n\tBUG_ON(!(PAGE_CACHE_SIZE >> rec_size_bits));\n\tbhs_per_rec = rec_size >> bh_size_bits;\n\tBUG_ON(!bhs_per_rec);\n\n\t/* The first block in the page. */\n\trec_block = block = (sector_t)page->index <<\n\t\t\t(PAGE_CACHE_SHIFT - bh_size_bits);\n\n\t/* The first out of bounds block for the data size. */\n\tdblock = (i_size_read(vi) + bh_size - 1) >> bh_size_bits;\n\n\trl = NULL;\n\terr = err2 = nr_bhs = nr_recs = nr_locked_nis = 0;\n\tpage_is_dirty = rec_is_dirty = false;\n\trec_start_bh = NULL;\n\tdo {\n\t\tbool is_retry = false;\n\n\t\tif (likely(block < rec_block)) {\n\t\t\tif (unlikely(block >= dblock)) {\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * This block is not the first one in the record.  We\n\t\t\t * ignore the buffer's dirty state because we could\n\t\t\t * have raced with a parallel mark_ntfs_record_dirty().\n\t\t\t */\n\t\t\tif (!rec_is_dirty)\n\t\t\t\tcontinue;\n\t\t\tif (unlikely(err2)) {\n\t\t\t\tif (err2 != -ENOMEM)\n\t\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else /* if (block == rec_block) */ {\n\t\t\tBUG_ON(block > rec_block);\n\t\t\t/* This block is the first one in the record. */\n\t\t\trec_block += bhs_per_rec;\n\t\t\terr2 = 0;\n\t\t\tif (unlikely(block >= dblock)) {\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\t/* Clean records are not written out. */\n\t\t\t\trec_is_dirty = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trec_is_dirty = true;\n\t\t\trec_start_bh = bh;\n\t\t}\n\t\t/* Need to map the buffer if it is not mapped already. */\n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t/* Obtain the vcn and offset of the current block. */\n\t\t\tvcn = (VCN)block << bh_size_bits;\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\nlock_retry_remap:\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\trl = ni->runlist.rl;\n\t\t\t}\n\t\t\tif (likely(rl != NULL)) {\n\t\t\t\t/* Seek to element containing target vcn. */\n\t\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\t\trl++;\n\t\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t} else\n\t\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t\t/* Successful remap. */\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> bh_size_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Remap failed.  Retry to map the runlist once\n\t\t\t\t * unless we are working on $MFT which always\n\t\t\t\t * has the whole of its runlist in memory.\n\t\t\t\t */\n\t\t\t\tif (!is_mft && !is_retry &&\n\t\t\t\t\t\tlcn == LCN_RL_NOT_MAPPED) {\n\t\t\t\t\tis_retry = true;\n\t\t\t\t\t/*\n\t\t\t\t\t * Attempt to map runlist, dropping\n\t\t\t\t\t * lock for the duration.\n\t\t\t\t\t */\n\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t\terr2 = ntfs_map_runlist(ni, vcn);\n\t\t\t\t\tif (likely(!err2))\n\t\t\t\t\t\tgoto lock_retry_remap;\n\t\t\t\t\tif (err2 == -ENOMEM)\n\t\t\t\t\t\tpage_is_dirty = true;\n\t\t\t\t\tlcn = err2;\n\t\t\t\t} else {\n\t\t\t\t\terr2 = -EIO;\n\t\t\t\t\tif (!rl)\n\t\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t}\n\t\t\t\t/* Hard error.  Abort writing this record. */\n\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\terr = err2;\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write ntfs record \"\n\t\t\t\t\t\t\"0x%llx (inode 0x%lx, \"\n\t\t\t\t\t\t\"attribute type 0x%x) because \"\n\t\t\t\t\t\t\"its location on disk could \"\n\t\t\t\t\t\t\"not be determined (error \"\n\t\t\t\t\t\t\"code %lli).\",\n\t\t\t\t\t\t(long long)block <<\n\t\t\t\t\t\tbh_size_bits >>\n\t\t\t\t\t\tvol->mft_record_size_bits,\n\t\t\t\t\t\tni->mft_no, ni->type,\n\t\t\t\t\t\t(long long)lcn);\n\t\t\t\t/*\n\t\t\t\t * If this is not the first buffer, remove the\n\t\t\t\t * buffers in this record from the list of\n\t\t\t\t * buffers to write and clear their dirty bit\n\t\t\t\t * if not error -ENOMEM.\n\t\t\t\t */\n\t\t\t\tif (rec_start_bh != bh) {\n\t\t\t\t\twhile (bhs[--nr_bhs] != rec_start_bh)\n\t\t\t\t\t\t;\n\t\t\t\t\tif (err2 != -ENOMEM) {\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tclear_buffer_dirty(\n\t\t\t\t\t\t\t\trec_start_bh);\n\t\t\t\t\t\t} while ((rec_start_bh =\n\t\t\t\t\t\t\t\trec_start_bh->\n\t\t\t\t\t\t\t\tb_this_page) !=\n\t\t\t\t\t\t\t\tbh);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t} while (block++, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&ni->runlist.lock);\n\t/* If there were no dirty buffers, we are done. */\n\tif (!nr_bhs)\n\t\tgoto done;\n\t/* Map the page so we can access its contents. */\n\tkaddr = kmap(page);\n\t/* Clear the page uptodate flag whilst the mst fixups are applied. */\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tunsigned int ofs;\n\n\t\t/* Skip buffers which are not at the beginning of records. */\n\t\tif (i % bhs_per_rec)\n\t\t\tcontinue;\n\t\ttbh = bhs[i];\n\t\tofs = bh_offset(tbh);\n\t\tif (is_mft) {\n\t\t\tntfs_inode *tni;\n\t\t\tunsigned long mft_no;\n\n\t\t\t/* Get the mft record number. */\n\t\t\tmft_no = (((s64)page->index << PAGE_CACHE_SHIFT) + ofs)\n\t\t\t\t\t>> rec_size_bits;\n\t\t\t/* Check whether to write this mft record. */\n\t\t\ttni = NULL;\n\t\t\tif (!ntfs_may_write_mft_record(vol, mft_no,\n\t\t\t\t\t(MFT_RECORD*)(kaddr + ofs), &tni)) {\n\t\t\t\t/*\n\t\t\t\t * The record should not be written.  This\n\t\t\t\t * means we need to redirty the page before\n\t\t\t\t * returning.\n\t\t\t\t */\n\t\t\t\tpage_is_dirty = true;\n\t\t\t\t/*\n\t\t\t\t * Remove the buffers in this mft record from\n\t\t\t\t * the list of buffers to write.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t} while (++i % bhs_per_rec);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * The record should be written.  If a locked ntfs\n\t\t\t * inode was returned, add it to the array of locked\n\t\t\t * ntfs inodes.\n\t\t\t */\n\t\t\tif (tni)\n\t\t\t\tlocked_nis[nr_locked_nis++] = tni;\n\t\t}\n\t\t/* Apply the mst protection fixups. */\n\t\terr2 = pre_write_mst_fixup((NTFS_RECORD*)(kaddr + ofs),\n\t\t\t\trec_size);\n\t\tif (unlikely(err2)) {\n\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\tntfs_error(vol->sb, \"Failed to apply mst fixups \"\n\t\t\t\t\t\"(inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"page index 0x%lx, page offset 0x%x)!\"\n\t\t\t\t\t\"  Unmount and run chkdsk.\", vi->i_ino,\n\t\t\t\t\tni->type, page->index, ofs);\n\t\t\t/*\n\t\t\t * Mark all the buffers in this record clean as we do\n\t\t\t * not want to write corrupt data to disk.\n\t\t\t */\n\t\t\tdo {\n\t\t\t\tclear_buffer_dirty(bhs[i]);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t} while (++i % bhs_per_rec);\n\t\t\tcontinue;\n\t\t}\n\t\tnr_recs++;\n\t}\n\t/* If no records are to be written out, we are done. */\n\tif (!nr_recs)\n\t\tgoto unm_done;\n\tflush_dcache_page(page);\n\t/* Lock buffers and start synchronous write i/o on them. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\ttbh = bhs[i];\n\t\tif (!tbh)\n\t\t\tcontinue;\n\t\tif (!trylock_buffer(tbh))\n\t\t\tBUG();\n\t\t/* The buffer dirty state is now irrelevant, just clean it. */\n\t\tclear_buffer_dirty(tbh);\n\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\tBUG_ON(!buffer_mapped(tbh));\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\tsubmit_bh(WRITE, tbh);\n\t}\n\t/* Synchronize the mft mirror now if not @sync. */\n\tif (is_mft && !sync)\n\t\tgoto do_mirror;\ndo_wait:\n\t/* Wait on i/o completion of buffers. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\ttbh = bhs[i];\n\t\tif (!tbh)\n\t\t\tcontinue;\n\t\twait_on_buffer(tbh);\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\tntfs_error(vol->sb, \"I/O error while writing ntfs \"\n\t\t\t\t\t\"record buffer (inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, page index \"\n\t\t\t\t\t\"0x%lx, page offset 0x%lx)!  Unmount \"\n\t\t\t\t\t\"and run chkdsk.\", vi->i_ino, ni->type,\n\t\t\t\t\tpage->index, bh_offset(tbh));\n\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\t/*\n\t\t\t * Set the buffer uptodate so the page and buffer\n\t\t\t * states do not become out of sync.\n\t\t\t */\n\t\t\tset_buffer_uptodate(tbh);\n\t\t}\n\t}\n\t/* If @sync, now synchronize the mft mirror. */\n\tif (is_mft && sync) {\ndo_mirror:\n\t\tfor (i = 0; i < nr_bhs; i++) {\n\t\t\tunsigned long mft_no;\n\t\t\tunsigned int ofs;\n\n\t\t\t/*\n\t\t\t * Skip buffers which are not at the beginning of\n\t\t\t * records.\n\t\t\t */\n\t\t\tif (i % bhs_per_rec)\n\t\t\t\tcontinue;\n\t\t\ttbh = bhs[i];\n\t\t\t/* Skip removed buffers (and hence records). */\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\tofs = bh_offset(tbh);\n\t\t\t/* Get the mft record number. */\n\t\t\tmft_no = (((s64)page->index << PAGE_CACHE_SHIFT) + ofs)\n\t\t\t\t\t>> rec_size_bits;\n\t\t\tif (mft_no < vol->mftmirr_size)\n\t\t\t\tntfs_sync_mft_mirror(vol, mft_no,\n\t\t\t\t\t\t(MFT_RECORD*)(kaddr + ofs),\n\t\t\t\t\t\tsync);\n\t\t}\n\t\tif (!sync)\n\t\t\tgoto do_wait;\n\t}\n\t/* Remove the mst protection fixups again. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tif (!(i % bhs_per_rec)) {\n\t\t\ttbh = bhs[i];\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\tpost_write_mst_fixup((NTFS_RECORD*)(kaddr +\n\t\t\t\t\tbh_offset(tbh)));\n\t\t}\n\t}\n\tflush_dcache_page(page);\nunm_done:\n\t/* Unlock any locked inodes. */\n\twhile (nr_locked_nis-- > 0) {\n\t\tntfs_inode *tni, *base_tni;\n\t\t\n\t\ttni = locked_nis[nr_locked_nis];\n\t\t/* Get the base inode. */\n\t\tmutex_lock(&tni->extent_lock);\n\t\tif (tni->nr_extents >= 0)\n\t\t\tbase_tni = tni;\n\t\telse {\n\t\t\tbase_tni = tni->ext.base_ntfs_ino;\n\t\t\tBUG_ON(!base_tni);\n\t\t}\n\t\tmutex_unlock(&tni->extent_lock);\n\t\tntfs_debug(\"Unlocking %s inode 0x%lx.\",\n\t\t\t\ttni == base_tni ? \"base\" : \"extent\",\n\t\t\t\ttni->mft_no);\n\t\tmutex_unlock(&tni->mrec_lock);\n\t\tatomic_dec(&tni->count);\n\t\tiput(VFS_I(base_tni));\n\t}\n\tSetPageUptodate(page);\n\tkunmap(page);\ndone:\n\tif (unlikely(err && err != -ENOMEM)) {\n\t\t/*\n\t\t * Set page error if there is only one ntfs record in the page.\n\t\t * Otherwise we would loose per-record granularity.\n\t\t */\n\t\tif (ni->itype.index.block_size == PAGE_CACHE_SIZE)\n\t\t\tSetPageError(page);\n\t\tNVolSetErrors(vol);\n\t}\n\tif (page_is_dirty) {\n\t\tntfs_debug(\"Page still contains one or more dirty ntfs \"\n\t\t\t\t\"records.  Redirtying the page starting at \"\n\t\t\t\t\"record 0x%lx.\", page->index <<\n\t\t\t\t(PAGE_CACHE_SHIFT - rec_size_bits));\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tunlock_page(page);\n\t} else {\n\t\t/*\n\t\t * Keep the VM happy.  This must be done otherwise the\n\t\t * radix-tree tag PAGECACHE_TAG_DIRTY remains set even though\n\t\t * the page is clean.\n\t\t */\n\t\tBUG_ON(PageWriteback(page));\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t\tend_page_writeback(page);\n\t}\n\tif (likely(!err))\n\t\tntfs_debug(\"Done.\");\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"types.h\"",
            "#include \"runlist.h\"",
            "#include \"mft.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"types.h\"\n#include \"runlist.h\"\n#include \"mft.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int ntfs_write_mst_block(struct page *page,\n\t\tstruct writeback_control *wbc)\n{\n\tsector_t block, dblock, rec_block;\n\tstruct inode *vi = page->mapping->host;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_volume *vol = ni->vol;\n\tu8 *kaddr;\n\tunsigned int rec_size = ni->itype.index.block_size;\n\tntfs_inode *locked_nis[PAGE_CACHE_SIZE / rec_size];\n\tstruct buffer_head *bh, *head, *tbh, *rec_start_bh;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\trunlist_element *rl;\n\tint i, nr_locked_nis, nr_recs, nr_bhs, max_bhs, bhs_per_rec, err, err2;\n\tunsigned bh_size, rec_size_bits;\n\tbool sync, is_mft, page_is_dirty, rec_is_dirty;\n\tunsigned char bh_size_bits;\n\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, page index \"\n\t\t\t\"0x%lx.\", vi->i_ino, ni->type, page->index);\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(!NInoMstProtected(ni));\n\tis_mft = (S_ISREG(vi->i_mode) && !vi->i_ino);\n\t/*\n\t * NOTE: ntfs_write_mst_block() would be called for $MFTMirr if a page\n\t * in its page cache were to be marked dirty.  However this should\n\t * never happen with the current driver and considering we do not\n\t * handle this case here we do want to BUG(), at least for now.\n\t */\n\tBUG_ON(!(is_mft || S_ISDIR(vi->i_mode) ||\n\t\t\t(NInoAttr(ni) && ni->type == AT_INDEX_ALLOCATION)));\n\tbh_size = vol->sb->s_blocksize;\n\tbh_size_bits = vol->sb->s_blocksize_bits;\n\tmax_bhs = PAGE_CACHE_SIZE / bh_size;\n\tBUG_ON(!max_bhs);\n\tBUG_ON(max_bhs > MAX_BUF_PER_PAGE);\n\n\t/* Were we called for sync purposes? */\n\tsync = (wbc->sync_mode == WB_SYNC_ALL);\n\n\t/* Make sure we have mapped buffers. */\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\n\trec_size_bits = ni->itype.index.block_size_bits;\n\tBUG_ON(!(PAGE_CACHE_SIZE >> rec_size_bits));\n\tbhs_per_rec = rec_size >> bh_size_bits;\n\tBUG_ON(!bhs_per_rec);\n\n\t/* The first block in the page. */\n\trec_block = block = (sector_t)page->index <<\n\t\t\t(PAGE_CACHE_SHIFT - bh_size_bits);\n\n\t/* The first out of bounds block for the data size. */\n\tdblock = (i_size_read(vi) + bh_size - 1) >> bh_size_bits;\n\n\trl = NULL;\n\terr = err2 = nr_bhs = nr_recs = nr_locked_nis = 0;\n\tpage_is_dirty = rec_is_dirty = false;\n\trec_start_bh = NULL;\n\tdo {\n\t\tbool is_retry = false;\n\n\t\tif (likely(block < rec_block)) {\n\t\t\tif (unlikely(block >= dblock)) {\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * This block is not the first one in the record.  We\n\t\t\t * ignore the buffer's dirty state because we could\n\t\t\t * have raced with a parallel mark_ntfs_record_dirty().\n\t\t\t */\n\t\t\tif (!rec_is_dirty)\n\t\t\t\tcontinue;\n\t\t\tif (unlikely(err2)) {\n\t\t\t\tif (err2 != -ENOMEM)\n\t\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else /* if (block == rec_block) */ {\n\t\t\tBUG_ON(block > rec_block);\n\t\t\t/* This block is the first one in the record. */\n\t\t\trec_block += bhs_per_rec;\n\t\t\terr2 = 0;\n\t\t\tif (unlikely(block >= dblock)) {\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\t/* Clean records are not written out. */\n\t\t\t\trec_is_dirty = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trec_is_dirty = true;\n\t\t\trec_start_bh = bh;\n\t\t}\n\t\t/* Need to map the buffer if it is not mapped already. */\n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t/* Obtain the vcn and offset of the current block. */\n\t\t\tvcn = (VCN)block << bh_size_bits;\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\nlock_retry_remap:\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\trl = ni->runlist.rl;\n\t\t\t}\n\t\t\tif (likely(rl != NULL)) {\n\t\t\t\t/* Seek to element containing target vcn. */\n\t\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\t\trl++;\n\t\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t} else\n\t\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t\t/* Successful remap. */\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> bh_size_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Remap failed.  Retry to map the runlist once\n\t\t\t\t * unless we are working on $MFT which always\n\t\t\t\t * has the whole of its runlist in memory.\n\t\t\t\t */\n\t\t\t\tif (!is_mft && !is_retry &&\n\t\t\t\t\t\tlcn == LCN_RL_NOT_MAPPED) {\n\t\t\t\t\tis_retry = true;\n\t\t\t\t\t/*\n\t\t\t\t\t * Attempt to map runlist, dropping\n\t\t\t\t\t * lock for the duration.\n\t\t\t\t\t */\n\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t\terr2 = ntfs_map_runlist(ni, vcn);\n\t\t\t\t\tif (likely(!err2))\n\t\t\t\t\t\tgoto lock_retry_remap;\n\t\t\t\t\tif (err2 == -ENOMEM)\n\t\t\t\t\t\tpage_is_dirty = true;\n\t\t\t\t\tlcn = err2;\n\t\t\t\t} else {\n\t\t\t\t\terr2 = -EIO;\n\t\t\t\t\tif (!rl)\n\t\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t}\n\t\t\t\t/* Hard error.  Abort writing this record. */\n\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\terr = err2;\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write ntfs record \"\n\t\t\t\t\t\t\"0x%llx (inode 0x%lx, \"\n\t\t\t\t\t\t\"attribute type 0x%x) because \"\n\t\t\t\t\t\t\"its location on disk could \"\n\t\t\t\t\t\t\"not be determined (error \"\n\t\t\t\t\t\t\"code %lli).\",\n\t\t\t\t\t\t(long long)block <<\n\t\t\t\t\t\tbh_size_bits >>\n\t\t\t\t\t\tvol->mft_record_size_bits,\n\t\t\t\t\t\tni->mft_no, ni->type,\n\t\t\t\t\t\t(long long)lcn);\n\t\t\t\t/*\n\t\t\t\t * If this is not the first buffer, remove the\n\t\t\t\t * buffers in this record from the list of\n\t\t\t\t * buffers to write and clear their dirty bit\n\t\t\t\t * if not error -ENOMEM.\n\t\t\t\t */\n\t\t\t\tif (rec_start_bh != bh) {\n\t\t\t\t\twhile (bhs[--nr_bhs] != rec_start_bh)\n\t\t\t\t\t\t;\n\t\t\t\t\tif (err2 != -ENOMEM) {\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tclear_buffer_dirty(\n\t\t\t\t\t\t\t\trec_start_bh);\n\t\t\t\t\t\t} while ((rec_start_bh =\n\t\t\t\t\t\t\t\trec_start_bh->\n\t\t\t\t\t\t\t\tb_this_page) !=\n\t\t\t\t\t\t\t\tbh);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t} while (block++, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&ni->runlist.lock);\n\t/* If there were no dirty buffers, we are done. */\n\tif (!nr_bhs)\n\t\tgoto done;\n\t/* Map the page so we can access its contents. */\n\tkaddr = kmap(page);\n\t/* Clear the page uptodate flag whilst the mst fixups are applied. */\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tunsigned int ofs;\n\n\t\t/* Skip buffers which are not at the beginning of records. */\n\t\tif (i % bhs_per_rec)\n\t\t\tcontinue;\n\t\ttbh = bhs[i];\n\t\tofs = bh_offset(tbh);\n\t\tif (is_mft) {\n\t\t\tntfs_inode *tni;\n\t\t\tunsigned long mft_no;\n\n\t\t\t/* Get the mft record number. */\n\t\t\tmft_no = (((s64)page->index << PAGE_CACHE_SHIFT) + ofs)\n\t\t\t\t\t>> rec_size_bits;\n\t\t\t/* Check whether to write this mft record. */\n\t\t\ttni = NULL;\n\t\t\tif (!ntfs_may_write_mft_record(vol, mft_no,\n\t\t\t\t\t(MFT_RECORD*)(kaddr + ofs), &tni)) {\n\t\t\t\t/*\n\t\t\t\t * The record should not be written.  This\n\t\t\t\t * means we need to redirty the page before\n\t\t\t\t * returning.\n\t\t\t\t */\n\t\t\t\tpage_is_dirty = true;\n\t\t\t\t/*\n\t\t\t\t * Remove the buffers in this mft record from\n\t\t\t\t * the list of buffers to write.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t} while (++i % bhs_per_rec);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * The record should be written.  If a locked ntfs\n\t\t\t * inode was returned, add it to the array of locked\n\t\t\t * ntfs inodes.\n\t\t\t */\n\t\t\tif (tni)\n\t\t\t\tlocked_nis[nr_locked_nis++] = tni;\n\t\t}\n\t\t/* Apply the mst protection fixups. */\n\t\terr2 = pre_write_mst_fixup((NTFS_RECORD*)(kaddr + ofs),\n\t\t\t\trec_size);\n\t\tif (unlikely(err2)) {\n\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\tntfs_error(vol->sb, \"Failed to apply mst fixups \"\n\t\t\t\t\t\"(inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"page index 0x%lx, page offset 0x%x)!\"\n\t\t\t\t\t\"  Unmount and run chkdsk.\", vi->i_ino,\n\t\t\t\t\tni->type, page->index, ofs);\n\t\t\t/*\n\t\t\t * Mark all the buffers in this record clean as we do\n\t\t\t * not want to write corrupt data to disk.\n\t\t\t */\n\t\t\tdo {\n\t\t\t\tclear_buffer_dirty(bhs[i]);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t} while (++i % bhs_per_rec);\n\t\t\tcontinue;\n\t\t}\n\t\tnr_recs++;\n\t}\n\t/* If no records are to be written out, we are done. */\n\tif (!nr_recs)\n\t\tgoto unm_done;\n\tflush_dcache_page(page);\n\t/* Lock buffers and start synchronous write i/o on them. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\ttbh = bhs[i];\n\t\tif (!tbh)\n\t\t\tcontinue;\n\t\tif (!trylock_buffer(tbh))\n\t\t\tBUG();\n\t\t/* The buffer dirty state is now irrelevant, just clean it. */\n\t\tclear_buffer_dirty(tbh);\n\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\tBUG_ON(!buffer_mapped(tbh));\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\tsubmit_bh(WRITE, tbh);\n\t}\n\t/* Synchronize the mft mirror now if not @sync. */\n\tif (is_mft && !sync)\n\t\tgoto do_mirror;\ndo_wait:\n\t/* Wait on i/o completion of buffers. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\ttbh = bhs[i];\n\t\tif (!tbh)\n\t\t\tcontinue;\n\t\twait_on_buffer(tbh);\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\tntfs_error(vol->sb, \"I/O error while writing ntfs \"\n\t\t\t\t\t\"record buffer (inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, page index \"\n\t\t\t\t\t\"0x%lx, page offset 0x%lx)!  Unmount \"\n\t\t\t\t\t\"and run chkdsk.\", vi->i_ino, ni->type,\n\t\t\t\t\tpage->index, bh_offset(tbh));\n\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\t/*\n\t\t\t * Set the buffer uptodate so the page and buffer\n\t\t\t * states do not become out of sync.\n\t\t\t */\n\t\t\tset_buffer_uptodate(tbh);\n\t\t}\n\t}\n\t/* If @sync, now synchronize the mft mirror. */\n\tif (is_mft && sync) {\ndo_mirror:\n\t\tfor (i = 0; i < nr_bhs; i++) {\n\t\t\tunsigned long mft_no;\n\t\t\tunsigned int ofs;\n\n\t\t\t/*\n\t\t\t * Skip buffers which are not at the beginning of\n\t\t\t * records.\n\t\t\t */\n\t\t\tif (i % bhs_per_rec)\n\t\t\t\tcontinue;\n\t\t\ttbh = bhs[i];\n\t\t\t/* Skip removed buffers (and hence records). */\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\tofs = bh_offset(tbh);\n\t\t\t/* Get the mft record number. */\n\t\t\tmft_no = (((s64)page->index << PAGE_CACHE_SHIFT) + ofs)\n\t\t\t\t\t>> rec_size_bits;\n\t\t\tif (mft_no < vol->mftmirr_size)\n\t\t\t\tntfs_sync_mft_mirror(vol, mft_no,\n\t\t\t\t\t\t(MFT_RECORD*)(kaddr + ofs),\n\t\t\t\t\t\tsync);\n\t\t}\n\t\tif (!sync)\n\t\t\tgoto do_wait;\n\t}\n\t/* Remove the mst protection fixups again. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tif (!(i % bhs_per_rec)) {\n\t\t\ttbh = bhs[i];\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\tpost_write_mst_fixup((NTFS_RECORD*)(kaddr +\n\t\t\t\t\tbh_offset(tbh)));\n\t\t}\n\t}\n\tflush_dcache_page(page);\nunm_done:\n\t/* Unlock any locked inodes. */\n\twhile (nr_locked_nis-- > 0) {\n\t\tntfs_inode *tni, *base_tni;\n\t\t\n\t\ttni = locked_nis[nr_locked_nis];\n\t\t/* Get the base inode. */\n\t\tmutex_lock(&tni->extent_lock);\n\t\tif (tni->nr_extents >= 0)\n\t\t\tbase_tni = tni;\n\t\telse {\n\t\t\tbase_tni = tni->ext.base_ntfs_ino;\n\t\t\tBUG_ON(!base_tni);\n\t\t}\n\t\tmutex_unlock(&tni->extent_lock);\n\t\tntfs_debug(\"Unlocking %s inode 0x%lx.\",\n\t\t\t\ttni == base_tni ? \"base\" : \"extent\",\n\t\t\t\ttni->mft_no);\n\t\tmutex_unlock(&tni->mrec_lock);\n\t\tatomic_dec(&tni->count);\n\t\tiput(VFS_I(base_tni));\n\t}\n\tSetPageUptodate(page);\n\tkunmap(page);\ndone:\n\tif (unlikely(err && err != -ENOMEM)) {\n\t\t/*\n\t\t * Set page error if there is only one ntfs record in the page.\n\t\t * Otherwise we would loose per-record granularity.\n\t\t */\n\t\tif (ni->itype.index.block_size == PAGE_CACHE_SIZE)\n\t\t\tSetPageError(page);\n\t\tNVolSetErrors(vol);\n\t}\n\tif (page_is_dirty) {\n\t\tntfs_debug(\"Page still contains one or more dirty ntfs \"\n\t\t\t\t\"records.  Redirtying the page starting at \"\n\t\t\t\t\"record 0x%lx.\", page->index <<\n\t\t\t\t(PAGE_CACHE_SHIFT - rec_size_bits));\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tunlock_page(page);\n\t} else {\n\t\t/*\n\t\t * Keep the VM happy.  This must be done otherwise the\n\t\t * radix-tree tag PAGECACHE_TAG_DIRTY remains set even though\n\t\t * the page is clean.\n\t\t */\n\t\tBUG_ON(PageWriteback(page));\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t\tend_page_writeback(page);\n\t}\n\tif (likely(!err))\n\t\tntfs_debug(\"Done.\");\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoMstProtected",
          "args": [
            "ni"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "ofs",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Writing to sparse files is not \"\n\t\t\t\t\t\"supported yet.  Sorry.\""
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSparse",
          "args": [
            "ni"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Writing to compressed files is \"\n\t\t\t\t\t\"not supported yet.  Sorry.\""
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ni->name_len"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ni->type != AT_DATA"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Denying write access to encrypted file.\""
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ni->type != AT_DATA"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoEncrypted",
          "args": [
            "ni"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_invalidatepage",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "block_invalidatepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1509-1555",
          "snippet": "void block_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t  unsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int curr_off = 0;\n\tunsigned int stop = length + offset;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\t/*\n\t * Check for overflow\n\t */\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\t/*\n\t\t * Are we still fully in range ?\n\t\t */\n\t\tif (next_off > stop)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * is this block fully invalidated?\n\t\t */\n\t\tif (offset <= curr_off)\n\t\t\tdiscard_buffer(bh);\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\t} while (bh != head);\n\n\t/*\n\t * We release buffers only if the entire page is being invalidated.\n\t * The get_block cached value has been unconditionally invalidated,\n\t * so real IO is not possible anymore.\n\t */\n\tif (offset == 0)\n\t\ttry_to_release_page(page, 0);\nout:\n\treturn;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid block_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t  unsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int curr_off = 0;\n\tunsigned int stop = length + offset;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\t/*\n\t * Check for overflow\n\t */\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\t/*\n\t\t * Are we still fully in range ?\n\t\t */\n\t\tif (next_off > stop)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * is this block fully invalidated?\n\t\t */\n\t\tif (offset <= curr_off)\n\t\t\tdiscard_buffer(bh);\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\t} while (bh != head);\n\n\t/*\n\t * We release buffers only if the entire page is being invalidated.\n\t * The get_block cached value has been unconditionally invalidated,\n\t * so real IO is not possible anymore.\n\t */\n\tif (offset == 0)\n\t\ttry_to_release_page(page, 0);\nout:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->index >= (i_size + PAGE_CACHE_SIZE - 1) >>\n\t\t\tPAGE_CACHE_SHIFT"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"types.h\"\n#include \"runlist.h\"\n#include \"mft.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int ntfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tloff_t i_size;\n\tstruct inode *vi = page->mapping->host;\n\tntfs_inode *base_ni = NULL, *ni = NTFS_I(vi);\n\tchar *addr;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tMFT_RECORD *m = NULL;\n\tu32 attr_len;\n\tint err;\n\nretry_writepage:\n\tBUG_ON(!PageLocked(page));\n\ti_size = i_size_read(vi);\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\tif (unlikely(page->index >= (i_size + PAGE_CACHE_SIZE - 1) >>\n\t\t\tPAGE_CACHE_SHIFT)) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tblock_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\tntfs_debug(\"Write outside i_size - truncated?\");\n\t\treturn 0;\n\t}\n\t/*\n\t * Only $DATA attributes can be encrypted and only unnamed $DATA\n\t * attributes can be compressed.  Index root can have the flags set but\n\t * this means to create compressed/encrypted files, not that the\n\t * attribute is compressed/encrypted.  Note we need to check for\n\t * AT_INDEX_ALLOCATION since this is the type of both directory and\n\t * index inodes.\n\t */\n\tif (ni->type != AT_INDEX_ALLOCATION) {\n\t\t/* If file is encrypted, deny access, just like NT4. */\n\t\tif (NInoEncrypted(ni)) {\n\t\t\tunlock_page(page);\n\t\t\tBUG_ON(ni->type != AT_DATA);\n\t\t\tntfs_debug(\"Denying write access to encrypted file.\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* Compressed data streams are handled in compress.c. */\n\t\tif (NInoNonResident(ni) && NInoCompressed(ni)) {\n\t\t\tBUG_ON(ni->type != AT_DATA);\n\t\t\tBUG_ON(ni->name_len);\n\t\t\t// TODO: Implement and replace this with\n\t\t\t// return ntfs_write_compressed_block(page);\n\t\t\tunlock_page(page);\n\t\t\tntfs_error(vi->i_sb, \"Writing to compressed files is \"\n\t\t\t\t\t\"not supported yet.  Sorry.\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\t// TODO: Implement and remove this check.\n\t\tif (NInoNonResident(ni) && NInoSparse(ni)) {\n\t\t\tunlock_page(page);\n\t\t\tntfs_error(vi->i_sb, \"Writing to sparse files is not \"\n\t\t\t\t\t\"supported yet.  Sorry.\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\t/* NInoNonResident() == NInoIndexAllocPresent() */\n\tif (NInoNonResident(ni)) {\n\t\t/* We have to zero every time due to mmap-at-end-of-file. */\n\t\tif (page->index >= (i_size >> PAGE_CACHE_SHIFT)) {\n\t\t\t/* The page straddles i_size. */\n\t\t\tunsigned int ofs = i_size & ~PAGE_CACHE_MASK;\n\t\t\tzero_user_segment(page, ofs, PAGE_CACHE_SIZE);\n\t\t}\n\t\t/* Handle mst protected attributes. */\n\t\tif (NInoMstProtected(ni))\n\t\t\treturn ntfs_write_mst_block(page, wbc);\n\t\t/* Normal, non-resident data stream. */\n\t\treturn ntfs_write_block(page, wbc);\n\t}\n\t/*\n\t * Attribute is resident, implying it is not compressed, encrypted, or\n\t * mst protected.  This also means the attribute is smaller than an mft\n\t * record and hence smaller than a page, so can simply return error on\n\t * any pages with index above 0.  Note the attribute can actually be\n\t * marked compressed but if it is resident the actual data is not\n\t * compressed so we are ok to ignore the compressed flag here.\n\t */\n\tBUG_ON(page_has_buffers(page));\n\tBUG_ON(!PageUptodate(page));\n\tif (unlikely(page->index > 0)) {\n\t\tntfs_error(vi->i_sb, \"BUG()! page->index (0x%lx) > 0.  \"\n\t\t\t\t\"Aborting write.\", page->index);\n\t\tBUG_ON(PageWriteback(page));\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t\tend_page_writeback(page);\n\t\treturn -EIO;\n\t}\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t/* Map, pin, and lock the mft record. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\t/*\n\t * If a parallel write made the attribute non-resident, drop the mft\n\t * record and retry the writepage.\n\t */\n\tif (unlikely(NInoNonResident(ni))) {\n\t\tunmap_mft_record(base_ni);\n\t\tgoto retry_writepage;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\t/*\n\t * Keep the VM happy.  This must be done otherwise the radix-tree tag\n\t * PAGECACHE_TAG_DIRTY remains set even though the page is clean.\n\t */\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tattr_len = le32_to_cpu(ctx->attr->data.resident.value_length);\n\ti_size = i_size_read(vi);\n\tif (unlikely(attr_len > i_size)) {\n\t\t/* Race with shrinking truncate or a failed truncate. */\n\t\tattr_len = i_size;\n\t\t/*\n\t\t * If the truncate failed, fix it up now.  If a concurrent\n\t\t * truncate, we do its job, so it does not have to do anything.\n\t\t */\n\t\terr = ntfs_resident_attr_value_resize(ctx->mrec, ctx->attr,\n\t\t\t\tattr_len);\n\t\t/* Shrinking cannot fail. */\n\t\tBUG_ON(err);\n\t}\n\taddr = kmap_atomic(page);\n\t/* Copy the data from the page to the mft record. */\n\tmemcpy((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset),\n\t\t\taddr, attr_len);\n\t/* Zero out of bounds area in the page cache page. */\n\tmemset(addr + attr_len, 0, PAGE_CACHE_SIZE - attr_len);\n\tkunmap_atomic(addr);\n\tflush_dcache_page(page);\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t/* We are done with the page. */\n\tend_page_writeback(page);\n\t/* Finally, mark the mft record dirty, so it gets written back. */\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\treturn 0;\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Error allocating memory. Redirtying \"\n\t\t\t\t\"page so we try again later.\");\n\t\t/*\n\t\t * Put the page back on mapping->dirty_pages, but leave its\n\t\t * buffers' dirty state as-is.\n\t\t */\n\t\tredirty_page_for_writepage(wbc, page);\n\t\terr = 0;\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Resident attribute write failed with \"\n\t\t\t\t\"error %i.\", err);\n\t\tSetPageError(page);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\tunlock_page(page);\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_write_mst_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.c",
    "lines": "919-1328",
    "snippet": "static int ntfs_write_mst_block(struct page *page,\n\t\tstruct writeback_control *wbc)\n{\n\tsector_t block, dblock, rec_block;\n\tstruct inode *vi = page->mapping->host;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_volume *vol = ni->vol;\n\tu8 *kaddr;\n\tunsigned int rec_size = ni->itype.index.block_size;\n\tntfs_inode *locked_nis[PAGE_CACHE_SIZE / rec_size];\n\tstruct buffer_head *bh, *head, *tbh, *rec_start_bh;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\trunlist_element *rl;\n\tint i, nr_locked_nis, nr_recs, nr_bhs, max_bhs, bhs_per_rec, err, err2;\n\tunsigned bh_size, rec_size_bits;\n\tbool sync, is_mft, page_is_dirty, rec_is_dirty;\n\tunsigned char bh_size_bits;\n\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, page index \"\n\t\t\t\"0x%lx.\", vi->i_ino, ni->type, page->index);\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(!NInoMstProtected(ni));\n\tis_mft = (S_ISREG(vi->i_mode) && !vi->i_ino);\n\t/*\n\t * NOTE: ntfs_write_mst_block() would be called for $MFTMirr if a page\n\t * in its page cache were to be marked dirty.  However this should\n\t * never happen with the current driver and considering we do not\n\t * handle this case here we do want to BUG(), at least for now.\n\t */\n\tBUG_ON(!(is_mft || S_ISDIR(vi->i_mode) ||\n\t\t\t(NInoAttr(ni) && ni->type == AT_INDEX_ALLOCATION)));\n\tbh_size = vol->sb->s_blocksize;\n\tbh_size_bits = vol->sb->s_blocksize_bits;\n\tmax_bhs = PAGE_CACHE_SIZE / bh_size;\n\tBUG_ON(!max_bhs);\n\tBUG_ON(max_bhs > MAX_BUF_PER_PAGE);\n\n\t/* Were we called for sync purposes? */\n\tsync = (wbc->sync_mode == WB_SYNC_ALL);\n\n\t/* Make sure we have mapped buffers. */\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\n\trec_size_bits = ni->itype.index.block_size_bits;\n\tBUG_ON(!(PAGE_CACHE_SIZE >> rec_size_bits));\n\tbhs_per_rec = rec_size >> bh_size_bits;\n\tBUG_ON(!bhs_per_rec);\n\n\t/* The first block in the page. */\n\trec_block = block = (sector_t)page->index <<\n\t\t\t(PAGE_CACHE_SHIFT - bh_size_bits);\n\n\t/* The first out of bounds block for the data size. */\n\tdblock = (i_size_read(vi) + bh_size - 1) >> bh_size_bits;\n\n\trl = NULL;\n\terr = err2 = nr_bhs = nr_recs = nr_locked_nis = 0;\n\tpage_is_dirty = rec_is_dirty = false;\n\trec_start_bh = NULL;\n\tdo {\n\t\tbool is_retry = false;\n\n\t\tif (likely(block < rec_block)) {\n\t\t\tif (unlikely(block >= dblock)) {\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * This block is not the first one in the record.  We\n\t\t\t * ignore the buffer's dirty state because we could\n\t\t\t * have raced with a parallel mark_ntfs_record_dirty().\n\t\t\t */\n\t\t\tif (!rec_is_dirty)\n\t\t\t\tcontinue;\n\t\t\tif (unlikely(err2)) {\n\t\t\t\tif (err2 != -ENOMEM)\n\t\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else /* if (block == rec_block) */ {\n\t\t\tBUG_ON(block > rec_block);\n\t\t\t/* This block is the first one in the record. */\n\t\t\trec_block += bhs_per_rec;\n\t\t\terr2 = 0;\n\t\t\tif (unlikely(block >= dblock)) {\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\t/* Clean records are not written out. */\n\t\t\t\trec_is_dirty = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trec_is_dirty = true;\n\t\t\trec_start_bh = bh;\n\t\t}\n\t\t/* Need to map the buffer if it is not mapped already. */\n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t/* Obtain the vcn and offset of the current block. */\n\t\t\tvcn = (VCN)block << bh_size_bits;\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\nlock_retry_remap:\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\trl = ni->runlist.rl;\n\t\t\t}\n\t\t\tif (likely(rl != NULL)) {\n\t\t\t\t/* Seek to element containing target vcn. */\n\t\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\t\trl++;\n\t\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t} else\n\t\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t\t/* Successful remap. */\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> bh_size_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Remap failed.  Retry to map the runlist once\n\t\t\t\t * unless we are working on $MFT which always\n\t\t\t\t * has the whole of its runlist in memory.\n\t\t\t\t */\n\t\t\t\tif (!is_mft && !is_retry &&\n\t\t\t\t\t\tlcn == LCN_RL_NOT_MAPPED) {\n\t\t\t\t\tis_retry = true;\n\t\t\t\t\t/*\n\t\t\t\t\t * Attempt to map runlist, dropping\n\t\t\t\t\t * lock for the duration.\n\t\t\t\t\t */\n\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t\terr2 = ntfs_map_runlist(ni, vcn);\n\t\t\t\t\tif (likely(!err2))\n\t\t\t\t\t\tgoto lock_retry_remap;\n\t\t\t\t\tif (err2 == -ENOMEM)\n\t\t\t\t\t\tpage_is_dirty = true;\n\t\t\t\t\tlcn = err2;\n\t\t\t\t} else {\n\t\t\t\t\terr2 = -EIO;\n\t\t\t\t\tif (!rl)\n\t\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t}\n\t\t\t\t/* Hard error.  Abort writing this record. */\n\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\terr = err2;\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write ntfs record \"\n\t\t\t\t\t\t\"0x%llx (inode 0x%lx, \"\n\t\t\t\t\t\t\"attribute type 0x%x) because \"\n\t\t\t\t\t\t\"its location on disk could \"\n\t\t\t\t\t\t\"not be determined (error \"\n\t\t\t\t\t\t\"code %lli).\",\n\t\t\t\t\t\t(long long)block <<\n\t\t\t\t\t\tbh_size_bits >>\n\t\t\t\t\t\tvol->mft_record_size_bits,\n\t\t\t\t\t\tni->mft_no, ni->type,\n\t\t\t\t\t\t(long long)lcn);\n\t\t\t\t/*\n\t\t\t\t * If this is not the first buffer, remove the\n\t\t\t\t * buffers in this record from the list of\n\t\t\t\t * buffers to write and clear their dirty bit\n\t\t\t\t * if not error -ENOMEM.\n\t\t\t\t */\n\t\t\t\tif (rec_start_bh != bh) {\n\t\t\t\t\twhile (bhs[--nr_bhs] != rec_start_bh)\n\t\t\t\t\t\t;\n\t\t\t\t\tif (err2 != -ENOMEM) {\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tclear_buffer_dirty(\n\t\t\t\t\t\t\t\trec_start_bh);\n\t\t\t\t\t\t} while ((rec_start_bh =\n\t\t\t\t\t\t\t\trec_start_bh->\n\t\t\t\t\t\t\t\tb_this_page) !=\n\t\t\t\t\t\t\t\tbh);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t} while (block++, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&ni->runlist.lock);\n\t/* If there were no dirty buffers, we are done. */\n\tif (!nr_bhs)\n\t\tgoto done;\n\t/* Map the page so we can access its contents. */\n\tkaddr = kmap(page);\n\t/* Clear the page uptodate flag whilst the mst fixups are applied. */\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tunsigned int ofs;\n\n\t\t/* Skip buffers which are not at the beginning of records. */\n\t\tif (i % bhs_per_rec)\n\t\t\tcontinue;\n\t\ttbh = bhs[i];\n\t\tofs = bh_offset(tbh);\n\t\tif (is_mft) {\n\t\t\tntfs_inode *tni;\n\t\t\tunsigned long mft_no;\n\n\t\t\t/* Get the mft record number. */\n\t\t\tmft_no = (((s64)page->index << PAGE_CACHE_SHIFT) + ofs)\n\t\t\t\t\t>> rec_size_bits;\n\t\t\t/* Check whether to write this mft record. */\n\t\t\ttni = NULL;\n\t\t\tif (!ntfs_may_write_mft_record(vol, mft_no,\n\t\t\t\t\t(MFT_RECORD*)(kaddr + ofs), &tni)) {\n\t\t\t\t/*\n\t\t\t\t * The record should not be written.  This\n\t\t\t\t * means we need to redirty the page before\n\t\t\t\t * returning.\n\t\t\t\t */\n\t\t\t\tpage_is_dirty = true;\n\t\t\t\t/*\n\t\t\t\t * Remove the buffers in this mft record from\n\t\t\t\t * the list of buffers to write.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t} while (++i % bhs_per_rec);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * The record should be written.  If a locked ntfs\n\t\t\t * inode was returned, add it to the array of locked\n\t\t\t * ntfs inodes.\n\t\t\t */\n\t\t\tif (tni)\n\t\t\t\tlocked_nis[nr_locked_nis++] = tni;\n\t\t}\n\t\t/* Apply the mst protection fixups. */\n\t\terr2 = pre_write_mst_fixup((NTFS_RECORD*)(kaddr + ofs),\n\t\t\t\trec_size);\n\t\tif (unlikely(err2)) {\n\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\tntfs_error(vol->sb, \"Failed to apply mst fixups \"\n\t\t\t\t\t\"(inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"page index 0x%lx, page offset 0x%x)!\"\n\t\t\t\t\t\"  Unmount and run chkdsk.\", vi->i_ino,\n\t\t\t\t\tni->type, page->index, ofs);\n\t\t\t/*\n\t\t\t * Mark all the buffers in this record clean as we do\n\t\t\t * not want to write corrupt data to disk.\n\t\t\t */\n\t\t\tdo {\n\t\t\t\tclear_buffer_dirty(bhs[i]);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t} while (++i % bhs_per_rec);\n\t\t\tcontinue;\n\t\t}\n\t\tnr_recs++;\n\t}\n\t/* If no records are to be written out, we are done. */\n\tif (!nr_recs)\n\t\tgoto unm_done;\n\tflush_dcache_page(page);\n\t/* Lock buffers and start synchronous write i/o on them. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\ttbh = bhs[i];\n\t\tif (!tbh)\n\t\t\tcontinue;\n\t\tif (!trylock_buffer(tbh))\n\t\t\tBUG();\n\t\t/* The buffer dirty state is now irrelevant, just clean it. */\n\t\tclear_buffer_dirty(tbh);\n\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\tBUG_ON(!buffer_mapped(tbh));\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\tsubmit_bh(WRITE, tbh);\n\t}\n\t/* Synchronize the mft mirror now if not @sync. */\n\tif (is_mft && !sync)\n\t\tgoto do_mirror;\ndo_wait:\n\t/* Wait on i/o completion of buffers. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\ttbh = bhs[i];\n\t\tif (!tbh)\n\t\t\tcontinue;\n\t\twait_on_buffer(tbh);\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\tntfs_error(vol->sb, \"I/O error while writing ntfs \"\n\t\t\t\t\t\"record buffer (inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, page index \"\n\t\t\t\t\t\"0x%lx, page offset 0x%lx)!  Unmount \"\n\t\t\t\t\t\"and run chkdsk.\", vi->i_ino, ni->type,\n\t\t\t\t\tpage->index, bh_offset(tbh));\n\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\t/*\n\t\t\t * Set the buffer uptodate so the page and buffer\n\t\t\t * states do not become out of sync.\n\t\t\t */\n\t\t\tset_buffer_uptodate(tbh);\n\t\t}\n\t}\n\t/* If @sync, now synchronize the mft mirror. */\n\tif (is_mft && sync) {\ndo_mirror:\n\t\tfor (i = 0; i < nr_bhs; i++) {\n\t\t\tunsigned long mft_no;\n\t\t\tunsigned int ofs;\n\n\t\t\t/*\n\t\t\t * Skip buffers which are not at the beginning of\n\t\t\t * records.\n\t\t\t */\n\t\t\tif (i % bhs_per_rec)\n\t\t\t\tcontinue;\n\t\t\ttbh = bhs[i];\n\t\t\t/* Skip removed buffers (and hence records). */\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\tofs = bh_offset(tbh);\n\t\t\t/* Get the mft record number. */\n\t\t\tmft_no = (((s64)page->index << PAGE_CACHE_SHIFT) + ofs)\n\t\t\t\t\t>> rec_size_bits;\n\t\t\tif (mft_no < vol->mftmirr_size)\n\t\t\t\tntfs_sync_mft_mirror(vol, mft_no,\n\t\t\t\t\t\t(MFT_RECORD*)(kaddr + ofs),\n\t\t\t\t\t\tsync);\n\t\t}\n\t\tif (!sync)\n\t\t\tgoto do_wait;\n\t}\n\t/* Remove the mst protection fixups again. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tif (!(i % bhs_per_rec)) {\n\t\t\ttbh = bhs[i];\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\tpost_write_mst_fixup((NTFS_RECORD*)(kaddr +\n\t\t\t\t\tbh_offset(tbh)));\n\t\t}\n\t}\n\tflush_dcache_page(page);\nunm_done:\n\t/* Unlock any locked inodes. */\n\twhile (nr_locked_nis-- > 0) {\n\t\tntfs_inode *tni, *base_tni;\n\t\t\n\t\ttni = locked_nis[nr_locked_nis];\n\t\t/* Get the base inode. */\n\t\tmutex_lock(&tni->extent_lock);\n\t\tif (tni->nr_extents >= 0)\n\t\t\tbase_tni = tni;\n\t\telse {\n\t\t\tbase_tni = tni->ext.base_ntfs_ino;\n\t\t\tBUG_ON(!base_tni);\n\t\t}\n\t\tmutex_unlock(&tni->extent_lock);\n\t\tntfs_debug(\"Unlocking %s inode 0x%lx.\",\n\t\t\t\ttni == base_tni ? \"base\" : \"extent\",\n\t\t\t\ttni->mft_no);\n\t\tmutex_unlock(&tni->mrec_lock);\n\t\tatomic_dec(&tni->count);\n\t\tiput(VFS_I(base_tni));\n\t}\n\tSetPageUptodate(page);\n\tkunmap(page);\ndone:\n\tif (unlikely(err && err != -ENOMEM)) {\n\t\t/*\n\t\t * Set page error if there is only one ntfs record in the page.\n\t\t * Otherwise we would loose per-record granularity.\n\t\t */\n\t\tif (ni->itype.index.block_size == PAGE_CACHE_SIZE)\n\t\t\tSetPageError(page);\n\t\tNVolSetErrors(vol);\n\t}\n\tif (page_is_dirty) {\n\t\tntfs_debug(\"Page still contains one or more dirty ntfs \"\n\t\t\t\t\"records.  Redirtying the page starting at \"\n\t\t\t\t\"record 0x%lx.\", page->index <<\n\t\t\t\t(PAGE_CACHE_SHIFT - rec_size_bits));\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tunlock_page(page);\n\t} else {\n\t\t/*\n\t\t * Keep the VM happy.  This must be done otherwise the\n\t\t * radix-tree tag PAGECACHE_TAG_DIRTY remains set even though\n\t\t * the page is clean.\n\t\t */\n\t\tBUG_ON(PageWriteback(page));\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t\tend_page_writeback(page);\n\t}\n\tif (likely(!err))\n\t\tntfs_debug(\"Done.\");\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"types.h\"",
      "#include \"runlist.h\"",
      "#include \"mft.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Page still contains one or more dirty ntfs \"\n\t\t\t\t\"records.  Redirtying the page starting at \"\n\t\t\t\t\"record 0x%lx.\"",
            "page->index <<\n\t\t\t\t(PAGE_CACHE_SHIFT - rec_size_bits)"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err && err != -ENOMEM"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "VFS_I(base_tni)"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "base_tni"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "245-248",
          "snippet": "static inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&tni->count"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tni->mrec_lock"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Unlocking %s inode 0x%lx.\"",
            "tni == base_tni ? \"base\" : \"extent\"",
            "tni->mft_no"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tni->extent_lock"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!base_tni"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tni->extent_lock"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "post_write_mst_fixup",
          "args": [
            "(NTFS_RECORD*)(kaddr +\n\t\t\t\t\tbh_offset(tbh))"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "post_write_mst_fixup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mst.c",
          "lines": "179-203",
          "snippet": "void post_write_mst_fixup(NTFS_RECORD *b)\n{\n\tle16 *usa_pos, *data_pos;\n\n\tu16 usa_ofs = le16_to_cpu(b->usa_ofs);\n\tu16 usa_count = le16_to_cpu(b->usa_count) - 1;\n\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (le16*)b + usa_ofs/sizeof(le16);\n\n\t/* Position in protected data of first u16 that needs fixing up. */\n\tdata_pos = (le16*)b + NTFS_BLOCK_SIZE/sizeof(le16) - 1;\n\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment position in usa and restore original data from\n\t\t * the usa into the data buffer.\n\t\t */\n\t\t*data_pos = *(++usa_pos);\n\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(le16);\n\t}\n}",
          "includes": [
            "#include \"ntfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n\nvoid post_write_mst_fixup(NTFS_RECORD *b)\n{\n\tle16 *usa_pos, *data_pos;\n\n\tu16 usa_ofs = le16_to_cpu(b->usa_ofs);\n\tu16 usa_count = le16_to_cpu(b->usa_count) - 1;\n\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (le16*)b + usa_ofs/sizeof(le16);\n\n\t/* Position in protected data of first u16 that needs fixing up. */\n\tdata_pos = (le16*)b + NTFS_BLOCK_SIZE/sizeof(le16) - 1;\n\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment position in usa and restore original data from\n\t\t * the usa into the data buffer.\n\t\t */\n\t\t*data_pos = *(++usa_pos);\n\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(le16);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "tbh"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_sync_mft_mirror",
          "args": [
            "vol",
            "mft_no",
            "(MFT_RECORD*)(kaddr + ofs)",
            "sync"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_sync_mft_mirror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "465-636",
          "snippet": "int ntfs_sync_mft_mirror(ntfs_volume *vol, const unsigned long mft_no,\n\t\tMFT_RECORD *m, int sync)\n{\n\tstruct page *page;\n\tunsigned int blocksize = vol->sb->s_blocksize;\n\tint max_bhs = vol->mft_record_size / blocksize;\n\tstruct buffer_head *bhs[max_bhs];\n\tstruct buffer_head *bh, *head;\n\tu8 *kmirr;\n\trunlist_element *rl;\n\tunsigned int block_start, block_end, m_start, m_end, page_ofs;\n\tint i_bhs, nr_bhs, err = 0;\n\tunsigned char blocksize_bits = vol->sb->s_blocksize_bits;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", mft_no);\n\tBUG_ON(!max_bhs);\n\tif (unlikely(!vol->mftmirr_ino)) {\n\t\t/* This could happen during umount... */\n\t\terr = ntfs_sync_mft_mirror_umount(vol, mft_no, m);\n\t\tif (likely(!err))\n\t\t\treturn err;\n\t\tgoto err_out;\n\t}\n\t/* Get the page containing the mirror copy of the mft record @m. */\n\tpage = ntfs_map_page(vol->mftmirr_ino->i_mapping, mft_no >>\n\t\t\t(PAGE_CACHE_SHIFT - vol->mft_record_size_bits));\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft mirror page.\");\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\t/* Offset of the mft mirror record inside the page. */\n\tpage_ofs = (mft_no << vol->mft_record_size_bits) & ~PAGE_CACHE_MASK;\n\t/* The address in the page of the mirror copy of the mft record @m. */\n\tkmirr = page_address(page) + page_ofs;\n\t/* Copy the mst protected mft record to the mirror. */\n\tmemcpy(kmirr, m, vol->mft_record_size);\n\t/* Create uptodate buffers if not present. */\n\tif (unlikely(!page_has_buffers(page))) {\n\t\tstruct buffer_head *tail;\n\n\t\tbh = head = alloc_page_buffers(page, blocksize, 1);\n\t\tdo {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\ttail = bh;\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh);\n\t\ttail->b_this_page = head;\n\t\tattach_page_buffers(page, head);\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\trl = NULL;\n\tnr_bhs = 0;\n\tblock_start = 0;\n\tm_start = kmirr - (u8*)page_address(page);\n\tm_end = m_start + vol->mft_record_size;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\t/* If the buffer is outside the mft record, skip it. */\n\t\tif (block_end <= m_start)\n\t\t\tcontinue;\n\t\tif (unlikely(block_start >= m_end))\n\t\t\tbreak;\n\t\t/* Need to map the buffer if it is not mapped already. */\n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t/* Obtain the vcn and offset of the current block. */\n\t\t\tvcn = ((VCN)mft_no << vol->mft_record_size_bits) +\n\t\t\t\t\t(block_start - m_start);\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\n\t\t\t\tdown_read(&NTFS_I(vol->mftmirr_ino)->\n\t\t\t\t\t\trunlist.lock);\n\t\t\t\trl = NTFS_I(vol->mftmirr_ino)->runlist.rl;\n\t\t\t\t/*\n\t\t\t\t * $MFTMirr always has the whole of its runlist\n\t\t\t\t * in memory.\n\t\t\t\t */\n\t\t\t\tBUG_ON(!rl);\n\t\t\t}\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t/* For $MFTMirr, only lcn >= 0 is a successful remap. */\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write mft mirror \"\n\t\t\t\t\t\t\"record 0x%lx because its \"\n\t\t\t\t\t\t\"location on disk could not \"\n\t\t\t\t\t\t\"be determined (error code \"\n\t\t\t\t\t\t\"%lli).\", mft_no,\n\t\t\t\t\t\t(long long)lcn);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(!nr_bhs && (m_start != block_start));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t\tBUG_ON((nr_bhs >= max_bhs) && (m_end != block_end));\n\t} while (block_start = block_end, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&NTFS_I(vol->mftmirr_ino)->runlist.lock);\n\tif (likely(!err)) {\n\t\t/* Lock buffers and start synchronous write i/o on them. */\n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\t\tif (!trylock_buffer(tbh))\n\t\t\t\tBUG();\n\t\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\t\tclear_buffer_dirty(tbh);\n\t\t\tget_bh(tbh);\n\t\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\t\tsubmit_bh(WRITE, tbh);\n\t\t}\n\t\t/* Wait on i/o completion of buffers. */\n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\t\twait_on_buffer(tbh);\n\t\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\t\terr = -EIO;\n\t\t\t\t/*\n\t\t\t\t * Set the buffer uptodate so the page and\n\t\t\t\t * buffer states do not become out of sync.\n\t\t\t\t */\n\t\t\t\tset_buffer_uptodate(tbh);\n\t\t\t}\n\t\t}\n\t} else /* if (unlikely(err)) */ {\n\t\t/* Clean the buffers. */\n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++)\n\t\t\tclear_buffer_dirty(bhs[i_bhs]);\n\t}\n\t/* Current state: all buffers are clean, unlocked, and uptodate. */\n\t/* Remove the mst protection fixups again. */\n\tpost_write_mst_fixup((NTFS_RECORD*)kmirr);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\tntfs_unmap_page(page);\n\tif (likely(!err)) {\n\t\tntfs_debug(\"Done.\");\n\t} else {\n\t\tntfs_error(vol->sb, \"I/O error while writing mft mirror \"\n\t\t\t\t\"record 0x%lx!\", mft_no);\nerr_out:\n\t\tntfs_error(vol->sb, \"Failed to synchronize $MFTMirr (error \"\n\t\t\t\t\"code %i).  Volume will be left marked dirty \"\n\t\t\t\t\"on umount.  Run ntfsfix on the partition \"\n\t\t\t\t\"after umounting to correct this.\", -err);\n\t\tNVolSetErrors(vol);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nint ntfs_sync_mft_mirror(ntfs_volume *vol, const unsigned long mft_no,\n\t\tMFT_RECORD *m, int sync)\n{\n\tstruct page *page;\n\tunsigned int blocksize = vol->sb->s_blocksize;\n\tint max_bhs = vol->mft_record_size / blocksize;\n\tstruct buffer_head *bhs[max_bhs];\n\tstruct buffer_head *bh, *head;\n\tu8 *kmirr;\n\trunlist_element *rl;\n\tunsigned int block_start, block_end, m_start, m_end, page_ofs;\n\tint i_bhs, nr_bhs, err = 0;\n\tunsigned char blocksize_bits = vol->sb->s_blocksize_bits;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", mft_no);\n\tBUG_ON(!max_bhs);\n\tif (unlikely(!vol->mftmirr_ino)) {\n\t\t/* This could happen during umount... */\n\t\terr = ntfs_sync_mft_mirror_umount(vol, mft_no, m);\n\t\tif (likely(!err))\n\t\t\treturn err;\n\t\tgoto err_out;\n\t}\n\t/* Get the page containing the mirror copy of the mft record @m. */\n\tpage = ntfs_map_page(vol->mftmirr_ino->i_mapping, mft_no >>\n\t\t\t(PAGE_CACHE_SHIFT - vol->mft_record_size_bits));\n\tif (IS_ERR(page)) {\n\t\tntfs_error(vol->sb, \"Failed to map mft mirror page.\");\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\t/* Offset of the mft mirror record inside the page. */\n\tpage_ofs = (mft_no << vol->mft_record_size_bits) & ~PAGE_CACHE_MASK;\n\t/* The address in the page of the mirror copy of the mft record @m. */\n\tkmirr = page_address(page) + page_ofs;\n\t/* Copy the mst protected mft record to the mirror. */\n\tmemcpy(kmirr, m, vol->mft_record_size);\n\t/* Create uptodate buffers if not present. */\n\tif (unlikely(!page_has_buffers(page))) {\n\t\tstruct buffer_head *tail;\n\n\t\tbh = head = alloc_page_buffers(page, blocksize, 1);\n\t\tdo {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\ttail = bh;\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh);\n\t\ttail->b_this_page = head;\n\t\tattach_page_buffers(page, head);\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\trl = NULL;\n\tnr_bhs = 0;\n\tblock_start = 0;\n\tm_start = kmirr - (u8*)page_address(page);\n\tm_end = m_start + vol->mft_record_size;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\t/* If the buffer is outside the mft record, skip it. */\n\t\tif (block_end <= m_start)\n\t\t\tcontinue;\n\t\tif (unlikely(block_start >= m_end))\n\t\t\tbreak;\n\t\t/* Need to map the buffer if it is not mapped already. */\n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t/* Obtain the vcn and offset of the current block. */\n\t\t\tvcn = ((VCN)mft_no << vol->mft_record_size_bits) +\n\t\t\t\t\t(block_start - m_start);\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\n\t\t\t\tdown_read(&NTFS_I(vol->mftmirr_ino)->\n\t\t\t\t\t\trunlist.lock);\n\t\t\t\trl = NTFS_I(vol->mftmirr_ino)->runlist.rl;\n\t\t\t\t/*\n\t\t\t\t * $MFTMirr always has the whole of its runlist\n\t\t\t\t * in memory.\n\t\t\t\t */\n\t\t\t\tBUG_ON(!rl);\n\t\t\t}\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t/* For $MFTMirr, only lcn >= 0 is a successful remap. */\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write mft mirror \"\n\t\t\t\t\t\t\"record 0x%lx because its \"\n\t\t\t\t\t\t\"location on disk could not \"\n\t\t\t\t\t\t\"be determined (error code \"\n\t\t\t\t\t\t\"%lli).\", mft_no,\n\t\t\t\t\t\t(long long)lcn);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(!nr_bhs && (m_start != block_start));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t\tBUG_ON((nr_bhs >= max_bhs) && (m_end != block_end));\n\t} while (block_start = block_end, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&NTFS_I(vol->mftmirr_ino)->runlist.lock);\n\tif (likely(!err)) {\n\t\t/* Lock buffers and start synchronous write i/o on them. */\n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\t\tif (!trylock_buffer(tbh))\n\t\t\t\tBUG();\n\t\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\t\tclear_buffer_dirty(tbh);\n\t\t\tget_bh(tbh);\n\t\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\t\tsubmit_bh(WRITE, tbh);\n\t\t}\n\t\t/* Wait on i/o completion of buffers. */\n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\t\twait_on_buffer(tbh);\n\t\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\t\terr = -EIO;\n\t\t\t\t/*\n\t\t\t\t * Set the buffer uptodate so the page and\n\t\t\t\t * buffer states do not become out of sync.\n\t\t\t\t */\n\t\t\t\tset_buffer_uptodate(tbh);\n\t\t\t}\n\t\t}\n\t} else /* if (unlikely(err)) */ {\n\t\t/* Clean the buffers. */\n\t\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++)\n\t\t\tclear_buffer_dirty(bhs[i_bhs]);\n\t}\n\t/* Current state: all buffers are clean, unlocked, and uptodate. */\n\t/* Remove the mst protection fixups again. */\n\tpost_write_mst_fixup((NTFS_RECORD*)kmirr);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\tntfs_unmap_page(page);\n\tif (likely(!err)) {\n\t\tntfs_debug(\"Done.\");\n\t} else {\n\t\tntfs_error(vol->sb, \"I/O error while writing mft mirror \"\n\t\t\t\t\"record 0x%lx!\", mft_no);\nerr_out:\n\t\tntfs_error(vol->sb, \"Failed to synchronize $MFTMirr (error \"\n\t\t\t\t\"code %i).  Volume will be left marked dirty \"\n\t\t\t\t\"on umount.  Run ntfsfix on the partition \"\n\t\t\t\t\"after umounting to correct this.\", -err);\n\t\tNVolSetErrors(vol);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "tbh"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "tbh"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"I/O error while writing ntfs \"\n\t\t\t\t\t\"record buffer (inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, page index \"\n\t\t\t\t\t\"0x%lx, page offset 0x%lx)!  Unmount \"\n\t\t\t\t\t\"and run chkdsk.\"",
            "vi->i_ino",
            "ni->type",
            "page->index",
            "bh_offset(tbh)"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "tbh"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(tbh)"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "tbh"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "WRITE",
            "tbh"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "tbh"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_mapped(tbh)"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "tbh"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(tbh)"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "tbh"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_buffer",
          "args": [
            "tbh"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bhs[i]"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err2"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pre_write_mst_fixup",
          "args": [
            "(NTFS_RECORD*)(kaddr + ofs)",
            "rec_size"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "pre_write_mst_fixup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mst.c",
          "lines": "123-169",
          "snippet": "int pre_write_mst_fixup(NTFS_RECORD *b, const u32 size)\n{\n\tle16 *usa_pos, *data_pos;\n\tu16 usa_ofs, usa_count, usn;\n\tle16 le_usn;\n\n\t/* Sanity check + only fixup if it makes sense. */\n\tif (!b || ntfs_is_baad_record(b->magic) ||\n\t\t\tntfs_is_hole_record(b->magic))\n\t\treturn -EINVAL;\n\t/* Setup the variables. */\n\tusa_ofs = le16_to_cpu(b->usa_ofs);\n\t/* Decrement usa_count to get number of fixups. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\t/* Size and alignment checks. */\n\tif ( size & (NTFS_BLOCK_SIZE - 1)\t||\n\t     usa_ofs & 1\t\t\t||\n\t     usa_ofs + (usa_count * 2) > size\t||\n\t     (size >> NTFS_BLOCK_SIZE_BITS) != usa_count)\n\t\treturn -EINVAL;\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (le16*)((u8*)b + usa_ofs);\n\t/*\n\t * Cyclically increment the update sequence number\n\t * (skipping 0 and -1, i.e. 0xffff).\n\t */\n\tusn = le16_to_cpup(usa_pos) + 1;\n\tif (usn == 0xffff || !usn)\n\t\tusn = 1;\n\tle_usn = cpu_to_le16(usn);\n\t*usa_pos = le_usn;\n\t/* Position in data of first u16 that needs fixing up. */\n\tdata_pos = (le16*)b + NTFS_BLOCK_SIZE/sizeof(le16) - 1;\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment the position in the usa and save the\n\t\t * original data from the data buffer into the usa.\n\t\t */\n\t\t*(++usa_pos) = *data_pos;\n\t\t/* Apply fixup to data. */\n\t\t*data_pos = le_usn;\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(le16);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ntfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n\nint pre_write_mst_fixup(NTFS_RECORD *b, const u32 size)\n{\n\tle16 *usa_pos, *data_pos;\n\tu16 usa_ofs, usa_count, usn;\n\tle16 le_usn;\n\n\t/* Sanity check + only fixup if it makes sense. */\n\tif (!b || ntfs_is_baad_record(b->magic) ||\n\t\t\tntfs_is_hole_record(b->magic))\n\t\treturn -EINVAL;\n\t/* Setup the variables. */\n\tusa_ofs = le16_to_cpu(b->usa_ofs);\n\t/* Decrement usa_count to get number of fixups. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\t/* Size and alignment checks. */\n\tif ( size & (NTFS_BLOCK_SIZE - 1)\t||\n\t     usa_ofs & 1\t\t\t||\n\t     usa_ofs + (usa_count * 2) > size\t||\n\t     (size >> NTFS_BLOCK_SIZE_BITS) != usa_count)\n\t\treturn -EINVAL;\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (le16*)((u8*)b + usa_ofs);\n\t/*\n\t * Cyclically increment the update sequence number\n\t * (skipping 0 and -1, i.e. 0xffff).\n\t */\n\tusn = le16_to_cpup(usa_pos) + 1;\n\tif (usn == 0xffff || !usn)\n\t\tusn = 1;\n\tle_usn = cpu_to_le16(usn);\n\t*usa_pos = le_usn;\n\t/* Position in data of first u16 that needs fixing up. */\n\tdata_pos = (le16*)b + NTFS_BLOCK_SIZE/sizeof(le16) - 1;\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment the position in the usa and save the\n\t\t * original data from the data buffer into the usa.\n\t\t */\n\t\t*(++usa_pos) = *data_pos;\n\t\t/* Apply fixup to data. */\n\t\t*data_pos = le_usn;\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(le16);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_may_write_mft_record",
          "args": [
            "vol",
            "mft_no",
            "(MFT_RECORD*)(kaddr + ofs)",
            "&tni"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_may_write_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "925-1107",
          "snippet": "bool ntfs_may_write_mft_record(ntfs_volume *vol, const unsigned long mft_no,\n\t\tconst MFT_RECORD *m, ntfs_inode **locked_ni)\n{\n\tstruct super_block *sb = vol->sb;\n\tstruct inode *mft_vi = vol->mft_ino;\n\tstruct inode *vi;\n\tntfs_inode *ni, *eni, **extent_nis;\n\tint i;\n\tntfs_attr na;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", mft_no);\n\t/*\n\t * Normally we do not return a locked inode so set @locked_ni to NULL.\n\t */\n\tBUG_ON(!locked_ni);\n\t*locked_ni = NULL;\n\t/*\n\t * Check if the inode corresponding to this mft record is in the VFS\n\t * inode cache and obtain a reference to it if it is.\n\t */\n\tntfs_debug(\"Looking for inode 0x%lx in icache.\", mft_no);\n\tna.mft_no = mft_no;\n\tna.name = NULL;\n\tna.name_len = 0;\n\tna.type = AT_UNUSED;\n\t/*\n\t * Optimize inode 0, i.e. $MFT itself, since we have it in memory and\n\t * we get here for it rather often.\n\t */\n\tif (!mft_no) {\n\t\t/* Balance the below iput(). */\n\t\tvi = igrab(mft_vi);\n\t\tBUG_ON(vi != mft_vi);\n\t} else {\n\t\t/*\n\t\t * Have to use ilookup5_nowait() since ilookup5() waits for the\n\t\t * inode lock which causes ntfs to deadlock when a concurrent\n\t\t * inode write via the inode dirty code paths and the page\n\t\t * dirty code path of the inode dirty code path when writing\n\t\t * $MFT occurs.\n\t\t */\n\t\tvi = ilookup5_nowait(sb, mft_no, (test_t)ntfs_test_inode, &na);\n\t}\n\tif (vi) {\n\t\tntfs_debug(\"Base inode 0x%lx is in icache.\", mft_no);\n\t\t/* The inode is in icache. */\n\t\tni = NTFS_I(vi);\n\t\t/* Take a reference to the ntfs inode. */\n\t\tatomic_inc(&ni->count);\n\t\t/* If the inode is dirty, do not write this record. */\n\t\tif (NInoDirty(ni)) {\n\t\t\tntfs_debug(\"Inode 0x%lx is dirty, do not write it.\",\n\t\t\t\t\tmft_no);\n\t\t\tatomic_dec(&ni->count);\n\t\t\tiput(vi);\n\t\t\treturn false;\n\t\t}\n\t\tntfs_debug(\"Inode 0x%lx is not dirty.\", mft_no);\n\t\t/* The inode is not dirty, try to take the mft record lock. */\n\t\tif (unlikely(!mutex_trylock(&ni->mrec_lock))) {\n\t\t\tntfs_debug(\"Mft record 0x%lx is already locked, do \"\n\t\t\t\t\t\"not write it.\", mft_no);\n\t\t\tatomic_dec(&ni->count);\n\t\t\tiput(vi);\n\t\t\treturn false;\n\t\t}\n\t\tntfs_debug(\"Managed to lock mft record 0x%lx, write it.\",\n\t\t\t\tmft_no);\n\t\t/*\n\t\t * The write has to occur while we hold the mft record lock so\n\t\t * return the locked ntfs inode.\n\t\t */\n\t\t*locked_ni = ni;\n\t\treturn true;\n\t}\n\tntfs_debug(\"Inode 0x%lx is not in icache.\", mft_no);\n\t/* The inode is not in icache. */\n\t/* Write the record if it is not a mft record (type \"FILE\"). */\n\tif (!ntfs_is_mft_record(m->magic)) {\n\t\tntfs_debug(\"Mft record 0x%lx is not a FILE record, write it.\",\n\t\t\t\tmft_no);\n\t\treturn true;\n\t}\n\t/* Write the mft record if it is a base inode. */\n\tif (!m->base_mft_record) {\n\t\tntfs_debug(\"Mft record 0x%lx is a base record, write it.\",\n\t\t\t\tmft_no);\n\t\treturn true;\n\t}\n\t/*\n\t * This is an extent mft record.  Check if the inode corresponding to\n\t * its base mft record is in icache and obtain a reference to it if it\n\t * is.\n\t */\n\tna.mft_no = MREF_LE(m->base_mft_record);\n\tntfs_debug(\"Mft record 0x%lx is an extent record.  Looking for base \"\n\t\t\t\"inode 0x%lx in icache.\", mft_no, na.mft_no);\n\tif (!na.mft_no) {\n\t\t/* Balance the below iput(). */\n\t\tvi = igrab(mft_vi);\n\t\tBUG_ON(vi != mft_vi);\n\t} else\n\t\tvi = ilookup5_nowait(sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t\t&na);\n\tif (!vi) {\n\t\t/*\n\t\t * The base inode is not in icache, write this extent mft\n\t\t * record.\n\t\t */\n\t\tntfs_debug(\"Base inode 0x%lx is not in icache, write the \"\n\t\t\t\t\"extent record.\", na.mft_no);\n\t\treturn true;\n\t}\n\tntfs_debug(\"Base inode 0x%lx is in icache.\", na.mft_no);\n\t/*\n\t * The base inode is in icache.  Check if it has the extent inode\n\t * corresponding to this extent mft record attached.\n\t */\n\tni = NTFS_I(vi);\n\tmutex_lock(&ni->extent_lock);\n\tif (ni->nr_extents <= 0) {\n\t\t/*\n\t\t * The base inode has no attached extent inodes, write this\n\t\t * extent mft record.\n\t\t */\n\t\tmutex_unlock(&ni->extent_lock);\n\t\tiput(vi);\n\t\tntfs_debug(\"Base inode 0x%lx has no attached extent inodes, \"\n\t\t\t\t\"write the extent record.\", na.mft_no);\n\t\treturn true;\n\t}\n\t/* Iterate over the attached extent inodes. */\n\textent_nis = ni->ext.extent_ntfs_inos;\n\tfor (eni = NULL, i = 0; i < ni->nr_extents; ++i) {\n\t\tif (mft_no == extent_nis[i]->mft_no) {\n\t\t\t/*\n\t\t\t * Found the extent inode corresponding to this extent\n\t\t\t * mft record.\n\t\t\t */\n\t\t\teni = extent_nis[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * If the extent inode was not attached to the base inode, write this\n\t * extent mft record.\n\t */\n\tif (!eni) {\n\t\tmutex_unlock(&ni->extent_lock);\n\t\tiput(vi);\n\t\tntfs_debug(\"Extent inode 0x%lx is not attached to its base \"\n\t\t\t\t\"inode 0x%lx, write the extent record.\",\n\t\t\t\tmft_no, na.mft_no);\n\t\treturn true;\n\t}\n\tntfs_debug(\"Extent inode 0x%lx is attached to its base inode 0x%lx.\",\n\t\t\tmft_no, na.mft_no);\n\t/* Take a reference to the extent ntfs inode. */\n\tatomic_inc(&eni->count);\n\tmutex_unlock(&ni->extent_lock);\n\t/*\n\t * Found the extent inode coresponding to this extent mft record.\n\t * Try to take the mft record lock.\n\t */\n\tif (unlikely(!mutex_trylock(&eni->mrec_lock))) {\n\t\tatomic_dec(&eni->count);\n\t\tiput(vi);\n\t\tntfs_debug(\"Extent mft record 0x%lx is already locked, do \"\n\t\t\t\t\"not write it.\", mft_no);\n\t\treturn false;\n\t}\n\tntfs_debug(\"Managed to lock extent mft record 0x%lx, write it.\",\n\t\t\tmft_no);\n\tif (NInoTestClearDirty(eni))\n\t\tntfs_debug(\"Extent inode 0x%lx is dirty, marking it clean.\",\n\t\t\t\tmft_no);\n\t/*\n\t * The write has to occur while we hold the mft record lock so return\n\t * the locked extent ntfs inode.\n\t */\n\t*locked_ni = eni;\n\treturn true;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nbool ntfs_may_write_mft_record(ntfs_volume *vol, const unsigned long mft_no,\n\t\tconst MFT_RECORD *m, ntfs_inode **locked_ni)\n{\n\tstruct super_block *sb = vol->sb;\n\tstruct inode *mft_vi = vol->mft_ino;\n\tstruct inode *vi;\n\tntfs_inode *ni, *eni, **extent_nis;\n\tint i;\n\tntfs_attr na;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", mft_no);\n\t/*\n\t * Normally we do not return a locked inode so set @locked_ni to NULL.\n\t */\n\tBUG_ON(!locked_ni);\n\t*locked_ni = NULL;\n\t/*\n\t * Check if the inode corresponding to this mft record is in the VFS\n\t * inode cache and obtain a reference to it if it is.\n\t */\n\tntfs_debug(\"Looking for inode 0x%lx in icache.\", mft_no);\n\tna.mft_no = mft_no;\n\tna.name = NULL;\n\tna.name_len = 0;\n\tna.type = AT_UNUSED;\n\t/*\n\t * Optimize inode 0, i.e. $MFT itself, since we have it in memory and\n\t * we get here for it rather often.\n\t */\n\tif (!mft_no) {\n\t\t/* Balance the below iput(). */\n\t\tvi = igrab(mft_vi);\n\t\tBUG_ON(vi != mft_vi);\n\t} else {\n\t\t/*\n\t\t * Have to use ilookup5_nowait() since ilookup5() waits for the\n\t\t * inode lock which causes ntfs to deadlock when a concurrent\n\t\t * inode write via the inode dirty code paths and the page\n\t\t * dirty code path of the inode dirty code path when writing\n\t\t * $MFT occurs.\n\t\t */\n\t\tvi = ilookup5_nowait(sb, mft_no, (test_t)ntfs_test_inode, &na);\n\t}\n\tif (vi) {\n\t\tntfs_debug(\"Base inode 0x%lx is in icache.\", mft_no);\n\t\t/* The inode is in icache. */\n\t\tni = NTFS_I(vi);\n\t\t/* Take a reference to the ntfs inode. */\n\t\tatomic_inc(&ni->count);\n\t\t/* If the inode is dirty, do not write this record. */\n\t\tif (NInoDirty(ni)) {\n\t\t\tntfs_debug(\"Inode 0x%lx is dirty, do not write it.\",\n\t\t\t\t\tmft_no);\n\t\t\tatomic_dec(&ni->count);\n\t\t\tiput(vi);\n\t\t\treturn false;\n\t\t}\n\t\tntfs_debug(\"Inode 0x%lx is not dirty.\", mft_no);\n\t\t/* The inode is not dirty, try to take the mft record lock. */\n\t\tif (unlikely(!mutex_trylock(&ni->mrec_lock))) {\n\t\t\tntfs_debug(\"Mft record 0x%lx is already locked, do \"\n\t\t\t\t\t\"not write it.\", mft_no);\n\t\t\tatomic_dec(&ni->count);\n\t\t\tiput(vi);\n\t\t\treturn false;\n\t\t}\n\t\tntfs_debug(\"Managed to lock mft record 0x%lx, write it.\",\n\t\t\t\tmft_no);\n\t\t/*\n\t\t * The write has to occur while we hold the mft record lock so\n\t\t * return the locked ntfs inode.\n\t\t */\n\t\t*locked_ni = ni;\n\t\treturn true;\n\t}\n\tntfs_debug(\"Inode 0x%lx is not in icache.\", mft_no);\n\t/* The inode is not in icache. */\n\t/* Write the record if it is not a mft record (type \"FILE\"). */\n\tif (!ntfs_is_mft_record(m->magic)) {\n\t\tntfs_debug(\"Mft record 0x%lx is not a FILE record, write it.\",\n\t\t\t\tmft_no);\n\t\treturn true;\n\t}\n\t/* Write the mft record if it is a base inode. */\n\tif (!m->base_mft_record) {\n\t\tntfs_debug(\"Mft record 0x%lx is a base record, write it.\",\n\t\t\t\tmft_no);\n\t\treturn true;\n\t}\n\t/*\n\t * This is an extent mft record.  Check if the inode corresponding to\n\t * its base mft record is in icache and obtain a reference to it if it\n\t * is.\n\t */\n\tna.mft_no = MREF_LE(m->base_mft_record);\n\tntfs_debug(\"Mft record 0x%lx is an extent record.  Looking for base \"\n\t\t\t\"inode 0x%lx in icache.\", mft_no, na.mft_no);\n\tif (!na.mft_no) {\n\t\t/* Balance the below iput(). */\n\t\tvi = igrab(mft_vi);\n\t\tBUG_ON(vi != mft_vi);\n\t} else\n\t\tvi = ilookup5_nowait(sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t\t&na);\n\tif (!vi) {\n\t\t/*\n\t\t * The base inode is not in icache, write this extent mft\n\t\t * record.\n\t\t */\n\t\tntfs_debug(\"Base inode 0x%lx is not in icache, write the \"\n\t\t\t\t\"extent record.\", na.mft_no);\n\t\treturn true;\n\t}\n\tntfs_debug(\"Base inode 0x%lx is in icache.\", na.mft_no);\n\t/*\n\t * The base inode is in icache.  Check if it has the extent inode\n\t * corresponding to this extent mft record attached.\n\t */\n\tni = NTFS_I(vi);\n\tmutex_lock(&ni->extent_lock);\n\tif (ni->nr_extents <= 0) {\n\t\t/*\n\t\t * The base inode has no attached extent inodes, write this\n\t\t * extent mft record.\n\t\t */\n\t\tmutex_unlock(&ni->extent_lock);\n\t\tiput(vi);\n\t\tntfs_debug(\"Base inode 0x%lx has no attached extent inodes, \"\n\t\t\t\t\"write the extent record.\", na.mft_no);\n\t\treturn true;\n\t}\n\t/* Iterate over the attached extent inodes. */\n\textent_nis = ni->ext.extent_ntfs_inos;\n\tfor (eni = NULL, i = 0; i < ni->nr_extents; ++i) {\n\t\tif (mft_no == extent_nis[i]->mft_no) {\n\t\t\t/*\n\t\t\t * Found the extent inode corresponding to this extent\n\t\t\t * mft record.\n\t\t\t */\n\t\t\teni = extent_nis[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * If the extent inode was not attached to the base inode, write this\n\t * extent mft record.\n\t */\n\tif (!eni) {\n\t\tmutex_unlock(&ni->extent_lock);\n\t\tiput(vi);\n\t\tntfs_debug(\"Extent inode 0x%lx is not attached to its base \"\n\t\t\t\t\"inode 0x%lx, write the extent record.\",\n\t\t\t\tmft_no, na.mft_no);\n\t\treturn true;\n\t}\n\tntfs_debug(\"Extent inode 0x%lx is attached to its base inode 0x%lx.\",\n\t\t\tmft_no, na.mft_no);\n\t/* Take a reference to the extent ntfs inode. */\n\tatomic_inc(&eni->count);\n\tmutex_unlock(&ni->extent_lock);\n\t/*\n\t * Found the extent inode coresponding to this extent mft record.\n\t * Try to take the mft record lock.\n\t */\n\tif (unlikely(!mutex_trylock(&eni->mrec_lock))) {\n\t\tatomic_dec(&eni->count);\n\t\tiput(vi);\n\t\tntfs_debug(\"Extent mft record 0x%lx is already locked, do \"\n\t\t\t\t\"not write it.\", mft_no);\n\t\treturn false;\n\t}\n\tntfs_debug(\"Managed to lock extent mft record 0x%lx, write it.\",\n\t\t\tmft_no);\n\tif (NInoTestClearDirty(eni))\n\t\tntfs_debug(\"Extent inode 0x%lx is dirty, marking it clean.\",\n\t\t\t\tmft_no);\n\t/*\n\t * The write has to occur while we hold the mft record lock so return\n\t * the locked extent ntfs inode.\n\t */\n\t*locked_ni = eni;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "tbh"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rl"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nr_bhs >= max_bhs"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "rec_start_bh"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err2"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_runlist",
          "args": [
            "ni",
            "vcn"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "298-309",
          "snippet": "int ntfs_map_runlist(ntfs_inode *ni, VCN vcn)\n{\n\tint err = 0;\n\n\tdown_write(&ni->runlist.lock);\n\t/* Make sure someone else didn't do the work while we were sleeping. */\n\tif (likely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) <=\n\t\t\tLCN_RL_NOT_MAPPED))\n\t\terr = ntfs_map_runlist_nolock(ni, vcn, NULL);\n\tup_write(&ni->runlist.lock);\n\treturn err;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_map_runlist(ntfs_inode *ni, VCN vcn)\n{\n\tint err = 0;\n\n\tdown_write(&ni->runlist.lock);\n\t/* Make sure someone else didn't do the work while we were sleeping. */\n\tif (likely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) <=\n\t\t\tLCN_RL_NOT_MAPPED))\n\t\terr = ntfs_map_runlist_nolock(ni, vcn, NULL);\n\tup_write(&ni->runlist.lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "lcn >= 0"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_vcn_to_lcn",
          "args": [
            "rl",
            "vcn"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_vcn_to_lcn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1004-1036",
          "snippet": "LCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nLCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl != NULL"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_mapped(bh)"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "block >= dblock"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "block > rec_block"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err2"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "block >= dblock"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "block < rec_block"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bhs_per_rec"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(PAGE_CACHE_SIZE >> rec_size_bits)"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bh"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "max_bhs > MAX_BUF_PER_PAGE"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!max_bhs"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(is_mft || S_ISDIR(vi->i_mode) ||\n\t\t\t(NInoAttr(ni) && ni->type == AT_INDEX_ALLOCATION))"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "vi->i_mode"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "vi->i_mode"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!NInoMstProtected(ni)"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoMstProtected",
          "args": [
            "ni"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!NInoNonResident(ni)"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for inode 0x%lx, attribute type 0x%x, page index \"\n\t\t\t\"0x%lx.\"",
            "vi->i_ino",
            "ni->type",
            "page->index"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"types.h\"\n#include \"runlist.h\"\n#include \"mft.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int ntfs_write_mst_block(struct page *page,\n\t\tstruct writeback_control *wbc)\n{\n\tsector_t block, dblock, rec_block;\n\tstruct inode *vi = page->mapping->host;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_volume *vol = ni->vol;\n\tu8 *kaddr;\n\tunsigned int rec_size = ni->itype.index.block_size;\n\tntfs_inode *locked_nis[PAGE_CACHE_SIZE / rec_size];\n\tstruct buffer_head *bh, *head, *tbh, *rec_start_bh;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\trunlist_element *rl;\n\tint i, nr_locked_nis, nr_recs, nr_bhs, max_bhs, bhs_per_rec, err, err2;\n\tunsigned bh_size, rec_size_bits;\n\tbool sync, is_mft, page_is_dirty, rec_is_dirty;\n\tunsigned char bh_size_bits;\n\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, page index \"\n\t\t\t\"0x%lx.\", vi->i_ino, ni->type, page->index);\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(!NInoMstProtected(ni));\n\tis_mft = (S_ISREG(vi->i_mode) && !vi->i_ino);\n\t/*\n\t * NOTE: ntfs_write_mst_block() would be called for $MFTMirr if a page\n\t * in its page cache were to be marked dirty.  However this should\n\t * never happen with the current driver and considering we do not\n\t * handle this case here we do want to BUG(), at least for now.\n\t */\n\tBUG_ON(!(is_mft || S_ISDIR(vi->i_mode) ||\n\t\t\t(NInoAttr(ni) && ni->type == AT_INDEX_ALLOCATION)));\n\tbh_size = vol->sb->s_blocksize;\n\tbh_size_bits = vol->sb->s_blocksize_bits;\n\tmax_bhs = PAGE_CACHE_SIZE / bh_size;\n\tBUG_ON(!max_bhs);\n\tBUG_ON(max_bhs > MAX_BUF_PER_PAGE);\n\n\t/* Were we called for sync purposes? */\n\tsync = (wbc->sync_mode == WB_SYNC_ALL);\n\n\t/* Make sure we have mapped buffers. */\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\n\trec_size_bits = ni->itype.index.block_size_bits;\n\tBUG_ON(!(PAGE_CACHE_SIZE >> rec_size_bits));\n\tbhs_per_rec = rec_size >> bh_size_bits;\n\tBUG_ON(!bhs_per_rec);\n\n\t/* The first block in the page. */\n\trec_block = block = (sector_t)page->index <<\n\t\t\t(PAGE_CACHE_SHIFT - bh_size_bits);\n\n\t/* The first out of bounds block for the data size. */\n\tdblock = (i_size_read(vi) + bh_size - 1) >> bh_size_bits;\n\n\trl = NULL;\n\terr = err2 = nr_bhs = nr_recs = nr_locked_nis = 0;\n\tpage_is_dirty = rec_is_dirty = false;\n\trec_start_bh = NULL;\n\tdo {\n\t\tbool is_retry = false;\n\n\t\tif (likely(block < rec_block)) {\n\t\t\tif (unlikely(block >= dblock)) {\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * This block is not the first one in the record.  We\n\t\t\t * ignore the buffer's dirty state because we could\n\t\t\t * have raced with a parallel mark_ntfs_record_dirty().\n\t\t\t */\n\t\t\tif (!rec_is_dirty)\n\t\t\t\tcontinue;\n\t\t\tif (unlikely(err2)) {\n\t\t\t\tif (err2 != -ENOMEM)\n\t\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else /* if (block == rec_block) */ {\n\t\t\tBUG_ON(block > rec_block);\n\t\t\t/* This block is the first one in the record. */\n\t\t\trec_block += bhs_per_rec;\n\t\t\terr2 = 0;\n\t\t\tif (unlikely(block >= dblock)) {\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\t/* Clean records are not written out. */\n\t\t\t\trec_is_dirty = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trec_is_dirty = true;\n\t\t\trec_start_bh = bh;\n\t\t}\n\t\t/* Need to map the buffer if it is not mapped already. */\n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t/* Obtain the vcn and offset of the current block. */\n\t\t\tvcn = (VCN)block << bh_size_bits;\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\nlock_retry_remap:\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\trl = ni->runlist.rl;\n\t\t\t}\n\t\t\tif (likely(rl != NULL)) {\n\t\t\t\t/* Seek to element containing target vcn. */\n\t\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\t\trl++;\n\t\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t} else\n\t\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t\t/* Successful remap. */\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> bh_size_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Remap failed.  Retry to map the runlist once\n\t\t\t\t * unless we are working on $MFT which always\n\t\t\t\t * has the whole of its runlist in memory.\n\t\t\t\t */\n\t\t\t\tif (!is_mft && !is_retry &&\n\t\t\t\t\t\tlcn == LCN_RL_NOT_MAPPED) {\n\t\t\t\t\tis_retry = true;\n\t\t\t\t\t/*\n\t\t\t\t\t * Attempt to map runlist, dropping\n\t\t\t\t\t * lock for the duration.\n\t\t\t\t\t */\n\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t\terr2 = ntfs_map_runlist(ni, vcn);\n\t\t\t\t\tif (likely(!err2))\n\t\t\t\t\t\tgoto lock_retry_remap;\n\t\t\t\t\tif (err2 == -ENOMEM)\n\t\t\t\t\t\tpage_is_dirty = true;\n\t\t\t\t\tlcn = err2;\n\t\t\t\t} else {\n\t\t\t\t\terr2 = -EIO;\n\t\t\t\t\tif (!rl)\n\t\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t}\n\t\t\t\t/* Hard error.  Abort writing this record. */\n\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\terr = err2;\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write ntfs record \"\n\t\t\t\t\t\t\"0x%llx (inode 0x%lx, \"\n\t\t\t\t\t\t\"attribute type 0x%x) because \"\n\t\t\t\t\t\t\"its location on disk could \"\n\t\t\t\t\t\t\"not be determined (error \"\n\t\t\t\t\t\t\"code %lli).\",\n\t\t\t\t\t\t(long long)block <<\n\t\t\t\t\t\tbh_size_bits >>\n\t\t\t\t\t\tvol->mft_record_size_bits,\n\t\t\t\t\t\tni->mft_no, ni->type,\n\t\t\t\t\t\t(long long)lcn);\n\t\t\t\t/*\n\t\t\t\t * If this is not the first buffer, remove the\n\t\t\t\t * buffers in this record from the list of\n\t\t\t\t * buffers to write and clear their dirty bit\n\t\t\t\t * if not error -ENOMEM.\n\t\t\t\t */\n\t\t\t\tif (rec_start_bh != bh) {\n\t\t\t\t\twhile (bhs[--nr_bhs] != rec_start_bh)\n\t\t\t\t\t\t;\n\t\t\t\t\tif (err2 != -ENOMEM) {\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tclear_buffer_dirty(\n\t\t\t\t\t\t\t\trec_start_bh);\n\t\t\t\t\t\t} while ((rec_start_bh =\n\t\t\t\t\t\t\t\trec_start_bh->\n\t\t\t\t\t\t\t\tb_this_page) !=\n\t\t\t\t\t\t\t\tbh);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t} while (block++, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&ni->runlist.lock);\n\t/* If there were no dirty buffers, we are done. */\n\tif (!nr_bhs)\n\t\tgoto done;\n\t/* Map the page so we can access its contents. */\n\tkaddr = kmap(page);\n\t/* Clear the page uptodate flag whilst the mst fixups are applied. */\n\tBUG_ON(!PageUptodate(page));\n\tClearPageUptodate(page);\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tunsigned int ofs;\n\n\t\t/* Skip buffers which are not at the beginning of records. */\n\t\tif (i % bhs_per_rec)\n\t\t\tcontinue;\n\t\ttbh = bhs[i];\n\t\tofs = bh_offset(tbh);\n\t\tif (is_mft) {\n\t\t\tntfs_inode *tni;\n\t\t\tunsigned long mft_no;\n\n\t\t\t/* Get the mft record number. */\n\t\t\tmft_no = (((s64)page->index << PAGE_CACHE_SHIFT) + ofs)\n\t\t\t\t\t>> rec_size_bits;\n\t\t\t/* Check whether to write this mft record. */\n\t\t\ttni = NULL;\n\t\t\tif (!ntfs_may_write_mft_record(vol, mft_no,\n\t\t\t\t\t(MFT_RECORD*)(kaddr + ofs), &tni)) {\n\t\t\t\t/*\n\t\t\t\t * The record should not be written.  This\n\t\t\t\t * means we need to redirty the page before\n\t\t\t\t * returning.\n\t\t\t\t */\n\t\t\t\tpage_is_dirty = true;\n\t\t\t\t/*\n\t\t\t\t * Remove the buffers in this mft record from\n\t\t\t\t * the list of buffers to write.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t} while (++i % bhs_per_rec);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * The record should be written.  If a locked ntfs\n\t\t\t * inode was returned, add it to the array of locked\n\t\t\t * ntfs inodes.\n\t\t\t */\n\t\t\tif (tni)\n\t\t\t\tlocked_nis[nr_locked_nis++] = tni;\n\t\t}\n\t\t/* Apply the mst protection fixups. */\n\t\terr2 = pre_write_mst_fixup((NTFS_RECORD*)(kaddr + ofs),\n\t\t\t\trec_size);\n\t\tif (unlikely(err2)) {\n\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\tntfs_error(vol->sb, \"Failed to apply mst fixups \"\n\t\t\t\t\t\"(inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"page index 0x%lx, page offset 0x%x)!\"\n\t\t\t\t\t\"  Unmount and run chkdsk.\", vi->i_ino,\n\t\t\t\t\tni->type, page->index, ofs);\n\t\t\t/*\n\t\t\t * Mark all the buffers in this record clean as we do\n\t\t\t * not want to write corrupt data to disk.\n\t\t\t */\n\t\t\tdo {\n\t\t\t\tclear_buffer_dirty(bhs[i]);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t} while (++i % bhs_per_rec);\n\t\t\tcontinue;\n\t\t}\n\t\tnr_recs++;\n\t}\n\t/* If no records are to be written out, we are done. */\n\tif (!nr_recs)\n\t\tgoto unm_done;\n\tflush_dcache_page(page);\n\t/* Lock buffers and start synchronous write i/o on them. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\ttbh = bhs[i];\n\t\tif (!tbh)\n\t\t\tcontinue;\n\t\tif (!trylock_buffer(tbh))\n\t\t\tBUG();\n\t\t/* The buffer dirty state is now irrelevant, just clean it. */\n\t\tclear_buffer_dirty(tbh);\n\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\tBUG_ON(!buffer_mapped(tbh));\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\tsubmit_bh(WRITE, tbh);\n\t}\n\t/* Synchronize the mft mirror now if not @sync. */\n\tif (is_mft && !sync)\n\t\tgoto do_mirror;\ndo_wait:\n\t/* Wait on i/o completion of buffers. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\ttbh = bhs[i];\n\t\tif (!tbh)\n\t\t\tcontinue;\n\t\twait_on_buffer(tbh);\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\tntfs_error(vol->sb, \"I/O error while writing ntfs \"\n\t\t\t\t\t\"record buffer (inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, page index \"\n\t\t\t\t\t\"0x%lx, page offset 0x%lx)!  Unmount \"\n\t\t\t\t\t\"and run chkdsk.\", vi->i_ino, ni->type,\n\t\t\t\t\tpage->index, bh_offset(tbh));\n\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\t/*\n\t\t\t * Set the buffer uptodate so the page and buffer\n\t\t\t * states do not become out of sync.\n\t\t\t */\n\t\t\tset_buffer_uptodate(tbh);\n\t\t}\n\t}\n\t/* If @sync, now synchronize the mft mirror. */\n\tif (is_mft && sync) {\ndo_mirror:\n\t\tfor (i = 0; i < nr_bhs; i++) {\n\t\t\tunsigned long mft_no;\n\t\t\tunsigned int ofs;\n\n\t\t\t/*\n\t\t\t * Skip buffers which are not at the beginning of\n\t\t\t * records.\n\t\t\t */\n\t\t\tif (i % bhs_per_rec)\n\t\t\t\tcontinue;\n\t\t\ttbh = bhs[i];\n\t\t\t/* Skip removed buffers (and hence records). */\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\tofs = bh_offset(tbh);\n\t\t\t/* Get the mft record number. */\n\t\t\tmft_no = (((s64)page->index << PAGE_CACHE_SHIFT) + ofs)\n\t\t\t\t\t>> rec_size_bits;\n\t\t\tif (mft_no < vol->mftmirr_size)\n\t\t\t\tntfs_sync_mft_mirror(vol, mft_no,\n\t\t\t\t\t\t(MFT_RECORD*)(kaddr + ofs),\n\t\t\t\t\t\tsync);\n\t\t}\n\t\tif (!sync)\n\t\t\tgoto do_wait;\n\t}\n\t/* Remove the mst protection fixups again. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tif (!(i % bhs_per_rec)) {\n\t\t\ttbh = bhs[i];\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\tpost_write_mst_fixup((NTFS_RECORD*)(kaddr +\n\t\t\t\t\tbh_offset(tbh)));\n\t\t}\n\t}\n\tflush_dcache_page(page);\nunm_done:\n\t/* Unlock any locked inodes. */\n\twhile (nr_locked_nis-- > 0) {\n\t\tntfs_inode *tni, *base_tni;\n\t\t\n\t\ttni = locked_nis[nr_locked_nis];\n\t\t/* Get the base inode. */\n\t\tmutex_lock(&tni->extent_lock);\n\t\tif (tni->nr_extents >= 0)\n\t\t\tbase_tni = tni;\n\t\telse {\n\t\t\tbase_tni = tni->ext.base_ntfs_ino;\n\t\t\tBUG_ON(!base_tni);\n\t\t}\n\t\tmutex_unlock(&tni->extent_lock);\n\t\tntfs_debug(\"Unlocking %s inode 0x%lx.\",\n\t\t\t\ttni == base_tni ? \"base\" : \"extent\",\n\t\t\t\ttni->mft_no);\n\t\tmutex_unlock(&tni->mrec_lock);\n\t\tatomic_dec(&tni->count);\n\t\tiput(VFS_I(base_tni));\n\t}\n\tSetPageUptodate(page);\n\tkunmap(page);\ndone:\n\tif (unlikely(err && err != -ENOMEM)) {\n\t\t/*\n\t\t * Set page error if there is only one ntfs record in the page.\n\t\t * Otherwise we would loose per-record granularity.\n\t\t */\n\t\tif (ni->itype.index.block_size == PAGE_CACHE_SIZE)\n\t\t\tSetPageError(page);\n\t\tNVolSetErrors(vol);\n\t}\n\tif (page_is_dirty) {\n\t\tntfs_debug(\"Page still contains one or more dirty ntfs \"\n\t\t\t\t\"records.  Redirtying the page starting at \"\n\t\t\t\t\"record 0x%lx.\", page->index <<\n\t\t\t\t(PAGE_CACHE_SHIFT - rec_size_bits));\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tunlock_page(page);\n\t} else {\n\t\t/*\n\t\t * Keep the VM happy.  This must be done otherwise the\n\t\t * radix-tree tag PAGECACHE_TAG_DIRTY remains set even though\n\t\t * the page is clean.\n\t\t */\n\t\tBUG_ON(PageWriteback(page));\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t\tend_page_writeback(page);\n\t}\n\tif (likely(!err))\n\t\tntfs_debug(\"Done.\");\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_write_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.c",
    "lines": "550-893",
    "snippet": "static int ntfs_write_block(struct page *page, struct writeback_control *wbc)\n{\n\tVCN vcn;\n\tLCN lcn;\n\ts64 initialized_size;\n\tloff_t i_size;\n\tsector_t block, dblock, iblock;\n\tstruct inode *vi;\n\tntfs_inode *ni;\n\tntfs_volume *vol;\n\trunlist_element *rl;\n\tstruct buffer_head *bh, *head;\n\tunsigned long flags;\n\tunsigned int blocksize, vcn_ofs;\n\tint err;\n\tbool need_end_writeback;\n\tunsigned char blocksize_bits;\n\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\tvol = ni->vol;\n\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, page index \"\n\t\t\t\"0x%lx.\", ni->mft_no, ni->type, page->index);\n\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(NInoMstProtected(ni));\n\tblocksize = vol->sb->s_blocksize;\n\tblocksize_bits = vol->sb->s_blocksize_bits;\n\tif (!page_has_buffers(page)) {\n\t\tBUG_ON(!PageUptodate(page));\n\t\tcreate_empty_buffers(page, blocksize,\n\t\t\t\t(1 << BH_Uptodate) | (1 << BH_Dirty));\n\t\tif (unlikely(!page_has_buffers(page))) {\n\t\t\tntfs_warning(vol->sb, \"Error allocating page \"\n\t\t\t\t\t\"buffers.  Redirtying page so we try \"\n\t\t\t\t\t\"again later.\");\n\t\t\t/*\n\t\t\t * Put the page back on mapping->dirty_pages, but leave\n\t\t\t * its buffers' dirty state as-is.\n\t\t\t */\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\n\t/* NOTE: Different naming scheme to ntfs_read_block()! */\n\n\t/* The first block in the page. */\n\tblock = (s64)page->index << (PAGE_CACHE_SHIFT - blocksize_bits);\n\n\tread_lock_irqsave(&ni->size_lock, flags);\n\ti_size = i_size_read(vi);\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\n\t/* The first out of bounds block for the data size. */\n\tdblock = (i_size + blocksize - 1) >> blocksize_bits;\n\n\t/* The last (fully or partially) initialized block. */\n\tiblock = initialized_size >> blocksize_bits;\n\n\t/*\n\t * Be very careful.  We have no exclusion from __set_page_dirty_buffers\n\t * here, and the (potentially unmapped) buffers may become dirty at\n\t * any time.  If a buffer becomes dirty here after we've inspected it\n\t * then we just miss that fact, and the page stays dirty.\n\t *\n\t * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;\n\t * handle that here by just cleaning them.\n\t */\n\n\t/*\n\t * Loop through all the buffers in the page, mapping all the dirty\n\t * buffers to disk addresses and handling any aliases from the\n\t * underlying block device's mapping.\n\t */\n\trl = NULL;\n\terr = 0;\n\tdo {\n\t\tbool is_retry = false;\n\n\t\tif (unlikely(block >= dblock)) {\n\t\t\t/*\n\t\t\t * Mapped buffers outside i_size will occur, because\n\t\t\t * this page can be outside i_size when there is a\n\t\t\t * truncate in progress. The contents of such buffers\n\t\t\t * were zeroed by ntfs_writepage().\n\t\t\t *\n\t\t\t * FIXME: What about the small race window where\n\t\t\t * ntfs_writepage() has not done any clearing because\n\t\t\t * the page was within i_size but before we get here,\n\t\t\t * vmtruncate() modifies i_size?\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Clean buffers are not written out, so no need to map them. */\n\t\tif (!buffer_dirty(bh))\n\t\t\tcontinue;\n\n\t\t/* Make sure we have enough initialized size. */\n\t\tif (unlikely((block >= iblock) &&\n\t\t\t\t(initialized_size < i_size))) {\n\t\t\t/*\n\t\t\t * If this page is fully outside initialized size, zero\n\t\t\t * out all pages between the current initialized size\n\t\t\t * and the current page. Just use ntfs_readpage() to do\n\t\t\t * the zeroing transparently.\n\t\t\t */\n\t\t\tif (block > iblock) {\n\t\t\t\t// TODO:\n\t\t\t\t// For each page do:\n\t\t\t\t// - read_cache_page()\n\t\t\t\t// Again for each page do:\n\t\t\t\t// - wait_on_page_locked()\n\t\t\t\t// - Check (PageUptodate(page) &&\n\t\t\t\t//\t\t\t!PageError(page))\n\t\t\t\t// Update initialized size in the attribute and\n\t\t\t\t// in the inode.\n\t\t\t\t// Again, for each page do:\n\t\t\t\t//\t__set_page_dirty_buffers();\n\t\t\t\t// page_cache_release()\n\t\t\t\t// We don't need to wait on the writes.\n\t\t\t\t// Update iblock.\n\t\t\t}\n\t\t\t/*\n\t\t\t * The current page straddles initialized size. Zero\n\t\t\t * all non-uptodate buffers and set them uptodate (and\n\t\t\t * dirty?). Note, there aren't any non-uptodate buffers\n\t\t\t * if the page is uptodate.\n\t\t\t * FIXME: For an uptodate page, the buffers may need to\n\t\t\t * be written out because they were not initialized on\n\t\t\t * disk before.\n\t\t\t */\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t// TODO:\n\t\t\t\t// Zero any non-uptodate buffers up to i_size.\n\t\t\t\t// Set them uptodate and dirty.\n\t\t\t}\n\t\t\t// TODO:\n\t\t\t// Update initialized size in the attribute and in the\n\t\t\t// inode (up to i_size).\n\t\t\t// Update iblock.\n\t\t\t// FIXME: This is inefficient. Try to batch the two\n\t\t\t// size changes to happen in one go.\n\t\t\tntfs_error(vol->sb, \"Writing beyond initialized size \"\n\t\t\t\t\t\"is not supported yet. Sorry.\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t\t// Do NOT set_buffer_new() BUT DO clear buffer range\n\t\t\t// outside write request range.\n\t\t\t// set_buffer_uptodate() on complete buffers as well as\n\t\t\t// set_buffer_dirty().\n\t\t}\n\n\t\t/* No need to map buffers that are already mapped. */\n\t\tif (buffer_mapped(bh))\n\t\t\tcontinue;\n\n\t\t/* Unmapped, dirty buffer. Need to map it. */\n\t\tbh->b_bdev = vol->sb->s_bdev;\n\n\t\t/* Convert block into corresponding vcn and offset. */\n\t\tvcn = (VCN)block << blocksize_bits;\n\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\tvcn >>= vol->cluster_size_bits;\n\t\tif (!rl) {\nlock_retry_remap:\n\t\t\tdown_read(&ni->runlist.lock);\n\t\t\trl = ni->runlist.rl;\n\t\t}\n\t\tif (likely(rl != NULL)) {\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t} else\n\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t/* Successful remap. */\n\t\tif (lcn >= 0) {\n\t\t\t/* Setup buffer head to point to correct block. */\n\t\t\tbh->b_blocknr = ((lcn << vol->cluster_size_bits) +\n\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\tset_buffer_mapped(bh);\n\t\t\tcontinue;\n\t\t}\n\t\t/* It is a hole, need to instantiate it. */\n\t\tif (lcn == LCN_HOLE) {\n\t\t\tu8 *kaddr;\n\t\t\tunsigned long *bpos, *bend;\n\n\t\t\t/* Check if the buffer is zero. */\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tbpos = (unsigned long *)(kaddr + bh_offset(bh));\n\t\t\tbend = (unsigned long *)((u8*)bpos + blocksize);\n\t\t\tdo {\n\t\t\t\tif (unlikely(*bpos))\n\t\t\t\t\tbreak;\n\t\t\t} while (likely(++bpos < bend));\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tif (bpos == bend) {\n\t\t\t\t/*\n\t\t\t\t * Buffer is zero and sparse, no need to write\n\t\t\t\t * it.\n\t\t\t\t */\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// TODO: Instantiate the hole.\n\t\t\t// clear_buffer_new(bh);\n\t\t\t// unmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);\n\t\t\tntfs_error(vol->sb, \"Writing into sparse regions is \"\n\t\t\t\t\t\"not supported yet. Sorry.\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\t/* If first try and runlist unmapped, map and retry. */\n\t\tif (!is_retry && lcn == LCN_RL_NOT_MAPPED) {\n\t\t\tis_retry = true;\n\t\t\t/*\n\t\t\t * Attempt to map runlist, dropping lock for\n\t\t\t * the duration.\n\t\t\t */\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\terr = ntfs_map_runlist(ni, vcn);\n\t\t\tif (likely(!err))\n\t\t\t\tgoto lock_retry_remap;\n\t\t\trl = NULL;\n\t\t} else if (!rl)\n\t\t\tup_read(&ni->runlist.lock);\n\t\t/*\n\t\t * If buffer is outside the runlist, truncate has cut it out\n\t\t * of the runlist.  Just clean and clear the buffer and set it\n\t\t * uptodate so it can get discarded by the VM.\n\t\t */\n\t\tif (err == -ENOENT || lcn == LCN_ENOENT) {\n\t\t\tbh->b_blocknr = -1;\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tzero_user(page, bh_offset(bh), blocksize);\n\t\t\tset_buffer_uptodate(bh);\n\t\t\terr = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Failed to map the buffer, even after retrying. */\n\t\tif (!err)\n\t\t\terr = -EIO;\n\t\tbh->b_blocknr = -1;\n\t\tntfs_error(vol->sb, \"Failed to write to inode 0x%lx, \"\n\t\t\t\t\"attribute type 0x%x, vcn 0x%llx, offset 0x%x \"\n\t\t\t\t\"because its location on disk could not be \"\n\t\t\t\t\"determined%s (error code %i).\", ni->mft_no,\n\t\t\t\tni->type, (unsigned long long)vcn,\n\t\t\t\tvcn_ofs, is_retry ? \" even after \"\n\t\t\t\t\"retrying\" : \"\", err);\n\t\tbreak;\n\t} while (block++, (bh = bh->b_this_page) != head);\n\n\t/* Release the lock if we took it. */\n\tif (rl)\n\t\tup_read(&ni->runlist.lock);\n\n\t/* For the error case, need to reset bh to the beginning. */\n\tbh = head;\n\n\t/* Just an optimization, so ->readpage() is not called later. */\n\tif (unlikely(!PageUptodate(page))) {\n\t\tint uptodate = 1;\n\t\tdo {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tuptodate = 0;\n\t\t\t\tbh = head;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while ((bh = bh->b_this_page) != head);\n\t\tif (uptodate)\n\t\t\tSetPageUptodate(page);\n\t}\n\n\t/* Setup all mapped, dirty buffers for async write i/o. */\n\tdo {\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh)) {\n\t\t\tlock_buffer(bh);\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tBUG_ON(!buffer_uptodate(bh));\n\t\t\t\tmark_buffer_async_write(bh);\n\t\t\t} else\n\t\t\t\tunlock_buffer(bh);\n\t\t} else if (unlikely(err)) {\n\t\t\t/*\n\t\t\t * For the error case. The buffer may have been set\n\t\t\t * dirty during attachment to a dirty page.\n\t\t\t */\n\t\t\tif (err != -ENOMEM)\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\tif (unlikely(err)) {\n\t\t// TODO: Remove the -EOPNOTSUPP check later on...\n\t\tif (unlikely(err == -EOPNOTSUPP))\n\t\t\terr = 0;\n\t\telse if (err == -ENOMEM) {\n\t\t\tntfs_warning(vol->sb, \"Error allocating memory. \"\n\t\t\t\t\t\"Redirtying page so we try again \"\n\t\t\t\t\t\"later.\");\n\t\t\t/*\n\t\t\t * Put the page back on mapping->dirty_pages, but\n\t\t\t * leave its buffer's dirty state as-is.\n\t\t\t */\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\terr = 0;\n\t\t} else\n\t\t\tSetPageError(page);\n\t}\n\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\t/* Keeps try_to_free_buffers() away. */\n\n\t/* Submit the prepared buffers for i/o. */\n\tneed_end_writeback = true;\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh(WRITE, bh);\n\t\t\tneed_end_writeback = false;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\n\t/* If no i/o was started, need to end_page_writeback(). */\n\tif (unlikely(need_end_writeback))\n\t\tend_page_writeback(page);\n\n\tntfs_debug(\"Done.\");\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"types.h\"",
      "#include \"runlist.h\"",
      "#include \"mft.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "need_end_writeback"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "WRITE",
            "bh"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_async_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "420-423",
          "snippet": "void mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vol->sb",
            "\"Error allocating memory. \"\n\t\t\t\t\t\"Redirtying page so we try again \"\n\t\t\t\t\t\"later.\""
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err == -EOPNOTSUPP"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to write to inode 0x%lx, \"\n\t\t\t\t\"attribute type 0x%x, vcn 0x%llx, offset 0x%x \"\n\t\t\t\t\"because its location on disk could not be \"\n\t\t\t\t\"determined%s (error code %i).\"",
            "ni->mft_no",
            "ni->type",
            "(unsigned long long)vcn",
            "vcn_ofs",
            "is_retry ? \" even after \"\n\t\t\t\t\"retrying\" : \"\"",
            "err"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "bh_offset(bh)",
            "blocksize"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_runlist",
          "args": [
            "ni",
            "vcn"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "298-309",
          "snippet": "int ntfs_map_runlist(ntfs_inode *ni, VCN vcn)\n{\n\tint err = 0;\n\n\tdown_write(&ni->runlist.lock);\n\t/* Make sure someone else didn't do the work while we were sleeping. */\n\tif (likely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) <=\n\t\t\tLCN_RL_NOT_MAPPED))\n\t\terr = ntfs_map_runlist_nolock(ni, vcn, NULL);\n\tup_write(&ni->runlist.lock);\n\treturn err;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_map_runlist(ntfs_inode *ni, VCN vcn)\n{\n\tint err = 0;\n\n\tdown_write(&ni->runlist.lock);\n\t/* Make sure someone else didn't do the work while we were sleeping. */\n\tif (likely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) <=\n\t\t\tLCN_RL_NOT_MAPPED))\n\t\terr = ntfs_map_runlist_nolock(ni, vcn, NULL);\n\tup_write(&ni->runlist.lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Writing into sparse regions is \"\n\t\t\t\t\t\"not supported yet. Sorry.\""
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "++bpos < bend"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*bpos"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_vcn_to_lcn",
          "args": [
            "rl",
            "vcn"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_vcn_to_lcn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1004-1036",
          "snippet": "LCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nLCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl != NULL"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Writing beyond initialized size \"\n\t\t\t\t\t\"is not supported yet. Sorry.\""
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(block >= iblock) &&\n\t\t\t\t(initialized_size < i_size)"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "block >= dblock"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bh"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vol->sb",
            "\"Error allocating page \"\n\t\t\t\t\t\"buffers.  Redirtying page so we try \"\n\t\t\t\t\t\"again later.\""
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_has_buffers(page)"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "blocksize",
            "(1 << BH_Uptodate) | (1 << BH_Dirty)"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoMstProtected(ni)"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoMstProtected",
          "args": [
            "ni"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!NInoNonResident(ni)"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for inode 0x%lx, attribute type 0x%x, page index \"\n\t\t\t\"0x%lx.\"",
            "ni->mft_no",
            "ni->type",
            "page->index"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"types.h\"\n#include \"runlist.h\"\n#include \"mft.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int ntfs_write_block(struct page *page, struct writeback_control *wbc)\n{\n\tVCN vcn;\n\tLCN lcn;\n\ts64 initialized_size;\n\tloff_t i_size;\n\tsector_t block, dblock, iblock;\n\tstruct inode *vi;\n\tntfs_inode *ni;\n\tntfs_volume *vol;\n\trunlist_element *rl;\n\tstruct buffer_head *bh, *head;\n\tunsigned long flags;\n\tunsigned int blocksize, vcn_ofs;\n\tint err;\n\tbool need_end_writeback;\n\tunsigned char blocksize_bits;\n\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\tvol = ni->vol;\n\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, page index \"\n\t\t\t\"0x%lx.\", ni->mft_no, ni->type, page->index);\n\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(NInoMstProtected(ni));\n\tblocksize = vol->sb->s_blocksize;\n\tblocksize_bits = vol->sb->s_blocksize_bits;\n\tif (!page_has_buffers(page)) {\n\t\tBUG_ON(!PageUptodate(page));\n\t\tcreate_empty_buffers(page, blocksize,\n\t\t\t\t(1 << BH_Uptodate) | (1 << BH_Dirty));\n\t\tif (unlikely(!page_has_buffers(page))) {\n\t\t\tntfs_warning(vol->sb, \"Error allocating page \"\n\t\t\t\t\t\"buffers.  Redirtying page so we try \"\n\t\t\t\t\t\"again later.\");\n\t\t\t/*\n\t\t\t * Put the page back on mapping->dirty_pages, but leave\n\t\t\t * its buffers' dirty state as-is.\n\t\t\t */\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\n\t/* NOTE: Different naming scheme to ntfs_read_block()! */\n\n\t/* The first block in the page. */\n\tblock = (s64)page->index << (PAGE_CACHE_SHIFT - blocksize_bits);\n\n\tread_lock_irqsave(&ni->size_lock, flags);\n\ti_size = i_size_read(vi);\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\n\t/* The first out of bounds block for the data size. */\n\tdblock = (i_size + blocksize - 1) >> blocksize_bits;\n\n\t/* The last (fully or partially) initialized block. */\n\tiblock = initialized_size >> blocksize_bits;\n\n\t/*\n\t * Be very careful.  We have no exclusion from __set_page_dirty_buffers\n\t * here, and the (potentially unmapped) buffers may become dirty at\n\t * any time.  If a buffer becomes dirty here after we've inspected it\n\t * then we just miss that fact, and the page stays dirty.\n\t *\n\t * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;\n\t * handle that here by just cleaning them.\n\t */\n\n\t/*\n\t * Loop through all the buffers in the page, mapping all the dirty\n\t * buffers to disk addresses and handling any aliases from the\n\t * underlying block device's mapping.\n\t */\n\trl = NULL;\n\terr = 0;\n\tdo {\n\t\tbool is_retry = false;\n\n\t\tif (unlikely(block >= dblock)) {\n\t\t\t/*\n\t\t\t * Mapped buffers outside i_size will occur, because\n\t\t\t * this page can be outside i_size when there is a\n\t\t\t * truncate in progress. The contents of such buffers\n\t\t\t * were zeroed by ntfs_writepage().\n\t\t\t *\n\t\t\t * FIXME: What about the small race window where\n\t\t\t * ntfs_writepage() has not done any clearing because\n\t\t\t * the page was within i_size but before we get here,\n\t\t\t * vmtruncate() modifies i_size?\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Clean buffers are not written out, so no need to map them. */\n\t\tif (!buffer_dirty(bh))\n\t\t\tcontinue;\n\n\t\t/* Make sure we have enough initialized size. */\n\t\tif (unlikely((block >= iblock) &&\n\t\t\t\t(initialized_size < i_size))) {\n\t\t\t/*\n\t\t\t * If this page is fully outside initialized size, zero\n\t\t\t * out all pages between the current initialized size\n\t\t\t * and the current page. Just use ntfs_readpage() to do\n\t\t\t * the zeroing transparently.\n\t\t\t */\n\t\t\tif (block > iblock) {\n\t\t\t\t// TODO:\n\t\t\t\t// For each page do:\n\t\t\t\t// - read_cache_page()\n\t\t\t\t// Again for each page do:\n\t\t\t\t// - wait_on_page_locked()\n\t\t\t\t// - Check (PageUptodate(page) &&\n\t\t\t\t//\t\t\t!PageError(page))\n\t\t\t\t// Update initialized size in the attribute and\n\t\t\t\t// in the inode.\n\t\t\t\t// Again, for each page do:\n\t\t\t\t//\t__set_page_dirty_buffers();\n\t\t\t\t// page_cache_release()\n\t\t\t\t// We don't need to wait on the writes.\n\t\t\t\t// Update iblock.\n\t\t\t}\n\t\t\t/*\n\t\t\t * The current page straddles initialized size. Zero\n\t\t\t * all non-uptodate buffers and set them uptodate (and\n\t\t\t * dirty?). Note, there aren't any non-uptodate buffers\n\t\t\t * if the page is uptodate.\n\t\t\t * FIXME: For an uptodate page, the buffers may need to\n\t\t\t * be written out because they were not initialized on\n\t\t\t * disk before.\n\t\t\t */\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t// TODO:\n\t\t\t\t// Zero any non-uptodate buffers up to i_size.\n\t\t\t\t// Set them uptodate and dirty.\n\t\t\t}\n\t\t\t// TODO:\n\t\t\t// Update initialized size in the attribute and in the\n\t\t\t// inode (up to i_size).\n\t\t\t// Update iblock.\n\t\t\t// FIXME: This is inefficient. Try to batch the two\n\t\t\t// size changes to happen in one go.\n\t\t\tntfs_error(vol->sb, \"Writing beyond initialized size \"\n\t\t\t\t\t\"is not supported yet. Sorry.\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t\t// Do NOT set_buffer_new() BUT DO clear buffer range\n\t\t\t// outside write request range.\n\t\t\t// set_buffer_uptodate() on complete buffers as well as\n\t\t\t// set_buffer_dirty().\n\t\t}\n\n\t\t/* No need to map buffers that are already mapped. */\n\t\tif (buffer_mapped(bh))\n\t\t\tcontinue;\n\n\t\t/* Unmapped, dirty buffer. Need to map it. */\n\t\tbh->b_bdev = vol->sb->s_bdev;\n\n\t\t/* Convert block into corresponding vcn and offset. */\n\t\tvcn = (VCN)block << blocksize_bits;\n\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\tvcn >>= vol->cluster_size_bits;\n\t\tif (!rl) {\nlock_retry_remap:\n\t\t\tdown_read(&ni->runlist.lock);\n\t\t\trl = ni->runlist.rl;\n\t\t}\n\t\tif (likely(rl != NULL)) {\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t} else\n\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t/* Successful remap. */\n\t\tif (lcn >= 0) {\n\t\t\t/* Setup buffer head to point to correct block. */\n\t\t\tbh->b_blocknr = ((lcn << vol->cluster_size_bits) +\n\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\tset_buffer_mapped(bh);\n\t\t\tcontinue;\n\t\t}\n\t\t/* It is a hole, need to instantiate it. */\n\t\tif (lcn == LCN_HOLE) {\n\t\t\tu8 *kaddr;\n\t\t\tunsigned long *bpos, *bend;\n\n\t\t\t/* Check if the buffer is zero. */\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tbpos = (unsigned long *)(kaddr + bh_offset(bh));\n\t\t\tbend = (unsigned long *)((u8*)bpos + blocksize);\n\t\t\tdo {\n\t\t\t\tif (unlikely(*bpos))\n\t\t\t\t\tbreak;\n\t\t\t} while (likely(++bpos < bend));\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tif (bpos == bend) {\n\t\t\t\t/*\n\t\t\t\t * Buffer is zero and sparse, no need to write\n\t\t\t\t * it.\n\t\t\t\t */\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// TODO: Instantiate the hole.\n\t\t\t// clear_buffer_new(bh);\n\t\t\t// unmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);\n\t\t\tntfs_error(vol->sb, \"Writing into sparse regions is \"\n\t\t\t\t\t\"not supported yet. Sorry.\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\t/* If first try and runlist unmapped, map and retry. */\n\t\tif (!is_retry && lcn == LCN_RL_NOT_MAPPED) {\n\t\t\tis_retry = true;\n\t\t\t/*\n\t\t\t * Attempt to map runlist, dropping lock for\n\t\t\t * the duration.\n\t\t\t */\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\terr = ntfs_map_runlist(ni, vcn);\n\t\t\tif (likely(!err))\n\t\t\t\tgoto lock_retry_remap;\n\t\t\trl = NULL;\n\t\t} else if (!rl)\n\t\t\tup_read(&ni->runlist.lock);\n\t\t/*\n\t\t * If buffer is outside the runlist, truncate has cut it out\n\t\t * of the runlist.  Just clean and clear the buffer and set it\n\t\t * uptodate so it can get discarded by the VM.\n\t\t */\n\t\tif (err == -ENOENT || lcn == LCN_ENOENT) {\n\t\t\tbh->b_blocknr = -1;\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tzero_user(page, bh_offset(bh), blocksize);\n\t\t\tset_buffer_uptodate(bh);\n\t\t\terr = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Failed to map the buffer, even after retrying. */\n\t\tif (!err)\n\t\t\terr = -EIO;\n\t\tbh->b_blocknr = -1;\n\t\tntfs_error(vol->sb, \"Failed to write to inode 0x%lx, \"\n\t\t\t\t\"attribute type 0x%x, vcn 0x%llx, offset 0x%x \"\n\t\t\t\t\"because its location on disk could not be \"\n\t\t\t\t\"determined%s (error code %i).\", ni->mft_no,\n\t\t\t\tni->type, (unsigned long long)vcn,\n\t\t\t\tvcn_ofs, is_retry ? \" even after \"\n\t\t\t\t\"retrying\" : \"\", err);\n\t\tbreak;\n\t} while (block++, (bh = bh->b_this_page) != head);\n\n\t/* Release the lock if we took it. */\n\tif (rl)\n\t\tup_read(&ni->runlist.lock);\n\n\t/* For the error case, need to reset bh to the beginning. */\n\tbh = head;\n\n\t/* Just an optimization, so ->readpage() is not called later. */\n\tif (unlikely(!PageUptodate(page))) {\n\t\tint uptodate = 1;\n\t\tdo {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tuptodate = 0;\n\t\t\t\tbh = head;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while ((bh = bh->b_this_page) != head);\n\t\tif (uptodate)\n\t\t\tSetPageUptodate(page);\n\t}\n\n\t/* Setup all mapped, dirty buffers for async write i/o. */\n\tdo {\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh)) {\n\t\t\tlock_buffer(bh);\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tBUG_ON(!buffer_uptodate(bh));\n\t\t\t\tmark_buffer_async_write(bh);\n\t\t\t} else\n\t\t\t\tunlock_buffer(bh);\n\t\t} else if (unlikely(err)) {\n\t\t\t/*\n\t\t\t * For the error case. The buffer may have been set\n\t\t\t * dirty during attachment to a dirty page.\n\t\t\t */\n\t\t\tif (err != -ENOMEM)\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\tif (unlikely(err)) {\n\t\t// TODO: Remove the -EOPNOTSUPP check later on...\n\t\tif (unlikely(err == -EOPNOTSUPP))\n\t\t\terr = 0;\n\t\telse if (err == -ENOMEM) {\n\t\t\tntfs_warning(vol->sb, \"Error allocating memory. \"\n\t\t\t\t\t\"Redirtying page so we try again \"\n\t\t\t\t\t\"later.\");\n\t\t\t/*\n\t\t\t * Put the page back on mapping->dirty_pages, but\n\t\t\t * leave its buffer's dirty state as-is.\n\t\t\t */\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\terr = 0;\n\t\t} else\n\t\t\tSetPageError(page);\n\t}\n\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\t/* Keeps try_to_free_buffers() away. */\n\n\t/* Submit the prepared buffers for i/o. */\n\tneed_end_writeback = true;\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh(WRITE, bh);\n\t\t\tneed_end_writeback = false;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\n\t/* If no i/o was started, need to end_page_writeback(). */\n\tif (unlikely(need_end_writeback))\n\t\tend_page_writeback(page);\n\n\tntfs_debug(\"Done.\");\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.c",
    "lines": "398-524",
    "snippet": "static int ntfs_readpage(struct file *file, struct page *page)\n{\n\tloff_t i_size;\n\tstruct inode *vi;\n\tntfs_inode *ni, *base_ni;\n\tu8 *addr;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *mrec;\n\tunsigned long flags;\n\tu32 attr_len;\n\tint err = 0;\n\nretry_readpage:\n\tBUG_ON(!PageLocked(page));\n\tvi = page->mapping->host;\n\ti_size = i_size_read(vi);\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\tif (unlikely(page->index >= (i_size + PAGE_CACHE_SIZE - 1) >>\n\t\t\tPAGE_CACHE_SHIFT)) {\n\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\t\tntfs_debug(\"Read outside i_size - truncated?\");\n\t\tgoto done;\n\t}\n\t/*\n\t * This can potentially happen because we clear PageUptodate() during\n\t * ntfs_writepage() of MstProtected() attributes.\n\t */\n\tif (PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\tni = NTFS_I(vi);\n\t/*\n\t * Only $DATA attributes can be encrypted and only unnamed $DATA\n\t * attributes can be compressed.  Index root can have the flags set but\n\t * this means to create compressed/encrypted files, not that the\n\t * attribute is compressed/encrypted.  Note we need to check for\n\t * AT_INDEX_ALLOCATION since this is the type of both directory and\n\t * index inodes.\n\t */\n\tif (ni->type != AT_INDEX_ALLOCATION) {\n\t\t/* If attribute is encrypted, deny access, just like NT4. */\n\t\tif (NInoEncrypted(ni)) {\n\t\t\tBUG_ON(ni->type != AT_DATA);\n\t\t\terr = -EACCES;\n\t\t\tgoto err_out;\n\t\t}\n\t\t/* Compressed data streams are handled in compress.c. */\n\t\tif (NInoNonResident(ni) && NInoCompressed(ni)) {\n\t\t\tBUG_ON(ni->type != AT_DATA);\n\t\t\tBUG_ON(ni->name_len);\n\t\t\treturn ntfs_read_compressed_block(page);\n\t\t}\n\t}\n\t/* NInoNonResident() == NInoIndexAllocPresent() */\n\tif (NInoNonResident(ni)) {\n\t\t/* Normal, non-resident data stream. */\n\t\treturn ntfs_read_block(page);\n\t}\n\t/*\n\t * Attribute is resident, implying it is not compressed or encrypted.\n\t * This also means the attribute is smaller than an mft record and\n\t * hence smaller than a page, so can simply zero out any pages with\n\t * index above 0.  Note the attribute can actually be marked compressed\n\t * but if it is resident the actual data is not compressed so we are\n\t * ok to ignore the compressed flag here.\n\t */\n\tif (unlikely(page->index > 0)) {\n\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\t\tgoto done;\n\t}\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t/* Map, pin, and lock the mft record. */\n\tmrec = map_mft_record(base_ni);\n\tif (IS_ERR(mrec)) {\n\t\terr = PTR_ERR(mrec);\n\t\tgoto err_out;\n\t}\n\t/*\n\t * If a parallel write made the attribute non-resident, drop the mft\n\t * record and retry the readpage.\n\t */\n\tif (unlikely(NInoNonResident(ni))) {\n\t\tunmap_mft_record(base_ni);\n\t\tgoto retry_readpage;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err))\n\t\tgoto put_unm_err_out;\n\tattr_len = le32_to_cpu(ctx->attr->data.resident.value_length);\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tif (unlikely(attr_len > ni->initialized_size))\n\t\tattr_len = ni->initialized_size;\n\ti_size = i_size_read(vi);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (unlikely(attr_len > i_size)) {\n\t\t/* Race with shrinking truncate. */\n\t\tattr_len = i_size;\n\t}\n\taddr = kmap_atomic(page);\n\t/* Copy the data to the page. */\n\tmemcpy(addr, (u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset),\n\t\t\tattr_len);\n\t/* Zero the remainder of the page. */\n\tmemset(addr + attr_len, 0, PAGE_CACHE_SIZE - attr_len);\n\tflush_dcache_page(page);\n\tkunmap_atomic(addr);\nput_unm_err_out:\n\tntfs_attr_put_search_ctx(ctx);\nunm_err_out:\n\tunmap_mft_record(base_ni);\ndone:\n\tSetPageUptodate(page);\nerr_out:\n\tunlock_page(page);\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"types.h\"",
      "#include \"runlist.h\"",
      "#include \"mft.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "base_ni"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "addr"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "addr + attr_len",
            "0",
            "PAGE_CACHE_SIZE - attr_len"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "addr",
            "(u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset)",
            "attr_len"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ctx->attr->data.resident.value_offset"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "attr_len > i_size"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "attr_len > ni->initialized_size"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ctx->attr->data.resident.value_length"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "ni->type",
            "ni->name",
            "ni->name_len",
            "CASE_SENSITIVE",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "base_ni",
            "mrec"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "NInoNonResident(ni)"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mrec"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mrec"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->index > 0"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_read_block",
          "args": [
            "page"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.c",
          "lines": "184-378",
          "snippet": "static int ntfs_read_block(struct page *page)\n{\n\tloff_t i_size;\n\tVCN vcn;\n\tLCN lcn;\n\ts64 init_size;\n\tstruct inode *vi;\n\tntfs_inode *ni;\n\tntfs_volume *vol;\n\trunlist_element *rl;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tsector_t iblock, lblock, zblock;\n\tunsigned long flags;\n\tunsigned int blocksize, vcn_ofs;\n\tint i, nr;\n\tunsigned char blocksize_bits;\n\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\tvol = ni->vol;\n\n\t/* $MFT/$DATA must have its complete runlist in memory at all times. */\n\tBUG_ON(!ni->runlist.rl && !ni->mft_no && !NInoAttr(ni));\n\n\tblocksize = vol->sb->s_blocksize;\n\tblocksize_bits = vol->sb->s_blocksize_bits;\n\n\tif (!page_has_buffers(page)) {\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\t\tif (unlikely(!page_has_buffers(page))) {\n\t\t\tunlock_page(page);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\n\t/*\n\t * We may be racing with truncate.  To avoid some of the problems we\n\t * now take a snapshot of the various sizes and use those for the whole\n\t * of the function.  In case of an extending truncate it just means we\n\t * may leave some buffers unmapped which are now allocated.  This is\n\t * not a problem since these buffers will just get mapped when a write\n\t * occurs.  In case of a shrinking truncate, we will detect this later\n\t * on due to the runlist being incomplete and if the page is being\n\t * fully truncated, truncate will throw it away as soon as we unlock\n\t * it so no need to worry what we do with it.\n\t */\n\tiblock = (s64)page->index << (PAGE_CACHE_SHIFT - blocksize_bits);\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tlblock = (ni->allocated_size + blocksize - 1) >> blocksize_bits;\n\tinit_size = ni->initialized_size;\n\ti_size = i_size_read(vi);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (unlikely(init_size > i_size)) {\n\t\t/* Race with shrinking truncate. */\n\t\tinit_size = i_size;\n\t}\n\tzblock = (init_size + blocksize - 1) >> blocksize_bits;\n\n\t/* Loop through all the buffers in the page. */\n\trl = NULL;\n\tnr = i = 0;\n\tdo {\n\t\tint err = 0;\n\n\t\tif (unlikely(buffer_uptodate(bh)))\n\t\t\tcontinue;\n\t\tif (unlikely(buffer_mapped(bh))) {\n\t\t\tarr[nr++] = bh;\n\t\t\tcontinue;\n\t\t}\n\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t/* Is the block within the allowed limits? */\n\t\tif (iblock < lblock) {\n\t\t\tbool is_retry = false;\n\n\t\t\t/* Convert iblock into corresponding vcn and offset. */\n\t\t\tvcn = (VCN)iblock << blocksize_bits >>\n\t\t\t\t\tvol->cluster_size_bits;\n\t\t\tvcn_ofs = ((VCN)iblock << blocksize_bits) &\n\t\t\t\t\tvol->cluster_size_mask;\n\t\t\tif (!rl) {\nlock_retry_remap:\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\trl = ni->runlist.rl;\n\t\t\t}\n\t\t\tif (likely(rl != NULL)) {\n\t\t\t\t/* Seek to element containing target vcn. */\n\t\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\t\trl++;\n\t\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t} else\n\t\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t\t/* Successful remap. */\n\t\t\tif (lcn >= 0) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn << vol->cluster_size_bits)\n\t\t\t\t\t\t+ vcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t\t/* Only read initialized data blocks. */\n\t\t\t\tif (iblock < zblock) {\n\t\t\t\t\tarr[nr++] = bh;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Fully non-initialized data block, zero it. */\n\t\t\t\tgoto handle_zblock;\n\t\t\t}\n\t\t\t/* It is a hole, need to zero it. */\n\t\t\tif (lcn == LCN_HOLE)\n\t\t\t\tgoto handle_hole;\n\t\t\t/* If first try and runlist unmapped, map and retry. */\n\t\t\tif (!is_retry && lcn == LCN_RL_NOT_MAPPED) {\n\t\t\t\tis_retry = true;\n\t\t\t\t/*\n\t\t\t\t * Attempt to map runlist, dropping lock for\n\t\t\t\t * the duration.\n\t\t\t\t */\n\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\terr = ntfs_map_runlist(ni, vcn);\n\t\t\t\tif (likely(!err))\n\t\t\t\t\tgoto lock_retry_remap;\n\t\t\t\trl = NULL;\n\t\t\t} else if (!rl)\n\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t/*\n\t\t\t * If buffer is outside the runlist, treat it as a\n\t\t\t * hole.  This can happen due to concurrent truncate\n\t\t\t * for example.\n\t\t\t */\n\t\t\tif (err == -ENOENT || lcn == LCN_ENOENT) {\n\t\t\t\terr = 0;\n\t\t\t\tgoto handle_hole;\n\t\t\t}\n\t\t\t/* Hard error, zero out region. */\n\t\t\tif (!err)\n\t\t\t\terr = -EIO;\n\t\t\tbh->b_blocknr = -1;\n\t\t\tSetPageError(page);\n\t\t\tntfs_error(vol->sb, \"Failed to read from inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, vcn 0x%llx, \"\n\t\t\t\t\t\"offset 0x%x because its location on \"\n\t\t\t\t\t\"disk could not be determined%s \"\n\t\t\t\t\t\"(error code %i).\", ni->mft_no,\n\t\t\t\t\tni->type, (unsigned long long)vcn,\n\t\t\t\t\tvcn_ofs, is_retry ? \" even after \"\n\t\t\t\t\t\"retrying\" : \"\", err);\n\t\t}\n\t\t/*\n\t\t * Either iblock was outside lblock limits or\n\t\t * ntfs_rl_vcn_to_lcn() returned error.  Just zero that portion\n\t\t * of the page and set the buffer uptodate.\n\t\t */\nhandle_hole:\n\t\tbh->b_blocknr = -1UL;\n\t\tclear_buffer_mapped(bh);\nhandle_zblock:\n\t\tzero_user(page, i * blocksize, blocksize);\n\t\tif (likely(!err))\n\t\t\tset_buffer_uptodate(bh);\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\t/* Release the lock if we took it. */\n\tif (rl)\n\t\tup_read(&ni->runlist.lock);\n\n\t/* Check we have at least one buffer ready for i/o. */\n\tif (nr) {\n\t\tstruct buffer_head *tbh;\n\n\t\t/* Lock the buffers. */\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\ttbh = arr[i];\n\t\t\tlock_buffer(tbh);\n\t\t\ttbh->b_end_io = ntfs_end_buffer_async_read;\n\t\t\tset_buffer_async_read(tbh);\n\t\t}\n\t\t/* Finally, start i/o on the buffers. */\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\ttbh = arr[i];\n\t\t\tif (likely(!buffer_uptodate(tbh)))\n\t\t\t\tsubmit_bh(READ, tbh);\n\t\t\telse\n\t\t\t\tntfs_end_buffer_async_read(tbh, 1);\n\t\t}\n\t\treturn 0;\n\t}\n\t/* No i/o was scheduled on any of the buffers. */\n\tif (likely(!PageError(page)))\n\t\tSetPageUptodate(page);\n\telse /* Signal synchronous i/o error. */\n\t\tnr = -EIO;\n\tunlock_page(page);\n\treturn nr;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"types.h\"",
            "#include \"runlist.h\"",
            "#include \"mft.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"types.h\"\n#include \"runlist.h\"\n#include \"mft.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int ntfs_read_block(struct page *page)\n{\n\tloff_t i_size;\n\tVCN vcn;\n\tLCN lcn;\n\ts64 init_size;\n\tstruct inode *vi;\n\tntfs_inode *ni;\n\tntfs_volume *vol;\n\trunlist_element *rl;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tsector_t iblock, lblock, zblock;\n\tunsigned long flags;\n\tunsigned int blocksize, vcn_ofs;\n\tint i, nr;\n\tunsigned char blocksize_bits;\n\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\tvol = ni->vol;\n\n\t/* $MFT/$DATA must have its complete runlist in memory at all times. */\n\tBUG_ON(!ni->runlist.rl && !ni->mft_no && !NInoAttr(ni));\n\n\tblocksize = vol->sb->s_blocksize;\n\tblocksize_bits = vol->sb->s_blocksize_bits;\n\n\tif (!page_has_buffers(page)) {\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\t\tif (unlikely(!page_has_buffers(page))) {\n\t\t\tunlock_page(page);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\n\t/*\n\t * We may be racing with truncate.  To avoid some of the problems we\n\t * now take a snapshot of the various sizes and use those for the whole\n\t * of the function.  In case of an extending truncate it just means we\n\t * may leave some buffers unmapped which are now allocated.  This is\n\t * not a problem since these buffers will just get mapped when a write\n\t * occurs.  In case of a shrinking truncate, we will detect this later\n\t * on due to the runlist being incomplete and if the page is being\n\t * fully truncated, truncate will throw it away as soon as we unlock\n\t * it so no need to worry what we do with it.\n\t */\n\tiblock = (s64)page->index << (PAGE_CACHE_SHIFT - blocksize_bits);\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tlblock = (ni->allocated_size + blocksize - 1) >> blocksize_bits;\n\tinit_size = ni->initialized_size;\n\ti_size = i_size_read(vi);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (unlikely(init_size > i_size)) {\n\t\t/* Race with shrinking truncate. */\n\t\tinit_size = i_size;\n\t}\n\tzblock = (init_size + blocksize - 1) >> blocksize_bits;\n\n\t/* Loop through all the buffers in the page. */\n\trl = NULL;\n\tnr = i = 0;\n\tdo {\n\t\tint err = 0;\n\n\t\tif (unlikely(buffer_uptodate(bh)))\n\t\t\tcontinue;\n\t\tif (unlikely(buffer_mapped(bh))) {\n\t\t\tarr[nr++] = bh;\n\t\t\tcontinue;\n\t\t}\n\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t/* Is the block within the allowed limits? */\n\t\tif (iblock < lblock) {\n\t\t\tbool is_retry = false;\n\n\t\t\t/* Convert iblock into corresponding vcn and offset. */\n\t\t\tvcn = (VCN)iblock << blocksize_bits >>\n\t\t\t\t\tvol->cluster_size_bits;\n\t\t\tvcn_ofs = ((VCN)iblock << blocksize_bits) &\n\t\t\t\t\tvol->cluster_size_mask;\n\t\t\tif (!rl) {\nlock_retry_remap:\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\trl = ni->runlist.rl;\n\t\t\t}\n\t\t\tif (likely(rl != NULL)) {\n\t\t\t\t/* Seek to element containing target vcn. */\n\t\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\t\trl++;\n\t\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t} else\n\t\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t\t/* Successful remap. */\n\t\t\tif (lcn >= 0) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn << vol->cluster_size_bits)\n\t\t\t\t\t\t+ vcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t\t/* Only read initialized data blocks. */\n\t\t\t\tif (iblock < zblock) {\n\t\t\t\t\tarr[nr++] = bh;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Fully non-initialized data block, zero it. */\n\t\t\t\tgoto handle_zblock;\n\t\t\t}\n\t\t\t/* It is a hole, need to zero it. */\n\t\t\tif (lcn == LCN_HOLE)\n\t\t\t\tgoto handle_hole;\n\t\t\t/* If first try and runlist unmapped, map and retry. */\n\t\t\tif (!is_retry && lcn == LCN_RL_NOT_MAPPED) {\n\t\t\t\tis_retry = true;\n\t\t\t\t/*\n\t\t\t\t * Attempt to map runlist, dropping lock for\n\t\t\t\t * the duration.\n\t\t\t\t */\n\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\terr = ntfs_map_runlist(ni, vcn);\n\t\t\t\tif (likely(!err))\n\t\t\t\t\tgoto lock_retry_remap;\n\t\t\t\trl = NULL;\n\t\t\t} else if (!rl)\n\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t/*\n\t\t\t * If buffer is outside the runlist, treat it as a\n\t\t\t * hole.  This can happen due to concurrent truncate\n\t\t\t * for example.\n\t\t\t */\n\t\t\tif (err == -ENOENT || lcn == LCN_ENOENT) {\n\t\t\t\terr = 0;\n\t\t\t\tgoto handle_hole;\n\t\t\t}\n\t\t\t/* Hard error, zero out region. */\n\t\t\tif (!err)\n\t\t\t\terr = -EIO;\n\t\t\tbh->b_blocknr = -1;\n\t\t\tSetPageError(page);\n\t\t\tntfs_error(vol->sb, \"Failed to read from inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, vcn 0x%llx, \"\n\t\t\t\t\t\"offset 0x%x because its location on \"\n\t\t\t\t\t\"disk could not be determined%s \"\n\t\t\t\t\t\"(error code %i).\", ni->mft_no,\n\t\t\t\t\tni->type, (unsigned long long)vcn,\n\t\t\t\t\tvcn_ofs, is_retry ? \" even after \"\n\t\t\t\t\t\"retrying\" : \"\", err);\n\t\t}\n\t\t/*\n\t\t * Either iblock was outside lblock limits or\n\t\t * ntfs_rl_vcn_to_lcn() returned error.  Just zero that portion\n\t\t * of the page and set the buffer uptodate.\n\t\t */\nhandle_hole:\n\t\tbh->b_blocknr = -1UL;\n\t\tclear_buffer_mapped(bh);\nhandle_zblock:\n\t\tzero_user(page, i * blocksize, blocksize);\n\t\tif (likely(!err))\n\t\t\tset_buffer_uptodate(bh);\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\t/* Release the lock if we took it. */\n\tif (rl)\n\t\tup_read(&ni->runlist.lock);\n\n\t/* Check we have at least one buffer ready for i/o. */\n\tif (nr) {\n\t\tstruct buffer_head *tbh;\n\n\t\t/* Lock the buffers. */\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\ttbh = arr[i];\n\t\t\tlock_buffer(tbh);\n\t\t\ttbh->b_end_io = ntfs_end_buffer_async_read;\n\t\t\tset_buffer_async_read(tbh);\n\t\t}\n\t\t/* Finally, start i/o on the buffers. */\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\ttbh = arr[i];\n\t\t\tif (likely(!buffer_uptodate(tbh)))\n\t\t\t\tsubmit_bh(READ, tbh);\n\t\t\telse\n\t\t\t\tntfs_end_buffer_async_read(tbh, 1);\n\t\t}\n\t\treturn 0;\n\t}\n\t/* No i/o was scheduled on any of the buffers. */\n\tif (likely(!PageError(page)))\n\t\tSetPageUptodate(page);\n\telse /* Signal synchronous i/o error. */\n\t\tnr = -EIO;\n\tunlock_page(page);\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_read_compressed_block",
          "args": [
            "page"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_compressed_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/compress.c",
          "lines": "482-969",
          "snippet": "int ntfs_read_compressed_block(struct page *page)\n{\n\tloff_t i_size;\n\ts64 initialized_size;\n\tstruct address_space *mapping = page->mapping;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tntfs_volume *vol = ni->vol;\n\tstruct super_block *sb = vol->sb;\n\trunlist_element *rl;\n\tunsigned long flags, block_size = sb->s_blocksize;\n\tunsigned char block_size_bits = sb->s_blocksize_bits;\n\tu8 *cb, *cb_pos, *cb_end;\n\tstruct buffer_head **bhs;\n\tunsigned long offset, index = page->index;\n\tu32 cb_size = ni->itype.compressed.block_size;\n\tu64 cb_size_mask = cb_size - 1UL;\n\tVCN vcn;\n\tLCN lcn;\n\t/* The first wanted vcn (minimum alignment is PAGE_CACHE_SIZE). */\n\tVCN start_vcn = (((s64)index << PAGE_CACHE_SHIFT) & ~cb_size_mask) >>\n\t\t\tvol->cluster_size_bits;\n\t/*\n\t * The first vcn after the last wanted vcn (minimum alignment is again\n\t * PAGE_CACHE_SIZE.\n\t */\n\tVCN end_vcn = ((((s64)(index + 1UL) << PAGE_CACHE_SHIFT) + cb_size - 1)\n\t\t\t& ~cb_size_mask) >> vol->cluster_size_bits;\n\t/* Number of compression blocks (cbs) in the wanted vcn range. */\n\tunsigned int nr_cbs = (end_vcn - start_vcn) << vol->cluster_size_bits\n\t\t\t>> ni->itype.compressed.block_size_bits;\n\t/*\n\t * Number of pages required to store the uncompressed data from all\n\t * compression blocks (cbs) overlapping @page. Due to alignment\n\t * guarantees of start_vcn and end_vcn, no need to round up here.\n\t */\n\tunsigned int nr_pages = (end_vcn - start_vcn) <<\n\t\t\tvol->cluster_size_bits >> PAGE_CACHE_SHIFT;\n\tunsigned int xpage, max_page, cur_page, cur_ofs, i;\n\tunsigned int cb_clusters, cb_max_ofs;\n\tint block, max_block, cb_max_page, bhs_size, nr_bhs, err = 0;\n\tstruct page **pages;\n\tunsigned char xpage_done = 0;\n\n\tntfs_debug(\"Entering, page->index = 0x%lx, cb_size = 0x%x, nr_pages = \"\n\t\t\t\"%i.\", index, cb_size, nr_pages);\n\t/*\n\t * Bad things happen if we get here for anything that is not an\n\t * unnamed $DATA attribute.\n\t */\n\tBUG_ON(ni->type != AT_DATA);\n\tBUG_ON(ni->name_len);\n\n\tpages = kmalloc(nr_pages * sizeof(struct page *), GFP_NOFS);\n\n\t/* Allocate memory to store the buffer heads we need. */\n\tbhs_size = cb_size / block_size * sizeof(struct buffer_head *);\n\tbhs = kmalloc(bhs_size, GFP_NOFS);\n\n\tif (unlikely(!pages || !bhs)) {\n\t\tkfree(bhs);\n\t\tkfree(pages);\n\t\tunlock_page(page);\n\t\tntfs_error(vol->sb, \"Failed to allocate internal buffers.\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * We have already been given one page, this is the one we must do.\n\t * Once again, the alignment guarantees keep it simple.\n\t */\n\toffset = start_vcn << vol->cluster_size_bits >> PAGE_CACHE_SHIFT;\n\txpage = index - offset;\n\tpages[xpage] = page;\n\t/*\n\t * The remaining pages need to be allocated and inserted into the page\n\t * cache, alignment guarantees keep all the below much simpler. (-8\n\t */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\ti_size = i_size_read(VFS_I(ni));\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tmax_page = ((i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t\toffset;\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\tif (xpage >= max_page) {\n\t\tkfree(bhs);\n\t\tkfree(pages);\n\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\t\tntfs_debug(\"Compressed read outside i_size - truncated?\");\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\tif (nr_pages < max_page)\n\t\tmax_page = nr_pages;\n\tfor (i = 0; i < max_page; i++, offset++) {\n\t\tif (i != xpage)\n\t\t\tpages[i] = grab_cache_page_nowait(mapping, offset);\n\t\tpage = pages[i];\n\t\tif (page) {\n\t\t\t/*\n\t\t\t * We only (re)read the page if it isn't already read\n\t\t\t * in and/or dirty or we would be losing data or at\n\t\t\t * least wasting our time.\n\t\t\t */\n\t\t\tif (!PageDirty(page) && (!PageUptodate(page) ||\n\t\t\t\t\tPageError(page))) {\n\t\t\t\tClearPageError(page);\n\t\t\t\tkmap(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tpages[i] = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * We have the runlist, and all the destination pages we need to fill.\n\t * Now read the first compression block.\n\t */\n\tcur_page = 0;\n\tcur_ofs = 0;\n\tcb_clusters = ni->itype.compressed.block_clusters;\ndo_next_cb:\n\tnr_cbs--;\n\tnr_bhs = 0;\n\n\t/* Read all cb buffer heads one cluster at a time. */\n\trl = NULL;\n\tfor (vcn = start_vcn, start_vcn += cb_clusters; vcn < start_vcn;\n\t\t\tvcn++) {\n\t\tbool is_retry = false;\n\n\t\tif (!rl) {\nlock_retry_remap:\n\t\t\tdown_read(&ni->runlist.lock);\n\t\t\trl = ni->runlist.rl;\n\t\t}\n\t\tif (likely(rl != NULL)) {\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t} else\n\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\tntfs_debug(\"Reading vcn = 0x%llx, lcn = 0x%llx.\",\n\t\t\t\t(unsigned long long)vcn,\n\t\t\t\t(unsigned long long)lcn);\n\t\tif (lcn < 0) {\n\t\t\t/*\n\t\t\t * When we reach the first sparse cluster we have\n\t\t\t * finished with the cb.\n\t\t\t */\n\t\t\tif (lcn == LCN_HOLE)\n\t\t\t\tbreak;\n\t\t\tif (is_retry || lcn != LCN_RL_NOT_MAPPED)\n\t\t\t\tgoto rl_err;\n\t\t\tis_retry = true;\n\t\t\t/*\n\t\t\t * Attempt to map runlist, dropping lock for the\n\t\t\t * duration.\n\t\t\t */\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\tif (!ntfs_map_runlist(ni, vcn))\n\t\t\t\tgoto lock_retry_remap;\n\t\t\tgoto map_rl_err;\n\t\t}\n\t\tblock = lcn << vol->cluster_size_bits >> block_size_bits;\n\t\t/* Read the lcn from device in chunks of block_size bytes. */\n\t\tmax_block = block + (vol->cluster_size >> block_size_bits);\n\t\tdo {\n\t\t\tntfs_debug(\"block = 0x%x.\", block);\n\t\t\tif (unlikely(!(bhs[nr_bhs] = sb_getblk(sb, block))))\n\t\t\t\tgoto getblk_err;\n\t\t\tnr_bhs++;\n\t\t} while (++block < max_block);\n\t}\n\n\t/* Release the lock if we took it. */\n\tif (rl)\n\t\tup_read(&ni->runlist.lock);\n\n\t/* Setup and initiate io on all buffer heads. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tstruct buffer_head *tbh = bhs[i];\n\n\t\tif (!trylock_buffer(tbh))\n\t\t\tcontinue;\n\t\tif (unlikely(buffer_uptodate(tbh))) {\n\t\t\tunlock_buffer(tbh);\n\t\t\tcontinue;\n\t\t}\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, tbh);\n\t}\n\n\t/* Wait for io completion on all buffer heads. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tstruct buffer_head *tbh = bhs[i];\n\n\t\tif (buffer_uptodate(tbh))\n\t\t\tcontinue;\n\t\twait_on_buffer(tbh);\n\t\t/*\n\t\t * We need an optimization barrier here, otherwise we start\n\t\t * hitting the below fixup code when accessing a loopback\n\t\t * mounted ntfs partition. This indicates either there is a\n\t\t * race condition in the loop driver or, more likely, gcc\n\t\t * overoptimises the code without the barrier and it doesn't\n\t\t * do the Right Thing(TM).\n\t\t */\n\t\tbarrier();\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\tntfs_warning(vol->sb, \"Buffer is unlocked but not \"\n\t\t\t\t\t\"uptodate! Unplugging the disk queue \"\n\t\t\t\t\t\"and rescheduling.\");\n\t\t\tget_bh(tbh);\n\t\t\tio_schedule();\n\t\t\tput_bh(tbh);\n\t\t\tif (unlikely(!buffer_uptodate(tbh)))\n\t\t\t\tgoto read_err;\n\t\t\tntfs_warning(vol->sb, \"Buffer is now uptodate. Good.\");\n\t\t}\n\t}\n\n\t/*\n\t * Get the compression buffer. We must not sleep any more\n\t * until we are finished with it.\n\t */\n\tspin_lock(&ntfs_cb_lock);\n\tcb = ntfs_compression_buffer;\n\n\tBUG_ON(!cb);\n\n\tcb_pos = cb;\n\tcb_end = cb + cb_size;\n\n\t/* Copy the buffer heads into the contiguous buffer. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tmemcpy(cb_pos, bhs[i]->b_data, block_size);\n\t\tcb_pos += block_size;\n\t}\n\n\t/* Just a precaution. */\n\tif (cb_pos + 2 <= cb + cb_size)\n\t\t*(u16*)cb_pos = 0;\n\n\t/* Reset cb_pos back to the beginning. */\n\tcb_pos = cb;\n\n\t/* We now have both source (if present) and destination. */\n\tntfs_debug(\"Successfully read the compression block.\");\n\n\t/* The last page and maximum offset within it for the current cb. */\n\tcb_max_page = (cur_page << PAGE_CACHE_SHIFT) + cur_ofs + cb_size;\n\tcb_max_ofs = cb_max_page & ~PAGE_CACHE_MASK;\n\tcb_max_page >>= PAGE_CACHE_SHIFT;\n\n\t/* Catch end of file inside a compression block. */\n\tif (cb_max_page > max_page)\n\t\tcb_max_page = max_page;\n\n\tif (vcn == start_vcn - cb_clusters) {\n\t\t/* Sparse cb, zero out page range overlapping the cb. */\n\t\tntfs_debug(\"Found sparse compression block.\");\n\t\t/* We can sleep from now on, so we drop lock. */\n\t\tspin_unlock(&ntfs_cb_lock);\n\t\tif (cb_max_ofs)\n\t\t\tcb_max_page--;\n\t\tfor (; cur_page < cb_max_page; cur_page++) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page) {\n\t\t\t\t/*\n\t\t\t\t * FIXME: Using clear_page() will become wrong\n\t\t\t\t * when we get PAGE_CACHE_SIZE != PAGE_SIZE but\n\t\t\t\t * for now there is no problem.\n\t\t\t\t */\n\t\t\t\tif (likely(!cur_ofs))\n\t\t\t\t\tclear_page(page_address(page));\n\t\t\t\telse\n\t\t\t\t\tmemset(page_address(page) + cur_ofs, 0,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE -\n\t\t\t\t\t\t\tcur_ofs);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tkunmap(page);\n\t\t\t\tSetPageUptodate(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tif (cur_page == xpage)\n\t\t\t\t\txpage_done = 1;\n\t\t\t\telse\n\t\t\t\t\tpage_cache_release(page);\n\t\t\t\tpages[cur_page] = NULL;\n\t\t\t}\n\t\t\tcb_pos += PAGE_CACHE_SIZE - cur_ofs;\n\t\t\tcur_ofs = 0;\n\t\t\tif (cb_pos >= cb_end)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* If we have a partial final page, deal with it now. */\n\t\tif (cb_max_ofs && cb_pos < cb_end) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page)\n\t\t\t\tmemset(page_address(page) + cur_ofs, 0,\n\t\t\t\t\t\tcb_max_ofs - cur_ofs);\n\t\t\t/*\n\t\t\t * No need to update cb_pos at this stage:\n\t\t\t *\tcb_pos += cb_max_ofs - cur_ofs;\n\t\t\t */\n\t\t\tcur_ofs = cb_max_ofs;\n\t\t}\n\t} else if (vcn == start_vcn) {\n\t\t/* We can't sleep so we need two stages. */\n\t\tunsigned int cur2_page = cur_page;\n\t\tunsigned int cur_ofs2 = cur_ofs;\n\t\tu8 *cb_pos2 = cb_pos;\n\n\t\tntfs_debug(\"Found uncompressed compression block.\");\n\t\t/* Uncompressed cb, copy it to the destination pages. */\n\t\t/*\n\t\t * TODO: As a big optimization, we could detect this case\n\t\t * before we read all the pages and use block_read_full_page()\n\t\t * on all full pages instead (we still have to treat partial\n\t\t * pages especially but at least we are getting rid of the\n\t\t * synchronous io for the majority of pages.\n\t\t * Or if we choose not to do the read-ahead/-behind stuff, we\n\t\t * could just return block_read_full_page(pages[xpage]) as long\n\t\t * as PAGE_CACHE_SIZE <= cb_size.\n\t\t */\n\t\tif (cb_max_ofs)\n\t\t\tcb_max_page--;\n\t\t/* First stage: copy data into destination pages. */\n\t\tfor (; cur_page < cb_max_page; cur_page++) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page)\n\t\t\t\tmemcpy(page_address(page) + cur_ofs, cb_pos,\n\t\t\t\t\t\tPAGE_CACHE_SIZE - cur_ofs);\n\t\t\tcb_pos += PAGE_CACHE_SIZE - cur_ofs;\n\t\t\tcur_ofs = 0;\n\t\t\tif (cb_pos >= cb_end)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* If we have a partial final page, deal with it now. */\n\t\tif (cb_max_ofs && cb_pos < cb_end) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page)\n\t\t\t\tmemcpy(page_address(page) + cur_ofs, cb_pos,\n\t\t\t\t\t\tcb_max_ofs - cur_ofs);\n\t\t\tcb_pos += cb_max_ofs - cur_ofs;\n\t\t\tcur_ofs = cb_max_ofs;\n\t\t}\n\t\t/* We can sleep from now on, so drop lock. */\n\t\tspin_unlock(&ntfs_cb_lock);\n\t\t/* Second stage: finalize pages. */\n\t\tfor (; cur2_page < cb_max_page; cur2_page++) {\n\t\t\tpage = pages[cur2_page];\n\t\t\tif (page) {\n\t\t\t\t/*\n\t\t\t\t * If we are outside the initialized size, zero\n\t\t\t\t * the out of bounds page range.\n\t\t\t\t */\n\t\t\t\thandle_bounds_compressed_page(page, i_size,\n\t\t\t\t\t\tinitialized_size);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tkunmap(page);\n\t\t\t\tSetPageUptodate(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tif (cur2_page == xpage)\n\t\t\t\t\txpage_done = 1;\n\t\t\t\telse\n\t\t\t\t\tpage_cache_release(page);\n\t\t\t\tpages[cur2_page] = NULL;\n\t\t\t}\n\t\t\tcb_pos2 += PAGE_CACHE_SIZE - cur_ofs2;\n\t\t\tcur_ofs2 = 0;\n\t\t\tif (cb_pos2 >= cb_end)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/* Compressed cb, decompress it into the destination page(s). */\n\t\tunsigned int prev_cur_page = cur_page;\n\n\t\tntfs_debug(\"Found compressed compression block.\");\n\t\terr = ntfs_decompress(pages, &cur_page, &cur_ofs,\n\t\t\t\tcb_max_page, cb_max_ofs, xpage, &xpage_done,\n\t\t\t\tcb_pos,\tcb_size - (cb_pos - cb), i_size,\n\t\t\t\tinitialized_size);\n\t\t/*\n\t\t * We can sleep from now on, lock already dropped by\n\t\t * ntfs_decompress().\n\t\t */\n\t\tif (err) {\n\t\t\tntfs_error(vol->sb, \"ntfs_decompress() failed in inode \"\n\t\t\t\t\t\"0x%lx with error code %i. Skipping \"\n\t\t\t\t\t\"this compression block.\",\n\t\t\t\t\tni->mft_no, -err);\n\t\t\t/* Release the unfinished pages. */\n\t\t\tfor (; prev_cur_page < cur_page; prev_cur_page++) {\n\t\t\t\tpage = pages[prev_cur_page];\n\t\t\t\tif (page) {\n\t\t\t\t\tflush_dcache_page(page);\n\t\t\t\t\tkunmap(page);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (prev_cur_page != xpage)\n\t\t\t\t\t\tpage_cache_release(page);\n\t\t\t\t\tpages[prev_cur_page] = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Release the buffer heads. */\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\n\t/* Do we have more work to do? */\n\tif (nr_cbs)\n\t\tgoto do_next_cb;\n\n\t/* We no longer need the list of buffer heads. */\n\tkfree(bhs);\n\n\t/* Clean up if we have any pages left. Should never happen. */\n\tfor (cur_page = 0; cur_page < max_page; cur_page++) {\n\t\tpage = pages[cur_page];\n\t\tif (page) {\n\t\t\tntfs_error(vol->sb, \"Still have pages left! \"\n\t\t\t\t\t\"Terminating them with extreme \"\n\t\t\t\t\t\"prejudice.  Inode 0x%lx, page index \"\n\t\t\t\t\t\"0x%lx.\", ni->mft_no, page->index);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap(page);\n\t\t\tunlock_page(page);\n\t\t\tif (cur_page != xpage)\n\t\t\t\tpage_cache_release(page);\n\t\t\tpages[cur_page] = NULL;\n\t\t}\n\t}\n\n\t/* We no longer need the list of pages. */\n\tkfree(pages);\n\n\t/* If we have completed the requested page, we return success. */\n\tif (likely(xpage_done))\n\t\treturn 0;\n\n\tntfs_debug(\"Failed. Returning error code %s.\", err == -EOVERFLOW ?\n\t\t\t\"EOVERFLOW\" : (!err ? \"EIO\" : \"unknown error\"));\n\treturn err < 0 ? err : -EIO;\n\nread_err:\n\tntfs_error(vol->sb, \"IO error while reading compressed data.\");\n\t/* Release the buffer heads. */\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tgoto err_out;\n\nmap_rl_err:\n\tntfs_error(vol->sb, \"ntfs_map_runlist() failed. Cannot read \"\n\t\t\t\"compression block.\");\n\tgoto err_out;\n\nrl_err:\n\tup_read(&ni->runlist.lock);\n\tntfs_error(vol->sb, \"ntfs_rl_vcn_to_lcn() failed. Cannot read \"\n\t\t\t\"compression block.\");\n\tgoto err_out;\n\ngetblk_err:\n\tup_read(&ni->runlist.lock);\n\tntfs_error(vol->sb, \"getblk() failed. Cannot read compression block.\");\n\nerr_out:\n\tkfree(bhs);\n\tfor (i = cur_page; i < max_page; i++) {\n\t\tpage = pages[i];\n\t\tif (page) {\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap(page);\n\t\t\tunlock_page(page);\n\t\t\tif (i != xpage)\n\t\t\t\tpage_cache_release(page);\n\t\t}\n\t}\n\tkfree(pages);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"attrib.h\"",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 *ntfs_compression_buffer;",
            "static DEFINE_SPINLOCK(ntfs_cb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic u8 *ntfs_compression_buffer;\nstatic DEFINE_SPINLOCK(ntfs_cb_lock);\n\nint ntfs_read_compressed_block(struct page *page)\n{\n\tloff_t i_size;\n\ts64 initialized_size;\n\tstruct address_space *mapping = page->mapping;\n\tntfs_inode *ni = NTFS_I(mapping->host);\n\tntfs_volume *vol = ni->vol;\n\tstruct super_block *sb = vol->sb;\n\trunlist_element *rl;\n\tunsigned long flags, block_size = sb->s_blocksize;\n\tunsigned char block_size_bits = sb->s_blocksize_bits;\n\tu8 *cb, *cb_pos, *cb_end;\n\tstruct buffer_head **bhs;\n\tunsigned long offset, index = page->index;\n\tu32 cb_size = ni->itype.compressed.block_size;\n\tu64 cb_size_mask = cb_size - 1UL;\n\tVCN vcn;\n\tLCN lcn;\n\t/* The first wanted vcn (minimum alignment is PAGE_CACHE_SIZE). */\n\tVCN start_vcn = (((s64)index << PAGE_CACHE_SHIFT) & ~cb_size_mask) >>\n\t\t\tvol->cluster_size_bits;\n\t/*\n\t * The first vcn after the last wanted vcn (minimum alignment is again\n\t * PAGE_CACHE_SIZE.\n\t */\n\tVCN end_vcn = ((((s64)(index + 1UL) << PAGE_CACHE_SHIFT) + cb_size - 1)\n\t\t\t& ~cb_size_mask) >> vol->cluster_size_bits;\n\t/* Number of compression blocks (cbs) in the wanted vcn range. */\n\tunsigned int nr_cbs = (end_vcn - start_vcn) << vol->cluster_size_bits\n\t\t\t>> ni->itype.compressed.block_size_bits;\n\t/*\n\t * Number of pages required to store the uncompressed data from all\n\t * compression blocks (cbs) overlapping @page. Due to alignment\n\t * guarantees of start_vcn and end_vcn, no need to round up here.\n\t */\n\tunsigned int nr_pages = (end_vcn - start_vcn) <<\n\t\t\tvol->cluster_size_bits >> PAGE_CACHE_SHIFT;\n\tunsigned int xpage, max_page, cur_page, cur_ofs, i;\n\tunsigned int cb_clusters, cb_max_ofs;\n\tint block, max_block, cb_max_page, bhs_size, nr_bhs, err = 0;\n\tstruct page **pages;\n\tunsigned char xpage_done = 0;\n\n\tntfs_debug(\"Entering, page->index = 0x%lx, cb_size = 0x%x, nr_pages = \"\n\t\t\t\"%i.\", index, cb_size, nr_pages);\n\t/*\n\t * Bad things happen if we get here for anything that is not an\n\t * unnamed $DATA attribute.\n\t */\n\tBUG_ON(ni->type != AT_DATA);\n\tBUG_ON(ni->name_len);\n\n\tpages = kmalloc(nr_pages * sizeof(struct page *), GFP_NOFS);\n\n\t/* Allocate memory to store the buffer heads we need. */\n\tbhs_size = cb_size / block_size * sizeof(struct buffer_head *);\n\tbhs = kmalloc(bhs_size, GFP_NOFS);\n\n\tif (unlikely(!pages || !bhs)) {\n\t\tkfree(bhs);\n\t\tkfree(pages);\n\t\tunlock_page(page);\n\t\tntfs_error(vol->sb, \"Failed to allocate internal buffers.\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * We have already been given one page, this is the one we must do.\n\t * Once again, the alignment guarantees keep it simple.\n\t */\n\toffset = start_vcn << vol->cluster_size_bits >> PAGE_CACHE_SHIFT;\n\txpage = index - offset;\n\tpages[xpage] = page;\n\t/*\n\t * The remaining pages need to be allocated and inserted into the page\n\t * cache, alignment guarantees keep all the below much simpler. (-8\n\t */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\ti_size = i_size_read(VFS_I(ni));\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tmax_page = ((i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t\toffset;\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\tif (xpage >= max_page) {\n\t\tkfree(bhs);\n\t\tkfree(pages);\n\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\t\tntfs_debug(\"Compressed read outside i_size - truncated?\");\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\tif (nr_pages < max_page)\n\t\tmax_page = nr_pages;\n\tfor (i = 0; i < max_page; i++, offset++) {\n\t\tif (i != xpage)\n\t\t\tpages[i] = grab_cache_page_nowait(mapping, offset);\n\t\tpage = pages[i];\n\t\tif (page) {\n\t\t\t/*\n\t\t\t * We only (re)read the page if it isn't already read\n\t\t\t * in and/or dirty or we would be losing data or at\n\t\t\t * least wasting our time.\n\t\t\t */\n\t\t\tif (!PageDirty(page) && (!PageUptodate(page) ||\n\t\t\t\t\tPageError(page))) {\n\t\t\t\tClearPageError(page);\n\t\t\t\tkmap(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tpages[i] = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * We have the runlist, and all the destination pages we need to fill.\n\t * Now read the first compression block.\n\t */\n\tcur_page = 0;\n\tcur_ofs = 0;\n\tcb_clusters = ni->itype.compressed.block_clusters;\ndo_next_cb:\n\tnr_cbs--;\n\tnr_bhs = 0;\n\n\t/* Read all cb buffer heads one cluster at a time. */\n\trl = NULL;\n\tfor (vcn = start_vcn, start_vcn += cb_clusters; vcn < start_vcn;\n\t\t\tvcn++) {\n\t\tbool is_retry = false;\n\n\t\tif (!rl) {\nlock_retry_remap:\n\t\t\tdown_read(&ni->runlist.lock);\n\t\t\trl = ni->runlist.rl;\n\t\t}\n\t\tif (likely(rl != NULL)) {\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t} else\n\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\tntfs_debug(\"Reading vcn = 0x%llx, lcn = 0x%llx.\",\n\t\t\t\t(unsigned long long)vcn,\n\t\t\t\t(unsigned long long)lcn);\n\t\tif (lcn < 0) {\n\t\t\t/*\n\t\t\t * When we reach the first sparse cluster we have\n\t\t\t * finished with the cb.\n\t\t\t */\n\t\t\tif (lcn == LCN_HOLE)\n\t\t\t\tbreak;\n\t\t\tif (is_retry || lcn != LCN_RL_NOT_MAPPED)\n\t\t\t\tgoto rl_err;\n\t\t\tis_retry = true;\n\t\t\t/*\n\t\t\t * Attempt to map runlist, dropping lock for the\n\t\t\t * duration.\n\t\t\t */\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\tif (!ntfs_map_runlist(ni, vcn))\n\t\t\t\tgoto lock_retry_remap;\n\t\t\tgoto map_rl_err;\n\t\t}\n\t\tblock = lcn << vol->cluster_size_bits >> block_size_bits;\n\t\t/* Read the lcn from device in chunks of block_size bytes. */\n\t\tmax_block = block + (vol->cluster_size >> block_size_bits);\n\t\tdo {\n\t\t\tntfs_debug(\"block = 0x%x.\", block);\n\t\t\tif (unlikely(!(bhs[nr_bhs] = sb_getblk(sb, block))))\n\t\t\t\tgoto getblk_err;\n\t\t\tnr_bhs++;\n\t\t} while (++block < max_block);\n\t}\n\n\t/* Release the lock if we took it. */\n\tif (rl)\n\t\tup_read(&ni->runlist.lock);\n\n\t/* Setup and initiate io on all buffer heads. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tstruct buffer_head *tbh = bhs[i];\n\n\t\tif (!trylock_buffer(tbh))\n\t\t\tcontinue;\n\t\tif (unlikely(buffer_uptodate(tbh))) {\n\t\t\tunlock_buffer(tbh);\n\t\t\tcontinue;\n\t\t}\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, tbh);\n\t}\n\n\t/* Wait for io completion on all buffer heads. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tstruct buffer_head *tbh = bhs[i];\n\n\t\tif (buffer_uptodate(tbh))\n\t\t\tcontinue;\n\t\twait_on_buffer(tbh);\n\t\t/*\n\t\t * We need an optimization barrier here, otherwise we start\n\t\t * hitting the below fixup code when accessing a loopback\n\t\t * mounted ntfs partition. This indicates either there is a\n\t\t * race condition in the loop driver or, more likely, gcc\n\t\t * overoptimises the code without the barrier and it doesn't\n\t\t * do the Right Thing(TM).\n\t\t */\n\t\tbarrier();\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\tntfs_warning(vol->sb, \"Buffer is unlocked but not \"\n\t\t\t\t\t\"uptodate! Unplugging the disk queue \"\n\t\t\t\t\t\"and rescheduling.\");\n\t\t\tget_bh(tbh);\n\t\t\tio_schedule();\n\t\t\tput_bh(tbh);\n\t\t\tif (unlikely(!buffer_uptodate(tbh)))\n\t\t\t\tgoto read_err;\n\t\t\tntfs_warning(vol->sb, \"Buffer is now uptodate. Good.\");\n\t\t}\n\t}\n\n\t/*\n\t * Get the compression buffer. We must not sleep any more\n\t * until we are finished with it.\n\t */\n\tspin_lock(&ntfs_cb_lock);\n\tcb = ntfs_compression_buffer;\n\n\tBUG_ON(!cb);\n\n\tcb_pos = cb;\n\tcb_end = cb + cb_size;\n\n\t/* Copy the buffer heads into the contiguous buffer. */\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\tmemcpy(cb_pos, bhs[i]->b_data, block_size);\n\t\tcb_pos += block_size;\n\t}\n\n\t/* Just a precaution. */\n\tif (cb_pos + 2 <= cb + cb_size)\n\t\t*(u16*)cb_pos = 0;\n\n\t/* Reset cb_pos back to the beginning. */\n\tcb_pos = cb;\n\n\t/* We now have both source (if present) and destination. */\n\tntfs_debug(\"Successfully read the compression block.\");\n\n\t/* The last page and maximum offset within it for the current cb. */\n\tcb_max_page = (cur_page << PAGE_CACHE_SHIFT) + cur_ofs + cb_size;\n\tcb_max_ofs = cb_max_page & ~PAGE_CACHE_MASK;\n\tcb_max_page >>= PAGE_CACHE_SHIFT;\n\n\t/* Catch end of file inside a compression block. */\n\tif (cb_max_page > max_page)\n\t\tcb_max_page = max_page;\n\n\tif (vcn == start_vcn - cb_clusters) {\n\t\t/* Sparse cb, zero out page range overlapping the cb. */\n\t\tntfs_debug(\"Found sparse compression block.\");\n\t\t/* We can sleep from now on, so we drop lock. */\n\t\tspin_unlock(&ntfs_cb_lock);\n\t\tif (cb_max_ofs)\n\t\t\tcb_max_page--;\n\t\tfor (; cur_page < cb_max_page; cur_page++) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page) {\n\t\t\t\t/*\n\t\t\t\t * FIXME: Using clear_page() will become wrong\n\t\t\t\t * when we get PAGE_CACHE_SIZE != PAGE_SIZE but\n\t\t\t\t * for now there is no problem.\n\t\t\t\t */\n\t\t\t\tif (likely(!cur_ofs))\n\t\t\t\t\tclear_page(page_address(page));\n\t\t\t\telse\n\t\t\t\t\tmemset(page_address(page) + cur_ofs, 0,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE -\n\t\t\t\t\t\t\tcur_ofs);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tkunmap(page);\n\t\t\t\tSetPageUptodate(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tif (cur_page == xpage)\n\t\t\t\t\txpage_done = 1;\n\t\t\t\telse\n\t\t\t\t\tpage_cache_release(page);\n\t\t\t\tpages[cur_page] = NULL;\n\t\t\t}\n\t\t\tcb_pos += PAGE_CACHE_SIZE - cur_ofs;\n\t\t\tcur_ofs = 0;\n\t\t\tif (cb_pos >= cb_end)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* If we have a partial final page, deal with it now. */\n\t\tif (cb_max_ofs && cb_pos < cb_end) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page)\n\t\t\t\tmemset(page_address(page) + cur_ofs, 0,\n\t\t\t\t\t\tcb_max_ofs - cur_ofs);\n\t\t\t/*\n\t\t\t * No need to update cb_pos at this stage:\n\t\t\t *\tcb_pos += cb_max_ofs - cur_ofs;\n\t\t\t */\n\t\t\tcur_ofs = cb_max_ofs;\n\t\t}\n\t} else if (vcn == start_vcn) {\n\t\t/* We can't sleep so we need two stages. */\n\t\tunsigned int cur2_page = cur_page;\n\t\tunsigned int cur_ofs2 = cur_ofs;\n\t\tu8 *cb_pos2 = cb_pos;\n\n\t\tntfs_debug(\"Found uncompressed compression block.\");\n\t\t/* Uncompressed cb, copy it to the destination pages. */\n\t\t/*\n\t\t * TODO: As a big optimization, we could detect this case\n\t\t * before we read all the pages and use block_read_full_page()\n\t\t * on all full pages instead (we still have to treat partial\n\t\t * pages especially but at least we are getting rid of the\n\t\t * synchronous io for the majority of pages.\n\t\t * Or if we choose not to do the read-ahead/-behind stuff, we\n\t\t * could just return block_read_full_page(pages[xpage]) as long\n\t\t * as PAGE_CACHE_SIZE <= cb_size.\n\t\t */\n\t\tif (cb_max_ofs)\n\t\t\tcb_max_page--;\n\t\t/* First stage: copy data into destination pages. */\n\t\tfor (; cur_page < cb_max_page; cur_page++) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page)\n\t\t\t\tmemcpy(page_address(page) + cur_ofs, cb_pos,\n\t\t\t\t\t\tPAGE_CACHE_SIZE - cur_ofs);\n\t\t\tcb_pos += PAGE_CACHE_SIZE - cur_ofs;\n\t\t\tcur_ofs = 0;\n\t\t\tif (cb_pos >= cb_end)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* If we have a partial final page, deal with it now. */\n\t\tif (cb_max_ofs && cb_pos < cb_end) {\n\t\t\tpage = pages[cur_page];\n\t\t\tif (page)\n\t\t\t\tmemcpy(page_address(page) + cur_ofs, cb_pos,\n\t\t\t\t\t\tcb_max_ofs - cur_ofs);\n\t\t\tcb_pos += cb_max_ofs - cur_ofs;\n\t\t\tcur_ofs = cb_max_ofs;\n\t\t}\n\t\t/* We can sleep from now on, so drop lock. */\n\t\tspin_unlock(&ntfs_cb_lock);\n\t\t/* Second stage: finalize pages. */\n\t\tfor (; cur2_page < cb_max_page; cur2_page++) {\n\t\t\tpage = pages[cur2_page];\n\t\t\tif (page) {\n\t\t\t\t/*\n\t\t\t\t * If we are outside the initialized size, zero\n\t\t\t\t * the out of bounds page range.\n\t\t\t\t */\n\t\t\t\thandle_bounds_compressed_page(page, i_size,\n\t\t\t\t\t\tinitialized_size);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tkunmap(page);\n\t\t\t\tSetPageUptodate(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tif (cur2_page == xpage)\n\t\t\t\t\txpage_done = 1;\n\t\t\t\telse\n\t\t\t\t\tpage_cache_release(page);\n\t\t\t\tpages[cur2_page] = NULL;\n\t\t\t}\n\t\t\tcb_pos2 += PAGE_CACHE_SIZE - cur_ofs2;\n\t\t\tcur_ofs2 = 0;\n\t\t\tif (cb_pos2 >= cb_end)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/* Compressed cb, decompress it into the destination page(s). */\n\t\tunsigned int prev_cur_page = cur_page;\n\n\t\tntfs_debug(\"Found compressed compression block.\");\n\t\terr = ntfs_decompress(pages, &cur_page, &cur_ofs,\n\t\t\t\tcb_max_page, cb_max_ofs, xpage, &xpage_done,\n\t\t\t\tcb_pos,\tcb_size - (cb_pos - cb), i_size,\n\t\t\t\tinitialized_size);\n\t\t/*\n\t\t * We can sleep from now on, lock already dropped by\n\t\t * ntfs_decompress().\n\t\t */\n\t\tif (err) {\n\t\t\tntfs_error(vol->sb, \"ntfs_decompress() failed in inode \"\n\t\t\t\t\t\"0x%lx with error code %i. Skipping \"\n\t\t\t\t\t\"this compression block.\",\n\t\t\t\t\tni->mft_no, -err);\n\t\t\t/* Release the unfinished pages. */\n\t\t\tfor (; prev_cur_page < cur_page; prev_cur_page++) {\n\t\t\t\tpage = pages[prev_cur_page];\n\t\t\t\tif (page) {\n\t\t\t\t\tflush_dcache_page(page);\n\t\t\t\t\tkunmap(page);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (prev_cur_page != xpage)\n\t\t\t\t\t\tpage_cache_release(page);\n\t\t\t\t\tpages[prev_cur_page] = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Release the buffer heads. */\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\n\t/* Do we have more work to do? */\n\tif (nr_cbs)\n\t\tgoto do_next_cb;\n\n\t/* We no longer need the list of buffer heads. */\n\tkfree(bhs);\n\n\t/* Clean up if we have any pages left. Should never happen. */\n\tfor (cur_page = 0; cur_page < max_page; cur_page++) {\n\t\tpage = pages[cur_page];\n\t\tif (page) {\n\t\t\tntfs_error(vol->sb, \"Still have pages left! \"\n\t\t\t\t\t\"Terminating them with extreme \"\n\t\t\t\t\t\"prejudice.  Inode 0x%lx, page index \"\n\t\t\t\t\t\"0x%lx.\", ni->mft_no, page->index);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap(page);\n\t\t\tunlock_page(page);\n\t\t\tif (cur_page != xpage)\n\t\t\t\tpage_cache_release(page);\n\t\t\tpages[cur_page] = NULL;\n\t\t}\n\t}\n\n\t/* We no longer need the list of pages. */\n\tkfree(pages);\n\n\t/* If we have completed the requested page, we return success. */\n\tif (likely(xpage_done))\n\t\treturn 0;\n\n\tntfs_debug(\"Failed. Returning error code %s.\", err == -EOVERFLOW ?\n\t\t\t\"EOVERFLOW\" : (!err ? \"EIO\" : \"unknown error\"));\n\treturn err < 0 ? err : -EIO;\n\nread_err:\n\tntfs_error(vol->sb, \"IO error while reading compressed data.\");\n\t/* Release the buffer heads. */\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tgoto err_out;\n\nmap_rl_err:\n\tntfs_error(vol->sb, \"ntfs_map_runlist() failed. Cannot read \"\n\t\t\t\"compression block.\");\n\tgoto err_out;\n\nrl_err:\n\tup_read(&ni->runlist.lock);\n\tntfs_error(vol->sb, \"ntfs_rl_vcn_to_lcn() failed. Cannot read \"\n\t\t\t\"compression block.\");\n\tgoto err_out;\n\ngetblk_err:\n\tup_read(&ni->runlist.lock);\n\tntfs_error(vol->sb, \"getblk() failed. Cannot read compression block.\");\n\nerr_out:\n\tkfree(bhs);\n\tfor (i = cur_page; i < max_page; i++) {\n\t\tpage = pages[i];\n\t\tif (page) {\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap(page);\n\t\t\tunlock_page(page);\n\t\t\tif (i != xpage)\n\t\t\t\tpage_cache_release(page);\n\t\t}\n\t}\n\tkfree(pages);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ni->name_len"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ni->type != AT_DATA"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ni->type != AT_DATA"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoEncrypted",
          "args": [
            "ni"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Read outside i_size - truncated?\""
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->index >= (i_size + PAGE_CACHE_SIZE - 1) >>\n\t\t\tPAGE_CACHE_SHIFT"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"types.h\"\n#include \"runlist.h\"\n#include \"mft.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int ntfs_readpage(struct file *file, struct page *page)\n{\n\tloff_t i_size;\n\tstruct inode *vi;\n\tntfs_inode *ni, *base_ni;\n\tu8 *addr;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *mrec;\n\tunsigned long flags;\n\tu32 attr_len;\n\tint err = 0;\n\nretry_readpage:\n\tBUG_ON(!PageLocked(page));\n\tvi = page->mapping->host;\n\ti_size = i_size_read(vi);\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\tif (unlikely(page->index >= (i_size + PAGE_CACHE_SIZE - 1) >>\n\t\t\tPAGE_CACHE_SHIFT)) {\n\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\t\tntfs_debug(\"Read outside i_size - truncated?\");\n\t\tgoto done;\n\t}\n\t/*\n\t * This can potentially happen because we clear PageUptodate() during\n\t * ntfs_writepage() of MstProtected() attributes.\n\t */\n\tif (PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\tni = NTFS_I(vi);\n\t/*\n\t * Only $DATA attributes can be encrypted and only unnamed $DATA\n\t * attributes can be compressed.  Index root can have the flags set but\n\t * this means to create compressed/encrypted files, not that the\n\t * attribute is compressed/encrypted.  Note we need to check for\n\t * AT_INDEX_ALLOCATION since this is the type of both directory and\n\t * index inodes.\n\t */\n\tif (ni->type != AT_INDEX_ALLOCATION) {\n\t\t/* If attribute is encrypted, deny access, just like NT4. */\n\t\tif (NInoEncrypted(ni)) {\n\t\t\tBUG_ON(ni->type != AT_DATA);\n\t\t\terr = -EACCES;\n\t\t\tgoto err_out;\n\t\t}\n\t\t/* Compressed data streams are handled in compress.c. */\n\t\tif (NInoNonResident(ni) && NInoCompressed(ni)) {\n\t\t\tBUG_ON(ni->type != AT_DATA);\n\t\t\tBUG_ON(ni->name_len);\n\t\t\treturn ntfs_read_compressed_block(page);\n\t\t}\n\t}\n\t/* NInoNonResident() == NInoIndexAllocPresent() */\n\tif (NInoNonResident(ni)) {\n\t\t/* Normal, non-resident data stream. */\n\t\treturn ntfs_read_block(page);\n\t}\n\t/*\n\t * Attribute is resident, implying it is not compressed or encrypted.\n\t * This also means the attribute is smaller than an mft record and\n\t * hence smaller than a page, so can simply zero out any pages with\n\t * index above 0.  Note the attribute can actually be marked compressed\n\t * but if it is resident the actual data is not compressed so we are\n\t * ok to ignore the compressed flag here.\n\t */\n\tif (unlikely(page->index > 0)) {\n\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\t\tgoto done;\n\t}\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t/* Map, pin, and lock the mft record. */\n\tmrec = map_mft_record(base_ni);\n\tif (IS_ERR(mrec)) {\n\t\terr = PTR_ERR(mrec);\n\t\tgoto err_out;\n\t}\n\t/*\n\t * If a parallel write made the attribute non-resident, drop the mft\n\t * record and retry the readpage.\n\t */\n\tif (unlikely(NInoNonResident(ni))) {\n\t\tunmap_mft_record(base_ni);\n\t\tgoto retry_readpage;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, mrec);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err))\n\t\tgoto put_unm_err_out;\n\tattr_len = le32_to_cpu(ctx->attr->data.resident.value_length);\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tif (unlikely(attr_len > ni->initialized_size))\n\t\tattr_len = ni->initialized_size;\n\ti_size = i_size_read(vi);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (unlikely(attr_len > i_size)) {\n\t\t/* Race with shrinking truncate. */\n\t\tattr_len = i_size;\n\t}\n\taddr = kmap_atomic(page);\n\t/* Copy the data to the page. */\n\tmemcpy(addr, (u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset),\n\t\t\tattr_len);\n\t/* Zero the remainder of the page. */\n\tmemset(addr + attr_len, 0, PAGE_CACHE_SIZE - attr_len);\n\tflush_dcache_page(page);\n\tkunmap_atomic(addr);\nput_unm_err_out:\n\tntfs_attr_put_search_ctx(ctx);\nunm_err_out:\n\tunmap_mft_record(base_ni);\ndone:\n\tSetPageUptodate(page);\nerr_out:\n\tunlock_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_read_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.c",
    "lines": "184-378",
    "snippet": "static int ntfs_read_block(struct page *page)\n{\n\tloff_t i_size;\n\tVCN vcn;\n\tLCN lcn;\n\ts64 init_size;\n\tstruct inode *vi;\n\tntfs_inode *ni;\n\tntfs_volume *vol;\n\trunlist_element *rl;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tsector_t iblock, lblock, zblock;\n\tunsigned long flags;\n\tunsigned int blocksize, vcn_ofs;\n\tint i, nr;\n\tunsigned char blocksize_bits;\n\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\tvol = ni->vol;\n\n\t/* $MFT/$DATA must have its complete runlist in memory at all times. */\n\tBUG_ON(!ni->runlist.rl && !ni->mft_no && !NInoAttr(ni));\n\n\tblocksize = vol->sb->s_blocksize;\n\tblocksize_bits = vol->sb->s_blocksize_bits;\n\n\tif (!page_has_buffers(page)) {\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\t\tif (unlikely(!page_has_buffers(page))) {\n\t\t\tunlock_page(page);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\n\t/*\n\t * We may be racing with truncate.  To avoid some of the problems we\n\t * now take a snapshot of the various sizes and use those for the whole\n\t * of the function.  In case of an extending truncate it just means we\n\t * may leave some buffers unmapped which are now allocated.  This is\n\t * not a problem since these buffers will just get mapped when a write\n\t * occurs.  In case of a shrinking truncate, we will detect this later\n\t * on due to the runlist being incomplete and if the page is being\n\t * fully truncated, truncate will throw it away as soon as we unlock\n\t * it so no need to worry what we do with it.\n\t */\n\tiblock = (s64)page->index << (PAGE_CACHE_SHIFT - blocksize_bits);\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tlblock = (ni->allocated_size + blocksize - 1) >> blocksize_bits;\n\tinit_size = ni->initialized_size;\n\ti_size = i_size_read(vi);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (unlikely(init_size > i_size)) {\n\t\t/* Race with shrinking truncate. */\n\t\tinit_size = i_size;\n\t}\n\tzblock = (init_size + blocksize - 1) >> blocksize_bits;\n\n\t/* Loop through all the buffers in the page. */\n\trl = NULL;\n\tnr = i = 0;\n\tdo {\n\t\tint err = 0;\n\n\t\tif (unlikely(buffer_uptodate(bh)))\n\t\t\tcontinue;\n\t\tif (unlikely(buffer_mapped(bh))) {\n\t\t\tarr[nr++] = bh;\n\t\t\tcontinue;\n\t\t}\n\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t/* Is the block within the allowed limits? */\n\t\tif (iblock < lblock) {\n\t\t\tbool is_retry = false;\n\n\t\t\t/* Convert iblock into corresponding vcn and offset. */\n\t\t\tvcn = (VCN)iblock << blocksize_bits >>\n\t\t\t\t\tvol->cluster_size_bits;\n\t\t\tvcn_ofs = ((VCN)iblock << blocksize_bits) &\n\t\t\t\t\tvol->cluster_size_mask;\n\t\t\tif (!rl) {\nlock_retry_remap:\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\trl = ni->runlist.rl;\n\t\t\t}\n\t\t\tif (likely(rl != NULL)) {\n\t\t\t\t/* Seek to element containing target vcn. */\n\t\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\t\trl++;\n\t\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t} else\n\t\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t\t/* Successful remap. */\n\t\t\tif (lcn >= 0) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn << vol->cluster_size_bits)\n\t\t\t\t\t\t+ vcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t\t/* Only read initialized data blocks. */\n\t\t\t\tif (iblock < zblock) {\n\t\t\t\t\tarr[nr++] = bh;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Fully non-initialized data block, zero it. */\n\t\t\t\tgoto handle_zblock;\n\t\t\t}\n\t\t\t/* It is a hole, need to zero it. */\n\t\t\tif (lcn == LCN_HOLE)\n\t\t\t\tgoto handle_hole;\n\t\t\t/* If first try and runlist unmapped, map and retry. */\n\t\t\tif (!is_retry && lcn == LCN_RL_NOT_MAPPED) {\n\t\t\t\tis_retry = true;\n\t\t\t\t/*\n\t\t\t\t * Attempt to map runlist, dropping lock for\n\t\t\t\t * the duration.\n\t\t\t\t */\n\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\terr = ntfs_map_runlist(ni, vcn);\n\t\t\t\tif (likely(!err))\n\t\t\t\t\tgoto lock_retry_remap;\n\t\t\t\trl = NULL;\n\t\t\t} else if (!rl)\n\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t/*\n\t\t\t * If buffer is outside the runlist, treat it as a\n\t\t\t * hole.  This can happen due to concurrent truncate\n\t\t\t * for example.\n\t\t\t */\n\t\t\tif (err == -ENOENT || lcn == LCN_ENOENT) {\n\t\t\t\terr = 0;\n\t\t\t\tgoto handle_hole;\n\t\t\t}\n\t\t\t/* Hard error, zero out region. */\n\t\t\tif (!err)\n\t\t\t\terr = -EIO;\n\t\t\tbh->b_blocknr = -1;\n\t\t\tSetPageError(page);\n\t\t\tntfs_error(vol->sb, \"Failed to read from inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, vcn 0x%llx, \"\n\t\t\t\t\t\"offset 0x%x because its location on \"\n\t\t\t\t\t\"disk could not be determined%s \"\n\t\t\t\t\t\"(error code %i).\", ni->mft_no,\n\t\t\t\t\tni->type, (unsigned long long)vcn,\n\t\t\t\t\tvcn_ofs, is_retry ? \" even after \"\n\t\t\t\t\t\"retrying\" : \"\", err);\n\t\t}\n\t\t/*\n\t\t * Either iblock was outside lblock limits or\n\t\t * ntfs_rl_vcn_to_lcn() returned error.  Just zero that portion\n\t\t * of the page and set the buffer uptodate.\n\t\t */\nhandle_hole:\n\t\tbh->b_blocknr = -1UL;\n\t\tclear_buffer_mapped(bh);\nhandle_zblock:\n\t\tzero_user(page, i * blocksize, blocksize);\n\t\tif (likely(!err))\n\t\t\tset_buffer_uptodate(bh);\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\t/* Release the lock if we took it. */\n\tif (rl)\n\t\tup_read(&ni->runlist.lock);\n\n\t/* Check we have at least one buffer ready for i/o. */\n\tif (nr) {\n\t\tstruct buffer_head *tbh;\n\n\t\t/* Lock the buffers. */\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\ttbh = arr[i];\n\t\t\tlock_buffer(tbh);\n\t\t\ttbh->b_end_io = ntfs_end_buffer_async_read;\n\t\t\tset_buffer_async_read(tbh);\n\t\t}\n\t\t/* Finally, start i/o on the buffers. */\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\ttbh = arr[i];\n\t\t\tif (likely(!buffer_uptodate(tbh)))\n\t\t\t\tsubmit_bh(READ, tbh);\n\t\t\telse\n\t\t\t\tntfs_end_buffer_async_read(tbh, 1);\n\t\t}\n\t\treturn 0;\n\t}\n\t/* No i/o was scheduled on any of the buffers. */\n\tif (likely(!PageError(page)))\n\t\tSetPageUptodate(page);\n\telse /* Signal synchronous i/o error. */\n\t\tnr = -EIO;\n\tunlock_page(page);\n\treturn nr;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"types.h\"",
      "#include \"runlist.h\"",
      "#include \"mft.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!PageError(page)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_end_buffer_async_read",
          "args": [
            "tbh",
            "1"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_end_buffer_async_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.c",
          "lines": "58-165",
          "snippet": "static void ntfs_end_buffer_async_read(struct buffer_head *bh, int uptodate)\n{\n\tunsigned long flags;\n\tstruct buffer_head *first, *tmp;\n\tstruct page *page;\n\tstruct inode *vi;\n\tntfs_inode *ni;\n\tint page_uptodate = 1;\n\n\tpage = bh->b_page;\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\n\tif (likely(uptodate)) {\n\t\tloff_t i_size;\n\t\ts64 file_ofs, init_size;\n\n\t\tset_buffer_uptodate(bh);\n\n\t\tfile_ofs = ((s64)page->index << PAGE_CACHE_SHIFT) +\n\t\t\t\tbh_offset(bh);\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tinit_size = ni->initialized_size;\n\t\ti_size = i_size_read(vi);\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (unlikely(init_size > i_size)) {\n\t\t\t/* Race with shrinking truncate. */\n\t\t\tinit_size = i_size;\n\t\t}\n\t\t/* Check for the current buffer head overflowing. */\n\t\tif (unlikely(file_ofs + bh->b_size > init_size)) {\n\t\t\tint ofs;\n\t\t\tvoid *kaddr;\n\n\t\t\tofs = 0;\n\t\t\tif (file_ofs < init_size)\n\t\t\t\tofs = init_size - file_ofs;\n\t\t\tlocal_irq_save(flags);\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tmemset(kaddr + bh_offset(bh) + ofs, 0,\n\t\t\t\t\tbh->b_size - ofs);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tlocal_irq_restore(flags);\n\t\t}\n\t} else {\n\t\tclear_buffer_uptodate(bh);\n\t\tSetPageError(page);\n\t\tntfs_error(ni->vol->sb, \"Buffer I/O error, logical block \"\n\t\t\t\t\"0x%llx.\", (unsigned long long)bh->b_blocknr);\n\t}\n\tfirst = page_buffers(page);\n\tlocal_irq_save(flags);\n\tbit_spin_lock(BH_Uptodate_Lock, &first->b_state);\n\tclear_buffer_async_read(bh);\n\tunlock_buffer(bh);\n\ttmp = bh;\n\tdo {\n\t\tif (!buffer_uptodate(tmp))\n\t\t\tpage_uptodate = 0;\n\t\tif (buffer_async_read(tmp)) {\n\t\t\tif (likely(buffer_locked(tmp)))\n\t\t\t\tgoto still_busy;\n\t\t\t/* Async buffers must be locked. */\n\t\t\tBUG();\n\t\t}\n\t\ttmp = tmp->b_this_page;\n\t} while (tmp != bh);\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\t/*\n\t * If none of the buffers had errors then we can set the page uptodate,\n\t * but we first have to perform the post read mst fixups, if the\n\t * attribute is mst protected, i.e. if NInoMstProteced(ni) is true.\n\t * Note we ignore fixup errors as those are detected when\n\t * map_mft_record() is called which gives us per record granularity\n\t * rather than per page granularity.\n\t */\n\tif (!NInoMstProtected(ni)) {\n\t\tif (likely(page_uptodate && !PageError(page)))\n\t\t\tSetPageUptodate(page);\n\t} else {\n\t\tu8 *kaddr;\n\t\tunsigned int i, recs;\n\t\tu32 rec_size;\n\n\t\trec_size = ni->itype.index.block_size;\n\t\trecs = PAGE_CACHE_SIZE / rec_size;\n\t\t/* Should have been verified before we got here... */\n\t\tBUG_ON(!recs);\n\t\tlocal_irq_save(flags);\n\t\tkaddr = kmap_atomic(page);\n\t\tfor (i = 0; i < recs; i++)\n\t\t\tpost_read_mst_fixup((NTFS_RECORD*)(kaddr +\n\t\t\t\t\ti * rec_size), rec_size);\n\t\tkunmap_atomic(kaddr);\n\t\tlocal_irq_restore(flags);\n\t\tflush_dcache_page(page);\n\t\tif (likely(page_uptodate && !PageError(page)))\n\t\t\tSetPageUptodate(page);\n\t}\n\tunlock_page(page);\n\treturn;\nstill_busy:\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"types.h\"",
            "#include \"runlist.h\"",
            "#include \"mft.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"types.h\"\n#include \"runlist.h\"\n#include \"mft.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic void ntfs_end_buffer_async_read(struct buffer_head *bh, int uptodate)\n{\n\tunsigned long flags;\n\tstruct buffer_head *first, *tmp;\n\tstruct page *page;\n\tstruct inode *vi;\n\tntfs_inode *ni;\n\tint page_uptodate = 1;\n\n\tpage = bh->b_page;\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\n\tif (likely(uptodate)) {\n\t\tloff_t i_size;\n\t\ts64 file_ofs, init_size;\n\n\t\tset_buffer_uptodate(bh);\n\n\t\tfile_ofs = ((s64)page->index << PAGE_CACHE_SHIFT) +\n\t\t\t\tbh_offset(bh);\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tinit_size = ni->initialized_size;\n\t\ti_size = i_size_read(vi);\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (unlikely(init_size > i_size)) {\n\t\t\t/* Race with shrinking truncate. */\n\t\t\tinit_size = i_size;\n\t\t}\n\t\t/* Check for the current buffer head overflowing. */\n\t\tif (unlikely(file_ofs + bh->b_size > init_size)) {\n\t\t\tint ofs;\n\t\t\tvoid *kaddr;\n\n\t\t\tofs = 0;\n\t\t\tif (file_ofs < init_size)\n\t\t\t\tofs = init_size - file_ofs;\n\t\t\tlocal_irq_save(flags);\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tmemset(kaddr + bh_offset(bh) + ofs, 0,\n\t\t\t\t\tbh->b_size - ofs);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tlocal_irq_restore(flags);\n\t\t}\n\t} else {\n\t\tclear_buffer_uptodate(bh);\n\t\tSetPageError(page);\n\t\tntfs_error(ni->vol->sb, \"Buffer I/O error, logical block \"\n\t\t\t\t\"0x%llx.\", (unsigned long long)bh->b_blocknr);\n\t}\n\tfirst = page_buffers(page);\n\tlocal_irq_save(flags);\n\tbit_spin_lock(BH_Uptodate_Lock, &first->b_state);\n\tclear_buffer_async_read(bh);\n\tunlock_buffer(bh);\n\ttmp = bh;\n\tdo {\n\t\tif (!buffer_uptodate(tmp))\n\t\t\tpage_uptodate = 0;\n\t\tif (buffer_async_read(tmp)) {\n\t\t\tif (likely(buffer_locked(tmp)))\n\t\t\t\tgoto still_busy;\n\t\t\t/* Async buffers must be locked. */\n\t\t\tBUG();\n\t\t}\n\t\ttmp = tmp->b_this_page;\n\t} while (tmp != bh);\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\t/*\n\t * If none of the buffers had errors then we can set the page uptodate,\n\t * but we first have to perform the post read mst fixups, if the\n\t * attribute is mst protected, i.e. if NInoMstProteced(ni) is true.\n\t * Note we ignore fixup errors as those are detected when\n\t * map_mft_record() is called which gives us per record granularity\n\t * rather than per page granularity.\n\t */\n\tif (!NInoMstProtected(ni)) {\n\t\tif (likely(page_uptodate && !PageError(page)))\n\t\t\tSetPageUptodate(page);\n\t} else {\n\t\tu8 *kaddr;\n\t\tunsigned int i, recs;\n\t\tu32 rec_size;\n\n\t\trec_size = ni->itype.index.block_size;\n\t\trecs = PAGE_CACHE_SIZE / rec_size;\n\t\t/* Should have been verified before we got here... */\n\t\tBUG_ON(!recs);\n\t\tlocal_irq_save(flags);\n\t\tkaddr = kmap_atomic(page);\n\t\tfor (i = 0; i < recs; i++)\n\t\t\tpost_read_mst_fixup((NTFS_RECORD*)(kaddr +\n\t\t\t\t\ti * rec_size), rec_size);\n\t\tkunmap_atomic(kaddr);\n\t\tlocal_irq_restore(flags);\n\t\tflush_dcache_page(page);\n\t\tif (likely(page_uptodate && !PageError(page)))\n\t\t\tSetPageUptodate(page);\n\t}\n\tunlock_page(page);\n\treturn;\nstill_busy:\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "READ",
            "tbh"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!buffer_uptodate(tbh)"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "tbh"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_async_read",
          "args": [
            "tbh"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "tbh"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "i * blocksize",
            "blocksize"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to read from inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, vcn 0x%llx, \"\n\t\t\t\t\t\"offset 0x%x because its location on \"\n\t\t\t\t\t\"disk could not be determined%s \"\n\t\t\t\t\t\"(error code %i).\"",
            "ni->mft_no",
            "ni->type",
            "(unsigned long long)vcn",
            "vcn_ofs",
            "is_retry ? \" even after \"\n\t\t\t\t\t\"retrying\" : \"\"",
            "err"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_runlist",
          "args": [
            "ni",
            "vcn"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "298-309",
          "snippet": "int ntfs_map_runlist(ntfs_inode *ni, VCN vcn)\n{\n\tint err = 0;\n\n\tdown_write(&ni->runlist.lock);\n\t/* Make sure someone else didn't do the work while we were sleeping. */\n\tif (likely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) <=\n\t\t\tLCN_RL_NOT_MAPPED))\n\t\terr = ntfs_map_runlist_nolock(ni, vcn, NULL);\n\tup_write(&ni->runlist.lock);\n\treturn err;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_map_runlist(ntfs_inode *ni, VCN vcn)\n{\n\tint err = 0;\n\n\tdown_write(&ni->runlist.lock);\n\t/* Make sure someone else didn't do the work while we were sleeping. */\n\tif (likely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) <=\n\t\t\tLCN_RL_NOT_MAPPED))\n\t\terr = ntfs_map_runlist_nolock(ni, vcn, NULL);\n\tup_write(&ni->runlist.lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_vcn_to_lcn",
          "args": [
            "rl",
            "vcn"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_vcn_to_lcn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1004-1036",
          "snippet": "LCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nLCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl != NULL"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "buffer_mapped(bh)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "buffer_uptodate(bh)"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "init_size > i_size"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bh"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_has_buffers(page)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "blocksize",
            "0"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ni->runlist.rl && !ni->mft_no && !NInoAttr(ni)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"types.h\"\n#include \"runlist.h\"\n#include \"mft.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int ntfs_read_block(struct page *page)\n{\n\tloff_t i_size;\n\tVCN vcn;\n\tLCN lcn;\n\ts64 init_size;\n\tstruct inode *vi;\n\tntfs_inode *ni;\n\tntfs_volume *vol;\n\trunlist_element *rl;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tsector_t iblock, lblock, zblock;\n\tunsigned long flags;\n\tunsigned int blocksize, vcn_ofs;\n\tint i, nr;\n\tunsigned char blocksize_bits;\n\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\tvol = ni->vol;\n\n\t/* $MFT/$DATA must have its complete runlist in memory at all times. */\n\tBUG_ON(!ni->runlist.rl && !ni->mft_no && !NInoAttr(ni));\n\n\tblocksize = vol->sb->s_blocksize;\n\tblocksize_bits = vol->sb->s_blocksize_bits;\n\n\tif (!page_has_buffers(page)) {\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\t\tif (unlikely(!page_has_buffers(page))) {\n\t\t\tunlock_page(page);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\n\t/*\n\t * We may be racing with truncate.  To avoid some of the problems we\n\t * now take a snapshot of the various sizes and use those for the whole\n\t * of the function.  In case of an extending truncate it just means we\n\t * may leave some buffers unmapped which are now allocated.  This is\n\t * not a problem since these buffers will just get mapped when a write\n\t * occurs.  In case of a shrinking truncate, we will detect this later\n\t * on due to the runlist being incomplete and if the page is being\n\t * fully truncated, truncate will throw it away as soon as we unlock\n\t * it so no need to worry what we do with it.\n\t */\n\tiblock = (s64)page->index << (PAGE_CACHE_SHIFT - blocksize_bits);\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tlblock = (ni->allocated_size + blocksize - 1) >> blocksize_bits;\n\tinit_size = ni->initialized_size;\n\ti_size = i_size_read(vi);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (unlikely(init_size > i_size)) {\n\t\t/* Race with shrinking truncate. */\n\t\tinit_size = i_size;\n\t}\n\tzblock = (init_size + blocksize - 1) >> blocksize_bits;\n\n\t/* Loop through all the buffers in the page. */\n\trl = NULL;\n\tnr = i = 0;\n\tdo {\n\t\tint err = 0;\n\n\t\tif (unlikely(buffer_uptodate(bh)))\n\t\t\tcontinue;\n\t\tif (unlikely(buffer_mapped(bh))) {\n\t\t\tarr[nr++] = bh;\n\t\t\tcontinue;\n\t\t}\n\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t/* Is the block within the allowed limits? */\n\t\tif (iblock < lblock) {\n\t\t\tbool is_retry = false;\n\n\t\t\t/* Convert iblock into corresponding vcn and offset. */\n\t\t\tvcn = (VCN)iblock << blocksize_bits >>\n\t\t\t\t\tvol->cluster_size_bits;\n\t\t\tvcn_ofs = ((VCN)iblock << blocksize_bits) &\n\t\t\t\t\tvol->cluster_size_mask;\n\t\t\tif (!rl) {\nlock_retry_remap:\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\trl = ni->runlist.rl;\n\t\t\t}\n\t\t\tif (likely(rl != NULL)) {\n\t\t\t\t/* Seek to element containing target vcn. */\n\t\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\t\trl++;\n\t\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t} else\n\t\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t\t/* Successful remap. */\n\t\t\tif (lcn >= 0) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn << vol->cluster_size_bits)\n\t\t\t\t\t\t+ vcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t\t/* Only read initialized data blocks. */\n\t\t\t\tif (iblock < zblock) {\n\t\t\t\t\tarr[nr++] = bh;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Fully non-initialized data block, zero it. */\n\t\t\t\tgoto handle_zblock;\n\t\t\t}\n\t\t\t/* It is a hole, need to zero it. */\n\t\t\tif (lcn == LCN_HOLE)\n\t\t\t\tgoto handle_hole;\n\t\t\t/* If first try and runlist unmapped, map and retry. */\n\t\t\tif (!is_retry && lcn == LCN_RL_NOT_MAPPED) {\n\t\t\t\tis_retry = true;\n\t\t\t\t/*\n\t\t\t\t * Attempt to map runlist, dropping lock for\n\t\t\t\t * the duration.\n\t\t\t\t */\n\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\terr = ntfs_map_runlist(ni, vcn);\n\t\t\t\tif (likely(!err))\n\t\t\t\t\tgoto lock_retry_remap;\n\t\t\t\trl = NULL;\n\t\t\t} else if (!rl)\n\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t/*\n\t\t\t * If buffer is outside the runlist, treat it as a\n\t\t\t * hole.  This can happen due to concurrent truncate\n\t\t\t * for example.\n\t\t\t */\n\t\t\tif (err == -ENOENT || lcn == LCN_ENOENT) {\n\t\t\t\terr = 0;\n\t\t\t\tgoto handle_hole;\n\t\t\t}\n\t\t\t/* Hard error, zero out region. */\n\t\t\tif (!err)\n\t\t\t\terr = -EIO;\n\t\t\tbh->b_blocknr = -1;\n\t\t\tSetPageError(page);\n\t\t\tntfs_error(vol->sb, \"Failed to read from inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, vcn 0x%llx, \"\n\t\t\t\t\t\"offset 0x%x because its location on \"\n\t\t\t\t\t\"disk could not be determined%s \"\n\t\t\t\t\t\"(error code %i).\", ni->mft_no,\n\t\t\t\t\tni->type, (unsigned long long)vcn,\n\t\t\t\t\tvcn_ofs, is_retry ? \" even after \"\n\t\t\t\t\t\"retrying\" : \"\", err);\n\t\t}\n\t\t/*\n\t\t * Either iblock was outside lblock limits or\n\t\t * ntfs_rl_vcn_to_lcn() returned error.  Just zero that portion\n\t\t * of the page and set the buffer uptodate.\n\t\t */\nhandle_hole:\n\t\tbh->b_blocknr = -1UL;\n\t\tclear_buffer_mapped(bh);\nhandle_zblock:\n\t\tzero_user(page, i * blocksize, blocksize);\n\t\tif (likely(!err))\n\t\t\tset_buffer_uptodate(bh);\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\t/* Release the lock if we took it. */\n\tif (rl)\n\t\tup_read(&ni->runlist.lock);\n\n\t/* Check we have at least one buffer ready for i/o. */\n\tif (nr) {\n\t\tstruct buffer_head *tbh;\n\n\t\t/* Lock the buffers. */\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\ttbh = arr[i];\n\t\t\tlock_buffer(tbh);\n\t\t\ttbh->b_end_io = ntfs_end_buffer_async_read;\n\t\t\tset_buffer_async_read(tbh);\n\t\t}\n\t\t/* Finally, start i/o on the buffers. */\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\ttbh = arr[i];\n\t\t\tif (likely(!buffer_uptodate(tbh)))\n\t\t\t\tsubmit_bh(READ, tbh);\n\t\t\telse\n\t\t\t\tntfs_end_buffer_async_read(tbh, 1);\n\t\t}\n\t\treturn 0;\n\t}\n\t/* No i/o was scheduled on any of the buffers. */\n\tif (likely(!PageError(page)))\n\t\tSetPageUptodate(page);\n\telse /* Signal synchronous i/o error. */\n\t\tnr = -EIO;\n\tunlock_page(page);\n\treturn nr;\n}"
  },
  {
    "function_name": "ntfs_end_buffer_async_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.c",
    "lines": "58-165",
    "snippet": "static void ntfs_end_buffer_async_read(struct buffer_head *bh, int uptodate)\n{\n\tunsigned long flags;\n\tstruct buffer_head *first, *tmp;\n\tstruct page *page;\n\tstruct inode *vi;\n\tntfs_inode *ni;\n\tint page_uptodate = 1;\n\n\tpage = bh->b_page;\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\n\tif (likely(uptodate)) {\n\t\tloff_t i_size;\n\t\ts64 file_ofs, init_size;\n\n\t\tset_buffer_uptodate(bh);\n\n\t\tfile_ofs = ((s64)page->index << PAGE_CACHE_SHIFT) +\n\t\t\t\tbh_offset(bh);\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tinit_size = ni->initialized_size;\n\t\ti_size = i_size_read(vi);\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (unlikely(init_size > i_size)) {\n\t\t\t/* Race with shrinking truncate. */\n\t\t\tinit_size = i_size;\n\t\t}\n\t\t/* Check for the current buffer head overflowing. */\n\t\tif (unlikely(file_ofs + bh->b_size > init_size)) {\n\t\t\tint ofs;\n\t\t\tvoid *kaddr;\n\n\t\t\tofs = 0;\n\t\t\tif (file_ofs < init_size)\n\t\t\t\tofs = init_size - file_ofs;\n\t\t\tlocal_irq_save(flags);\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tmemset(kaddr + bh_offset(bh) + ofs, 0,\n\t\t\t\t\tbh->b_size - ofs);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tlocal_irq_restore(flags);\n\t\t}\n\t} else {\n\t\tclear_buffer_uptodate(bh);\n\t\tSetPageError(page);\n\t\tntfs_error(ni->vol->sb, \"Buffer I/O error, logical block \"\n\t\t\t\t\"0x%llx.\", (unsigned long long)bh->b_blocknr);\n\t}\n\tfirst = page_buffers(page);\n\tlocal_irq_save(flags);\n\tbit_spin_lock(BH_Uptodate_Lock, &first->b_state);\n\tclear_buffer_async_read(bh);\n\tunlock_buffer(bh);\n\ttmp = bh;\n\tdo {\n\t\tif (!buffer_uptodate(tmp))\n\t\t\tpage_uptodate = 0;\n\t\tif (buffer_async_read(tmp)) {\n\t\t\tif (likely(buffer_locked(tmp)))\n\t\t\t\tgoto still_busy;\n\t\t\t/* Async buffers must be locked. */\n\t\t\tBUG();\n\t\t}\n\t\ttmp = tmp->b_this_page;\n\t} while (tmp != bh);\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\t/*\n\t * If none of the buffers had errors then we can set the page uptodate,\n\t * but we first have to perform the post read mst fixups, if the\n\t * attribute is mst protected, i.e. if NInoMstProteced(ni) is true.\n\t * Note we ignore fixup errors as those are detected when\n\t * map_mft_record() is called which gives us per record granularity\n\t * rather than per page granularity.\n\t */\n\tif (!NInoMstProtected(ni)) {\n\t\tif (likely(page_uptodate && !PageError(page)))\n\t\t\tSetPageUptodate(page);\n\t} else {\n\t\tu8 *kaddr;\n\t\tunsigned int i, recs;\n\t\tu32 rec_size;\n\n\t\trec_size = ni->itype.index.block_size;\n\t\trecs = PAGE_CACHE_SIZE / rec_size;\n\t\t/* Should have been verified before we got here... */\n\t\tBUG_ON(!recs);\n\t\tlocal_irq_save(flags);\n\t\tkaddr = kmap_atomic(page);\n\t\tfor (i = 0; i < recs; i++)\n\t\t\tpost_read_mst_fixup((NTFS_RECORD*)(kaddr +\n\t\t\t\t\ti * rec_size), rec_size);\n\t\tkunmap_atomic(kaddr);\n\t\tlocal_irq_restore(flags);\n\t\tflush_dcache_page(page);\n\t\tif (likely(page_uptodate && !PageError(page)))\n\t\t\tSetPageUptodate(page);\n\t}\n\tunlock_page(page);\n\treturn;\nstill_busy:\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\treturn;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"types.h\"",
      "#include \"runlist.h\"",
      "#include \"mft.h\"",
      "#include \"inode.h\"",
      "#include \"debug.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_spin_unlock",
          "args": [
            "BH_Uptodate_Lock",
            "&first->b_state"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "page_uptodate && !PageError(page)"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "post_read_mst_fixup",
          "args": [
            "(NTFS_RECORD*)(kaddr +\n\t\t\t\t\ti * rec_size)",
            "rec_size"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "post_read_mst_fixup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mst.c",
          "lines": "42-100",
          "snippet": "int post_read_mst_fixup(NTFS_RECORD *b, const u32 size)\n{\n\tu16 usa_ofs, usa_count, usn;\n\tu16 *usa_pos, *data_pos;\n\n\t/* Setup the variables. */\n\tusa_ofs = le16_to_cpu(b->usa_ofs);\n\t/* Decrement usa_count to get number of fixups. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\t/* Size and alignment checks. */\n\tif ( size & (NTFS_BLOCK_SIZE - 1)\t||\n\t     usa_ofs & 1\t\t\t||\n\t     usa_ofs + (usa_count * 2) > size\t||\n\t     (size >> NTFS_BLOCK_SIZE_BITS) != usa_count)\n\t\treturn 0;\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (u16*)b + usa_ofs/sizeof(u16);\n\t/*\n\t * The update sequence number which has to be equal to each of the\n\t * u16 values before they are fixed up. Note no need to care for\n\t * endianness since we are comparing and moving data for on disk\n\t * structures which means the data is consistent. - If it is\n\t * consistenty the wrong endianness it doesn't make any difference.\n\t */\n\tusn = *usa_pos;\n\t/*\n\t * Position in protected data of first u16 that needs fixing up.\n\t */\n\tdata_pos = (u16*)b + NTFS_BLOCK_SIZE/sizeof(u16) - 1;\n\t/*\n\t * Check for incomplete multi sector transfer(s).\n\t */\n\twhile (usa_count--) {\n\t\tif (*data_pos != usn) {\n\t\t\t/*\n\t\t\t * Incomplete multi sector transfer detected! )-:\n\t\t\t * Set the magic to \"BAAD\" and return failure.\n\t\t\t * Note that magic_BAAD is already converted to le32.\n\t\t\t */\n\t\t\tb->magic = magic_BAAD;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(u16);\n\t}\n\t/* Re-setup the variables. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\tdata_pos = (u16*)b + NTFS_BLOCK_SIZE/sizeof(u16) - 1;\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment position in usa and restore original data from\n\t\t * the usa into the data buffer.\n\t\t */\n\t\t*data_pos = *(++usa_pos);\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(u16);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ntfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n\nint post_read_mst_fixup(NTFS_RECORD *b, const u32 size)\n{\n\tu16 usa_ofs, usa_count, usn;\n\tu16 *usa_pos, *data_pos;\n\n\t/* Setup the variables. */\n\tusa_ofs = le16_to_cpu(b->usa_ofs);\n\t/* Decrement usa_count to get number of fixups. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\t/* Size and alignment checks. */\n\tif ( size & (NTFS_BLOCK_SIZE - 1)\t||\n\t     usa_ofs & 1\t\t\t||\n\t     usa_ofs + (usa_count * 2) > size\t||\n\t     (size >> NTFS_BLOCK_SIZE_BITS) != usa_count)\n\t\treturn 0;\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (u16*)b + usa_ofs/sizeof(u16);\n\t/*\n\t * The update sequence number which has to be equal to each of the\n\t * u16 values before they are fixed up. Note no need to care for\n\t * endianness since we are comparing and moving data for on disk\n\t * structures which means the data is consistent. - If it is\n\t * consistenty the wrong endianness it doesn't make any difference.\n\t */\n\tusn = *usa_pos;\n\t/*\n\t * Position in protected data of first u16 that needs fixing up.\n\t */\n\tdata_pos = (u16*)b + NTFS_BLOCK_SIZE/sizeof(u16) - 1;\n\t/*\n\t * Check for incomplete multi sector transfer(s).\n\t */\n\twhile (usa_count--) {\n\t\tif (*data_pos != usn) {\n\t\t\t/*\n\t\t\t * Incomplete multi sector transfer detected! )-:\n\t\t\t * Set the magic to \"BAAD\" and return failure.\n\t\t\t * Note that magic_BAAD is already converted to le32.\n\t\t\t */\n\t\t\tb->magic = magic_BAAD;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(u16);\n\t}\n\t/* Re-setup the variables. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\tdata_pos = (u16*)b + NTFS_BLOCK_SIZE/sizeof(u16) - 1;\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment position in usa and restore original data from\n\t\t * the usa into the data buffer.\n\t\t */\n\t\t*data_pos = *(++usa_pos);\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(u16);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!recs"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "page_uptodate && !PageError(page)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoMstProtected",
          "args": [
            "ni"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_spin_unlock",
          "args": [
            "BH_Uptodate_Lock",
            "&first->b_state"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "buffer_locked(tmp)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "tmp"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_async_read",
          "args": [
            "tmp"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_async_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "407-411",
          "snippet": "static void mark_buffer_async_read(struct buffer_head *bh)\n{\n\tbh->b_end_io = end_buffer_async_read;\n\tset_buffer_async_read(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void mark_buffer_async_read(struct buffer_head *bh)\n{\n\tbh->b_end_io = end_buffer_async_read;\n\tset_buffer_async_read(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "tmp"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_async_read",
          "args": [
            "bh"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_spin_lock",
          "args": [
            "BH_Uptodate_Lock",
            "&first->b_state"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "ni->vol->sb",
            "\"Buffer I/O error, logical block \"\n\t\t\t\t\"0x%llx.\"",
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr + bh_offset(bh) + ofs",
            "0",
            "bh->b_size - ofs"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "file_ofs + bh->b_size > init_size"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "init_size > i_size"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "uptodate"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"types.h\"\n#include \"runlist.h\"\n#include \"mft.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic void ntfs_end_buffer_async_read(struct buffer_head *bh, int uptodate)\n{\n\tunsigned long flags;\n\tstruct buffer_head *first, *tmp;\n\tstruct page *page;\n\tstruct inode *vi;\n\tntfs_inode *ni;\n\tint page_uptodate = 1;\n\n\tpage = bh->b_page;\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\n\tif (likely(uptodate)) {\n\t\tloff_t i_size;\n\t\ts64 file_ofs, init_size;\n\n\t\tset_buffer_uptodate(bh);\n\n\t\tfile_ofs = ((s64)page->index << PAGE_CACHE_SHIFT) +\n\t\t\t\tbh_offset(bh);\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tinit_size = ni->initialized_size;\n\t\ti_size = i_size_read(vi);\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (unlikely(init_size > i_size)) {\n\t\t\t/* Race with shrinking truncate. */\n\t\t\tinit_size = i_size;\n\t\t}\n\t\t/* Check for the current buffer head overflowing. */\n\t\tif (unlikely(file_ofs + bh->b_size > init_size)) {\n\t\t\tint ofs;\n\t\t\tvoid *kaddr;\n\n\t\t\tofs = 0;\n\t\t\tif (file_ofs < init_size)\n\t\t\t\tofs = init_size - file_ofs;\n\t\t\tlocal_irq_save(flags);\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tmemset(kaddr + bh_offset(bh) + ofs, 0,\n\t\t\t\t\tbh->b_size - ofs);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tlocal_irq_restore(flags);\n\t\t}\n\t} else {\n\t\tclear_buffer_uptodate(bh);\n\t\tSetPageError(page);\n\t\tntfs_error(ni->vol->sb, \"Buffer I/O error, logical block \"\n\t\t\t\t\"0x%llx.\", (unsigned long long)bh->b_blocknr);\n\t}\n\tfirst = page_buffers(page);\n\tlocal_irq_save(flags);\n\tbit_spin_lock(BH_Uptodate_Lock, &first->b_state);\n\tclear_buffer_async_read(bh);\n\tunlock_buffer(bh);\n\ttmp = bh;\n\tdo {\n\t\tif (!buffer_uptodate(tmp))\n\t\t\tpage_uptodate = 0;\n\t\tif (buffer_async_read(tmp)) {\n\t\t\tif (likely(buffer_locked(tmp)))\n\t\t\t\tgoto still_busy;\n\t\t\t/* Async buffers must be locked. */\n\t\t\tBUG();\n\t\t}\n\t\ttmp = tmp->b_this_page;\n\t} while (tmp != bh);\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\t/*\n\t * If none of the buffers had errors then we can set the page uptodate,\n\t * but we first have to perform the post read mst fixups, if the\n\t * attribute is mst protected, i.e. if NInoMstProteced(ni) is true.\n\t * Note we ignore fixup errors as those are detected when\n\t * map_mft_record() is called which gives us per record granularity\n\t * rather than per page granularity.\n\t */\n\tif (!NInoMstProtected(ni)) {\n\t\tif (likely(page_uptodate && !PageError(page)))\n\t\t\tSetPageUptodate(page);\n\t} else {\n\t\tu8 *kaddr;\n\t\tunsigned int i, recs;\n\t\tu32 rec_size;\n\n\t\trec_size = ni->itype.index.block_size;\n\t\trecs = PAGE_CACHE_SIZE / rec_size;\n\t\t/* Should have been verified before we got here... */\n\t\tBUG_ON(!recs);\n\t\tlocal_irq_save(flags);\n\t\tkaddr = kmap_atomic(page);\n\t\tfor (i = 0; i < recs; i++)\n\t\t\tpost_read_mst_fixup((NTFS_RECORD*)(kaddr +\n\t\t\t\t\ti * rec_size), rec_size);\n\t\tkunmap_atomic(kaddr);\n\t\tlocal_irq_restore(flags);\n\t\tflush_dcache_page(page);\n\t\tif (likely(page_uptodate && !PageError(page)))\n\t\t\tSetPageUptodate(page);\n\t}\n\tunlock_page(page);\n\treturn;\nstill_busy:\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\treturn;\n}"
  }
]