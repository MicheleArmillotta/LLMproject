[
  {
    "function_name": "f2fs_compat_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "1089-1102",
    "snippet": "long f2fs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase F2FS_IOC32_GETFLAGS:\n\t\tcmd = F2FS_IOC_GETFLAGS;\n\t\tbreak;\n\tcase F2FS_IOC32_SETFLAGS:\n\t\tcmd = F2FS_IOC_SETFLAGS;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn f2fs_ioctl(file, cmd, (unsigned long) compat_ptr(arg));\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_ioctl",
          "args": [
            "file",
            "cmd",
            "(unsigned long) compat_ptr(arg)"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "1062-1086",
          "snippet": "long f2fs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase F2FS_IOC_GETFLAGS:\n\t\treturn f2fs_ioc_getflags(filp, arg);\n\tcase F2FS_IOC_SETFLAGS:\n\t\treturn f2fs_ioc_setflags(filp, arg);\n\tcase F2FS_IOC_GETVERSION:\n\t\treturn f2fs_ioc_getversion(filp, arg);\n\tcase F2FS_IOC_START_ATOMIC_WRITE:\n\t\treturn f2fs_ioc_start_atomic_write(filp);\n\tcase F2FS_IOC_COMMIT_ATOMIC_WRITE:\n\t\treturn f2fs_ioc_commit_atomic_write(filp);\n\tcase F2FS_IOC_START_VOLATILE_WRITE:\n\t\treturn f2fs_ioc_start_volatile_write(filp);\n\tcase F2FS_IOC_RELEASE_VOLATILE_WRITE:\n\t\treturn f2fs_ioc_release_volatile_write(filp);\n\tcase F2FS_IOC_ABORT_VOLATILE_WRITE:\n\t\treturn f2fs_ioc_abort_volatile_write(filp);\n\tcase FITRIM:\n\t\treturn f2fs_ioc_fitrim(filp, arg);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nlong f2fs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase F2FS_IOC_GETFLAGS:\n\t\treturn f2fs_ioc_getflags(filp, arg);\n\tcase F2FS_IOC_SETFLAGS:\n\t\treturn f2fs_ioc_setflags(filp, arg);\n\tcase F2FS_IOC_GETVERSION:\n\t\treturn f2fs_ioc_getversion(filp, arg);\n\tcase F2FS_IOC_START_ATOMIC_WRITE:\n\t\treturn f2fs_ioc_start_atomic_write(filp);\n\tcase F2FS_IOC_COMMIT_ATOMIC_WRITE:\n\t\treturn f2fs_ioc_commit_atomic_write(filp);\n\tcase F2FS_IOC_START_VOLATILE_WRITE:\n\t\treturn f2fs_ioc_start_volatile_write(filp);\n\tcase F2FS_IOC_RELEASE_VOLATILE_WRITE:\n\t\treturn f2fs_ioc_release_volatile_write(filp);\n\tcase F2FS_IOC_ABORT_VOLATILE_WRITE:\n\t\treturn f2fs_ioc_abort_volatile_write(filp);\n\tcase FITRIM:\n\t\treturn f2fs_ioc_fitrim(filp, arg);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "arg"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nlong f2fs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase F2FS_IOC32_GETFLAGS:\n\t\tcmd = F2FS_IOC_GETFLAGS;\n\t\tbreak;\n\tcase F2FS_IOC32_SETFLAGS:\n\t\tcmd = F2FS_IOC_SETFLAGS;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn f2fs_ioctl(file, cmd, (unsigned long) compat_ptr(arg));\n}"
  },
  {
    "function_name": "f2fs_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "1062-1086",
    "snippet": "long f2fs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase F2FS_IOC_GETFLAGS:\n\t\treturn f2fs_ioc_getflags(filp, arg);\n\tcase F2FS_IOC_SETFLAGS:\n\t\treturn f2fs_ioc_setflags(filp, arg);\n\tcase F2FS_IOC_GETVERSION:\n\t\treturn f2fs_ioc_getversion(filp, arg);\n\tcase F2FS_IOC_START_ATOMIC_WRITE:\n\t\treturn f2fs_ioc_start_atomic_write(filp);\n\tcase F2FS_IOC_COMMIT_ATOMIC_WRITE:\n\t\treturn f2fs_ioc_commit_atomic_write(filp);\n\tcase F2FS_IOC_START_VOLATILE_WRITE:\n\t\treturn f2fs_ioc_start_volatile_write(filp);\n\tcase F2FS_IOC_RELEASE_VOLATILE_WRITE:\n\t\treturn f2fs_ioc_release_volatile_write(filp);\n\tcase F2FS_IOC_ABORT_VOLATILE_WRITE:\n\t\treturn f2fs_ioc_abort_volatile_write(filp);\n\tcase FITRIM:\n\t\treturn f2fs_ioc_fitrim(filp, arg);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_ioc_fitrim",
          "args": [
            "filp",
            "arg"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_ioc_fitrim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "1032-1060",
          "snippet": "static int f2fs_ioc_fitrim(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\tstruct fstrim_range range;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!blk_queue_discard(q))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t\t\tsizeof(range)))\n\t\treturn -EFAULT;\n\n\trange.minlen = max((unsigned int)range.minlen,\n\t\t\t\tq->limits.discard_granularity);\n\tret = f2fs_trim_fs(F2FS_SB(sb), &range);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t\t\tsizeof(range)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_ioc_fitrim(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\tstruct fstrim_range range;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!blk_queue_discard(q))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t\t\tsizeof(range)))\n\t\treturn -EFAULT;\n\n\trange.minlen = max((unsigned int)range.minlen,\n\t\t\t\tq->limits.discard_granularity);\n\tret = f2fs_trim_fs(F2FS_SB(sb), &range);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t\t\tsizeof(range)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_ioc_abort_volatile_write",
          "args": [
            "filp"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_ioc_abort_volatile_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "1004-1030",
          "snippet": "static int f2fs_ioc_abort_volatile_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint ret;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tf2fs_balance_fs(F2FS_I_SB(inode));\n\n\tif (f2fs_is_atomic_file(inode)) {\n\t\tcommit_inmem_pages(inode, false);\n\t\tclear_inode_flag(F2FS_I(inode), FI_ATOMIC_FILE);\n\t}\n\n\tif (f2fs_is_volatile_file(inode)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_VOLATILE_FILE);\n\t\tfilemap_fdatawrite(inode->i_mapping);\n\t\tset_inode_flag(F2FS_I(inode), FI_VOLATILE_FILE);\n\t}\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_ioc_abort_volatile_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint ret;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tf2fs_balance_fs(F2FS_I_SB(inode));\n\n\tif (f2fs_is_atomic_file(inode)) {\n\t\tcommit_inmem_pages(inode, false);\n\t\tclear_inode_flag(F2FS_I(inode), FI_ATOMIC_FILE);\n\t}\n\n\tif (f2fs_is_volatile_file(inode)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_VOLATILE_FILE);\n\t\tfilemap_fdatawrite(inode->i_mapping);\n\t\tset_inode_flag(F2FS_I(inode), FI_VOLATILE_FILE);\n\t}\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_ioc_release_volatile_write",
          "args": [
            "filp"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_ioc_release_volatile_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "990-1002",
          "snippet": "static int f2fs_ioc_release_volatile_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (!f2fs_is_volatile_file(inode))\n\t\treturn 0;\n\n\tpunch_hole(inode, 0, F2FS_BLKSIZE);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_ioc_release_volatile_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (!f2fs_is_volatile_file(inode))\n\t\treturn 0;\n\n\tpunch_hole(inode, 0, F2FS_BLKSIZE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_ioc_start_volatile_write",
          "args": [
            "filp"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_ioc_start_volatile_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "975-988",
          "snippet": "static int f2fs_ioc_start_volatile_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (f2fs_is_volatile_file(inode))\n\t\treturn 0;\n\n\tset_inode_flag(F2FS_I(inode), FI_VOLATILE_FILE);\n\n\treturn f2fs_convert_inline_inode(inode);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_ioc_start_volatile_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (f2fs_is_volatile_file(inode))\n\t\treturn 0;\n\n\tset_inode_flag(F2FS_I(inode), FI_VOLATILE_FILE);\n\n\treturn f2fs_convert_inline_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_ioc_commit_atomic_write",
          "args": [
            "filp"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_ioc_commit_atomic_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "951-973",
          "snippet": "static int f2fs_ioc_commit_atomic_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint ret;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (f2fs_is_volatile_file(inode))\n\t\treturn 0;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (f2fs_is_atomic_file(inode))\n\t\tcommit_inmem_pages(inode, false);\n\n\tret = f2fs_sync_file(filp, 0, LONG_MAX, 0);\n\tmnt_drop_write_file(filp);\n\tclear_inode_flag(F2FS_I(inode), FI_ATOMIC_FILE);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_ioc_commit_atomic_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint ret;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (f2fs_is_volatile_file(inode))\n\t\treturn 0;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (f2fs_is_atomic_file(inode))\n\t\tcommit_inmem_pages(inode, false);\n\n\tret = f2fs_sync_file(filp, 0, LONG_MAX, 0);\n\tmnt_drop_write_file(filp);\n\tclear_inode_flag(F2FS_I(inode), FI_ATOMIC_FILE);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_ioc_start_atomic_write",
          "args": [
            "filp"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_ioc_start_atomic_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "934-949",
          "snippet": "static int f2fs_ioc_start_atomic_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tf2fs_balance_fs(F2FS_I_SB(inode));\n\n\tif (f2fs_is_atomic_file(inode))\n\t\treturn 0;\n\n\tset_inode_flag(F2FS_I(inode), FI_ATOMIC_FILE);\n\n\treturn f2fs_convert_inline_inode(inode);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_ioc_start_atomic_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tf2fs_balance_fs(F2FS_I_SB(inode));\n\n\tif (f2fs_is_atomic_file(inode))\n\t\treturn 0;\n\n\tset_inode_flag(F2FS_I(inode), FI_ATOMIC_FILE);\n\n\treturn f2fs_convert_inline_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_ioc_getversion",
          "args": [
            "filp",
            "arg"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_ioc_getversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "927-932",
          "snippet": "static int f2fs_ioc_getversion(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\treturn put_user(inode->i_generation, (int __user *)arg);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_ioc_getversion(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\treturn put_user(inode->i_generation, (int __user *)arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_ioc_setflags",
          "args": [
            "filp",
            "arg"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_ioc_setflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "878-925",
          "snippet": "static int f2fs_ioc_setflags(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int flags = fi->i_flags & FS_FL_USER_VISIBLE;\n\tunsigned int oldflags;\n\tint ret;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!inode_owner_or_capable(inode)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (get_user(flags, (int __user *)arg)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tflags = f2fs_mask_flags(inode->i_mode, flags);\n\n\tmutex_lock(&inode->i_mutex);\n\n\toldflags = fi->i_flags;\n\n\tif ((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL)) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tflags = flags & FS_FL_USER_MODIFIABLE;\n\tflags |= oldflags & ~FS_FL_USER_MODIFIABLE;\n\tfi->i_flags = flags;\n\tmutex_unlock(&inode->i_mutex);\n\n\tf2fs_set_inode_flags(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_ioc_setflags(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int flags = fi->i_flags & FS_FL_USER_VISIBLE;\n\tunsigned int oldflags;\n\tint ret;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!inode_owner_or_capable(inode)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (get_user(flags, (int __user *)arg)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tflags = f2fs_mask_flags(inode->i_mode, flags);\n\n\tmutex_lock(&inode->i_mutex);\n\n\toldflags = fi->i_flags;\n\n\tif ((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL)) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tflags = flags & FS_FL_USER_MODIFIABLE;\n\tflags |= oldflags & ~FS_FL_USER_MODIFIABLE;\n\tfi->i_flags = flags;\n\tmutex_unlock(&inode->i_mutex);\n\n\tf2fs_set_inode_flags(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_ioc_getflags",
          "args": [
            "filp",
            "arg"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_ioc_getflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "870-876",
          "snippet": "static int f2fs_ioc_getflags(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int flags = fi->i_flags & FS_FL_USER_VISIBLE;\n\treturn put_user(flags, (int __user *)arg);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_ioc_getflags(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int flags = fi->i_flags & FS_FL_USER_VISIBLE;\n\treturn put_user(flags, (int __user *)arg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nlong f2fs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase F2FS_IOC_GETFLAGS:\n\t\treturn f2fs_ioc_getflags(filp, arg);\n\tcase F2FS_IOC_SETFLAGS:\n\t\treturn f2fs_ioc_setflags(filp, arg);\n\tcase F2FS_IOC_GETVERSION:\n\t\treturn f2fs_ioc_getversion(filp, arg);\n\tcase F2FS_IOC_START_ATOMIC_WRITE:\n\t\treturn f2fs_ioc_start_atomic_write(filp);\n\tcase F2FS_IOC_COMMIT_ATOMIC_WRITE:\n\t\treturn f2fs_ioc_commit_atomic_write(filp);\n\tcase F2FS_IOC_START_VOLATILE_WRITE:\n\t\treturn f2fs_ioc_start_volatile_write(filp);\n\tcase F2FS_IOC_RELEASE_VOLATILE_WRITE:\n\t\treturn f2fs_ioc_release_volatile_write(filp);\n\tcase F2FS_IOC_ABORT_VOLATILE_WRITE:\n\t\treturn f2fs_ioc_abort_volatile_write(filp);\n\tcase FITRIM:\n\t\treturn f2fs_ioc_fitrim(filp, arg);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
  },
  {
    "function_name": "f2fs_ioc_fitrim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "1032-1060",
    "snippet": "static int f2fs_ioc_fitrim(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\tstruct fstrim_range range;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!blk_queue_discard(q))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t\t\tsizeof(range)))\n\t\treturn -EFAULT;\n\n\trange.minlen = max((unsigned int)range.minlen,\n\t\t\t\tq->limits.discard_granularity);\n\tret = f2fs_trim_fs(F2FS_SB(sb), &range);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t\t\tsizeof(range)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(struct fstrim_range __user *)arg",
            "&range",
            "sizeof(range)"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_trim_fs",
          "args": [
            "F2FS_SB(sb)",
            "&range"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_trim_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1049-1085",
          "snippet": "int f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)\n{\n\t__u64 start = F2FS_BYTES_TO_BLK(range->start);\n\t__u64 end = start + F2FS_BYTES_TO_BLK(range->len) - 1;\n\tunsigned int start_segno, end_segno;\n\tstruct cp_control cpc;\n\n\tif (range->minlen > SEGMENT_SIZE(sbi) || start >= MAX_BLKADDR(sbi) ||\n\t\t\t\t\t\trange->len < sbi->blocksize)\n\t\treturn -EINVAL;\n\n\tcpc.trimmed = 0;\n\tif (end <= MAIN_BLKADDR(sbi))\n\t\tgoto out;\n\n\t/* start/end segment number in main_area */\n\tstart_segno = (start <= MAIN_BLKADDR(sbi)) ? 0 : GET_SEGNO(sbi, start);\n\tend_segno = (end >= MAX_BLKADDR(sbi)) ? MAIN_SEGS(sbi) - 1 :\n\t\t\t\t\t\tGET_SEGNO(sbi, end);\n\tcpc.reason = CP_DISCARD;\n\tcpc.trim_minlen = F2FS_BYTES_TO_BLK(range->minlen);\n\n\t/* do checkpoint to issue discard commands safely */\n\tfor (; start_segno <= end_segno; start_segno = cpc.trim_end + 1) {\n\t\tcpc.trim_start = start_segno;\n\t\tcpc.trim_end = min_t(unsigned int, rounddown(start_segno +\n\t\t\t\tBATCHED_TRIM_SEGMENTS(sbi),\n\t\t\t\tsbi->segs_per_sec) - 1, end_segno);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t}\nout:\n\trange->len = F2FS_BLK_TO_BYTES(cpc.trimmed);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)\n{\n\t__u64 start = F2FS_BYTES_TO_BLK(range->start);\n\t__u64 end = start + F2FS_BYTES_TO_BLK(range->len) - 1;\n\tunsigned int start_segno, end_segno;\n\tstruct cp_control cpc;\n\n\tif (range->minlen > SEGMENT_SIZE(sbi) || start >= MAX_BLKADDR(sbi) ||\n\t\t\t\t\t\trange->len < sbi->blocksize)\n\t\treturn -EINVAL;\n\n\tcpc.trimmed = 0;\n\tif (end <= MAIN_BLKADDR(sbi))\n\t\tgoto out;\n\n\t/* start/end segment number in main_area */\n\tstart_segno = (start <= MAIN_BLKADDR(sbi)) ? 0 : GET_SEGNO(sbi, start);\n\tend_segno = (end >= MAX_BLKADDR(sbi)) ? MAIN_SEGS(sbi) - 1 :\n\t\t\t\t\t\tGET_SEGNO(sbi, end);\n\tcpc.reason = CP_DISCARD;\n\tcpc.trim_minlen = F2FS_BYTES_TO_BLK(range->minlen);\n\n\t/* do checkpoint to issue discard commands safely */\n\tfor (; start_segno <= end_segno; start_segno = cpc.trim_end + 1) {\n\t\tcpc.trim_start = start_segno;\n\t\tcpc.trim_end = min_t(unsigned int, rounddown(start_segno +\n\t\t\t\tBATCHED_TRIM_SEGMENTS(sbi),\n\t\t\t\tsbi->segs_per_sec) - 1, end_segno);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t}\nout:\n\trange->len = F2FS_BLK_TO_BYTES(cpc.trimmed);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_SB",
          "args": [
            "sb"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "640-643",
          "snippet": "static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "(unsigned int)range.minlen",
            "q->limits.discard_granularity"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_max_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
          "lines": "13-18",
          "snippet": "static u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry) + 1;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&range",
            "(struct fstrim_range __user *)arg",
            "sizeof(range)"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_queue_discard",
          "args": [
            "q"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "sb->s_bdev"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_ioc_fitrim(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\tstruct fstrim_range range;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!blk_queue_discard(q))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t\t\tsizeof(range)))\n\t\treturn -EFAULT;\n\n\trange.minlen = max((unsigned int)range.minlen,\n\t\t\t\tq->limits.discard_granularity);\n\tret = f2fs_trim_fs(F2FS_SB(sb), &range);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t\t\tsizeof(range)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_ioc_abort_volatile_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "1004-1030",
    "snippet": "static int f2fs_ioc_abort_volatile_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint ret;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tf2fs_balance_fs(F2FS_I_SB(inode));\n\n\tif (f2fs_is_atomic_file(inode)) {\n\t\tcommit_inmem_pages(inode, false);\n\t\tclear_inode_flag(F2FS_I(inode), FI_ATOMIC_FILE);\n\t}\n\n\tif (f2fs_is_volatile_file(inode)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_VOLATILE_FILE);\n\t\tfilemap_fdatawrite(inode->i_mapping);\n\t\tset_inode_flag(F2FS_I(inode), FI_VOLATILE_FILE);\n\t}\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_VOLATILE_FILE"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_VOLATILE_FILE"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_is_volatile_file",
          "args": [
            "inode"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_is_volatile_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1272-1275",
          "snippet": "static inline bool f2fs_is_volatile_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_VOLATILE_FILE);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_is_volatile_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_VOLATILE_FILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "commit_inmem_pages",
          "args": [
            "inode",
            "false"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "commit_inmem_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "210-260",
          "snippet": "void commit_inmem_pages(struct inode *inode, bool abort)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct inmem_pages *cur, *tmp;\n\tbool submit_bio = false;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC | REQ_PRIO,\n\t};\n\n\t/*\n\t * The abort is true only when f2fs_evict_inode is called.\n\t * Basically, the f2fs_evict_inode doesn't produce any data writes, so\n\t * that we don't need to call f2fs_balance_fs.\n\t * Otherwise, f2fs_gc in f2fs_balance_fs can wait forever until this\n\t * inode becomes free by iget_locked in f2fs_iget.\n\t */\n\tif (!abort) {\n\t\tf2fs_balance_fs(sbi);\n\t\tf2fs_lock_op(sbi);\n\t}\n\n\tmutex_lock(&fi->inmem_lock);\n\tlist_for_each_entry_safe(cur, tmp, &fi->inmem_pages, list) {\n\t\tif (!abort) {\n\t\t\tlock_page(cur->page);\n\t\t\tif (cur->page->mapping == inode->i_mapping) {\n\t\t\t\tf2fs_wait_on_page_writeback(cur->page, DATA);\n\t\t\t\tif (clear_page_dirty_for_io(cur->page))\n\t\t\t\t\tinode_dec_dirty_pages(inode);\n\t\t\t\tdo_write_data_page(cur->page, &fio);\n\t\t\t\tsubmit_bio = true;\n\t\t\t}\n\t\t\tf2fs_put_page(cur->page, 1);\n\t\t} else {\n\t\t\tput_page(cur->page);\n\t\t}\n\t\tradix_tree_delete(&fi->inmem_root, cur->page->index);\n\t\tlist_del(&cur->list);\n\t\tkmem_cache_free(inmem_entry_slab, cur);\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);\n\t}\n\tmutex_unlock(&fi->inmem_lock);\n\n\tif (!abort) {\n\t\tf2fs_unlock_op(sbi);\n\t\tif (submit_bio)\n\t\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *inmem_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *inmem_entry_slab;\n\nvoid commit_inmem_pages(struct inode *inode, bool abort)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct inmem_pages *cur, *tmp;\n\tbool submit_bio = false;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC | REQ_PRIO,\n\t};\n\n\t/*\n\t * The abort is true only when f2fs_evict_inode is called.\n\t * Basically, the f2fs_evict_inode doesn't produce any data writes, so\n\t * that we don't need to call f2fs_balance_fs.\n\t * Otherwise, f2fs_gc in f2fs_balance_fs can wait forever until this\n\t * inode becomes free by iget_locked in f2fs_iget.\n\t */\n\tif (!abort) {\n\t\tf2fs_balance_fs(sbi);\n\t\tf2fs_lock_op(sbi);\n\t}\n\n\tmutex_lock(&fi->inmem_lock);\n\tlist_for_each_entry_safe(cur, tmp, &fi->inmem_pages, list) {\n\t\tif (!abort) {\n\t\t\tlock_page(cur->page);\n\t\t\tif (cur->page->mapping == inode->i_mapping) {\n\t\t\t\tf2fs_wait_on_page_writeback(cur->page, DATA);\n\t\t\t\tif (clear_page_dirty_for_io(cur->page))\n\t\t\t\t\tinode_dec_dirty_pages(inode);\n\t\t\t\tdo_write_data_page(cur->page, &fio);\n\t\t\t\tsubmit_bio = true;\n\t\t\t}\n\t\t\tf2fs_put_page(cur->page, 1);\n\t\t} else {\n\t\t\tput_page(cur->page);\n\t\t}\n\t\tradix_tree_delete(&fi->inmem_root, cur->page->index);\n\t\tlist_del(&cur->list);\n\t\tkmem_cache_free(inmem_entry_slab, cur);\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);\n\t}\n\tmutex_unlock(&fi->inmem_lock);\n\n\tif (!abort) {\n\t\tf2fs_unlock_op(sbi);\n\t\tif (submit_bio)\n\t\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_is_atomic_file",
          "args": [
            "inode"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_is_atomic_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1267-1270",
          "snippet": "static inline bool f2fs_is_atomic_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_ATOMIC_FILE);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_is_atomic_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_ATOMIC_FILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "F2FS_I_SB(inode)"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "inode"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_ioc_abort_volatile_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint ret;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tf2fs_balance_fs(F2FS_I_SB(inode));\n\n\tif (f2fs_is_atomic_file(inode)) {\n\t\tcommit_inmem_pages(inode, false);\n\t\tclear_inode_flag(F2FS_I(inode), FI_ATOMIC_FILE);\n\t}\n\n\tif (f2fs_is_volatile_file(inode)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_VOLATILE_FILE);\n\t\tfilemap_fdatawrite(inode->i_mapping);\n\t\tset_inode_flag(F2FS_I(inode), FI_VOLATILE_FILE);\n\t}\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}"
  },
  {
    "function_name": "f2fs_ioc_release_volatile_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "990-1002",
    "snippet": "static int f2fs_ioc_release_volatile_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (!f2fs_is_volatile_file(inode))\n\t\treturn 0;\n\n\tpunch_hole(inode, 0, F2FS_BLKSIZE);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "punch_hole",
          "args": [
            "inode",
            "0",
            "F2FS_BLKSIZE"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "punch_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "700-754",
          "snippet": "static int punch_hole(struct inode *inode, loff_t offset, loff_t len)\n{\n\tpgoff_t pg_start, pg_end;\n\tloff_t off_start, off_end;\n\tint ret = 0;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\t/* skip punching hole beyond i_size */\n\tif (offset >= inode->i_size)\n\t\treturn ret;\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tret = f2fs_convert_inline_inode(inode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpg_start = ((unsigned long long) offset) >> PAGE_CACHE_SHIFT;\n\tpg_end = ((unsigned long long) offset + len) >> PAGE_CACHE_SHIFT;\n\n\toff_start = offset & (PAGE_CACHE_SIZE - 1);\n\toff_end = (offset + len) & (PAGE_CACHE_SIZE - 1);\n\n\tif (pg_start == pg_end) {\n\t\tfill_zero(inode, pg_start, off_start,\n\t\t\t\t\t\toff_end - off_start);\n\t} else {\n\t\tif (off_start)\n\t\t\tfill_zero(inode, pg_start++, off_start,\n\t\t\t\t\tPAGE_CACHE_SIZE - off_start);\n\t\tif (off_end)\n\t\t\tfill_zero(inode, pg_end, 0, off_end);\n\n\t\tif (pg_start < pg_end) {\n\t\t\tstruct address_space *mapping = inode->i_mapping;\n\t\t\tloff_t blk_start, blk_end;\n\t\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\t\t\tf2fs_balance_fs(sbi);\n\n\t\t\tblk_start = pg_start << PAGE_CACHE_SHIFT;\n\t\t\tblk_end = pg_end << PAGE_CACHE_SHIFT;\n\t\t\ttruncate_inode_pages_range(mapping, blk_start,\n\t\t\t\t\tblk_end - 1);\n\n\t\t\tf2fs_lock_op(sbi);\n\t\t\tret = truncate_hole(inode, pg_start, pg_end);\n\t\t\tf2fs_unlock_op(sbi);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int punch_hole(struct inode *inode, loff_t offset, loff_t len)\n{\n\tpgoff_t pg_start, pg_end;\n\tloff_t off_start, off_end;\n\tint ret = 0;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\t/* skip punching hole beyond i_size */\n\tif (offset >= inode->i_size)\n\t\treturn ret;\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tret = f2fs_convert_inline_inode(inode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpg_start = ((unsigned long long) offset) >> PAGE_CACHE_SHIFT;\n\tpg_end = ((unsigned long long) offset + len) >> PAGE_CACHE_SHIFT;\n\n\toff_start = offset & (PAGE_CACHE_SIZE - 1);\n\toff_end = (offset + len) & (PAGE_CACHE_SIZE - 1);\n\n\tif (pg_start == pg_end) {\n\t\tfill_zero(inode, pg_start, off_start,\n\t\t\t\t\t\toff_end - off_start);\n\t} else {\n\t\tif (off_start)\n\t\t\tfill_zero(inode, pg_start++, off_start,\n\t\t\t\t\tPAGE_CACHE_SIZE - off_start);\n\t\tif (off_end)\n\t\t\tfill_zero(inode, pg_end, 0, off_end);\n\n\t\tif (pg_start < pg_end) {\n\t\t\tstruct address_space *mapping = inode->i_mapping;\n\t\t\tloff_t blk_start, blk_end;\n\t\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\t\t\tf2fs_balance_fs(sbi);\n\n\t\t\tblk_start = pg_start << PAGE_CACHE_SHIFT;\n\t\t\tblk_end = pg_end << PAGE_CACHE_SHIFT;\n\t\t\ttruncate_inode_pages_range(mapping, blk_start,\n\t\t\t\t\tblk_end - 1);\n\n\t\t\tf2fs_lock_op(sbi);\n\t\t\tret = truncate_hole(inode, pg_start, pg_end);\n\t\t\tf2fs_unlock_op(sbi);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_is_volatile_file",
          "args": [
            "inode"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_is_volatile_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1272-1275",
          "snippet": "static inline bool f2fs_is_volatile_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_VOLATILE_FILE);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_is_volatile_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_VOLATILE_FILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "inode"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_ioc_release_volatile_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (!f2fs_is_volatile_file(inode))\n\t\treturn 0;\n\n\tpunch_hole(inode, 0, F2FS_BLKSIZE);\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_ioc_start_volatile_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "975-988",
    "snippet": "static int f2fs_ioc_start_volatile_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (f2fs_is_volatile_file(inode))\n\t\treturn 0;\n\n\tset_inode_flag(F2FS_I(inode), FI_VOLATILE_FILE);\n\n\treturn f2fs_convert_inline_inode(inode);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_convert_inline_inode",
          "args": [
            "inode"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_convert_inline_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "143-173",
          "snippet": "int f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_VOLATILE_FILE"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_is_volatile_file",
          "args": [
            "inode"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_is_volatile_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1272-1275",
          "snippet": "static inline bool f2fs_is_volatile_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_VOLATILE_FILE);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_is_volatile_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_VOLATILE_FILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "inode"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_ioc_start_volatile_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (f2fs_is_volatile_file(inode))\n\t\treturn 0;\n\n\tset_inode_flag(F2FS_I(inode), FI_VOLATILE_FILE);\n\n\treturn f2fs_convert_inline_inode(inode);\n}"
  },
  {
    "function_name": "f2fs_ioc_commit_atomic_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "951-973",
    "snippet": "static int f2fs_ioc_commit_atomic_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint ret;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (f2fs_is_volatile_file(inode))\n\t\treturn 0;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (f2fs_is_atomic_file(inode))\n\t\tcommit_inmem_pages(inode, false);\n\n\tret = f2fs_sync_file(filp, 0, LONG_MAX, 0);\n\tmnt_drop_write_file(filp);\n\tclear_inode_flag(F2FS_I(inode), FI_ATOMIC_FILE);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_ATOMIC_FILE"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_sync_file",
          "args": [
            "filp",
            "0",
            "LONG_MAX",
            "0"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_sync_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "172-274",
          "snippet": "int f2fs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t ino = inode->i_ino;\n\tint ret = 0;\n\tbool need_cp = false;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.for_reclaim = 0,\n\t};\n\n\tif (unlikely(f2fs_readonly(inode->i_sb)))\n\t\treturn 0;\n\n\ttrace_f2fs_sync_file_enter(inode);\n\n\t/* if fdatasync is triggered, let's do in-place-update */\n\tif (get_dirty_pages(inode) <= SM_I(sbi)->min_fsync_blocks)\n\t\tset_inode_flag(fi, FI_NEED_IPU);\n\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tclear_inode_flag(fi, FI_NEED_IPU);\n\n\tif (ret) {\n\t\ttrace_f2fs_sync_file_exit(inode, need_cp, datasync, ret);\n\t\treturn ret;\n\t}\n\n\t/* if the inode is dirty, let's recover all the time */\n\tif (!datasync && is_inode_flag_set(fi, FI_DIRTY_INODE)) {\n\t\tupdate_inode_page(inode);\n\t\tgoto go_write;\n\t}\n\n\t/*\n\t * if there is no written data, don't waste time to write recovery info.\n\t */\n\tif (!is_inode_flag_set(fi, FI_APPEND_WRITE) &&\n\t\t\t!exist_written_data(sbi, ino, APPEND_INO)) {\n\n\t\t/* it may call write_inode just prior to fsync */\n\t\tif (need_inode_page_update(sbi, ino))\n\t\t\tgoto go_write;\n\n\t\tif (is_inode_flag_set(fi, FI_UPDATE_WRITE) ||\n\t\t\t\texist_written_data(sbi, ino, UPDATE_INO))\n\t\t\tgoto flush_out;\n\t\tgoto out;\n\t}\ngo_write:\n\t/* guarantee free sections for fsync */\n\tf2fs_balance_fs(sbi);\n\n\t/*\n\t * Both of fdatasync() and fsync() are able to be recovered from\n\t * sudden-power-off.\n\t */\n\tdown_read(&fi->i_sem);\n\tneed_cp = need_do_checkpoint(inode);\n\tup_read(&fi->i_sem);\n\n\tif (need_cp) {\n\t\t/* all the dirty node pages should be flushed for POR */\n\t\tret = f2fs_sync_fs(inode->i_sb, 1);\n\n\t\t/*\n\t\t * We've secured consistency through sync_fs. Following pino\n\t\t * will be used only for fsynced inodes after checkpoint.\n\t\t */\n\t\ttry_to_fix_pino(inode);\n\t\tgoto out;\n\t}\nsync_nodes:\n\tsync_node_pages(sbi, ino, &wbc);\n\n\t/* if cp_error was enabled, we should avoid infinite loop */\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto out;\n\n\tif (need_inode_block_update(sbi, ino)) {\n\t\tmark_inode_dirty_sync(inode);\n\t\tf2fs_write_inode(inode, NULL);\n\t\tgoto sync_nodes;\n\t}\n\n\tret = wait_on_node_pages_writeback(sbi, ino);\n\tif (ret)\n\t\tgoto out;\n\n\t/* once recovery info is written, don't need to tack this */\n\tremove_dirty_inode(sbi, ino, APPEND_INO);\n\tclear_inode_flag(fi, FI_APPEND_WRITE);\nflush_out:\n\tremove_dirty_inode(sbi, ino, UPDATE_INO);\n\tclear_inode_flag(fi, FI_UPDATE_WRITE);\n\tret = f2fs_issue_flush(sbi);\nout:\n\ttrace_f2fs_sync_file_exit(inode, need_cp, datasync, ret);\n\tf2fs_trace_ios(NULL, NULL, 1);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t ino = inode->i_ino;\n\tint ret = 0;\n\tbool need_cp = false;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.for_reclaim = 0,\n\t};\n\n\tif (unlikely(f2fs_readonly(inode->i_sb)))\n\t\treturn 0;\n\n\ttrace_f2fs_sync_file_enter(inode);\n\n\t/* if fdatasync is triggered, let's do in-place-update */\n\tif (get_dirty_pages(inode) <= SM_I(sbi)->min_fsync_blocks)\n\t\tset_inode_flag(fi, FI_NEED_IPU);\n\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tclear_inode_flag(fi, FI_NEED_IPU);\n\n\tif (ret) {\n\t\ttrace_f2fs_sync_file_exit(inode, need_cp, datasync, ret);\n\t\treturn ret;\n\t}\n\n\t/* if the inode is dirty, let's recover all the time */\n\tif (!datasync && is_inode_flag_set(fi, FI_DIRTY_INODE)) {\n\t\tupdate_inode_page(inode);\n\t\tgoto go_write;\n\t}\n\n\t/*\n\t * if there is no written data, don't waste time to write recovery info.\n\t */\n\tif (!is_inode_flag_set(fi, FI_APPEND_WRITE) &&\n\t\t\t!exist_written_data(sbi, ino, APPEND_INO)) {\n\n\t\t/* it may call write_inode just prior to fsync */\n\t\tif (need_inode_page_update(sbi, ino))\n\t\t\tgoto go_write;\n\n\t\tif (is_inode_flag_set(fi, FI_UPDATE_WRITE) ||\n\t\t\t\texist_written_data(sbi, ino, UPDATE_INO))\n\t\t\tgoto flush_out;\n\t\tgoto out;\n\t}\ngo_write:\n\t/* guarantee free sections for fsync */\n\tf2fs_balance_fs(sbi);\n\n\t/*\n\t * Both of fdatasync() and fsync() are able to be recovered from\n\t * sudden-power-off.\n\t */\n\tdown_read(&fi->i_sem);\n\tneed_cp = need_do_checkpoint(inode);\n\tup_read(&fi->i_sem);\n\n\tif (need_cp) {\n\t\t/* all the dirty node pages should be flushed for POR */\n\t\tret = f2fs_sync_fs(inode->i_sb, 1);\n\n\t\t/*\n\t\t * We've secured consistency through sync_fs. Following pino\n\t\t * will be used only for fsynced inodes after checkpoint.\n\t\t */\n\t\ttry_to_fix_pino(inode);\n\t\tgoto out;\n\t}\nsync_nodes:\n\tsync_node_pages(sbi, ino, &wbc);\n\n\t/* if cp_error was enabled, we should avoid infinite loop */\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto out;\n\n\tif (need_inode_block_update(sbi, ino)) {\n\t\tmark_inode_dirty_sync(inode);\n\t\tf2fs_write_inode(inode, NULL);\n\t\tgoto sync_nodes;\n\t}\n\n\tret = wait_on_node_pages_writeback(sbi, ino);\n\tif (ret)\n\t\tgoto out;\n\n\t/* once recovery info is written, don't need to tack this */\n\tremove_dirty_inode(sbi, ino, APPEND_INO);\n\tclear_inode_flag(fi, FI_APPEND_WRITE);\nflush_out:\n\tremove_dirty_inode(sbi, ino, UPDATE_INO);\n\tclear_inode_flag(fi, FI_UPDATE_WRITE);\n\tret = f2fs_issue_flush(sbi);\nout:\n\ttrace_f2fs_sync_file_exit(inode, need_cp, datasync, ret);\n\tf2fs_trace_ios(NULL, NULL, 1);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "commit_inmem_pages",
          "args": [
            "inode",
            "false"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "commit_inmem_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "210-260",
          "snippet": "void commit_inmem_pages(struct inode *inode, bool abort)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct inmem_pages *cur, *tmp;\n\tbool submit_bio = false;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC | REQ_PRIO,\n\t};\n\n\t/*\n\t * The abort is true only when f2fs_evict_inode is called.\n\t * Basically, the f2fs_evict_inode doesn't produce any data writes, so\n\t * that we don't need to call f2fs_balance_fs.\n\t * Otherwise, f2fs_gc in f2fs_balance_fs can wait forever until this\n\t * inode becomes free by iget_locked in f2fs_iget.\n\t */\n\tif (!abort) {\n\t\tf2fs_balance_fs(sbi);\n\t\tf2fs_lock_op(sbi);\n\t}\n\n\tmutex_lock(&fi->inmem_lock);\n\tlist_for_each_entry_safe(cur, tmp, &fi->inmem_pages, list) {\n\t\tif (!abort) {\n\t\t\tlock_page(cur->page);\n\t\t\tif (cur->page->mapping == inode->i_mapping) {\n\t\t\t\tf2fs_wait_on_page_writeback(cur->page, DATA);\n\t\t\t\tif (clear_page_dirty_for_io(cur->page))\n\t\t\t\t\tinode_dec_dirty_pages(inode);\n\t\t\t\tdo_write_data_page(cur->page, &fio);\n\t\t\t\tsubmit_bio = true;\n\t\t\t}\n\t\t\tf2fs_put_page(cur->page, 1);\n\t\t} else {\n\t\t\tput_page(cur->page);\n\t\t}\n\t\tradix_tree_delete(&fi->inmem_root, cur->page->index);\n\t\tlist_del(&cur->list);\n\t\tkmem_cache_free(inmem_entry_slab, cur);\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);\n\t}\n\tmutex_unlock(&fi->inmem_lock);\n\n\tif (!abort) {\n\t\tf2fs_unlock_op(sbi);\n\t\tif (submit_bio)\n\t\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *inmem_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *inmem_entry_slab;\n\nvoid commit_inmem_pages(struct inode *inode, bool abort)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct inmem_pages *cur, *tmp;\n\tbool submit_bio = false;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC | REQ_PRIO,\n\t};\n\n\t/*\n\t * The abort is true only when f2fs_evict_inode is called.\n\t * Basically, the f2fs_evict_inode doesn't produce any data writes, so\n\t * that we don't need to call f2fs_balance_fs.\n\t * Otherwise, f2fs_gc in f2fs_balance_fs can wait forever until this\n\t * inode becomes free by iget_locked in f2fs_iget.\n\t */\n\tif (!abort) {\n\t\tf2fs_balance_fs(sbi);\n\t\tf2fs_lock_op(sbi);\n\t}\n\n\tmutex_lock(&fi->inmem_lock);\n\tlist_for_each_entry_safe(cur, tmp, &fi->inmem_pages, list) {\n\t\tif (!abort) {\n\t\t\tlock_page(cur->page);\n\t\t\tif (cur->page->mapping == inode->i_mapping) {\n\t\t\t\tf2fs_wait_on_page_writeback(cur->page, DATA);\n\t\t\t\tif (clear_page_dirty_for_io(cur->page))\n\t\t\t\t\tinode_dec_dirty_pages(inode);\n\t\t\t\tdo_write_data_page(cur->page, &fio);\n\t\t\t\tsubmit_bio = true;\n\t\t\t}\n\t\t\tf2fs_put_page(cur->page, 1);\n\t\t} else {\n\t\t\tput_page(cur->page);\n\t\t}\n\t\tradix_tree_delete(&fi->inmem_root, cur->page->index);\n\t\tlist_del(&cur->list);\n\t\tkmem_cache_free(inmem_entry_slab, cur);\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);\n\t}\n\tmutex_unlock(&fi->inmem_lock);\n\n\tif (!abort) {\n\t\tf2fs_unlock_op(sbi);\n\t\tif (submit_bio)\n\t\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_is_atomic_file",
          "args": [
            "inode"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_is_atomic_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1267-1270",
          "snippet": "static inline bool f2fs_is_atomic_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_ATOMIC_FILE);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_is_atomic_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_ATOMIC_FILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_is_volatile_file",
          "args": [
            "inode"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_is_volatile_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1272-1275",
          "snippet": "static inline bool f2fs_is_volatile_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_VOLATILE_FILE);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_is_volatile_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_VOLATILE_FILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "inode"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_ioc_commit_atomic_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint ret;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (f2fs_is_volatile_file(inode))\n\t\treturn 0;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (f2fs_is_atomic_file(inode))\n\t\tcommit_inmem_pages(inode, false);\n\n\tret = f2fs_sync_file(filp, 0, LONG_MAX, 0);\n\tmnt_drop_write_file(filp);\n\tclear_inode_flag(F2FS_I(inode), FI_ATOMIC_FILE);\n\treturn ret;\n}"
  },
  {
    "function_name": "f2fs_ioc_start_atomic_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "934-949",
    "snippet": "static int f2fs_ioc_start_atomic_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tf2fs_balance_fs(F2FS_I_SB(inode));\n\n\tif (f2fs_is_atomic_file(inode))\n\t\treturn 0;\n\n\tset_inode_flag(F2FS_I(inode), FI_ATOMIC_FILE);\n\n\treturn f2fs_convert_inline_inode(inode);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_convert_inline_inode",
          "args": [
            "inode"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_convert_inline_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "143-173",
          "snippet": "int f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_ATOMIC_FILE"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_is_atomic_file",
          "args": [
            "inode"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_is_atomic_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1267-1270",
          "snippet": "static inline bool f2fs_is_atomic_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_ATOMIC_FILE);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_is_atomic_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_ATOMIC_FILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "F2FS_I_SB(inode)"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "inode"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_ioc_start_atomic_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tf2fs_balance_fs(F2FS_I_SB(inode));\n\n\tif (f2fs_is_atomic_file(inode))\n\t\treturn 0;\n\n\tset_inode_flag(F2FS_I(inode), FI_ATOMIC_FILE);\n\n\treturn f2fs_convert_inline_inode(inode);\n}"
  },
  {
    "function_name": "f2fs_ioc_getversion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "927-932",
    "snippet": "static int f2fs_ioc_getversion(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\treturn put_user(inode->i_generation, (int __user *)arg);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "inode->i_generation",
            "(int __user *)arg"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_ioc_getversion(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\treturn put_user(inode->i_generation, (int __user *)arg);\n}"
  },
  {
    "function_name": "f2fs_ioc_setflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "878-925",
    "snippet": "static int f2fs_ioc_setflags(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int flags = fi->i_flags & FS_FL_USER_VISIBLE;\n\tunsigned int oldflags;\n\tint ret;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!inode_owner_or_capable(inode)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (get_user(flags, (int __user *)arg)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tflags = f2fs_mask_flags(inode->i_mode, flags);\n\n\tmutex_lock(&inode->i_mutex);\n\n\toldflags = fi->i_flags;\n\n\tif ((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL)) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tflags = flags & FS_FL_USER_MODIFIABLE;\n\tflags |= oldflags & ~FS_FL_USER_MODIFIABLE;\n\tfi->i_flags = flags;\n\tmutex_unlock(&inode->i_mutex);\n\n\tf2fs_set_inode_flags(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "22-39",
          "snippet": "void f2fs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = F2FS_I(inode)->i_flags;\n\tunsigned int new_fl = 0;\n\n\tif (flags & FS_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tif (flags & FS_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & FS_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & FS_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tset_mask_bits(&inode->i_flags,\n\t\t\tS_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC, new_fl);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = F2FS_I(inode)->i_flags;\n\tunsigned int new_fl = 0;\n\n\tif (flags & FS_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tif (flags & FS_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & FS_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & FS_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tset_mask_bits(&inode->i_flags,\n\t\t\tS_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC, new_fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_LINUX_IMMUTABLE"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_mask_flags",
          "args": [
            "inode->i_mode",
            "flags"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_mask_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "860-868",
          "snippet": "static inline __u32 f2fs_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & F2FS_REG_FLMASK;\n\telse\n\t\treturn flags & F2FS_OTHER_FLMASK;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define F2FS_OTHER_FLMASK\t(FS_NODUMP_FL | FS_NOATIME_FL)",
            "#define F2FS_REG_FLMASK\t\t(~(FS_DIRSYNC_FL | FS_TOPDIR_FL))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\n#define F2FS_OTHER_FLMASK\t(FS_NODUMP_FL | FS_NOATIME_FL)\n#define F2FS_REG_FLMASK\t\t(~(FS_DIRSYNC_FL | FS_TOPDIR_FL))\n\nstatic inline __u32 f2fs_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & F2FS_REG_FLMASK;\n\telse\n\t\treturn flags & F2FS_OTHER_FLMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "flags",
            "(int __user *)arg"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_ioc_setflags(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int flags = fi->i_flags & FS_FL_USER_VISIBLE;\n\tunsigned int oldflags;\n\tint ret;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!inode_owner_or_capable(inode)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (get_user(flags, (int __user *)arg)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tflags = f2fs_mask_flags(inode->i_mode, flags);\n\n\tmutex_lock(&inode->i_mutex);\n\n\toldflags = fi->i_flags;\n\n\tif ((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL)) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tflags = flags & FS_FL_USER_MODIFIABLE;\n\tflags |= oldflags & ~FS_FL_USER_MODIFIABLE;\n\tfi->i_flags = flags;\n\tmutex_unlock(&inode->i_mutex);\n\n\tf2fs_set_inode_flags(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}"
  },
  {
    "function_name": "f2fs_ioc_getflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "870-876",
    "snippet": "static int f2fs_ioc_getflags(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int flags = fi->i_flags & FS_FL_USER_VISIBLE;\n\treturn put_user(flags, (int __user *)arg);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "flags",
            "(int __user *)arg"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_ioc_getflags(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int flags = fi->i_flags & FS_FL_USER_VISIBLE;\n\treturn put_user(flags, (int __user *)arg);\n}"
  },
  {
    "function_name": "f2fs_mask_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "860-868",
    "snippet": "static inline __u32 f2fs_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & F2FS_REG_FLMASK;\n\telse\n\t\treturn flags & F2FS_OTHER_FLMASK;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define F2FS_OTHER_FLMASK\t(FS_NODUMP_FL | FS_NOATIME_FL)",
      "#define F2FS_REG_FLMASK\t\t(~(FS_DIRSYNC_FL | FS_TOPDIR_FL))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\n#define F2FS_OTHER_FLMASK\t(FS_NODUMP_FL | FS_NOATIME_FL)\n#define F2FS_REG_FLMASK\t\t(~(FS_DIRSYNC_FL | FS_TOPDIR_FL))\n\nstatic inline __u32 f2fs_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & F2FS_REG_FLMASK;\n\telse\n\t\treturn flags & F2FS_OTHER_FLMASK;\n}"
  },
  {
    "function_name": "f2fs_release_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "844-855",
    "snippet": "static int f2fs_release_file(struct inode *inode, struct file *filp)\n{\n\t/* some remained atomic pages should discarded */\n\tif (f2fs_is_atomic_file(inode))\n\t\tcommit_inmem_pages(inode, true);\n\tif (f2fs_is_volatile_file(inode)) {\n\t\tset_inode_flag(F2FS_I(inode), FI_DROP_CACHE);\n\t\tfilemap_fdatawrite(inode->i_mapping);\n\t\tclear_inode_flag(F2FS_I(inode), FI_DROP_CACHE);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_DROP_CACHE"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite",
          "args": [
            "inode->i_mapping"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_DROP_CACHE"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_is_volatile_file",
          "args": [
            "inode"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_is_volatile_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1272-1275",
          "snippet": "static inline bool f2fs_is_volatile_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_VOLATILE_FILE);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_is_volatile_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_VOLATILE_FILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "commit_inmem_pages",
          "args": [
            "inode",
            "true"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "commit_inmem_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "210-260",
          "snippet": "void commit_inmem_pages(struct inode *inode, bool abort)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct inmem_pages *cur, *tmp;\n\tbool submit_bio = false;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC | REQ_PRIO,\n\t};\n\n\t/*\n\t * The abort is true only when f2fs_evict_inode is called.\n\t * Basically, the f2fs_evict_inode doesn't produce any data writes, so\n\t * that we don't need to call f2fs_balance_fs.\n\t * Otherwise, f2fs_gc in f2fs_balance_fs can wait forever until this\n\t * inode becomes free by iget_locked in f2fs_iget.\n\t */\n\tif (!abort) {\n\t\tf2fs_balance_fs(sbi);\n\t\tf2fs_lock_op(sbi);\n\t}\n\n\tmutex_lock(&fi->inmem_lock);\n\tlist_for_each_entry_safe(cur, tmp, &fi->inmem_pages, list) {\n\t\tif (!abort) {\n\t\t\tlock_page(cur->page);\n\t\t\tif (cur->page->mapping == inode->i_mapping) {\n\t\t\t\tf2fs_wait_on_page_writeback(cur->page, DATA);\n\t\t\t\tif (clear_page_dirty_for_io(cur->page))\n\t\t\t\t\tinode_dec_dirty_pages(inode);\n\t\t\t\tdo_write_data_page(cur->page, &fio);\n\t\t\t\tsubmit_bio = true;\n\t\t\t}\n\t\t\tf2fs_put_page(cur->page, 1);\n\t\t} else {\n\t\t\tput_page(cur->page);\n\t\t}\n\t\tradix_tree_delete(&fi->inmem_root, cur->page->index);\n\t\tlist_del(&cur->list);\n\t\tkmem_cache_free(inmem_entry_slab, cur);\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);\n\t}\n\tmutex_unlock(&fi->inmem_lock);\n\n\tif (!abort) {\n\t\tf2fs_unlock_op(sbi);\n\t\tif (submit_bio)\n\t\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *inmem_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *inmem_entry_slab;\n\nvoid commit_inmem_pages(struct inode *inode, bool abort)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct inmem_pages *cur, *tmp;\n\tbool submit_bio = false;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC | REQ_PRIO,\n\t};\n\n\t/*\n\t * The abort is true only when f2fs_evict_inode is called.\n\t * Basically, the f2fs_evict_inode doesn't produce any data writes, so\n\t * that we don't need to call f2fs_balance_fs.\n\t * Otherwise, f2fs_gc in f2fs_balance_fs can wait forever until this\n\t * inode becomes free by iget_locked in f2fs_iget.\n\t */\n\tif (!abort) {\n\t\tf2fs_balance_fs(sbi);\n\t\tf2fs_lock_op(sbi);\n\t}\n\n\tmutex_lock(&fi->inmem_lock);\n\tlist_for_each_entry_safe(cur, tmp, &fi->inmem_pages, list) {\n\t\tif (!abort) {\n\t\t\tlock_page(cur->page);\n\t\t\tif (cur->page->mapping == inode->i_mapping) {\n\t\t\t\tf2fs_wait_on_page_writeback(cur->page, DATA);\n\t\t\t\tif (clear_page_dirty_for_io(cur->page))\n\t\t\t\t\tinode_dec_dirty_pages(inode);\n\t\t\t\tdo_write_data_page(cur->page, &fio);\n\t\t\t\tsubmit_bio = true;\n\t\t\t}\n\t\t\tf2fs_put_page(cur->page, 1);\n\t\t} else {\n\t\t\tput_page(cur->page);\n\t\t}\n\t\tradix_tree_delete(&fi->inmem_root, cur->page->index);\n\t\tlist_del(&cur->list);\n\t\tkmem_cache_free(inmem_entry_slab, cur);\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);\n\t}\n\tmutex_unlock(&fi->inmem_lock);\n\n\tif (!abort) {\n\t\tf2fs_unlock_op(sbi);\n\t\tif (submit_bio)\n\t\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_is_atomic_file",
          "args": [
            "inode"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_is_atomic_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1267-1270",
          "snippet": "static inline bool f2fs_is_atomic_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_ATOMIC_FILE);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_is_atomic_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_ATOMIC_FILE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_release_file(struct inode *inode, struct file *filp)\n{\n\t/* some remained atomic pages should discarded */\n\tif (f2fs_is_atomic_file(inode))\n\t\tcommit_inmem_pages(inode, true);\n\tif (f2fs_is_volatile_file(inode)) {\n\t\tset_inode_flag(F2FS_I(inode), FI_DROP_CACHE);\n\t\tfilemap_fdatawrite(inode->i_mapping);\n\t\tclear_inode_flag(F2FS_I(inode), FI_DROP_CACHE);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "817-842",
    "snippet": "static long f2fs_fallocate(struct file *file, int mode,\n\t\t\t\tloff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tlong ret;\n\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\tret = punch_hole(inode, offset, len);\n\telse\n\t\tret = expand_inode_data(inode, offset, len, mode);\n\n\tif (!ret) {\n\t\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tmutex_unlock(&inode->i_mutex);\n\n\ttrace_f2fs_fallocate(inode, mode, offset, len, ret);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_f2fs_fallocate",
          "args": [
            "inode",
            "mode",
            "offset",
            "len",
            "ret"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "expand_inode_data",
          "args": [
            "inode",
            "offset",
            "len",
            "mode"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "expand_inode_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "756-815",
          "snippet": "static int expand_inode_data(struct inode *inode, loff_t offset,\n\t\t\t\t\tloff_t len, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tpgoff_t index, pg_start, pg_end;\n\tloff_t new_size = i_size_read(inode);\n\tloff_t off_start, off_end;\n\tint ret = 0;\n\n\tf2fs_balance_fs(sbi);\n\n\tret = inode_newsize_ok(inode, (len + offset));\n\tif (ret)\n\t\treturn ret;\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tret = f2fs_convert_inline_inode(inode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpg_start = ((unsigned long long) offset) >> PAGE_CACHE_SHIFT;\n\tpg_end = ((unsigned long long) offset + len) >> PAGE_CACHE_SHIFT;\n\n\toff_start = offset & (PAGE_CACHE_SIZE - 1);\n\toff_end = (offset + len) & (PAGE_CACHE_SIZE - 1);\n\n\tf2fs_lock_op(sbi);\n\n\tfor (index = pg_start; index <= pg_end; index++) {\n\t\tstruct dnode_of_data dn;\n\n\t\tif (index == pg_end && !off_end)\n\t\t\tgoto noalloc;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\tret = f2fs_reserve_block(&dn, index);\n\t\tif (ret)\n\t\t\tbreak;\nnoalloc:\n\t\tif (pg_start == pg_end)\n\t\t\tnew_size = offset + len;\n\t\telse if (index == pg_start && off_start)\n\t\t\tnew_size = (index + 1) << PAGE_CACHE_SHIFT;\n\t\telse if (index == pg_end)\n\t\t\tnew_size = (index << PAGE_CACHE_SHIFT) + off_end;\n\t\telse\n\t\t\tnew_size += PAGE_CACHE_SIZE;\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t\ti_size_read(inode) < new_size) {\n\t\ti_size_write(inode, new_size);\n\t\tmark_inode_dirty(inode);\n\t\tupdate_inode_page(inode);\n\t}\n\tf2fs_unlock_op(sbi);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int expand_inode_data(struct inode *inode, loff_t offset,\n\t\t\t\t\tloff_t len, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tpgoff_t index, pg_start, pg_end;\n\tloff_t new_size = i_size_read(inode);\n\tloff_t off_start, off_end;\n\tint ret = 0;\n\n\tf2fs_balance_fs(sbi);\n\n\tret = inode_newsize_ok(inode, (len + offset));\n\tif (ret)\n\t\treturn ret;\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tret = f2fs_convert_inline_inode(inode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpg_start = ((unsigned long long) offset) >> PAGE_CACHE_SHIFT;\n\tpg_end = ((unsigned long long) offset + len) >> PAGE_CACHE_SHIFT;\n\n\toff_start = offset & (PAGE_CACHE_SIZE - 1);\n\toff_end = (offset + len) & (PAGE_CACHE_SIZE - 1);\n\n\tf2fs_lock_op(sbi);\n\n\tfor (index = pg_start; index <= pg_end; index++) {\n\t\tstruct dnode_of_data dn;\n\n\t\tif (index == pg_end && !off_end)\n\t\t\tgoto noalloc;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\tret = f2fs_reserve_block(&dn, index);\n\t\tif (ret)\n\t\t\tbreak;\nnoalloc:\n\t\tif (pg_start == pg_end)\n\t\t\tnew_size = offset + len;\n\t\telse if (index == pg_start && off_start)\n\t\t\tnew_size = (index + 1) << PAGE_CACHE_SHIFT;\n\t\telse if (index == pg_end)\n\t\t\tnew_size = (index << PAGE_CACHE_SHIFT) + off_end;\n\t\telse\n\t\t\tnew_size += PAGE_CACHE_SIZE;\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t\ti_size_read(inode) < new_size) {\n\t\ti_size_write(inode, new_size);\n\t\tmark_inode_dirty(inode);\n\t\tupdate_inode_page(inode);\n\t}\n\tf2fs_unlock_op(sbi);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "punch_hole",
          "args": [
            "inode",
            "offset",
            "len"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "punch_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "700-754",
          "snippet": "static int punch_hole(struct inode *inode, loff_t offset, loff_t len)\n{\n\tpgoff_t pg_start, pg_end;\n\tloff_t off_start, off_end;\n\tint ret = 0;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\t/* skip punching hole beyond i_size */\n\tif (offset >= inode->i_size)\n\t\treturn ret;\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tret = f2fs_convert_inline_inode(inode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpg_start = ((unsigned long long) offset) >> PAGE_CACHE_SHIFT;\n\tpg_end = ((unsigned long long) offset + len) >> PAGE_CACHE_SHIFT;\n\n\toff_start = offset & (PAGE_CACHE_SIZE - 1);\n\toff_end = (offset + len) & (PAGE_CACHE_SIZE - 1);\n\n\tif (pg_start == pg_end) {\n\t\tfill_zero(inode, pg_start, off_start,\n\t\t\t\t\t\toff_end - off_start);\n\t} else {\n\t\tif (off_start)\n\t\t\tfill_zero(inode, pg_start++, off_start,\n\t\t\t\t\tPAGE_CACHE_SIZE - off_start);\n\t\tif (off_end)\n\t\t\tfill_zero(inode, pg_end, 0, off_end);\n\n\t\tif (pg_start < pg_end) {\n\t\t\tstruct address_space *mapping = inode->i_mapping;\n\t\t\tloff_t blk_start, blk_end;\n\t\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\t\t\tf2fs_balance_fs(sbi);\n\n\t\t\tblk_start = pg_start << PAGE_CACHE_SHIFT;\n\t\t\tblk_end = pg_end << PAGE_CACHE_SHIFT;\n\t\t\ttruncate_inode_pages_range(mapping, blk_start,\n\t\t\t\t\tblk_end - 1);\n\n\t\t\tf2fs_lock_op(sbi);\n\t\t\tret = truncate_hole(inode, pg_start, pg_end);\n\t\t\tf2fs_unlock_op(sbi);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int punch_hole(struct inode *inode, loff_t offset, loff_t len)\n{\n\tpgoff_t pg_start, pg_end;\n\tloff_t off_start, off_end;\n\tint ret = 0;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\t/* skip punching hole beyond i_size */\n\tif (offset >= inode->i_size)\n\t\treturn ret;\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tret = f2fs_convert_inline_inode(inode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpg_start = ((unsigned long long) offset) >> PAGE_CACHE_SHIFT;\n\tpg_end = ((unsigned long long) offset + len) >> PAGE_CACHE_SHIFT;\n\n\toff_start = offset & (PAGE_CACHE_SIZE - 1);\n\toff_end = (offset + len) & (PAGE_CACHE_SIZE - 1);\n\n\tif (pg_start == pg_end) {\n\t\tfill_zero(inode, pg_start, off_start,\n\t\t\t\t\t\toff_end - off_start);\n\t} else {\n\t\tif (off_start)\n\t\t\tfill_zero(inode, pg_start++, off_start,\n\t\t\t\t\tPAGE_CACHE_SIZE - off_start);\n\t\tif (off_end)\n\t\t\tfill_zero(inode, pg_end, 0, off_end);\n\n\t\tif (pg_start < pg_end) {\n\t\t\tstruct address_space *mapping = inode->i_mapping;\n\t\t\tloff_t blk_start, blk_end;\n\t\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\t\t\tf2fs_balance_fs(sbi);\n\n\t\t\tblk_start = pg_start << PAGE_CACHE_SHIFT;\n\t\t\tblk_end = pg_end << PAGE_CACHE_SHIFT;\n\t\t\ttruncate_inode_pages_range(mapping, blk_start,\n\t\t\t\t\tblk_end - 1);\n\n\t\t\tf2fs_lock_op(sbi);\n\t\t\tret = truncate_hole(inode, pg_start, pg_end);\n\t\t\tf2fs_unlock_op(sbi);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic long f2fs_fallocate(struct file *file, int mode,\n\t\t\t\tloff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tlong ret;\n\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\tret = punch_hole(inode, offset, len);\n\telse\n\t\tret = expand_inode_data(inode, offset, len, mode);\n\n\tif (!ret) {\n\t\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tmutex_unlock(&inode->i_mutex);\n\n\ttrace_f2fs_fallocate(inode, mode, offset, len, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "expand_inode_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "756-815",
    "snippet": "static int expand_inode_data(struct inode *inode, loff_t offset,\n\t\t\t\t\tloff_t len, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tpgoff_t index, pg_start, pg_end;\n\tloff_t new_size = i_size_read(inode);\n\tloff_t off_start, off_end;\n\tint ret = 0;\n\n\tf2fs_balance_fs(sbi);\n\n\tret = inode_newsize_ok(inode, (len + offset));\n\tif (ret)\n\t\treturn ret;\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tret = f2fs_convert_inline_inode(inode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpg_start = ((unsigned long long) offset) >> PAGE_CACHE_SHIFT;\n\tpg_end = ((unsigned long long) offset + len) >> PAGE_CACHE_SHIFT;\n\n\toff_start = offset & (PAGE_CACHE_SIZE - 1);\n\toff_end = (offset + len) & (PAGE_CACHE_SIZE - 1);\n\n\tf2fs_lock_op(sbi);\n\n\tfor (index = pg_start; index <= pg_end; index++) {\n\t\tstruct dnode_of_data dn;\n\n\t\tif (index == pg_end && !off_end)\n\t\t\tgoto noalloc;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\tret = f2fs_reserve_block(&dn, index);\n\t\tif (ret)\n\t\t\tbreak;\nnoalloc:\n\t\tif (pg_start == pg_end)\n\t\t\tnew_size = offset + len;\n\t\telse if (index == pg_start && off_start)\n\t\t\tnew_size = (index + 1) << PAGE_CACHE_SHIFT;\n\t\telse if (index == pg_end)\n\t\t\tnew_size = (index << PAGE_CACHE_SHIFT) + off_end;\n\t\telse\n\t\t\tnew_size += PAGE_CACHE_SIZE;\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t\ti_size_read(inode) < new_size) {\n\t\ti_size_write(inode, new_size);\n\t\tmark_inode_dirty(inode);\n\t\tupdate_inode_page(inode);\n\t}\n\tf2fs_unlock_op(sbi);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_inode_page",
          "args": [
            "inode"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "246-264",
          "snippet": "void update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "new_size"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_reserve_block",
          "args": [
            "&dn",
            "index"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_reserve_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "235-249",
          "snippet": "int f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index)\n{\n\tbool need_put = dn->inode_page ? false : true;\n\tint err;\n\n\terr = get_dnode_of_data(dn, index, ALLOC_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (dn->data_blkaddr == NULL_ADDR)\n\t\terr = reserve_new_block(dn);\n\tif (err || need_put)\n\t\tf2fs_put_dnode(dn);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index)\n{\n\tbool need_put = dn->inode_page ? false : true;\n\tint err;\n\n\terr = get_dnode_of_data(dn, index, ALLOC_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (dn->data_blkaddr == NULL_ADDR)\n\t\terr = reserve_new_block(dn);\n\tif (err || need_put)\n\t\tf2fs_put_dnode(dn);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_convert_inline_inode",
          "args": [
            "inode"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_convert_inline_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "143-173",
          "snippet": "int f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "(len + offset)"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "99-124",
          "snippet": "int inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int expand_inode_data(struct inode *inode, loff_t offset,\n\t\t\t\t\tloff_t len, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tpgoff_t index, pg_start, pg_end;\n\tloff_t new_size = i_size_read(inode);\n\tloff_t off_start, off_end;\n\tint ret = 0;\n\n\tf2fs_balance_fs(sbi);\n\n\tret = inode_newsize_ok(inode, (len + offset));\n\tif (ret)\n\t\treturn ret;\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tret = f2fs_convert_inline_inode(inode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpg_start = ((unsigned long long) offset) >> PAGE_CACHE_SHIFT;\n\tpg_end = ((unsigned long long) offset + len) >> PAGE_CACHE_SHIFT;\n\n\toff_start = offset & (PAGE_CACHE_SIZE - 1);\n\toff_end = (offset + len) & (PAGE_CACHE_SIZE - 1);\n\n\tf2fs_lock_op(sbi);\n\n\tfor (index = pg_start; index <= pg_end; index++) {\n\t\tstruct dnode_of_data dn;\n\n\t\tif (index == pg_end && !off_end)\n\t\t\tgoto noalloc;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\tret = f2fs_reserve_block(&dn, index);\n\t\tif (ret)\n\t\t\tbreak;\nnoalloc:\n\t\tif (pg_start == pg_end)\n\t\t\tnew_size = offset + len;\n\t\telse if (index == pg_start && off_start)\n\t\t\tnew_size = (index + 1) << PAGE_CACHE_SHIFT;\n\t\telse if (index == pg_end)\n\t\t\tnew_size = (index << PAGE_CACHE_SHIFT) + off_end;\n\t\telse\n\t\t\tnew_size += PAGE_CACHE_SIZE;\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t\ti_size_read(inode) < new_size) {\n\t\ti_size_write(inode, new_size);\n\t\tmark_inode_dirty(inode);\n\t\tupdate_inode_page(inode);\n\t}\n\tf2fs_unlock_op(sbi);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "punch_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "700-754",
    "snippet": "static int punch_hole(struct inode *inode, loff_t offset, loff_t len)\n{\n\tpgoff_t pg_start, pg_end;\n\tloff_t off_start, off_end;\n\tint ret = 0;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\t/* skip punching hole beyond i_size */\n\tif (offset >= inode->i_size)\n\t\treturn ret;\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tret = f2fs_convert_inline_inode(inode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpg_start = ((unsigned long long) offset) >> PAGE_CACHE_SHIFT;\n\tpg_end = ((unsigned long long) offset + len) >> PAGE_CACHE_SHIFT;\n\n\toff_start = offset & (PAGE_CACHE_SIZE - 1);\n\toff_end = (offset + len) & (PAGE_CACHE_SIZE - 1);\n\n\tif (pg_start == pg_end) {\n\t\tfill_zero(inode, pg_start, off_start,\n\t\t\t\t\t\toff_end - off_start);\n\t} else {\n\t\tif (off_start)\n\t\t\tfill_zero(inode, pg_start++, off_start,\n\t\t\t\t\tPAGE_CACHE_SIZE - off_start);\n\t\tif (off_end)\n\t\t\tfill_zero(inode, pg_end, 0, off_end);\n\n\t\tif (pg_start < pg_end) {\n\t\t\tstruct address_space *mapping = inode->i_mapping;\n\t\t\tloff_t blk_start, blk_end;\n\t\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\t\t\tf2fs_balance_fs(sbi);\n\n\t\t\tblk_start = pg_start << PAGE_CACHE_SHIFT;\n\t\t\tblk_end = pg_end << PAGE_CACHE_SHIFT;\n\t\t\ttruncate_inode_pages_range(mapping, blk_start,\n\t\t\t\t\tblk_end - 1);\n\n\t\t\tf2fs_lock_op(sbi);\n\t\t\tret = truncate_hole(inode, pg_start, pg_end);\n\t\t\tf2fs_unlock_op(sbi);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_hole",
          "args": [
            "inode",
            "pg_start",
            "pg_end"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "677-698",
          "snippet": "int truncate_hole(struct inode *inode, pgoff_t pg_start, pgoff_t pg_end)\n{\n\tpgoff_t index;\n\tint err;\n\n\tfor (index = pg_start; index < pg_end; index++) {\n\t\tstruct dnode_of_data dn;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\treturn err;\n\t\t}\n\n\t\tif (dn.data_blkaddr != NULL_ADDR)\n\t\t\ttruncate_data_blocks_range(&dn, 1);\n\t\tf2fs_put_dnode(&dn);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_hole(struct inode *inode, pgoff_t pg_start, pgoff_t pg_end)\n{\n\tpgoff_t index;\n\tint err;\n\n\tfor (index = pg_start; index < pg_end; index++) {\n\t\tstruct dnode_of_data dn;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\treturn err;\n\t\t}\n\n\t\tif (dn.data_blkaddr != NULL_ADDR)\n\t\t\ttruncate_data_blocks_range(&dn, 1);\n\t\tf2fs_put_dnode(&dn);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_range",
          "args": [
            "mapping",
            "blk_start",
            "blk_end - 1"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_zero",
          "args": [
            "inode",
            "pg_end",
            "0",
            "off_end"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "fill_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "654-675",
          "snippet": "static void fill_zero(struct inode *inode, pgoff_t index,\n\t\t\t\t\tloff_t start, loff_t len)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *page;\n\n\tif (!len)\n\t\treturn;\n\n\tf2fs_balance_fs(sbi);\n\n\tf2fs_lock_op(sbi);\n\tpage = get_new_data_page(inode, NULL, index, false);\n\tf2fs_unlock_op(sbi);\n\n\tif (!IS_ERR(page)) {\n\t\tf2fs_wait_on_page_writeback(page, DATA);\n\t\tzero_user(page, start, len);\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void fill_zero(struct inode *inode, pgoff_t index,\n\t\t\t\t\tloff_t start, loff_t len)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *page;\n\n\tif (!len)\n\t\treturn;\n\n\tf2fs_balance_fs(sbi);\n\n\tf2fs_lock_op(sbi);\n\tpage = get_new_data_page(inode, NULL, index, false);\n\tf2fs_unlock_op(sbi);\n\n\tif (!IS_ERR(page)) {\n\t\tf2fs_wait_on_page_writeback(page, DATA);\n\t\tzero_user(page, start, len);\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_convert_inline_inode",
          "args": [
            "inode"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_convert_inline_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "143-173",
          "snippet": "int f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int punch_hole(struct inode *inode, loff_t offset, loff_t len)\n{\n\tpgoff_t pg_start, pg_end;\n\tloff_t off_start, off_end;\n\tint ret = 0;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\t/* skip punching hole beyond i_size */\n\tif (offset >= inode->i_size)\n\t\treturn ret;\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tret = f2fs_convert_inline_inode(inode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpg_start = ((unsigned long long) offset) >> PAGE_CACHE_SHIFT;\n\tpg_end = ((unsigned long long) offset + len) >> PAGE_CACHE_SHIFT;\n\n\toff_start = offset & (PAGE_CACHE_SIZE - 1);\n\toff_end = (offset + len) & (PAGE_CACHE_SIZE - 1);\n\n\tif (pg_start == pg_end) {\n\t\tfill_zero(inode, pg_start, off_start,\n\t\t\t\t\t\toff_end - off_start);\n\t} else {\n\t\tif (off_start)\n\t\t\tfill_zero(inode, pg_start++, off_start,\n\t\t\t\t\tPAGE_CACHE_SIZE - off_start);\n\t\tif (off_end)\n\t\t\tfill_zero(inode, pg_end, 0, off_end);\n\n\t\tif (pg_start < pg_end) {\n\t\t\tstruct address_space *mapping = inode->i_mapping;\n\t\t\tloff_t blk_start, blk_end;\n\t\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\t\t\tf2fs_balance_fs(sbi);\n\n\t\t\tblk_start = pg_start << PAGE_CACHE_SHIFT;\n\t\t\tblk_end = pg_end << PAGE_CACHE_SHIFT;\n\t\t\ttruncate_inode_pages_range(mapping, blk_start,\n\t\t\t\t\tblk_end - 1);\n\n\t\t\tf2fs_lock_op(sbi);\n\t\t\tret = truncate_hole(inode, pg_start, pg_end);\n\t\t\tf2fs_unlock_op(sbi);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "truncate_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "677-698",
    "snippet": "int truncate_hole(struct inode *inode, pgoff_t pg_start, pgoff_t pg_end)\n{\n\tpgoff_t index;\n\tint err;\n\n\tfor (index = pg_start; index < pg_end; index++) {\n\t\tstruct dnode_of_data dn;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\treturn err;\n\t\t}\n\n\t\tif (dn.data_blkaddr != NULL_ADDR)\n\t\t\ttruncate_data_blocks_range(&dn, 1);\n\t\tf2fs_put_dnode(&dn);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_dnode",
          "args": [
            "&dn"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1048-1056",
          "snippet": "static inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_data_blocks_range",
          "args": [
            "&dn",
            "1"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_data_blocks_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "420-450",
          "snippet": "int truncate_data_blocks_range(struct dnode_of_data *dn, int count)\n{\n\tint nr_free = 0, ofs = dn->ofs_in_node;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr;\n\n\traw_node = F2FS_NODE(dn->node_page);\n\taddr = blkaddr_in_node(raw_node) + ofs;\n\n\tfor (; count > 0; count--, addr++, dn->ofs_in_node++) {\n\t\tblock_t blkaddr = le32_to_cpu(*addr);\n\t\tif (blkaddr == NULL_ADDR)\n\t\t\tcontinue;\n\n\t\tdn->data_blkaddr = NULL_ADDR;\n\t\tupdate_extent_cache(dn);\n\t\tinvalidate_blocks(sbi, blkaddr);\n\t\tnr_free++;\n\t}\n\tif (nr_free) {\n\t\tdec_valid_block_count(sbi, dn->inode, nr_free);\n\t\tset_page_dirty(dn->node_page);\n\t\tsync_inode_page(dn);\n\t}\n\tdn->ofs_in_node = ofs;\n\n\ttrace_f2fs_truncate_data_blocks_range(dn->inode, dn->nid,\n\t\t\t\t\t dn->ofs_in_node, nr_free);\n\treturn nr_free;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_data_blocks_range(struct dnode_of_data *dn, int count)\n{\n\tint nr_free = 0, ofs = dn->ofs_in_node;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr;\n\n\traw_node = F2FS_NODE(dn->node_page);\n\taddr = blkaddr_in_node(raw_node) + ofs;\n\n\tfor (; count > 0; count--, addr++, dn->ofs_in_node++) {\n\t\tblock_t blkaddr = le32_to_cpu(*addr);\n\t\tif (blkaddr == NULL_ADDR)\n\t\t\tcontinue;\n\n\t\tdn->data_blkaddr = NULL_ADDR;\n\t\tupdate_extent_cache(dn);\n\t\tinvalidate_blocks(sbi, blkaddr);\n\t\tnr_free++;\n\t}\n\tif (nr_free) {\n\t\tdec_valid_block_count(sbi, dn->inode, nr_free);\n\t\tset_page_dirty(dn->node_page);\n\t\tsync_inode_page(dn);\n\t}\n\tdn->ofs_in_node = ofs;\n\n\ttrace_f2fs_truncate_data_blocks_range(dn->inode, dn->nid,\n\t\t\t\t\t dn->ofs_in_node, nr_free);\n\treturn nr_free;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dnode_of_data",
          "args": [
            "&dn",
            "index",
            "LOOKUP_NODE"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "get_dnode_of_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "473-572",
          "snippet": "int get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_hole(struct inode *inode, pgoff_t pg_start, pgoff_t pg_end)\n{\n\tpgoff_t index;\n\tint err;\n\n\tfor (index = pg_start; index < pg_end; index++) {\n\t\tstruct dnode_of_data dn;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\treturn err;\n\t\t}\n\n\t\tif (dn.data_blkaddr != NULL_ADDR)\n\t\t\ttruncate_data_blocks_range(&dn, 1);\n\t\tf2fs_put_dnode(&dn);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "fill_zero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "654-675",
    "snippet": "static void fill_zero(struct inode *inode, pgoff_t index,\n\t\t\t\t\tloff_t start, loff_t len)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *page;\n\n\tif (!len)\n\t\treturn;\n\n\tf2fs_balance_fs(sbi);\n\n\tf2fs_lock_op(sbi);\n\tpage = get_new_data_page(inode, NULL, index, false);\n\tf2fs_unlock_op(sbi);\n\n\tif (!IS_ERR(page)) {\n\t\tf2fs_wait_on_page_writeback(page, DATA);\n\t\tzero_user(page, start, len);\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "start",
            "len"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "page",
            "DATA"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_new_data_page",
          "args": [
            "inode",
            "NULL",
            "index",
            "false"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "get_new_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "501-559",
          "snippet": "struct page *get_new_data_page(struct inode *inode,\n\t\tstruct page *ipage, pgoff_t index, bool new_i_size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tint err;\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, index);\n\tif (err)\n\t\treturn ERR_PTR(err);\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\terr = -ENOMEM;\n\t\tgoto put_err;\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn page;\n\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t} else {\n\t\tstruct f2fs_io_info fio = {\n\t\t\t.type = DATA,\n\t\t\t.rw = READ_SYNC,\n\t\t\t.blk_addr = dn.data_blkaddr,\n\t\t};\n\t\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\t\tif (err)\n\t\t\tgoto put_err;\n\n\t\tlock_page(page);\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\terr = -EIO;\n\t\t\tgoto put_err;\n\t\t}\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\n\tif (new_i_size &&\n\t\ti_size_read(inode) < ((index + 1) << PAGE_CACHE_SHIFT)) {\n\t\ti_size_write(inode, ((index + 1) << PAGE_CACHE_SHIFT));\n\t\t/* Only the directory inode sets new_i_size */\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_DIR);\n\t}\n\treturn page;\n\nput_err:\n\tf2fs_put_dnode(&dn);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_new_data_page(struct inode *inode,\n\t\tstruct page *ipage, pgoff_t index, bool new_i_size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tint err;\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, index);\n\tif (err)\n\t\treturn ERR_PTR(err);\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\terr = -ENOMEM;\n\t\tgoto put_err;\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn page;\n\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t} else {\n\t\tstruct f2fs_io_info fio = {\n\t\t\t.type = DATA,\n\t\t\t.rw = READ_SYNC,\n\t\t\t.blk_addr = dn.data_blkaddr,\n\t\t};\n\t\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\t\tif (err)\n\t\t\tgoto put_err;\n\n\t\tlock_page(page);\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\terr = -EIO;\n\t\t\tgoto put_err;\n\t\t}\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\n\tif (new_i_size &&\n\t\ti_size_read(inode) < ((index + 1) << PAGE_CACHE_SHIFT)) {\n\t\ti_size_write(inode, ((index + 1) << PAGE_CACHE_SHIFT));\n\t\t/* Only the directory inode sets new_i_size */\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_DIR);\n\t}\n\treturn page;\n\nput_err:\n\tf2fs_put_dnode(&dn);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void fill_zero(struct inode *inode, pgoff_t index,\n\t\t\t\t\tloff_t start, loff_t len)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *page;\n\n\tif (!len)\n\t\treturn;\n\n\tf2fs_balance_fs(sbi);\n\n\tf2fs_lock_op(sbi);\n\tpage = get_new_data_page(inode, NULL, index, false);\n\tf2fs_unlock_op(sbi);\n\n\tif (!IS_ERR(page)) {\n\t\tf2fs_wait_on_page_writeback(page, DATA);\n\t\tzero_user(page, start, len);\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n}"
  },
  {
    "function_name": "f2fs_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "602-638",
    "snippet": "int f2fs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tint err;\n\n\terr = inode_change_ok(inode, attr);\n\tif (err)\n\t\treturn err;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tif (attr->ia_size != i_size_read(inode)) {\n\t\t\ttruncate_setsize(inode, attr->ia_size);\n\t\t\tf2fs_truncate(inode);\n\t\t\tf2fs_balance_fs(F2FS_I_SB(inode));\n\t\t} else {\n\t\t\t/*\n\t\t\t * giving a chance to truncate blocks past EOF which\n\t\t\t * are fallocated with FALLOC_FL_KEEP_SIZE.\n\t\t\t */\n\t\t\tf2fs_truncate(inode);\n\t\t}\n\t}\n\n\t__setattr_copy(inode, attr);\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\terr = posix_acl_chmod(inode, get_inode_mode(inode));\n\t\tif (err || is_inode_flag_set(fi, FI_ACL_MODE)) {\n\t\t\tinode->i_mode = fi->i_acl_mode;\n\t\t\tclear_inode_flag(fi, FI_ACL_MODE);\n\t\t}\n\t}\n\n\tmark_inode_dirty(inode);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define __setattr_copy setattr_copy"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "fi",
            "FI_ACL_MODE"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_inode_flag_set",
          "args": [
            "fi",
            "FI_ACL_MODE"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1179-1182",
          "snippet": "static inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_chmod",
          "args": [
            "inode",
            "get_inode_mode(inode)"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "518-542",
          "snippet": "int\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode_mode",
          "args": [
            "inode"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "__setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "572-597",
          "snippet": "static void __setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tset_acl_inode(fi, mode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define __setattr_copy setattr_copy"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\n#define __setattr_copy setattr_copy\n\nstatic void __setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tset_acl_inode(fi, mode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_truncate",
          "args": [
            "inode"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "542-560",
          "snippet": "void f2fs_truncate(struct inode *inode)\n{\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode)))\n\t\treturn;\n\n\ttrace_f2fs_truncate(inode);\n\n\t/* we should check inline_data size */\n\tif (f2fs_has_inline_data(inode) && !f2fs_may_inline(inode)) {\n\t\tif (f2fs_convert_inline_inode(inode))\n\t\t\treturn;\n\t}\n\n\tif (!truncate_blocks(inode, i_size_read(inode), true)) {\n\t\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(inode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_truncate(struct inode *inode)\n{\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode)))\n\t\treturn;\n\n\ttrace_f2fs_truncate(inode);\n\n\t/* we should check inline_data size */\n\tif (f2fs_has_inline_data(inode) && !f2fs_may_inline(inode)) {\n\t\tif (f2fs_convert_inline_inode(inode))\n\t\t\treturn;\n\t}\n\n\tif (!truncate_blocks(inode, i_size_read(inode), true)) {\n\t\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "F2FS_I_SB(inode)"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\n#define __setattr_copy setattr_copy\n\nint f2fs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tint err;\n\n\terr = inode_change_ok(inode, attr);\n\tif (err)\n\t\treturn err;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tif (attr->ia_size != i_size_read(inode)) {\n\t\t\ttruncate_setsize(inode, attr->ia_size);\n\t\t\tf2fs_truncate(inode);\n\t\t\tf2fs_balance_fs(F2FS_I_SB(inode));\n\t\t} else {\n\t\t\t/*\n\t\t\t * giving a chance to truncate blocks past EOF which\n\t\t\t * are fallocated with FALLOC_FL_KEEP_SIZE.\n\t\t\t */\n\t\t\tf2fs_truncate(inode);\n\t\t}\n\t}\n\n\t__setattr_copy(inode, attr);\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\terr = posix_acl_chmod(inode, get_inode_mode(inode));\n\t\tif (err || is_inode_flag_set(fi, FI_ACL_MODE)) {\n\t\t\tinode->i_mode = fi->i_acl_mode;\n\t\t\tclear_inode_flag(fi, FI_ACL_MODE);\n\t\t}\n\t}\n\n\tmark_inode_dirty(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "__setattr_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "572-597",
    "snippet": "static void __setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tset_acl_inode(fi, mode);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define __setattr_copy setattr_copy"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_acl_inode",
          "args": [
            "fi",
            "mode"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "set_acl_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1190-1194",
          "snippet": "static inline void set_acl_inode(struct f2fs_inode_info *fi, umode_t mode)\n{\n\tfi->i_acl_mode = mode;\n\tset_inode_flag(fi, FI_ACL_MODE);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_acl_inode(struct f2fs_inode_info *fi, umode_t mode)\n{\n\tfi->i_acl_mode = mode;\n\tset_inode_flag(fi, FI_ACL_MODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_FSETID"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "inode->i_gid"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_trunc",
          "args": [
            "attr->ia_ctime",
            "inode->i_sb->s_time_gran"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_trunc",
          "args": [
            "attr->ia_mtime",
            "inode->i_sb->s_time_gran"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_trunc",
          "args": [
            "attr->ia_atime",
            "inode->i_sb->s_time_gran"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\n#define __setattr_copy setattr_copy\n\nstatic void __setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tset_acl_inode(fi, mode);\n\t}\n}"
  },
  {
    "function_name": "f2fs_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "562-569",
    "snippet": "int f2fs_getattr(struct vfsmount *mnt,\n\t\t\t struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tgeneric_fillattr(inode, stat);\n\tstat->blocks <<= 3;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "inode",
            "stat"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_getattr(struct vfsmount *mnt,\n\t\t\t struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tgeneric_fillattr(inode, stat);\n\tstat->blocks <<= 3;\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "542-560",
    "snippet": "void f2fs_truncate(struct inode *inode)\n{\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode)))\n\t\treturn;\n\n\ttrace_f2fs_truncate(inode);\n\n\t/* we should check inline_data size */\n\tif (f2fs_has_inline_data(inode) && !f2fs_may_inline(inode)) {\n\t\tif (f2fs_convert_inline_inode(inode))\n\t\t\treturn;\n\t}\n\n\tif (!truncate_blocks(inode, i_size_read(inode), true)) {\n\t\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(inode);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_blocks",
          "args": [
            "inode",
            "i_size_read(inode)",
            "true"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "482-540",
          "snippet": "int truncate_blocks(struct inode *inode, u64 from, bool lock)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tunsigned int blocksize = inode->i_sb->s_blocksize;\n\tstruct dnode_of_data dn;\n\tpgoff_t free_from;\n\tint count = 0, err = 0;\n\tstruct page *ipage;\n\n\ttrace_f2fs_truncate_blocks_enter(inode, from);\n\n\tfree_from = (pgoff_t)F2FS_BYTES_TO_BLK(from + blocksize - 1);\n\n\tif (lock)\n\t\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = get_dnode_of_data(&dn, free_from, LOOKUP_NODE);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\tgoto free_next;\n\t\tgoto out;\n\t}\n\n\tcount = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\n\tcount -= dn.ofs_in_node;\n\tf2fs_bug_on(sbi, count < 0);\n\n\tif (dn.ofs_in_node || IS_INODE(dn.node_page)) {\n\t\ttruncate_data_blocks_range(&dn, count);\n\t\tfree_from += count;\n\t}\n\n\tf2fs_put_dnode(&dn);\nfree_next:\n\terr = truncate_inode_blocks(inode, free_from);\nout:\n\tif (lock)\n\t\tf2fs_unlock_op(sbi);\n\n\t/* lastly zero out the first data page */\n\tif (!err)\n\t\terr = truncate_partial_data_page(inode, from);\n\n\ttrace_f2fs_truncate_blocks_exit(inode, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_blocks(struct inode *inode, u64 from, bool lock)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tunsigned int blocksize = inode->i_sb->s_blocksize;\n\tstruct dnode_of_data dn;\n\tpgoff_t free_from;\n\tint count = 0, err = 0;\n\tstruct page *ipage;\n\n\ttrace_f2fs_truncate_blocks_enter(inode, from);\n\n\tfree_from = (pgoff_t)F2FS_BYTES_TO_BLK(from + blocksize - 1);\n\n\tif (lock)\n\t\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = get_dnode_of_data(&dn, free_from, LOOKUP_NODE);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\tgoto free_next;\n\t\tgoto out;\n\t}\n\n\tcount = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\n\tcount -= dn.ofs_in_node;\n\tf2fs_bug_on(sbi, count < 0);\n\n\tif (dn.ofs_in_node || IS_INODE(dn.node_page)) {\n\t\ttruncate_data_blocks_range(&dn, count);\n\t\tfree_from += count;\n\t}\n\n\tf2fs_put_dnode(&dn);\nfree_next:\n\terr = truncate_inode_blocks(inode, free_from);\nout:\n\tif (lock)\n\t\tf2fs_unlock_op(sbi);\n\n\t/* lastly zero out the first data page */\n\tif (!err)\n\t\terr = truncate_partial_data_page(inode, from);\n\n\ttrace_f2fs_truncate_blocks_exit(inode, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_convert_inline_inode",
          "args": [
            "inode"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_convert_inline_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "143-173",
          "snippet": "int f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_may_inline",
          "args": [
            "inode"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_may_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "16-31",
          "snippet": "bool f2fs_may_inline(struct inode *inode)\n{\n\tif (!test_opt(F2FS_I_SB(inode), INLINE_DATA))\n\t\treturn false;\n\n\tif (f2fs_is_atomic_file(inode))\n\t\treturn false;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn false;\n\n\tif (i_size_read(inode) > MAX_INLINE_DATA)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool f2fs_may_inline(struct inode *inode)\n{\n\tif (!test_opt(F2FS_I_SB(inode), INLINE_DATA))\n\t\treturn false;\n\n\tif (f2fs_is_atomic_file(inode))\n\t\treturn false;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn false;\n\n\tif (i_size_read(inode) > MAX_INLINE_DATA)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_truncate",
          "args": [
            "inode"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_truncate(struct inode *inode)\n{\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode)))\n\t\treturn;\n\n\ttrace_f2fs_truncate(inode);\n\n\t/* we should check inline_data size */\n\tif (f2fs_has_inline_data(inode) && !f2fs_may_inline(inode)) {\n\t\tif (f2fs_convert_inline_inode(inode))\n\t\t\treturn;\n\t}\n\n\tif (!truncate_blocks(inode, i_size_read(inode), true)) {\n\t\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(inode);\n\t}\n}"
  },
  {
    "function_name": "truncate_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "482-540",
    "snippet": "int truncate_blocks(struct inode *inode, u64 from, bool lock)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tunsigned int blocksize = inode->i_sb->s_blocksize;\n\tstruct dnode_of_data dn;\n\tpgoff_t free_from;\n\tint count = 0, err = 0;\n\tstruct page *ipage;\n\n\ttrace_f2fs_truncate_blocks_enter(inode, from);\n\n\tfree_from = (pgoff_t)F2FS_BYTES_TO_BLK(from + blocksize - 1);\n\n\tif (lock)\n\t\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = get_dnode_of_data(&dn, free_from, LOOKUP_NODE);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\tgoto free_next;\n\t\tgoto out;\n\t}\n\n\tcount = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\n\tcount -= dn.ofs_in_node;\n\tf2fs_bug_on(sbi, count < 0);\n\n\tif (dn.ofs_in_node || IS_INODE(dn.node_page)) {\n\t\ttruncate_data_blocks_range(&dn, count);\n\t\tfree_from += count;\n\t}\n\n\tf2fs_put_dnode(&dn);\nfree_next:\n\terr = truncate_inode_blocks(inode, free_from);\nout:\n\tif (lock)\n\t\tf2fs_unlock_op(sbi);\n\n\t/* lastly zero out the first data page */\n\tif (!err)\n\t\terr = truncate_partial_data_page(inode, from);\n\n\ttrace_f2fs_truncate_blocks_exit(inode, err);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_f2fs_truncate_blocks_exit",
          "args": [
            "inode",
            "err"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_partial_data_page",
          "args": [
            "inode",
            "from"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_partial_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "457-480",
          "snippet": "static int truncate_partial_data_page(struct inode *inode, u64 from)\n{\n\tunsigned offset = from & (PAGE_CACHE_SIZE - 1);\n\tstruct page *page;\n\n\tif (!offset)\n\t\treturn 0;\n\n\tpage = find_data_page(inode, from >> PAGE_CACHE_SHIFT, false);\n\tif (IS_ERR(page))\n\t\treturn 0;\n\n\tlock_page(page);\n\tif (unlikely(!PageUptodate(page) ||\n\t\t\tpage->mapping != inode->i_mapping))\n\t\tgoto out;\n\n\tf2fs_wait_on_page_writeback(page, DATA);\n\tzero_user(page, offset, PAGE_CACHE_SIZE - offset);\n\tset_page_dirty(page);\nout:\n\tf2fs_put_page(page, 1);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int truncate_partial_data_page(struct inode *inode, u64 from)\n{\n\tunsigned offset = from & (PAGE_CACHE_SIZE - 1);\n\tstruct page *page;\n\n\tif (!offset)\n\t\treturn 0;\n\n\tpage = find_data_page(inode, from >> PAGE_CACHE_SHIFT, false);\n\tif (IS_ERR(page))\n\t\treturn 0;\n\n\tlock_page(page);\n\tif (unlikely(!PageUptodate(page) ||\n\t\t\tpage->mapping != inode->i_mapping))\n\t\tgoto out;\n\n\tf2fs_wait_on_page_writeback(page, DATA);\n\tzero_user(page, offset, PAGE_CACHE_SIZE - offset);\n\tset_page_dirty(page);\nout:\n\tf2fs_put_page(page, 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_blocks",
          "args": [
            "inode",
            "free_from"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "763-857",
          "snippet": "int truncate_inode_blocks(struct inode *inode, pgoff_t from)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint err = 0, cont = 1;\n\tint level, offset[4], noffset[4];\n\tunsigned int nofs = 0;\n\tstruct f2fs_inode *ri;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\n\ttrace_f2fs_truncate_inode_blocks_enter(inode, from);\n\n\tlevel = get_node_path(F2FS_I(inode), from, offset, noffset);\nrestart:\n\tpage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(page)) {\n\t\ttrace_f2fs_truncate_inode_blocks_exit(inode, PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\n\tset_new_dnode(&dn, inode, page, NULL, 0);\n\tunlock_page(page);\n\n\tri = F2FS_INODE(page);\n\tswitch (level) {\n\tcase 0:\n\tcase 1:\n\t\tnofs = noffset[1];\n\t\tbreak;\n\tcase 2:\n\t\tnofs = noffset[1];\n\t\tif (!offset[level - 1])\n\t\t\tgoto skip_partial;\n\t\terr = truncate_partial_nodes(&dn, ri, offset, level);\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tnofs += 1 + NIDS_PER_BLOCK;\n\t\tbreak;\n\tcase 3:\n\t\tnofs = 5 + 2 * NIDS_PER_BLOCK;\n\t\tif (!offset[level - 1])\n\t\t\tgoto skip_partial;\n\t\terr = truncate_partial_nodes(&dn, ri, offset, level);\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\nskip_partial:\n\twhile (cont) {\n\t\tdn.nid = le32_to_cpu(ri->i_nid[offset[0] - NODE_DIR1_BLOCK]);\n\t\tswitch (offset[0]) {\n\t\tcase NODE_DIR1_BLOCK:\n\t\tcase NODE_DIR2_BLOCK:\n\t\t\terr = truncate_dnode(&dn);\n\t\t\tbreak;\n\n\t\tcase NODE_IND1_BLOCK:\n\t\tcase NODE_IND2_BLOCK:\n\t\t\terr = truncate_nodes(&dn, nofs, offset[1], 2);\n\t\t\tbreak;\n\n\t\tcase NODE_DIND_BLOCK:\n\t\t\terr = truncate_nodes(&dn, nofs, offset[1], 3);\n\t\t\tcont = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tif (offset[1] == 0 &&\n\t\t\t\tri->i_nid[offset[0] - NODE_DIR1_BLOCK]) {\n\t\t\tlock_page(page);\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\t\t\tf2fs_put_page(page, 1);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tf2fs_wait_on_page_writeback(page, NODE);\n\t\t\tri->i_nid[offset[0] - NODE_DIR1_BLOCK] = 0;\n\t\t\tset_page_dirty(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\toffset[1] = 0;\n\t\toffset[0]++;\n\t\tnofs += err;\n\t}\nfail:\n\tf2fs_put_page(page, 0);\n\ttrace_f2fs_truncate_inode_blocks_exit(inode, err);\n\treturn err > 0 ? 0 : err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_inode_blocks(struct inode *inode, pgoff_t from)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint err = 0, cont = 1;\n\tint level, offset[4], noffset[4];\n\tunsigned int nofs = 0;\n\tstruct f2fs_inode *ri;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\n\ttrace_f2fs_truncate_inode_blocks_enter(inode, from);\n\n\tlevel = get_node_path(F2FS_I(inode), from, offset, noffset);\nrestart:\n\tpage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(page)) {\n\t\ttrace_f2fs_truncate_inode_blocks_exit(inode, PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\n\tset_new_dnode(&dn, inode, page, NULL, 0);\n\tunlock_page(page);\n\n\tri = F2FS_INODE(page);\n\tswitch (level) {\n\tcase 0:\n\tcase 1:\n\t\tnofs = noffset[1];\n\t\tbreak;\n\tcase 2:\n\t\tnofs = noffset[1];\n\t\tif (!offset[level - 1])\n\t\t\tgoto skip_partial;\n\t\terr = truncate_partial_nodes(&dn, ri, offset, level);\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tnofs += 1 + NIDS_PER_BLOCK;\n\t\tbreak;\n\tcase 3:\n\t\tnofs = 5 + 2 * NIDS_PER_BLOCK;\n\t\tif (!offset[level - 1])\n\t\t\tgoto skip_partial;\n\t\terr = truncate_partial_nodes(&dn, ri, offset, level);\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\nskip_partial:\n\twhile (cont) {\n\t\tdn.nid = le32_to_cpu(ri->i_nid[offset[0] - NODE_DIR1_BLOCK]);\n\t\tswitch (offset[0]) {\n\t\tcase NODE_DIR1_BLOCK:\n\t\tcase NODE_DIR2_BLOCK:\n\t\t\terr = truncate_dnode(&dn);\n\t\t\tbreak;\n\n\t\tcase NODE_IND1_BLOCK:\n\t\tcase NODE_IND2_BLOCK:\n\t\t\terr = truncate_nodes(&dn, nofs, offset[1], 2);\n\t\t\tbreak;\n\n\t\tcase NODE_DIND_BLOCK:\n\t\t\terr = truncate_nodes(&dn, nofs, offset[1], 3);\n\t\t\tcont = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tif (offset[1] == 0 &&\n\t\t\t\tri->i_nid[offset[0] - NODE_DIR1_BLOCK]) {\n\t\t\tlock_page(page);\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\t\t\tf2fs_put_page(page, 1);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tf2fs_wait_on_page_writeback(page, NODE);\n\t\t\tri->i_nid[offset[0] - NODE_DIR1_BLOCK] = 0;\n\t\t\tset_page_dirty(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\toffset[1] = 0;\n\t\toffset[0]++;\n\t\tnofs += err;\n\t}\nfail:\n\tf2fs_put_page(page, 0);\n\ttrace_f2fs_truncate_inode_blocks_exit(inode, err);\n\treturn err > 0 ? 0 : err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_dnode",
          "args": [
            "&dn"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1048-1056",
          "snippet": "static inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_data_blocks_range",
          "args": [
            "&dn",
            "count"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_data_blocks_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "420-450",
          "snippet": "int truncate_data_blocks_range(struct dnode_of_data *dn, int count)\n{\n\tint nr_free = 0, ofs = dn->ofs_in_node;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr;\n\n\traw_node = F2FS_NODE(dn->node_page);\n\taddr = blkaddr_in_node(raw_node) + ofs;\n\n\tfor (; count > 0; count--, addr++, dn->ofs_in_node++) {\n\t\tblock_t blkaddr = le32_to_cpu(*addr);\n\t\tif (blkaddr == NULL_ADDR)\n\t\t\tcontinue;\n\n\t\tdn->data_blkaddr = NULL_ADDR;\n\t\tupdate_extent_cache(dn);\n\t\tinvalidate_blocks(sbi, blkaddr);\n\t\tnr_free++;\n\t}\n\tif (nr_free) {\n\t\tdec_valid_block_count(sbi, dn->inode, nr_free);\n\t\tset_page_dirty(dn->node_page);\n\t\tsync_inode_page(dn);\n\t}\n\tdn->ofs_in_node = ofs;\n\n\ttrace_f2fs_truncate_data_blocks_range(dn->inode, dn->nid,\n\t\t\t\t\t dn->ofs_in_node, nr_free);\n\treturn nr_free;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_data_blocks_range(struct dnode_of_data *dn, int count)\n{\n\tint nr_free = 0, ofs = dn->ofs_in_node;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr;\n\n\traw_node = F2FS_NODE(dn->node_page);\n\taddr = blkaddr_in_node(raw_node) + ofs;\n\n\tfor (; count > 0; count--, addr++, dn->ofs_in_node++) {\n\t\tblock_t blkaddr = le32_to_cpu(*addr);\n\t\tif (blkaddr == NULL_ADDR)\n\t\t\tcontinue;\n\n\t\tdn->data_blkaddr = NULL_ADDR;\n\t\tupdate_extent_cache(dn);\n\t\tinvalidate_blocks(sbi, blkaddr);\n\t\tnr_free++;\n\t}\n\tif (nr_free) {\n\t\tdec_valid_block_count(sbi, dn->inode, nr_free);\n\t\tset_page_dirty(dn->node_page);\n\t\tsync_inode_page(dn);\n\t}\n\tdn->ofs_in_node = ofs;\n\n\ttrace_f2fs_truncate_data_blocks_range(dn->inode, dn->nid,\n\t\t\t\t\t dn->ofs_in_node, nr_free);\n\treturn nr_free;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_INODE",
          "args": [
            "dn.node_page"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "IS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1087-1091",
          "snippet": "static inline bool IS_INODE(struct page *page)\n{\n\tstruct f2fs_node *p = F2FS_NODE(page);\n\treturn RAW_IS_INODE(p);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool IS_INODE(struct page *page)\n{\n\tstruct f2fs_node *p = F2FS_NODE(page);\n\treturn RAW_IS_INODE(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "count < 0"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADDRS_PER_PAGE",
          "args": [
            "dn.node_page",
            "F2FS_I(inode)"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dnode_of_data",
          "args": [
            "&dn",
            "free_from",
            "LOOKUP_NODE"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "get_dnode_of_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "473-572",
          "snippet": "int get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "ipage",
            "NULL",
            "0"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "ipage",
            "1"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ipage"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ipage"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "sbi",
            "inode->i_ino"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_BYTES_TO_BLK",
          "args": [
            "from + blocksize - 1"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_f2fs_truncate_blocks_enter",
          "args": [
            "inode",
            "from"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_blocks(struct inode *inode, u64 from, bool lock)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tunsigned int blocksize = inode->i_sb->s_blocksize;\n\tstruct dnode_of_data dn;\n\tpgoff_t free_from;\n\tint count = 0, err = 0;\n\tstruct page *ipage;\n\n\ttrace_f2fs_truncate_blocks_enter(inode, from);\n\n\tfree_from = (pgoff_t)F2FS_BYTES_TO_BLK(from + blocksize - 1);\n\n\tif (lock)\n\t\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = get_dnode_of_data(&dn, free_from, LOOKUP_NODE);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\tgoto free_next;\n\t\tgoto out;\n\t}\n\n\tcount = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\n\tcount -= dn.ofs_in_node;\n\tf2fs_bug_on(sbi, count < 0);\n\n\tif (dn.ofs_in_node || IS_INODE(dn.node_page)) {\n\t\ttruncate_data_blocks_range(&dn, count);\n\t\tfree_from += count;\n\t}\n\n\tf2fs_put_dnode(&dn);\nfree_next:\n\terr = truncate_inode_blocks(inode, free_from);\nout:\n\tif (lock)\n\t\tf2fs_unlock_op(sbi);\n\n\t/* lastly zero out the first data page */\n\tif (!err)\n\t\terr = truncate_partial_data_page(inode, from);\n\n\ttrace_f2fs_truncate_blocks_exit(inode, err);\n\treturn err;\n}"
  },
  {
    "function_name": "truncate_partial_data_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "457-480",
    "snippet": "static int truncate_partial_data_page(struct inode *inode, u64 from)\n{\n\tunsigned offset = from & (PAGE_CACHE_SIZE - 1);\n\tstruct page *page;\n\n\tif (!offset)\n\t\treturn 0;\n\n\tpage = find_data_page(inode, from >> PAGE_CACHE_SHIFT, false);\n\tif (IS_ERR(page))\n\t\treturn 0;\n\n\tlock_page(page);\n\tif (unlikely(!PageUptodate(page) ||\n\t\t\tpage->mapping != inode->i_mapping))\n\t\tgoto out;\n\n\tf2fs_wait_on_page_writeback(page, DATA);\n\tzero_user(page, offset, PAGE_CACHE_SIZE - offset);\n\tset_page_dirty(page);\nout:\n\tf2fs_put_page(page, 1);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "offset",
            "PAGE_CACHE_SIZE - offset"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "page",
            "DATA"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageUptodate(page) ||\n\t\t\tpage->mapping != inode->i_mapping"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_data_page",
          "args": [
            "inode",
            "from >> PAGE_CACHE_SHIFT",
            "false"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "find_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "375-426",
          "snippet": "struct page *find_data_page(struct inode *inode, pgoff_t index, bool sync)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tint err;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = sync ? READ_SYNC : READA,\n\t};\n\n\tpage = find_get_page(mapping, index);\n\tif (page && PageUptodate(page))\n\t\treturn page;\n\tf2fs_put_page(page, 0);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tf2fs_put_dnode(&dn);\n\n\tif (dn.data_blkaddr == NULL_ADDR)\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/* By fallocate(), there is no cached page, but with NEW_ADDR */\n\tif (unlikely(dn.data_blkaddr == NEW_ADDR))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\treturn page;\n\t}\n\n\tfio.blk_addr = dn.data_blkaddr;\n\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif (sync) {\n\t\twait_on_page_locked(page);\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\tf2fs_put_page(page, 0);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *find_data_page(struct inode *inode, pgoff_t index, bool sync)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tint err;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = sync ? READ_SYNC : READA,\n\t};\n\n\tpage = find_get_page(mapping, index);\n\tif (page && PageUptodate(page))\n\t\treturn page;\n\tf2fs_put_page(page, 0);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tf2fs_put_dnode(&dn);\n\n\tif (dn.data_blkaddr == NULL_ADDR)\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/* By fallocate(), there is no cached page, but with NEW_ADDR */\n\tif (unlikely(dn.data_blkaddr == NEW_ADDR))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\treturn page;\n\t}\n\n\tfio.blk_addr = dn.data_blkaddr;\n\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif (sync) {\n\t\twait_on_page_locked(page);\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\tf2fs_put_page(page, 0);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int truncate_partial_data_page(struct inode *inode, u64 from)\n{\n\tunsigned offset = from & (PAGE_CACHE_SIZE - 1);\n\tstruct page *page;\n\n\tif (!offset)\n\t\treturn 0;\n\n\tpage = find_data_page(inode, from >> PAGE_CACHE_SHIFT, false);\n\tif (IS_ERR(page))\n\t\treturn 0;\n\n\tlock_page(page);\n\tif (unlikely(!PageUptodate(page) ||\n\t\t\tpage->mapping != inode->i_mapping))\n\t\tgoto out;\n\n\tf2fs_wait_on_page_writeback(page, DATA);\n\tzero_user(page, offset, PAGE_CACHE_SIZE - offset);\n\tset_page_dirty(page);\nout:\n\tf2fs_put_page(page, 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "truncate_data_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "452-455",
    "snippet": "void truncate_data_blocks(struct dnode_of_data *dn)\n{\n\ttruncate_data_blocks_range(dn, ADDRS_PER_BLOCK);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_data_blocks_range",
          "args": [
            "dn",
            "ADDRS_PER_BLOCK"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_data_blocks_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "420-450",
          "snippet": "int truncate_data_blocks_range(struct dnode_of_data *dn, int count)\n{\n\tint nr_free = 0, ofs = dn->ofs_in_node;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr;\n\n\traw_node = F2FS_NODE(dn->node_page);\n\taddr = blkaddr_in_node(raw_node) + ofs;\n\n\tfor (; count > 0; count--, addr++, dn->ofs_in_node++) {\n\t\tblock_t blkaddr = le32_to_cpu(*addr);\n\t\tif (blkaddr == NULL_ADDR)\n\t\t\tcontinue;\n\n\t\tdn->data_blkaddr = NULL_ADDR;\n\t\tupdate_extent_cache(dn);\n\t\tinvalidate_blocks(sbi, blkaddr);\n\t\tnr_free++;\n\t}\n\tif (nr_free) {\n\t\tdec_valid_block_count(sbi, dn->inode, nr_free);\n\t\tset_page_dirty(dn->node_page);\n\t\tsync_inode_page(dn);\n\t}\n\tdn->ofs_in_node = ofs;\n\n\ttrace_f2fs_truncate_data_blocks_range(dn->inode, dn->nid,\n\t\t\t\t\t dn->ofs_in_node, nr_free);\n\treturn nr_free;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_data_blocks_range(struct dnode_of_data *dn, int count)\n{\n\tint nr_free = 0, ofs = dn->ofs_in_node;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr;\n\n\traw_node = F2FS_NODE(dn->node_page);\n\taddr = blkaddr_in_node(raw_node) + ofs;\n\n\tfor (; count > 0; count--, addr++, dn->ofs_in_node++) {\n\t\tblock_t blkaddr = le32_to_cpu(*addr);\n\t\tif (blkaddr == NULL_ADDR)\n\t\t\tcontinue;\n\n\t\tdn->data_blkaddr = NULL_ADDR;\n\t\tupdate_extent_cache(dn);\n\t\tinvalidate_blocks(sbi, blkaddr);\n\t\tnr_free++;\n\t}\n\tif (nr_free) {\n\t\tdec_valid_block_count(sbi, dn->inode, nr_free);\n\t\tset_page_dirty(dn->node_page);\n\t\tsync_inode_page(dn);\n\t}\n\tdn->ofs_in_node = ofs;\n\n\ttrace_f2fs_truncate_data_blocks_range(dn->inode, dn->nid,\n\t\t\t\t\t dn->ofs_in_node, nr_free);\n\treturn nr_free;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid truncate_data_blocks(struct dnode_of_data *dn)\n{\n\ttruncate_data_blocks_range(dn, ADDRS_PER_BLOCK);\n}"
  },
  {
    "function_name": "truncate_data_blocks_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "420-450",
    "snippet": "int truncate_data_blocks_range(struct dnode_of_data *dn, int count)\n{\n\tint nr_free = 0, ofs = dn->ofs_in_node;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr;\n\n\traw_node = F2FS_NODE(dn->node_page);\n\taddr = blkaddr_in_node(raw_node) + ofs;\n\n\tfor (; count > 0; count--, addr++, dn->ofs_in_node++) {\n\t\tblock_t blkaddr = le32_to_cpu(*addr);\n\t\tif (blkaddr == NULL_ADDR)\n\t\t\tcontinue;\n\n\t\tdn->data_blkaddr = NULL_ADDR;\n\t\tupdate_extent_cache(dn);\n\t\tinvalidate_blocks(sbi, blkaddr);\n\t\tnr_free++;\n\t}\n\tif (nr_free) {\n\t\tdec_valid_block_count(sbi, dn->inode, nr_free);\n\t\tset_page_dirty(dn->node_page);\n\t\tsync_inode_page(dn);\n\t}\n\tdn->ofs_in_node = ofs;\n\n\ttrace_f2fs_truncate_data_blocks_range(dn->inode, dn->nid,\n\t\t\t\t\t dn->ofs_in_node, nr_free);\n\treturn nr_free;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_f2fs_truncate_data_blocks_range",
          "args": [
            "dn->inode",
            "dn->nid",
            "dn->ofs_in_node",
            "nr_free"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_inode_page",
          "args": [
            "dn"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1116-1129",
          "snippet": "void sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "dn->node_page"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_valid_block_count",
          "args": [
            "sbi",
            "dn->inode",
            "nr_free"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "dec_valid_block_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "846-856",
          "snippet": "static inline void dec_valid_block_count(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\t\tblkcnt_t count)\n{\n\tspin_lock(&sbi->stat_lock);\n\tf2fs_bug_on(sbi, sbi->total_valid_block_count < (block_t) count);\n\tf2fs_bug_on(sbi, inode->i_blocks < count);\n\tinode->i_blocks -= count;\n\tsbi->total_valid_block_count -= (block_t)count;\n\tspin_unlock(&sbi->stat_lock);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void dec_valid_block_count(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\t\tblkcnt_t count)\n{\n\tspin_lock(&sbi->stat_lock);\n\tf2fs_bug_on(sbi, sbi->total_valid_block_count < (block_t) count);\n\tf2fs_bug_on(sbi, inode->i_blocks < count);\n\tinode->i_blocks -= count;\n\tsbi->total_valid_block_count -= (block_t)count;\n\tspin_unlock(&sbi->stat_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_blocks",
          "args": [
            "sbi",
            "blkaddr"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "695-713",
          "snippet": "void invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr)\n{\n\tunsigned int segno = GET_SEGNO(sbi, addr);\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tf2fs_bug_on(sbi, addr == NULL_ADDR);\n\tif (addr == NEW_ADDR)\n\t\treturn;\n\n\t/* add it into sit main buffer */\n\tmutex_lock(&sit_i->sentry_lock);\n\n\tupdate_sit_entry(sbi, addr, -1);\n\n\t/* add it into dirty seglist */\n\tlocate_dirty_segment(sbi, segno);\n\n\tmutex_unlock(&sit_i->sentry_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr)\n{\n\tunsigned int segno = GET_SEGNO(sbi, addr);\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tf2fs_bug_on(sbi, addr == NULL_ADDR);\n\tif (addr == NEW_ADDR)\n\t\treturn;\n\n\t/* add it into sit main buffer */\n\tmutex_lock(&sit_i->sentry_lock);\n\n\tupdate_sit_entry(sbi, addr, -1);\n\n\t/* add it into dirty seglist */\n\tlocate_dirty_segment(sbi, segno);\n\n\tmutex_unlock(&sit_i->sentry_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_extent_cache",
          "args": [
            "dn"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "update_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "294-373",
          "snippet": "void update_extent_cache(struct dnode_of_data *dn)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(dn->inode);\n\tpgoff_t fofs, start_fofs, end_fofs;\n\tblock_t start_blkaddr, end_blkaddr;\n\tint need_update = true;\n\n\tf2fs_bug_on(F2FS_I_SB(dn->inode), dn->data_blkaddr == NEW_ADDR);\n\n\t/* Update the page address in the parent node */\n\t__set_data_blkaddr(dn);\n\n\tif (is_inode_flag_set(fi, FI_NO_EXTENT))\n\t\treturn;\n\n\tfofs = start_bidx_of_node(ofs_of_node(dn->node_page), fi) +\n\t\t\t\t\t\t\tdn->ofs_in_node;\n\n\twrite_lock(&fi->ext.ext_lock);\n\n\tstart_fofs = fi->ext.fofs;\n\tend_fofs = fi->ext.fofs + fi->ext.len - 1;\n\tstart_blkaddr = fi->ext.blk_addr;\n\tend_blkaddr = fi->ext.blk_addr + fi->ext.len - 1;\n\n\t/* Drop and initialize the matched extent */\n\tif (fi->ext.len == 1 && fofs == start_fofs)\n\t\tfi->ext.len = 0;\n\n\t/* Initial extent */\n\tif (fi->ext.len == 0) {\n\t\tif (dn->data_blkaddr != NULL_ADDR) {\n\t\t\tfi->ext.fofs = fofs;\n\t\t\tfi->ext.blk_addr = dn->data_blkaddr;\n\t\t\tfi->ext.len = 1;\n\t\t}\n\t\tgoto end_update;\n\t}\n\n\t/* Front merge */\n\tif (fofs == start_fofs - 1 && dn->data_blkaddr == start_blkaddr - 1) {\n\t\tfi->ext.fofs--;\n\t\tfi->ext.blk_addr--;\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Back merge */\n\tif (fofs == end_fofs + 1 && dn->data_blkaddr == end_blkaddr + 1) {\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Split the existing extent */\n\tif (fi->ext.len > 1 &&\n\t\tfofs >= start_fofs && fofs <= end_fofs) {\n\t\tif ((end_fofs - fofs) < (fi->ext.len >> 1)) {\n\t\t\tfi->ext.len = fofs - start_fofs;\n\t\t} else {\n\t\t\tfi->ext.fofs = fofs + 1;\n\t\t\tfi->ext.blk_addr = start_blkaddr +\n\t\t\t\t\tfofs - start_fofs + 1;\n\t\t\tfi->ext.len -= fofs - start_fofs + 1;\n\t\t}\n\t} else {\n\t\tneed_update = false;\n\t}\n\n\t/* Finally, if the extent is very fragmented, let's drop the cache. */\n\tif (fi->ext.len < F2FS_MIN_EXTENT_LEN) {\n\t\tfi->ext.len = 0;\n\t\tset_inode_flag(fi, FI_NO_EXTENT);\n\t\tneed_update = true;\n\t}\nend_update:\n\twrite_unlock(&fi->ext.ext_lock);\n\tif (need_update)\n\t\tsync_inode_page(dn);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_extent_cache(struct dnode_of_data *dn)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(dn->inode);\n\tpgoff_t fofs, start_fofs, end_fofs;\n\tblock_t start_blkaddr, end_blkaddr;\n\tint need_update = true;\n\n\tf2fs_bug_on(F2FS_I_SB(dn->inode), dn->data_blkaddr == NEW_ADDR);\n\n\t/* Update the page address in the parent node */\n\t__set_data_blkaddr(dn);\n\n\tif (is_inode_flag_set(fi, FI_NO_EXTENT))\n\t\treturn;\n\n\tfofs = start_bidx_of_node(ofs_of_node(dn->node_page), fi) +\n\t\t\t\t\t\t\tdn->ofs_in_node;\n\n\twrite_lock(&fi->ext.ext_lock);\n\n\tstart_fofs = fi->ext.fofs;\n\tend_fofs = fi->ext.fofs + fi->ext.len - 1;\n\tstart_blkaddr = fi->ext.blk_addr;\n\tend_blkaddr = fi->ext.blk_addr + fi->ext.len - 1;\n\n\t/* Drop and initialize the matched extent */\n\tif (fi->ext.len == 1 && fofs == start_fofs)\n\t\tfi->ext.len = 0;\n\n\t/* Initial extent */\n\tif (fi->ext.len == 0) {\n\t\tif (dn->data_blkaddr != NULL_ADDR) {\n\t\t\tfi->ext.fofs = fofs;\n\t\t\tfi->ext.blk_addr = dn->data_blkaddr;\n\t\t\tfi->ext.len = 1;\n\t\t}\n\t\tgoto end_update;\n\t}\n\n\t/* Front merge */\n\tif (fofs == start_fofs - 1 && dn->data_blkaddr == start_blkaddr - 1) {\n\t\tfi->ext.fofs--;\n\t\tfi->ext.blk_addr--;\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Back merge */\n\tif (fofs == end_fofs + 1 && dn->data_blkaddr == end_blkaddr + 1) {\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Split the existing extent */\n\tif (fi->ext.len > 1 &&\n\t\tfofs >= start_fofs && fofs <= end_fofs) {\n\t\tif ((end_fofs - fofs) < (fi->ext.len >> 1)) {\n\t\t\tfi->ext.len = fofs - start_fofs;\n\t\t} else {\n\t\t\tfi->ext.fofs = fofs + 1;\n\t\t\tfi->ext.blk_addr = start_blkaddr +\n\t\t\t\t\tfofs - start_fofs + 1;\n\t\t\tfi->ext.len -= fofs - start_fofs + 1;\n\t\t}\n\t} else {\n\t\tneed_update = false;\n\t}\n\n\t/* Finally, if the extent is very fragmented, let's drop the cache. */\n\tif (fi->ext.len < F2FS_MIN_EXTENT_LEN) {\n\t\tfi->ext.len = 0;\n\t\tset_inode_flag(fi, FI_NO_EXTENT);\n\t\tneed_update = true;\n\t}\nend_update:\n\twrite_unlock(&fi->ext.ext_lock);\n\tif (need_update)\n\t\tsync_inode_page(dn);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*addr"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blkaddr_in_node",
          "args": [
            "raw_node"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "blkaddr_in_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1093-1096",
          "snippet": "static inline __le32 *blkaddr_in_node(struct f2fs_node *node)\n{\n\treturn RAW_IS_INODE(node) ? node->i.i_addr : node->dn.addr;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline __le32 *blkaddr_in_node(struct f2fs_node *node)\n{\n\treturn RAW_IS_INODE(node) ? node->i.i_addr : node->dn.addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_NODE",
          "args": [
            "dn->node_page"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_NODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "670-673",
          "snippet": "static inline struct f2fs_node *F2FS_NODE(struct page *page)\n{\n\treturn (struct f2fs_node *)page_address(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_node *F2FS_NODE(struct page *page)\n{\n\treturn (struct f2fs_node *)page_address(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dn->inode"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_data_blocks_range(struct dnode_of_data *dn, int count)\n{\n\tint nr_free = 0, ofs = dn->ofs_in_node;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr;\n\n\traw_node = F2FS_NODE(dn->node_page);\n\taddr = blkaddr_in_node(raw_node) + ofs;\n\n\tfor (; count > 0; count--, addr++, dn->ofs_in_node++) {\n\t\tblock_t blkaddr = le32_to_cpu(*addr);\n\t\tif (blkaddr == NULL_ADDR)\n\t\t\tcontinue;\n\n\t\tdn->data_blkaddr = NULL_ADDR;\n\t\tupdate_extent_cache(dn);\n\t\tinvalidate_blocks(sbi, blkaddr);\n\t\tnr_free++;\n\t}\n\tif (nr_free) {\n\t\tdec_valid_block_count(sbi, dn->inode, nr_free);\n\t\tset_page_dirty(dn->node_page);\n\t\tsync_inode_page(dn);\n\t}\n\tdn->ofs_in_node = ofs;\n\n\ttrace_f2fs_truncate_data_blocks_range(dn->inode, dn->nid,\n\t\t\t\t\t dn->ofs_in_node, nr_free);\n\treturn nr_free;\n}"
  },
  {
    "function_name": "f2fs_file_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "404-418",
    "snippet": "static int f2fs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct inode *inode = file_inode(file);\n\n\t/* we don't need to use inline_data strictly */\n\tif (f2fs_has_inline_data(inode)) {\n\t\tint err = f2fs_convert_inline_inode(inode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfile_accessed(file);\n\tvma->vm_ops = &f2fs_file_vm_ops;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct f2fs_file_vm_ops = {\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= f2fs_vm_page_mkwrite,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "file"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_convert_inline_inode",
          "args": [
            "inode"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_convert_inline_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "143-173",
          "snippet": "int f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic const struct vm_operations_struct f2fs_file_vm_ops = {\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= f2fs_vm_page_mkwrite,\n};\n\nstatic int f2fs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct inode *inode = file_inode(file);\n\n\t/* we don't need to use inline_data strictly */\n\tif (f2fs_has_inline_data(inode)) {\n\t\tint err = f2fs_convert_inline_inode(inode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfile_accessed(file);\n\tvma->vm_ops = &f2fs_file_vm_ops;\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "383-402",
    "snippet": "static loff_t f2fs_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t maxbytes = inode->i_sb->s_maxbytes;\n\n\tswitch (whence) {\n\tcase SEEK_SET:\n\tcase SEEK_CUR:\n\tcase SEEK_END:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tmaxbytes, i_size_read(inode));\n\tcase SEEK_DATA:\n\tcase SEEK_HOLE:\n\t\tif (offset < 0)\n\t\t\treturn -ENXIO;\n\t\treturn f2fs_seek_block(file, offset, whence);\n\t}\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_seek_block",
          "args": [
            "file",
            "offset",
            "whence"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_seek_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "311-381",
          "snippet": "static loff_t f2fs_seek_block(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t maxbytes = inode->i_sb->s_maxbytes;\n\tstruct dnode_of_data dn;\n\tpgoff_t pgofs, end_offset, dirty;\n\tloff_t data_ofs = offset;\n\tloff_t isize;\n\tint err = 0;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tisize = i_size_read(inode);\n\tif (offset >= isize)\n\t\tgoto fail;\n\n\t/* handle inline data case */\n\tif (f2fs_has_inline_data(inode) || f2fs_has_inline_dentry(inode)) {\n\t\tif (whence == SEEK_HOLE)\n\t\t\tdata_ofs = isize;\n\t\tgoto found;\n\t}\n\n\tpgofs = (pgoff_t)(offset >> PAGE_CACHE_SHIFT);\n\n\tdirty = __get_first_dirty_index(inode->i_mapping, pgofs, whence);\n\n\tfor (; data_ofs < isize; data_ofs = pgofs << PAGE_CACHE_SHIFT) {\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, pgofs, LOOKUP_NODE_RA);\n\t\tif (err && err != -ENOENT) {\n\t\t\tgoto fail;\n\t\t} else if (err == -ENOENT) {\n\t\t\t/* direct node does not exists */\n\t\t\tif (whence == SEEK_DATA) {\n\t\t\t\tpgofs = PGOFS_OF_NEXT_DNODE(pgofs,\n\t\t\t\t\t\t\tF2FS_I(inode));\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\n\t\t/* find data/hole in dnode block */\n\t\tfor (; dn.ofs_in_node < end_offset;\n\t\t\t\tdn.ofs_in_node++, pgofs++,\n\t\t\t\tdata_ofs = (loff_t)pgofs << PAGE_CACHE_SHIFT) {\n\t\t\tblock_t blkaddr;\n\t\t\tblkaddr = datablock_addr(dn.node_page, dn.ofs_in_node);\n\n\t\t\tif (__found_offset(blkaddr, dirty, pgofs, whence)) {\n\t\t\t\tf2fs_put_dnode(&dn);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tf2fs_put_dnode(&dn);\n\t}\n\n\tif (whence == SEEK_DATA)\n\t\tgoto fail;\nfound:\n\tif (whence == SEEK_HOLE && data_ofs > isize)\n\t\tdata_ofs = isize;\n\tmutex_unlock(&inode->i_mutex);\n\treturn vfs_setpos(file, data_ofs, maxbytes);\nfail:\n\tmutex_unlock(&inode->i_mutex);\n\treturn -ENXIO;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic loff_t f2fs_seek_block(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t maxbytes = inode->i_sb->s_maxbytes;\n\tstruct dnode_of_data dn;\n\tpgoff_t pgofs, end_offset, dirty;\n\tloff_t data_ofs = offset;\n\tloff_t isize;\n\tint err = 0;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tisize = i_size_read(inode);\n\tif (offset >= isize)\n\t\tgoto fail;\n\n\t/* handle inline data case */\n\tif (f2fs_has_inline_data(inode) || f2fs_has_inline_dentry(inode)) {\n\t\tif (whence == SEEK_HOLE)\n\t\t\tdata_ofs = isize;\n\t\tgoto found;\n\t}\n\n\tpgofs = (pgoff_t)(offset >> PAGE_CACHE_SHIFT);\n\n\tdirty = __get_first_dirty_index(inode->i_mapping, pgofs, whence);\n\n\tfor (; data_ofs < isize; data_ofs = pgofs << PAGE_CACHE_SHIFT) {\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, pgofs, LOOKUP_NODE_RA);\n\t\tif (err && err != -ENOENT) {\n\t\t\tgoto fail;\n\t\t} else if (err == -ENOENT) {\n\t\t\t/* direct node does not exists */\n\t\t\tif (whence == SEEK_DATA) {\n\t\t\t\tpgofs = PGOFS_OF_NEXT_DNODE(pgofs,\n\t\t\t\t\t\t\tF2FS_I(inode));\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\n\t\t/* find data/hole in dnode block */\n\t\tfor (; dn.ofs_in_node < end_offset;\n\t\t\t\tdn.ofs_in_node++, pgofs++,\n\t\t\t\tdata_ofs = (loff_t)pgofs << PAGE_CACHE_SHIFT) {\n\t\t\tblock_t blkaddr;\n\t\t\tblkaddr = datablock_addr(dn.node_page, dn.ofs_in_node);\n\n\t\t\tif (__found_offset(blkaddr, dirty, pgofs, whence)) {\n\t\t\t\tf2fs_put_dnode(&dn);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tf2fs_put_dnode(&dn);\n\t}\n\n\tif (whence == SEEK_DATA)\n\t\tgoto fail;\nfound:\n\tif (whence == SEEK_HOLE && data_ofs > isize)\n\t\tdata_ofs = isize;\n\tmutex_unlock(&inode->i_mutex);\n\treturn vfs_setpos(file, data_ofs, maxbytes);\nfail:\n\tmutex_unlock(&inode->i_mutex);\n\treturn -ENXIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_file_llseek_size",
          "args": [
            "file",
            "offset",
            "whence",
            "maxbytes",
            "i_size_read(inode)"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "88-134",
          "snippet": "loff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic loff_t f2fs_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t maxbytes = inode->i_sb->s_maxbytes;\n\n\tswitch (whence) {\n\tcase SEEK_SET:\n\tcase SEEK_CUR:\n\tcase SEEK_END:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tmaxbytes, i_size_read(inode));\n\tcase SEEK_DATA:\n\tcase SEEK_HOLE:\n\t\tif (offset < 0)\n\t\t\treturn -ENXIO;\n\t\treturn f2fs_seek_block(file, offset, whence);\n\t}\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "f2fs_seek_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "311-381",
    "snippet": "static loff_t f2fs_seek_block(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t maxbytes = inode->i_sb->s_maxbytes;\n\tstruct dnode_of_data dn;\n\tpgoff_t pgofs, end_offset, dirty;\n\tloff_t data_ofs = offset;\n\tloff_t isize;\n\tint err = 0;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tisize = i_size_read(inode);\n\tif (offset >= isize)\n\t\tgoto fail;\n\n\t/* handle inline data case */\n\tif (f2fs_has_inline_data(inode) || f2fs_has_inline_dentry(inode)) {\n\t\tif (whence == SEEK_HOLE)\n\t\t\tdata_ofs = isize;\n\t\tgoto found;\n\t}\n\n\tpgofs = (pgoff_t)(offset >> PAGE_CACHE_SHIFT);\n\n\tdirty = __get_first_dirty_index(inode->i_mapping, pgofs, whence);\n\n\tfor (; data_ofs < isize; data_ofs = pgofs << PAGE_CACHE_SHIFT) {\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, pgofs, LOOKUP_NODE_RA);\n\t\tif (err && err != -ENOENT) {\n\t\t\tgoto fail;\n\t\t} else if (err == -ENOENT) {\n\t\t\t/* direct node does not exists */\n\t\t\tif (whence == SEEK_DATA) {\n\t\t\t\tpgofs = PGOFS_OF_NEXT_DNODE(pgofs,\n\t\t\t\t\t\t\tF2FS_I(inode));\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\n\t\t/* find data/hole in dnode block */\n\t\tfor (; dn.ofs_in_node < end_offset;\n\t\t\t\tdn.ofs_in_node++, pgofs++,\n\t\t\t\tdata_ofs = (loff_t)pgofs << PAGE_CACHE_SHIFT) {\n\t\t\tblock_t blkaddr;\n\t\t\tblkaddr = datablock_addr(dn.node_page, dn.ofs_in_node);\n\n\t\t\tif (__found_offset(blkaddr, dirty, pgofs, whence)) {\n\t\t\t\tf2fs_put_dnode(&dn);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tf2fs_put_dnode(&dn);\n\t}\n\n\tif (whence == SEEK_DATA)\n\t\tgoto fail;\nfound:\n\tif (whence == SEEK_HOLE && data_ofs > isize)\n\t\tdata_ofs = isize;\n\tmutex_unlock(&inode->i_mutex);\n\treturn vfs_setpos(file, data_ofs, maxbytes);\nfail:\n\tmutex_unlock(&inode->i_mutex);\n\treturn -ENXIO;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_setpos",
          "args": [
            "file",
            "data_ofs",
            "maxbytes"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setpos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "57-69",
          "snippet": "loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_dnode",
          "args": [
            "&dn"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1048-1056",
          "snippet": "static inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__found_offset",
          "args": [
            "blkaddr",
            "dirty",
            "pgofs",
            "whence"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "__found_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "294-309",
          "snippet": "static bool __found_offset(block_t blkaddr, pgoff_t dirty, pgoff_t pgofs,\n\t\t\t\t\t\t\tint whence)\n{\n\tswitch (whence) {\n\tcase SEEK_DATA:\n\t\tif ((blkaddr == NEW_ADDR && dirty == pgofs) ||\n\t\t\t(blkaddr != NEW_ADDR && blkaddr != NULL_ADDR))\n\t\t\treturn true;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\tif (blkaddr == NULL_ADDR)\n\t\t\treturn true;\n\t\tbreak;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic bool __found_offset(block_t blkaddr, pgoff_t dirty, pgoff_t pgofs,\n\t\t\t\t\t\t\tint whence)\n{\n\tswitch (whence) {\n\tcase SEEK_DATA:\n\t\tif ((blkaddr == NEW_ADDR && dirty == pgofs) ||\n\t\t\t(blkaddr != NEW_ADDR && blkaddr != NULL_ADDR))\n\t\t\treturn true;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\tif (blkaddr == NULL_ADDR)\n\t\t\treturn true;\n\t\tbreak;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "datablock_addr",
          "args": [
            "dn.node_page",
            "dn.ofs_in_node"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "datablock_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1098-1106",
          "snippet": "static inline block_t datablock_addr(struct page *node_page,\n\t\tunsigned int offset)\n{\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr_array;\n\traw_node = F2FS_NODE(node_page);\n\taddr_array = blkaddr_in_node(raw_node);\n\treturn le32_to_cpu(addr_array[offset]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline block_t datablock_addr(struct page *node_page,\n\t\tunsigned int offset)\n{\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr_array;\n\traw_node = F2FS_NODE(node_page);\n\taddr_array = blkaddr_in_node(raw_node);\n\treturn le32_to_cpu(addr_array[offset]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADDRS_PER_PAGE",
          "args": [
            "dn.node_page",
            "F2FS_I(inode)"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PGOFS_OF_NEXT_DNODE",
          "args": [
            "pgofs",
            "F2FS_I(inode)"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dnode_of_data",
          "args": [
            "&dn",
            "pgofs",
            "LOOKUP_NODE_RA"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "get_dnode_of_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "473-572",
          "snippet": "int get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_first_dirty_index",
          "args": [
            "inode->i_mapping",
            "pgofs",
            "whence"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "__get_first_dirty_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "276-292",
          "snippet": "static pgoff_t __get_first_dirty_index(struct address_space *mapping,\n\t\t\t\t\t\tpgoff_t pgofs, int whence)\n{\n\tstruct pagevec pvec;\n\tint nr_pages;\n\n\tif (whence != SEEK_DATA)\n\t\treturn 0;\n\n\t/* find first dirty page index */\n\tpagevec_init(&pvec, 0);\n\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &pgofs,\n\t\t\t\t\tPAGECACHE_TAG_DIRTY, 1);\n\tpgofs = nr_pages ? pvec.pages[0]->index : LONG_MAX;\n\tpagevec_release(&pvec);\n\treturn pgofs;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic pgoff_t __get_first_dirty_index(struct address_space *mapping,\n\t\t\t\t\t\tpgoff_t pgofs, int whence)\n{\n\tstruct pagevec pvec;\n\tint nr_pages;\n\n\tif (whence != SEEK_DATA)\n\t\treturn 0;\n\n\t/* find first dirty page index */\n\tpagevec_init(&pvec, 0);\n\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &pgofs,\n\t\t\t\t\tPAGECACHE_TAG_DIRTY, 1);\n\tpgofs = nr_pages ? pvec.pages[0]->index : LONG_MAX;\n\tpagevec_release(&pvec);\n\treturn pgofs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "offset >> PAGE_CACHE_SHIFT"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_dentry",
          "args": [
            "inode"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1288-1291",
          "snippet": "static inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DENTRY);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DENTRY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic loff_t f2fs_seek_block(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t maxbytes = inode->i_sb->s_maxbytes;\n\tstruct dnode_of_data dn;\n\tpgoff_t pgofs, end_offset, dirty;\n\tloff_t data_ofs = offset;\n\tloff_t isize;\n\tint err = 0;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tisize = i_size_read(inode);\n\tif (offset >= isize)\n\t\tgoto fail;\n\n\t/* handle inline data case */\n\tif (f2fs_has_inline_data(inode) || f2fs_has_inline_dentry(inode)) {\n\t\tif (whence == SEEK_HOLE)\n\t\t\tdata_ofs = isize;\n\t\tgoto found;\n\t}\n\n\tpgofs = (pgoff_t)(offset >> PAGE_CACHE_SHIFT);\n\n\tdirty = __get_first_dirty_index(inode->i_mapping, pgofs, whence);\n\n\tfor (; data_ofs < isize; data_ofs = pgofs << PAGE_CACHE_SHIFT) {\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, pgofs, LOOKUP_NODE_RA);\n\t\tif (err && err != -ENOENT) {\n\t\t\tgoto fail;\n\t\t} else if (err == -ENOENT) {\n\t\t\t/* direct node does not exists */\n\t\t\tif (whence == SEEK_DATA) {\n\t\t\t\tpgofs = PGOFS_OF_NEXT_DNODE(pgofs,\n\t\t\t\t\t\t\tF2FS_I(inode));\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\n\t\t/* find data/hole in dnode block */\n\t\tfor (; dn.ofs_in_node < end_offset;\n\t\t\t\tdn.ofs_in_node++, pgofs++,\n\t\t\t\tdata_ofs = (loff_t)pgofs << PAGE_CACHE_SHIFT) {\n\t\t\tblock_t blkaddr;\n\t\t\tblkaddr = datablock_addr(dn.node_page, dn.ofs_in_node);\n\n\t\t\tif (__found_offset(blkaddr, dirty, pgofs, whence)) {\n\t\t\t\tf2fs_put_dnode(&dn);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tf2fs_put_dnode(&dn);\n\t}\n\n\tif (whence == SEEK_DATA)\n\t\tgoto fail;\nfound:\n\tif (whence == SEEK_HOLE && data_ofs > isize)\n\t\tdata_ofs = isize;\n\tmutex_unlock(&inode->i_mutex);\n\treturn vfs_setpos(file, data_ofs, maxbytes);\nfail:\n\tmutex_unlock(&inode->i_mutex);\n\treturn -ENXIO;\n}"
  },
  {
    "function_name": "__found_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "294-309",
    "snippet": "static bool __found_offset(block_t blkaddr, pgoff_t dirty, pgoff_t pgofs,\n\t\t\t\t\t\t\tint whence)\n{\n\tswitch (whence) {\n\tcase SEEK_DATA:\n\t\tif ((blkaddr == NEW_ADDR && dirty == pgofs) ||\n\t\t\t(blkaddr != NEW_ADDR && blkaddr != NULL_ADDR))\n\t\t\treturn true;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\tif (blkaddr == NULL_ADDR)\n\t\t\treturn true;\n\t\tbreak;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic bool __found_offset(block_t blkaddr, pgoff_t dirty, pgoff_t pgofs,\n\t\t\t\t\t\t\tint whence)\n{\n\tswitch (whence) {\n\tcase SEEK_DATA:\n\t\tif ((blkaddr == NEW_ADDR && dirty == pgofs) ||\n\t\t\t(blkaddr != NEW_ADDR && blkaddr != NULL_ADDR))\n\t\t\treturn true;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\tif (blkaddr == NULL_ADDR)\n\t\t\treturn true;\n\t\tbreak;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "__get_first_dirty_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "276-292",
    "snippet": "static pgoff_t __get_first_dirty_index(struct address_space *mapping,\n\t\t\t\t\t\tpgoff_t pgofs, int whence)\n{\n\tstruct pagevec pvec;\n\tint nr_pages;\n\n\tif (whence != SEEK_DATA)\n\t\treturn 0;\n\n\t/* find first dirty page index */\n\tpagevec_init(&pvec, 0);\n\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &pgofs,\n\t\t\t\t\tPAGECACHE_TAG_DIRTY, 1);\n\tpgofs = nr_pages ? pvec.pages[0]->index : LONG_MAX;\n\tpagevec_release(&pvec);\n\treturn pgofs;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_tag",
          "args": [
            "&pvec",
            "mapping",
            "&pgofs",
            "PAGECACHE_TAG_DIRTY",
            "1"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic pgoff_t __get_first_dirty_index(struct address_space *mapping,\n\t\t\t\t\t\tpgoff_t pgofs, int whence)\n{\n\tstruct pagevec pvec;\n\tint nr_pages;\n\n\tif (whence != SEEK_DATA)\n\t\treturn 0;\n\n\t/* find first dirty page index */\n\tpagevec_init(&pvec, 0);\n\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &pgofs,\n\t\t\t\t\tPAGECACHE_TAG_DIRTY, 1);\n\tpgofs = nr_pages ? pvec.pages[0]->index : LONG_MAX;\n\tpagevec_release(&pvec);\n\treturn pgofs;\n}"
  },
  {
    "function_name": "f2fs_sync_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "172-274",
    "snippet": "int f2fs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t ino = inode->i_ino;\n\tint ret = 0;\n\tbool need_cp = false;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.for_reclaim = 0,\n\t};\n\n\tif (unlikely(f2fs_readonly(inode->i_sb)))\n\t\treturn 0;\n\n\ttrace_f2fs_sync_file_enter(inode);\n\n\t/* if fdatasync is triggered, let's do in-place-update */\n\tif (get_dirty_pages(inode) <= SM_I(sbi)->min_fsync_blocks)\n\t\tset_inode_flag(fi, FI_NEED_IPU);\n\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tclear_inode_flag(fi, FI_NEED_IPU);\n\n\tif (ret) {\n\t\ttrace_f2fs_sync_file_exit(inode, need_cp, datasync, ret);\n\t\treturn ret;\n\t}\n\n\t/* if the inode is dirty, let's recover all the time */\n\tif (!datasync && is_inode_flag_set(fi, FI_DIRTY_INODE)) {\n\t\tupdate_inode_page(inode);\n\t\tgoto go_write;\n\t}\n\n\t/*\n\t * if there is no written data, don't waste time to write recovery info.\n\t */\n\tif (!is_inode_flag_set(fi, FI_APPEND_WRITE) &&\n\t\t\t!exist_written_data(sbi, ino, APPEND_INO)) {\n\n\t\t/* it may call write_inode just prior to fsync */\n\t\tif (need_inode_page_update(sbi, ino))\n\t\t\tgoto go_write;\n\n\t\tif (is_inode_flag_set(fi, FI_UPDATE_WRITE) ||\n\t\t\t\texist_written_data(sbi, ino, UPDATE_INO))\n\t\t\tgoto flush_out;\n\t\tgoto out;\n\t}\ngo_write:\n\t/* guarantee free sections for fsync */\n\tf2fs_balance_fs(sbi);\n\n\t/*\n\t * Both of fdatasync() and fsync() are able to be recovered from\n\t * sudden-power-off.\n\t */\n\tdown_read(&fi->i_sem);\n\tneed_cp = need_do_checkpoint(inode);\n\tup_read(&fi->i_sem);\n\n\tif (need_cp) {\n\t\t/* all the dirty node pages should be flushed for POR */\n\t\tret = f2fs_sync_fs(inode->i_sb, 1);\n\n\t\t/*\n\t\t * We've secured consistency through sync_fs. Following pino\n\t\t * will be used only for fsynced inodes after checkpoint.\n\t\t */\n\t\ttry_to_fix_pino(inode);\n\t\tgoto out;\n\t}\nsync_nodes:\n\tsync_node_pages(sbi, ino, &wbc);\n\n\t/* if cp_error was enabled, we should avoid infinite loop */\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto out;\n\n\tif (need_inode_block_update(sbi, ino)) {\n\t\tmark_inode_dirty_sync(inode);\n\t\tf2fs_write_inode(inode, NULL);\n\t\tgoto sync_nodes;\n\t}\n\n\tret = wait_on_node_pages_writeback(sbi, ino);\n\tif (ret)\n\t\tgoto out;\n\n\t/* once recovery info is written, don't need to tack this */\n\tremove_dirty_inode(sbi, ino, APPEND_INO);\n\tclear_inode_flag(fi, FI_APPEND_WRITE);\nflush_out:\n\tremove_dirty_inode(sbi, ino, UPDATE_INO);\n\tclear_inode_flag(fi, FI_UPDATE_WRITE);\n\tret = f2fs_issue_flush(sbi);\nout:\n\ttrace_f2fs_sync_file_exit(inode, need_cp, datasync, ret);\n\tf2fs_trace_ios(NULL, NULL, 1);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_trace_ios",
          "args": [
            "NULL",
            "NULL",
            "1"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_trace_ios",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/trace.c",
          "lines": "83-118",
          "snippet": "void f2fs_trace_ios(struct page *page, struct f2fs_io_info *fio, int flush)\n{\n\tstruct inode *inode;\n\tpid_t pid;\n\tint major, minor;\n\n\tif (flush) {\n\t\t__print_last_io();\n\t\treturn;\n\t}\n\n\tinode = page->mapping->host;\n\tpid = page_private(page);\n\n\tmajor = MAJOR(inode->i_sb->s_dev);\n\tminor = MINOR(inode->i_sb->s_dev);\n\n\tif (last_io.major == major && last_io.minor == minor &&\n\t\t\tlast_io.pid == pid &&\n\t\t\tlast_io.type == __file_type(inode, pid) &&\n\t\t\tlast_io.fio.rw == fio->rw &&\n\t\t\tlast_io.fio.blk_addr + last_io.len == fio->blk_addr) {\n\t\tlast_io.len++;\n\t\treturn;\n\t}\n\n\t__print_last_io();\n\n\tlast_io.major = major;\n\tlast_io.minor = minor;\n\tlast_io.pid = pid;\n\tlast_io.type = __file_type(inode, pid);\n\tlast_io.fio = *fio;\n\tlast_io.len = 1;\n\treturn;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/radix-tree.h>",
            "#include <linux/sched.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct last_io_info last_io;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"f2fs.h\"\n#include <linux/radix-tree.h>\n#include <linux/sched.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct last_io_info last_io;\n\nvoid f2fs_trace_ios(struct page *page, struct f2fs_io_info *fio, int flush)\n{\n\tstruct inode *inode;\n\tpid_t pid;\n\tint major, minor;\n\n\tif (flush) {\n\t\t__print_last_io();\n\t\treturn;\n\t}\n\n\tinode = page->mapping->host;\n\tpid = page_private(page);\n\n\tmajor = MAJOR(inode->i_sb->s_dev);\n\tminor = MINOR(inode->i_sb->s_dev);\n\n\tif (last_io.major == major && last_io.minor == minor &&\n\t\t\tlast_io.pid == pid &&\n\t\t\tlast_io.type == __file_type(inode, pid) &&\n\t\t\tlast_io.fio.rw == fio->rw &&\n\t\t\tlast_io.fio.blk_addr + last_io.len == fio->blk_addr) {\n\t\tlast_io.len++;\n\t\treturn;\n\t}\n\n\t__print_last_io();\n\n\tlast_io.major = major;\n\tlast_io.minor = minor;\n\tlast_io.pid = pid;\n\tlast_io.type = __file_type(inode, pid);\n\tlast_io.fio = *fio;\n\tlast_io.len = 1;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_sync_file_exit",
          "args": [
            "inode",
            "need_cp",
            "datasync",
            "ret"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_issue_flush",
          "args": [
            "sbi"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_issue_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "321-345",
          "snippet": "int f2fs_issue_flush(struct f2fs_sb_info *sbi)\n{\n\tstruct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;\n\tstruct flush_cmd cmd;\n\n\ttrace_f2fs_issue_flush(sbi->sb, test_opt(sbi, NOBARRIER),\n\t\t\t\t\ttest_opt(sbi, FLUSH_MERGE));\n\n\tif (test_opt(sbi, NOBARRIER))\n\t\treturn 0;\n\n\tif (!test_opt(sbi, FLUSH_MERGE))\n\t\treturn blkdev_issue_flush(sbi->sb->s_bdev, GFP_KERNEL, NULL);\n\n\tinit_completion(&cmd.wait);\n\n\tllist_add(&cmd.llnode, &fcc->issue_list);\n\n\tif (!fcc->dispatch_list)\n\t\twake_up(&fcc->flush_wait_queue);\n\n\twait_for_completion(&cmd.wait);\n\n\treturn cmd.ret;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_issue_flush(struct f2fs_sb_info *sbi)\n{\n\tstruct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;\n\tstruct flush_cmd cmd;\n\n\ttrace_f2fs_issue_flush(sbi->sb, test_opt(sbi, NOBARRIER),\n\t\t\t\t\ttest_opt(sbi, FLUSH_MERGE));\n\n\tif (test_opt(sbi, NOBARRIER))\n\t\treturn 0;\n\n\tif (!test_opt(sbi, FLUSH_MERGE))\n\t\treturn blkdev_issue_flush(sbi->sb->s_bdev, GFP_KERNEL, NULL);\n\n\tinit_completion(&cmd.wait);\n\n\tllist_add(&cmd.llnode, &fcc->issue_list);\n\n\tif (!fcc->dispatch_list)\n\t\twake_up(&fcc->flush_wait_queue);\n\n\twait_for_completion(&cmd.wait);\n\n\treturn cmd.ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "fi",
            "FI_UPDATE_WRITE"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_dirty_inode",
          "args": [
            "sbi",
            "ino",
            "UPDATE_INO"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "remove_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "381-385",
          "snippet": "void remove_dirty_inode(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\t/* remove dirty ino entry from list */\n\t__remove_ino_entry(sbi, ino, type);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid remove_dirty_inode(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\t/* remove dirty ino entry from list */\n\t__remove_ino_entry(sbi, ino, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_node_pages_writeback",
          "args": [
            "sbi",
            "ino"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_node_pages_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1239-1279",
          "snippet": "int wait_on_node_pages_writeback(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tpgoff_t index = 0, end = LONG_MAX;\n\tstruct pagevec pvec;\n\tint ret2 = 0, ret = 0;\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_WRITEBACK,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* until radix tree lookup accepts end_index */\n\t\t\tif (unlikely(page->index > end))\n\t\t\t\tcontinue;\n\n\t\t\tif (ino && ino_of_node(page) == ino) {\n\t\t\t\tf2fs_wait_on_page_writeback(page, NODE);\n\t\t\t\tif (TestClearPageError(page))\n\t\t\t\t\tret = -EIO;\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\tif (unlikely(test_and_clear_bit(AS_ENOSPC, &NODE_MAPPING(sbi)->flags)))\n\t\tret2 = -ENOSPC;\n\tif (unlikely(test_and_clear_bit(AS_EIO, &NODE_MAPPING(sbi)->flags)))\n\t\tret2 = -EIO;\n\tif (!ret)\n\t\tret = ret2;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint wait_on_node_pages_writeback(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tpgoff_t index = 0, end = LONG_MAX;\n\tstruct pagevec pvec;\n\tint ret2 = 0, ret = 0;\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_WRITEBACK,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* until radix tree lookup accepts end_index */\n\t\t\tif (unlikely(page->index > end))\n\t\t\t\tcontinue;\n\n\t\t\tif (ino && ino_of_node(page) == ino) {\n\t\t\t\tf2fs_wait_on_page_writeback(page, NODE);\n\t\t\t\tif (TestClearPageError(page))\n\t\t\t\t\tret = -EIO;\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\tif (unlikely(test_and_clear_bit(AS_ENOSPC, &NODE_MAPPING(sbi)->flags)))\n\t\tret2 = -ENOSPC;\n\tif (unlikely(test_and_clear_bit(AS_EIO, &NODE_MAPPING(sbi)->flags)))\n\t\tret2 = -EIO;\n\tif (!ret)\n\t\tret = ret2;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_write_inode",
          "args": [
            "inode",
            "NULL"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "266-289",
          "snippet": "int f2fs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tif (inode->i_ino == F2FS_NODE_INO(sbi) ||\n\t\t\tinode->i_ino == F2FS_META_INO(sbi))\n\t\treturn 0;\n\n\tif (!is_inode_flag_set(F2FS_I(inode), FI_DIRTY_INODE))\n\t\treturn 0;\n\n\t/*\n\t * We need to lock here to prevent from producing dirty node pages\n\t * during the urgent cleaning time when runing out of free sections.\n\t */\n\tf2fs_lock_op(sbi);\n\tupdate_inode_page(inode);\n\tf2fs_unlock_op(sbi);\n\n\tif (wbc)\n\t\tf2fs_balance_fs(sbi);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tif (inode->i_ino == F2FS_NODE_INO(sbi) ||\n\t\t\tinode->i_ino == F2FS_META_INO(sbi))\n\t\treturn 0;\n\n\tif (!is_inode_flag_set(F2FS_I(inode), FI_DIRTY_INODE))\n\t\treturn 0;\n\n\t/*\n\t * We need to lock here to prevent from producing dirty node pages\n\t * during the urgent cleaning time when runing out of free sections.\n\t */\n\tf2fs_lock_op(sbi);\n\tupdate_inode_page(inode);\n\tf2fs_unlock_op(sbi);\n\n\tif (wbc)\n\t\tf2fs_balance_fs(sbi);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty_sync",
          "args": [
            "inode"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "291-294",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_inode_block_update",
          "args": [
            "sbi",
            "ino"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "need_inode_block_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "219-233",
          "snippet": "bool need_inode_block_update(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool need_update = true;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ino);\n\tif (e && get_nat_flag(e, HAS_LAST_FSYNC) &&\n\t\t\t(get_nat_flag(e, IS_CHECKPOINTED) ||\n\t\t\t get_nat_flag(e, HAS_FSYNCED_INODE)))\n\t\tneed_update = false;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn need_update;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool need_inode_block_update(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool need_update = true;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ino);\n\tif (e && get_nat_flag(e, HAS_LAST_FSYNC) &&\n\t\t\t(get_nat_flag(e, IS_CHECKPOINTED) ||\n\t\t\t get_nat_flag(e, HAS_FSYNCED_INODE)))\n\t\tneed_update = false;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn need_update;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "f2fs_cp_error(sbi)"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_cp_error",
          "args": [
            "sbi"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_cp_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1310-1313",
          "snippet": "static inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_node_pages",
          "args": [
            "sbi",
            "ino",
            "&wbc"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "sync_node_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1131-1237",
          "snippet": "int sync_node_pages(struct f2fs_sb_info *sbi, nid_t ino,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tint step = ino ? 2 : 0;\n\tint nwritten = 0, wrote = 0;\n\n\tpagevec_init(&pvec, 0);\n\nnext_step:\n\tindex = 0;\n\tend = LONG_MAX;\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * flushing sequence with step:\n\t\t\t * 0. indirect nodes\n\t\t\t * 1. dentry dnodes\n\t\t\t * 2. file dnodes\n\t\t\t */\n\t\t\tif (step == 0 && IS_DNODE(page))\n\t\t\t\tcontinue;\n\t\t\tif (step == 1 && (!IS_DNODE(page) ||\n\t\t\t\t\t\tis_cold_node(page)))\n\t\t\t\tcontinue;\n\t\t\tif (step == 2 && (!IS_DNODE(page) ||\n\t\t\t\t\t\t!is_cold_node(page)))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If an fsync mode,\n\t\t\t * we should not skip writing node pages.\n\t\t\t */\n\t\t\tif (ino && ino_of_node(page) == ino)\n\t\t\t\tlock_page(page);\n\t\t\telse if (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ino && ino_of_node(page) != ino)\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\t/* called by fsync() */\n\t\t\tif (ino && IS_DNODE(page)) {\n\t\t\t\tset_fsync_mark(page, 1);\n\t\t\t\tif (IS_INODE(page)) {\n\t\t\t\t\tif (!is_checkpointed_node(sbi, ino) &&\n\t\t\t\t\t\t!has_fsynced_inode(sbi, ino))\n\t\t\t\t\t\tset_dentry_mark(page, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t\t}\n\t\t\t\tnwritten++;\n\t\t\t} else {\n\t\t\t\tset_fsync_mark(page, 0);\n\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t}\n\n\t\t\tif (NODE_MAPPING(sbi)->a_ops->writepage(page, wbc))\n\t\t\t\tunlock_page(page);\n\t\t\telse\n\t\t\t\twrote++;\n\n\t\t\tif (--wbc->nr_to_write == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\n\t\tif (wbc->nr_to_write == 0) {\n\t\t\tstep = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (step < 2) {\n\t\tstep++;\n\t\tgoto next_step;\n\t}\n\n\tif (wrote)\n\t\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\treturn nwritten;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint sync_node_pages(struct f2fs_sb_info *sbi, nid_t ino,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tint step = ino ? 2 : 0;\n\tint nwritten = 0, wrote = 0;\n\n\tpagevec_init(&pvec, 0);\n\nnext_step:\n\tindex = 0;\n\tend = LONG_MAX;\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * flushing sequence with step:\n\t\t\t * 0. indirect nodes\n\t\t\t * 1. dentry dnodes\n\t\t\t * 2. file dnodes\n\t\t\t */\n\t\t\tif (step == 0 && IS_DNODE(page))\n\t\t\t\tcontinue;\n\t\t\tif (step == 1 && (!IS_DNODE(page) ||\n\t\t\t\t\t\tis_cold_node(page)))\n\t\t\t\tcontinue;\n\t\t\tif (step == 2 && (!IS_DNODE(page) ||\n\t\t\t\t\t\t!is_cold_node(page)))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If an fsync mode,\n\t\t\t * we should not skip writing node pages.\n\t\t\t */\n\t\t\tif (ino && ino_of_node(page) == ino)\n\t\t\t\tlock_page(page);\n\t\t\telse if (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ino && ino_of_node(page) != ino)\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\t/* called by fsync() */\n\t\t\tif (ino && IS_DNODE(page)) {\n\t\t\t\tset_fsync_mark(page, 1);\n\t\t\t\tif (IS_INODE(page)) {\n\t\t\t\t\tif (!is_checkpointed_node(sbi, ino) &&\n\t\t\t\t\t\t!has_fsynced_inode(sbi, ino))\n\t\t\t\t\t\tset_dentry_mark(page, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t\t}\n\t\t\t\tnwritten++;\n\t\t\t} else {\n\t\t\t\tset_fsync_mark(page, 0);\n\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t}\n\n\t\t\tif (NODE_MAPPING(sbi)->a_ops->writepage(page, wbc))\n\t\t\t\tunlock_page(page);\n\t\t\telse\n\t\t\t\twrote++;\n\n\t\t\tif (--wbc->nr_to_write == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\n\t\tif (wbc->nr_to_write == 0) {\n\t\t\tstep = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (step < 2) {\n\t\tstep++;\n\t\tgoto next_step;\n\t}\n\n\tif (wrote)\n\t\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\treturn nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_fix_pino",
          "args": [
            "inode"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_fix_pino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "152-170",
          "snippet": "static void try_to_fix_pino(struct inode *inode)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tnid_t pino;\n\n\tdown_write(&fi->i_sem);\n\tfi->xattr_ver = 0;\n\tif (file_wrong_pino(inode) && inode->i_nlink == 1 &&\n\t\t\tget_parent_ino(inode, &pino)) {\n\t\tfi->i_pino = pino;\n\t\tfile_got_pino(inode);\n\t\tup_write(&fi->i_sem);\n\n\t\tmark_inode_dirty_sync(inode);\n\t\tf2fs_write_inode(inode, NULL);\n\t} else {\n\t\tup_write(&fi->i_sem);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void try_to_fix_pino(struct inode *inode)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tnid_t pino;\n\n\tdown_write(&fi->i_sem);\n\tfi->xattr_ver = 0;\n\tif (file_wrong_pino(inode) && inode->i_nlink == 1 &&\n\t\t\tget_parent_ino(inode, &pino)) {\n\t\tfi->i_pino = pino;\n\t\tfile_got_pino(inode);\n\t\tup_write(&fi->i_sem);\n\n\t\tmark_inode_dirty_sync(inode);\n\t\tf2fs_write_inode(inode, NULL);\n\t} else {\n\t\tup_write(&fi->i_sem);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_sync_fs",
          "args": [
            "inode->i_sb",
            "1"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "496-516",
          "snippet": "int f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fi->i_sem"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_do_checkpoint",
          "args": [
            "inode"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "need_do_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "118-139",
          "snippet": "static inline bool need_do_checkpoint(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tbool need_cp = false;\n\n\tif (!S_ISREG(inode->i_mode) || inode->i_nlink != 1)\n\t\tneed_cp = true;\n\telse if (file_wrong_pino(inode))\n\t\tneed_cp = true;\n\telse if (!space_for_roll_forward(sbi))\n\t\tneed_cp = true;\n\telse if (!is_checkpointed_node(sbi, F2FS_I(inode)->i_pino))\n\t\tneed_cp = true;\n\telse if (F2FS_I(inode)->xattr_ver == cur_cp_version(F2FS_CKPT(sbi)))\n\t\tneed_cp = true;\n\telse if (test_opt(sbi, FASTBOOT))\n\t\tneed_cp = true;\n\telse if (sbi->active_logs == 2)\n\t\tneed_cp = true;\n\n\treturn need_cp;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic inline bool need_do_checkpoint(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tbool need_cp = false;\n\n\tif (!S_ISREG(inode->i_mode) || inode->i_nlink != 1)\n\t\tneed_cp = true;\n\telse if (file_wrong_pino(inode))\n\t\tneed_cp = true;\n\telse if (!space_for_roll_forward(sbi))\n\t\tneed_cp = true;\n\telse if (!is_checkpointed_node(sbi, F2FS_I(inode)->i_pino))\n\t\tneed_cp = true;\n\telse if (F2FS_I(inode)->xattr_ver == cur_cp_version(F2FS_CKPT(sbi)))\n\t\tneed_cp = true;\n\telse if (test_opt(sbi, FASTBOOT))\n\t\tneed_cp = true;\n\telse if (sbi->active_logs == 2)\n\t\tneed_cp = true;\n\n\treturn need_cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&fi->i_sem"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exist_written_data",
          "args": [
            "sbi",
            "ino",
            "UPDATE_INO"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "exist_written_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "388-397",
          "snippet": "bool exist_written_data(struct f2fs_sb_info *sbi, nid_t ino, int mode)\n{\n\tstruct inode_management *im = &sbi->im[mode];\n\tstruct ino_entry *e;\n\n\tspin_lock(&im->ino_lock);\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tspin_unlock(&im->ino_lock);\n\treturn e ? true : false;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nbool exist_written_data(struct f2fs_sb_info *sbi, nid_t ino, int mode)\n{\n\tstruct inode_management *im = &sbi->im[mode];\n\tstruct ino_entry *e;\n\n\tspin_lock(&im->ino_lock);\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tspin_unlock(&im->ino_lock);\n\treturn e ? true : false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_inode_flag_set",
          "args": [
            "fi",
            "FI_UPDATE_WRITE"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1179-1182",
          "snippet": "static inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_inode_page_update",
          "args": [
            "sbi",
            "ino"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "need_inode_page_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "141-150",
          "snippet": "static bool need_inode_page_update(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct page *i = find_get_page(NODE_MAPPING(sbi), ino);\n\tbool ret = false;\n\t/* But we need to avoid that there are some inode updates */\n\tif ((i && PageDirty(i)) || need_inode_block_update(sbi, ino))\n\t\tret = true;\n\tf2fs_put_page(i, 0);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic bool need_inode_page_update(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct page *i = find_get_page(NODE_MAPPING(sbi), ino);\n\tbool ret = false;\n\t/* But we need to avoid that there are some inode updates */\n\tif ((i && PageDirty(i)) || need_inode_block_update(sbi, ino))\n\t\tret = true;\n\tf2fs_put_page(i, 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_inode_page",
          "args": [
            "inode"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "246-264",
          "snippet": "void update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_sync_file_exit",
          "args": [
            "inode",
            "need_cp",
            "datasync",
            "ret"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "fi",
            "FI_NEED_IPU"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dirty_pages",
          "args": [
            "inode"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "get_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "892-895",
          "snippet": "static inline int get_dirty_pages(struct inode *inode)\n{\n\treturn atomic_read(&F2FS_I(inode)->dirty_pages);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int get_dirty_pages(struct inode *inode)\n{\n\treturn atomic_read(&F2FS_I(inode)->dirty_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_sync_file_enter",
          "args": [
            "inode"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "f2fs_readonly(inode->i_sb)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_readonly",
          "args": [
            "inode->i_sb"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1305-1308",
          "snippet": "static inline int f2fs_readonly(struct super_block *sb)\n{\n\treturn sb->s_flags & MS_RDONLY;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_readonly(struct super_block *sb)\n{\n\treturn sb->s_flags & MS_RDONLY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t ino = inode->i_ino;\n\tint ret = 0;\n\tbool need_cp = false;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.for_reclaim = 0,\n\t};\n\n\tif (unlikely(f2fs_readonly(inode->i_sb)))\n\t\treturn 0;\n\n\ttrace_f2fs_sync_file_enter(inode);\n\n\t/* if fdatasync is triggered, let's do in-place-update */\n\tif (get_dirty_pages(inode) <= SM_I(sbi)->min_fsync_blocks)\n\t\tset_inode_flag(fi, FI_NEED_IPU);\n\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tclear_inode_flag(fi, FI_NEED_IPU);\n\n\tif (ret) {\n\t\ttrace_f2fs_sync_file_exit(inode, need_cp, datasync, ret);\n\t\treturn ret;\n\t}\n\n\t/* if the inode is dirty, let's recover all the time */\n\tif (!datasync && is_inode_flag_set(fi, FI_DIRTY_INODE)) {\n\t\tupdate_inode_page(inode);\n\t\tgoto go_write;\n\t}\n\n\t/*\n\t * if there is no written data, don't waste time to write recovery info.\n\t */\n\tif (!is_inode_flag_set(fi, FI_APPEND_WRITE) &&\n\t\t\t!exist_written_data(sbi, ino, APPEND_INO)) {\n\n\t\t/* it may call write_inode just prior to fsync */\n\t\tif (need_inode_page_update(sbi, ino))\n\t\t\tgoto go_write;\n\n\t\tif (is_inode_flag_set(fi, FI_UPDATE_WRITE) ||\n\t\t\t\texist_written_data(sbi, ino, UPDATE_INO))\n\t\t\tgoto flush_out;\n\t\tgoto out;\n\t}\ngo_write:\n\t/* guarantee free sections for fsync */\n\tf2fs_balance_fs(sbi);\n\n\t/*\n\t * Both of fdatasync() and fsync() are able to be recovered from\n\t * sudden-power-off.\n\t */\n\tdown_read(&fi->i_sem);\n\tneed_cp = need_do_checkpoint(inode);\n\tup_read(&fi->i_sem);\n\n\tif (need_cp) {\n\t\t/* all the dirty node pages should be flushed for POR */\n\t\tret = f2fs_sync_fs(inode->i_sb, 1);\n\n\t\t/*\n\t\t * We've secured consistency through sync_fs. Following pino\n\t\t * will be used only for fsynced inodes after checkpoint.\n\t\t */\n\t\ttry_to_fix_pino(inode);\n\t\tgoto out;\n\t}\nsync_nodes:\n\tsync_node_pages(sbi, ino, &wbc);\n\n\t/* if cp_error was enabled, we should avoid infinite loop */\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto out;\n\n\tif (need_inode_block_update(sbi, ino)) {\n\t\tmark_inode_dirty_sync(inode);\n\t\tf2fs_write_inode(inode, NULL);\n\t\tgoto sync_nodes;\n\t}\n\n\tret = wait_on_node_pages_writeback(sbi, ino);\n\tif (ret)\n\t\tgoto out;\n\n\t/* once recovery info is written, don't need to tack this */\n\tremove_dirty_inode(sbi, ino, APPEND_INO);\n\tclear_inode_flag(fi, FI_APPEND_WRITE);\nflush_out:\n\tremove_dirty_inode(sbi, ino, UPDATE_INO);\n\tclear_inode_flag(fi, FI_UPDATE_WRITE);\n\tret = f2fs_issue_flush(sbi);\nout:\n\ttrace_f2fs_sync_file_exit(inode, need_cp, datasync, ret);\n\tf2fs_trace_ios(NULL, NULL, 1);\n\treturn ret;\n}"
  },
  {
    "function_name": "try_to_fix_pino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "152-170",
    "snippet": "static void try_to_fix_pino(struct inode *inode)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tnid_t pino;\n\n\tdown_write(&fi->i_sem);\n\tfi->xattr_ver = 0;\n\tif (file_wrong_pino(inode) && inode->i_nlink == 1 &&\n\t\t\tget_parent_ino(inode, &pino)) {\n\t\tfi->i_pino = pino;\n\t\tfile_got_pino(inode);\n\t\tup_write(&fi->i_sem);\n\n\t\tmark_inode_dirty_sync(inode);\n\t\tf2fs_write_inode(inode, NULL);\n\t} else {\n\t\tup_write(&fi->i_sem);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&fi->i_sem"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_write_inode",
          "args": [
            "inode",
            "NULL"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "266-289",
          "snippet": "int f2fs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tif (inode->i_ino == F2FS_NODE_INO(sbi) ||\n\t\t\tinode->i_ino == F2FS_META_INO(sbi))\n\t\treturn 0;\n\n\tif (!is_inode_flag_set(F2FS_I(inode), FI_DIRTY_INODE))\n\t\treturn 0;\n\n\t/*\n\t * We need to lock here to prevent from producing dirty node pages\n\t * during the urgent cleaning time when runing out of free sections.\n\t */\n\tf2fs_lock_op(sbi);\n\tupdate_inode_page(inode);\n\tf2fs_unlock_op(sbi);\n\n\tif (wbc)\n\t\tf2fs_balance_fs(sbi);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tif (inode->i_ino == F2FS_NODE_INO(sbi) ||\n\t\t\tinode->i_ino == F2FS_META_INO(sbi))\n\t\treturn 0;\n\n\tif (!is_inode_flag_set(F2FS_I(inode), FI_DIRTY_INODE))\n\t\treturn 0;\n\n\t/*\n\t * We need to lock here to prevent from producing dirty node pages\n\t * during the urgent cleaning time when runing out of free sections.\n\t */\n\tf2fs_lock_op(sbi);\n\tupdate_inode_page(inode);\n\tf2fs_unlock_op(sbi);\n\n\tif (wbc)\n\t\tf2fs_balance_fs(sbi);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty_sync",
          "args": [
            "inode"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "291-294",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&fi->i_sem"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_got_pino",
          "args": [
            "inode"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_parent_ino",
          "args": [
            "inode",
            "&pino"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "get_parent_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "98-116",
          "snippet": "static int get_parent_ino(struct inode *inode, nid_t *pino)\n{\n\tstruct dentry *dentry;\n\n\tinode = igrab(inode);\n\tdentry = d_find_any_alias(inode);\n\tiput(inode);\n\tif (!dentry)\n\t\treturn 0;\n\n\tif (update_dent_inode(inode, &dentry->d_name)) {\n\t\tdput(dentry);\n\t\treturn 0;\n\t}\n\n\t*pino = parent_ino(dentry);\n\tdput(dentry);\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int get_parent_ino(struct inode *inode, nid_t *pino)\n{\n\tstruct dentry *dentry;\n\n\tinode = igrab(inode);\n\tdentry = d_find_any_alias(inode);\n\tiput(inode);\n\tif (!dentry)\n\t\treturn 0;\n\n\tif (update_dent_inode(inode, &dentry->d_name)) {\n\t\tdput(dentry);\n\t\treturn 0;\n\t}\n\n\t*pino = parent_ino(dentry);\n\tdput(dentry);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_wrong_pino",
          "args": [
            "inode"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&fi->i_sem"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void try_to_fix_pino(struct inode *inode)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tnid_t pino;\n\n\tdown_write(&fi->i_sem);\n\tfi->xattr_ver = 0;\n\tif (file_wrong_pino(inode) && inode->i_nlink == 1 &&\n\t\t\tget_parent_ino(inode, &pino)) {\n\t\tfi->i_pino = pino;\n\t\tfile_got_pino(inode);\n\t\tup_write(&fi->i_sem);\n\n\t\tmark_inode_dirty_sync(inode);\n\t\tf2fs_write_inode(inode, NULL);\n\t} else {\n\t\tup_write(&fi->i_sem);\n\t}\n}"
  },
  {
    "function_name": "need_inode_page_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "141-150",
    "snippet": "static bool need_inode_page_update(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct page *i = find_get_page(NODE_MAPPING(sbi), ino);\n\tbool ret = false;\n\t/* But we need to avoid that there are some inode updates */\n\tif ((i && PageDirty(i)) || need_inode_block_update(sbi, ino))\n\t\tret = true;\n\tf2fs_put_page(i, 0);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "i",
            "0"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_inode_block_update",
          "args": [
            "sbi",
            "ino"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "need_inode_block_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "219-233",
          "snippet": "bool need_inode_block_update(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool need_update = true;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ino);\n\tif (e && get_nat_flag(e, HAS_LAST_FSYNC) &&\n\t\t\t(get_nat_flag(e, IS_CHECKPOINTED) ||\n\t\t\t get_nat_flag(e, HAS_FSYNCED_INODE)))\n\t\tneed_update = false;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn need_update;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool need_inode_block_update(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool need_update = true;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ino);\n\tif (e && get_nat_flag(e, HAS_LAST_FSYNC) &&\n\t\t\t(get_nat_flag(e, IS_CHECKPOINTED) ||\n\t\t\t get_nat_flag(e, HAS_FSYNCED_INODE)))\n\t\tneed_update = false;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn need_update;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "i"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "NODE_MAPPING(sbi)",
            "ino"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "NODE_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "710-713",
          "snippet": "static inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic bool need_inode_page_update(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct page *i = find_get_page(NODE_MAPPING(sbi), ino);\n\tbool ret = false;\n\t/* But we need to avoid that there are some inode updates */\n\tif ((i && PageDirty(i)) || need_inode_block_update(sbi, ino))\n\t\tret = true;\n\tf2fs_put_page(i, 0);\n\treturn ret;\n}"
  },
  {
    "function_name": "need_do_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "118-139",
    "snippet": "static inline bool need_do_checkpoint(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tbool need_cp = false;\n\n\tif (!S_ISREG(inode->i_mode) || inode->i_nlink != 1)\n\t\tneed_cp = true;\n\telse if (file_wrong_pino(inode))\n\t\tneed_cp = true;\n\telse if (!space_for_roll_forward(sbi))\n\t\tneed_cp = true;\n\telse if (!is_checkpointed_node(sbi, F2FS_I(inode)->i_pino))\n\t\tneed_cp = true;\n\telse if (F2FS_I(inode)->xattr_ver == cur_cp_version(F2FS_CKPT(sbi)))\n\t\tneed_cp = true;\n\telse if (test_opt(sbi, FASTBOOT))\n\t\tneed_cp = true;\n\telse if (sbi->active_logs == 2)\n\t\tneed_cp = true;\n\n\treturn need_cp;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "FASTBOOT"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_cp_version",
          "args": [
            "F2FS_CKPT(sbi)"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "cur_cp_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "730-733",
          "snippet": "static inline unsigned long long cur_cp_version(struct f2fs_checkpoint *cp)\n{\n\treturn le64_to_cpu(cp->checkpoint_ver);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline unsigned long long cur_cp_version(struct f2fs_checkpoint *cp)\n{\n\treturn le64_to_cpu(cp->checkpoint_ver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_CKPT",
          "args": [
            "sbi"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_CKPT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "665-668",
          "snippet": "static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_checkpointed_node",
          "args": [
            "sbi",
            "F2FS_I(inode)->i_pino"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "is_checkpointed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "191-203",
          "snippet": "bool is_checkpointed_node(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool is_cp = true;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e && !get_nat_flag(e, IS_CHECKPOINTED))\n\t\tis_cp = false;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn is_cp;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool is_checkpointed_node(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool is_cp = true;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e && !get_nat_flag(e, IS_CHECKPOINTED))\n\t\tis_cp = false;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn is_cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "space_for_roll_forward",
          "args": [
            "sbi"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "space_for_roll_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
          "lines": "50-56",
          "snippet": "bool space_for_roll_forward(struct f2fs_sb_info *sbi)\n{\n\tif (sbi->last_valid_block_count + sbi->alloc_valid_block_count\n\t\t\t> sbi->user_block_count)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool space_for_roll_forward(struct f2fs_sb_info *sbi)\n{\n\tif (sbi->last_valid_block_count + sbi->alloc_valid_block_count\n\t\t\t> sbi->user_block_count)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_wrong_pino",
          "args": [
            "inode"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic inline bool need_do_checkpoint(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tbool need_cp = false;\n\n\tif (!S_ISREG(inode->i_mode) || inode->i_nlink != 1)\n\t\tneed_cp = true;\n\telse if (file_wrong_pino(inode))\n\t\tneed_cp = true;\n\telse if (!space_for_roll_forward(sbi))\n\t\tneed_cp = true;\n\telse if (!is_checkpointed_node(sbi, F2FS_I(inode)->i_pino))\n\t\tneed_cp = true;\n\telse if (F2FS_I(inode)->xattr_ver == cur_cp_version(F2FS_CKPT(sbi)))\n\t\tneed_cp = true;\n\telse if (test_opt(sbi, FASTBOOT))\n\t\tneed_cp = true;\n\telse if (sbi->active_logs == 2)\n\t\tneed_cp = true;\n\n\treturn need_cp;\n}"
  },
  {
    "function_name": "get_parent_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "98-116",
    "snippet": "static int get_parent_ino(struct inode *inode, nid_t *pino)\n{\n\tstruct dentry *dentry;\n\n\tinode = igrab(inode);\n\tdentry = d_find_any_alias(inode);\n\tiput(inode);\n\tif (!dentry)\n\t\treturn 0;\n\n\tif (update_dent_inode(inode, &dentry->d_name)) {\n\t\tdput(dentry);\n\t\treturn 0;\n\t}\n\n\t*pino = parent_ino(dentry);\n\tdput(dentry);\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_ino",
          "args": [
            "dentry"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_parent_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "376-389",
          "snippet": "ino_t exofs_parent_ino(struct dentry *child)\n{\n\tstruct page *page;\n\tstruct exofs_dir_entry *de;\n\tino_t ino;\n\n\tde = exofs_dotdot(child->d_inode, &page);\n\tif (!de)\n\t\treturn 0;\n\n\tino = le64_to_cpu(de->inode_no);\n\texofs_put_page(page);\n\treturn ino;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nino_t exofs_parent_ino(struct dentry *child)\n{\n\tstruct page *page;\n\tstruct exofs_dir_entry *de;\n\tino_t ino;\n\n\tde = exofs_dotdot(child->d_inode, &page);\n\tif (!de)\n\t\treturn 0;\n\n\tino = le64_to_cpu(de->inode_no);\n\texofs_put_page(page);\n\treturn ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_dent_inode",
          "args": [
            "inode",
            "&dentry->d_name"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "update_dent_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "310-322",
          "snippet": "int update_dent_inode(struct inode *inode, const struct qstr *name)\n{\n\tstruct page *page;\n\n\tpage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tinit_dent_inode(name, page);\n\tf2fs_put_page(page, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint update_dent_inode(struct inode *inode, const struct qstr *name)\n{\n\tstruct page *page;\n\n\tpage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tinit_dent_inode(name, page);\n\tf2fs_put_page(page, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_find_any_alias",
          "args": [
            "inode"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_any_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1892-1900",
          "snippet": "struct dentry *d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *de;\n\n\tspin_lock(&inode->i_lock);\n\tde = __d_find_any_alias(inode);\n\tspin_unlock(&inode->i_lock);\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *de;\n\n\tspin_lock(&inode->i_lock);\n\tde = __d_find_any_alias(inode);\n\tspin_unlock(&inode->i_lock);\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "inode"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int get_parent_ino(struct inode *inode, nid_t *pino)\n{\n\tstruct dentry *dentry;\n\n\tinode = igrab(inode);\n\tdentry = d_find_any_alias(inode);\n\tiput(inode);\n\tif (!dentry)\n\t\treturn 0;\n\n\tif (update_dent_inode(inode, &dentry->d_name)) {\n\t\tdput(dentry);\n\t\treturn 0;\n\t}\n\n\t*pino = parent_ino(dentry);\n\tdput(dentry);\n\treturn 1;\n}"
  },
  {
    "function_name": "f2fs_vm_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
    "lines": "32-90",
    "snippet": "static int f2fs_vm_page_mkwrite(struct vm_area_struct *vma,\n\t\t\t\t\t\tstruct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tint err;\n\n\tf2fs_balance_fs(sbi);\n\n\tsb_start_pagefault(inode->i_sb);\n\n\tf2fs_bug_on(sbi, f2fs_has_inline_data(inode));\n\n\t/* block allocation */\n\tf2fs_lock_op(sbi);\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = f2fs_reserve_block(&dn, page->index);\n\tif (err) {\n\t\tf2fs_unlock_op(sbi);\n\t\tgoto out;\n\t}\n\tf2fs_put_dnode(&dn);\n\tf2fs_unlock_op(sbi);\n\n\tfile_update_time(vma->vm_file);\n\tlock_page(page);\n\tif (unlikely(page->mapping != inode->i_mapping ||\n\t\t\tpage_offset(page) > i_size_read(inode) ||\n\t\t\t!PageUptodate(page))) {\n\t\tunlock_page(page);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * check to see if the page is mapped already (no holes)\n\t */\n\tif (PageMappedToDisk(page))\n\t\tgoto mapped;\n\n\t/* page is wholly or partially inside EOF */\n\tif (((page->index + 1) << PAGE_CACHE_SHIFT) > i_size_read(inode)) {\n\t\tunsigned offset;\n\t\toffset = i_size_read(inode) & ~PAGE_CACHE_MASK;\n\t\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\t}\n\tset_page_dirty(page);\n\tSetPageUptodate(page);\n\n\ttrace_f2fs_vm_page_mkwrite(page, DATA);\nmapped:\n\t/* fill the page */\n\tf2fs_wait_on_page_writeback(page, DATA);\nout:\n\tsb_end_pagefault(inode->i_sb);\n\treturn block_page_mkwrite_return(err);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/types.h>",
      "#include <linux/falloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/stat.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_page_mkwrite_return",
          "args": [
            "err"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_end_pagefault",
          "args": [
            "inode->i_sb"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "page",
            "DATA"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_vm_page_mkwrite",
          "args": [
            "page",
            "DATA"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "offset",
            "PAGE_CACHE_SIZE"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMappedToDisk",
          "args": [
            "page"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != inode->i_mapping ||\n\t\t\tpage_offset(page) > i_size_read(inode) ||\n\t\t\t!PageUptodate(page)"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "vma->vm_file"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_dnode",
          "args": [
            "&dn"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1048-1056",
          "snippet": "static inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_reserve_block",
          "args": [
            "&dn",
            "page->index"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_reserve_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "235-249",
          "snippet": "int f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index)\n{\n\tbool need_put = dn->inode_page ? false : true;\n\tint err;\n\n\terr = get_dnode_of_data(dn, index, ALLOC_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (dn->data_blkaddr == NULL_ADDR)\n\t\terr = reserve_new_block(dn);\n\tif (err || need_put)\n\t\tf2fs_put_dnode(dn);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index)\n{\n\tbool need_put = dn->inode_page ? false : true;\n\tint err;\n\n\terr = get_dnode_of_data(dn, index, ALLOC_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (dn->data_blkaddr == NULL_ADDR)\n\t\terr = reserve_new_block(dn);\n\tif (err || need_put)\n\t\tf2fs_put_dnode(dn);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "f2fs_has_inline_data(inode)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_pagefault",
          "args": [
            "inode->i_sb"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_vm_page_mkwrite(struct vm_area_struct *vma,\n\t\t\t\t\t\tstruct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tint err;\n\n\tf2fs_balance_fs(sbi);\n\n\tsb_start_pagefault(inode->i_sb);\n\n\tf2fs_bug_on(sbi, f2fs_has_inline_data(inode));\n\n\t/* block allocation */\n\tf2fs_lock_op(sbi);\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = f2fs_reserve_block(&dn, page->index);\n\tif (err) {\n\t\tf2fs_unlock_op(sbi);\n\t\tgoto out;\n\t}\n\tf2fs_put_dnode(&dn);\n\tf2fs_unlock_op(sbi);\n\n\tfile_update_time(vma->vm_file);\n\tlock_page(page);\n\tif (unlikely(page->mapping != inode->i_mapping ||\n\t\t\tpage_offset(page) > i_size_read(inode) ||\n\t\t\t!PageUptodate(page))) {\n\t\tunlock_page(page);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * check to see if the page is mapped already (no holes)\n\t */\n\tif (PageMappedToDisk(page))\n\t\tgoto mapped;\n\n\t/* page is wholly or partially inside EOF */\n\tif (((page->index + 1) << PAGE_CACHE_SHIFT) > i_size_read(inode)) {\n\t\tunsigned offset;\n\t\toffset = i_size_read(inode) & ~PAGE_CACHE_MASK;\n\t\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\t}\n\tset_page_dirty(page);\n\tSetPageUptodate(page);\n\n\ttrace_f2fs_vm_page_mkwrite(page, DATA);\nmapped:\n\t/* fill the page */\n\tf2fs_wait_on_page_writeback(page, DATA);\nout:\n\tsb_end_pagefault(inode->i_sb);\n\treturn block_page_mkwrite_return(err);\n}"
  }
]