[
  {
    "function_name": "pstore_register_ftrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ftrace.c",
    "lines": "107-131",
    "snippet": "void pstore_register_ftrace(void)\n{\n\tstruct dentry *dir;\n\tstruct dentry *file;\n\n\tif (!psinfo->write_buf)\n\t\treturn;\n\n\tdir = debugfs_create_dir(\"pstore\", NULL);\n\tif (!dir) {\n\t\tpr_err(\"%s: unable to create pstore directory\\n\", __func__);\n\t\treturn;\n\t}\n\n\tfile = debugfs_create_file(\"record_ftrace\", 0600, dir, NULL,\n\t\t\t\t   &pstore_knob_fops);\n\tif (!file) {\n\t\tpr_err(\"%s: unable to create record_ftrace file\\n\", __func__);\n\t\tgoto err_file;\n\t}\n\n\treturn;\nerr_file:\n\tdebugfs_remove(dir);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/barrier.h>",
      "#include <linux/cache.h>",
      "#include <linux/err.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/compiler.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations pstore_knob_fops = {\n\t.open\t= simple_open,\n\t.read\t= pstore_ftrace_knob_read,\n\t.write\t= pstore_ftrace_knob_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "dir"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_stats_debugfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "318-321",
          "snippet": "void ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: unable to create record_ftrace file\\n\"",
            "__func__"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"record_ftrace\"",
            "0600",
            "dir",
            "NULL",
            "&pstore_knob_fops"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "321-346",
          "snippet": "struct dentry *debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = mode;\n\tinode->i_fop = fops ? fops : &debugfs_file_operations;\n\tinode->i_private = data;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = mode;\n\tinode->i_fop = fops ? fops : &debugfs_file_operations;\n\tinode->i_private = data;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: unable to create pstore directory\\n\"",
            "__func__"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"pstore\"",
            "NULL"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "407-429",
          "snippet": "struct dentry *debugfs_create_dir(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(dentry->d_parent->d_inode);\n\tfsnotify_mkdir(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_dir(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(dentry->d_parent->d_inode);\n\tfsnotify_mkdir(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/barrier.h>\n#include <linux/cache.h>\n#include <linux/err.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/irqflags.h>\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n\nstatic const struct file_operations pstore_knob_fops = {\n\t.open\t= simple_open,\n\t.read\t= pstore_ftrace_knob_read,\n\t.write\t= pstore_ftrace_knob_write,\n};\n\nvoid pstore_register_ftrace(void)\n{\n\tstruct dentry *dir;\n\tstruct dentry *file;\n\n\tif (!psinfo->write_buf)\n\t\treturn;\n\n\tdir = debugfs_create_dir(\"pstore\", NULL);\n\tif (!dir) {\n\t\tpr_err(\"%s: unable to create pstore directory\\n\", __func__);\n\t\treturn;\n\t}\n\n\tfile = debugfs_create_file(\"record_ftrace\", 0600, dir, NULL,\n\t\t\t\t   &pstore_knob_fops);\n\tif (!file) {\n\t\tpr_err(\"%s: unable to create record_ftrace file\\n\", __func__);\n\t\tgoto err_file;\n\t}\n\n\treturn;\nerr_file:\n\tdebugfs_remove(dir);\n}"
  },
  {
    "function_name": "pstore_ftrace_knob_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ftrace.c",
    "lines": "93-99",
    "snippet": "static ssize_t pstore_ftrace_knob_read(struct file *f, char __user *buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tchar val[] = { '0' + pstore_ftrace_enabled, '\\n' };\n\n\treturn simple_read_from_buffer(buf, count, ppos, val, sizeof(val));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/barrier.h>",
      "#include <linux/cache.h>",
      "#include <linux/err.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/compiler.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool pstore_ftrace_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "val",
            "sizeof(val)"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "590-608",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/barrier.h>\n#include <linux/cache.h>\n#include <linux/err.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/irqflags.h>\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n\nstatic bool pstore_ftrace_enabled;\n\nstatic ssize_t pstore_ftrace_knob_read(struct file *f, char __user *buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tchar val[] = { '0' + pstore_ftrace_enabled, '\\n' };\n\n\treturn simple_read_from_buffer(buf, count, ppos, val, sizeof(val));\n}"
  },
  {
    "function_name": "pstore_ftrace_knob_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ftrace.c",
    "lines": "59-91",
    "snippet": "static ssize_t pstore_ftrace_knob_write(struct file *f, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tu8 on;\n\tssize_t ret;\n\n\tret = kstrtou8_from_user(buf, count, 2, &on);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&pstore_ftrace_lock);\n\n\tif (!on ^ pstore_ftrace_enabled)\n\t\tgoto out;\n\n\tif (on)\n\t\tret = register_ftrace_function(&pstore_ftrace_ops);\n\telse\n\t\tret = unregister_ftrace_function(&pstore_ftrace_ops);\n\tif (ret) {\n\t\tpr_err(\"%s: unable to %sregister ftrace ops: %zd\\n\",\n\t\t       __func__, on ? \"\" : \"un\", ret);\n\t\tgoto err;\n\t}\n\n\tpstore_ftrace_enabled = on;\nout:\n\tret = count;\nerr:\n\tmutex_unlock(&pstore_ftrace_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/barrier.h>",
      "#include <linux/cache.h>",
      "#include <linux/err.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/compiler.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(pstore_ftrace_lock);",
      "static bool pstore_ftrace_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pstore_ftrace_lock"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: unable to %sregister ftrace ops: %zd\\n\"",
            "__func__",
            "on ? \"\" : \"un\"",
            "ret"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "&pstore_ftrace_ops"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "&pstore_ftrace_ops"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pstore_ftrace_lock"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtou8_from_user",
          "args": [
            "buf",
            "count",
            "2",
            "&on"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/barrier.h>\n#include <linux/cache.h>\n#include <linux/err.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/irqflags.h>\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(pstore_ftrace_lock);\nstatic bool pstore_ftrace_enabled;\n\nstatic ssize_t pstore_ftrace_knob_write(struct file *f, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tu8 on;\n\tssize_t ret;\n\n\tret = kstrtou8_from_user(buf, count, 2, &on);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&pstore_ftrace_lock);\n\n\tif (!on ^ pstore_ftrace_enabled)\n\t\tgoto out;\n\n\tif (on)\n\t\tret = register_ftrace_function(&pstore_ftrace_ops);\n\telse\n\t\tret = unregister_ftrace_function(&pstore_ftrace_ops);\n\tif (ret) {\n\t\tpr_err(\"%s: unable to %sregister ftrace ops: %zd\\n\",\n\t\t       __func__, on ? \"\" : \"un\", ret);\n\t\tgoto err;\n\t}\n\n\tpstore_ftrace_enabled = on;\nout:\n\tret = count;\nerr:\n\tmutex_unlock(&pstore_ftrace_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pstore_ftrace_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ftrace.c",
    "lines": "30-50",
    "snippet": "static void notrace pstore_ftrace_call(unsigned long ip,\n\t\t\t\t       unsigned long parent_ip,\n\t\t\t\t       struct ftrace_ops *op,\n\t\t\t\t       struct pt_regs *regs)\n{\n\tunsigned long flags;\n\tstruct pstore_ftrace_record rec = {};\n\n\tif (unlikely(oops_in_progress))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\trec.ip = ip;\n\trec.parent_ip = parent_ip;\n\tpstore_ftrace_encode_cpu(&rec, raw_smp_processor_id());\n\tpsinfo->write_buf(PSTORE_TYPE_FTRACE, 0, NULL, 0, (void *)&rec,\n\t\t\t  0, sizeof(rec), psinfo);\n\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/barrier.h>",
      "#include <linux/cache.h>",
      "#include <linux/err.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/types.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/compiler.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psinfo->write_buf",
          "args": [
            "PSTORE_TYPE_FTRACE",
            "0",
            "NULL",
            "0",
            "(void *)&rec",
            "0",
            "sizeof(rec)",
            "psinfo"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstore_ftrace_encode_cpu",
          "args": [
            "&rec",
            "raw_smp_processor_id()"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_ftrace_encode_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/internal.h",
          "lines": "22-30",
          "snippet": "static inline void\npstore_ftrace_encode_cpu(struct pstore_ftrace_record *rec, unsigned int cpu)\n{\n#ifndef PSTORE_CPU_IN_IP\n\trec->cpu = cpu;\n#else\n\trec->ip |= cpu;\n#endif\n}",
          "includes": [
            "#include <linux/pstore.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define PSTORE_CPU_IN_IP 0x3",
            "#define PSTORE_CPU_IN_IP 0x1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pstore.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\n#define PSTORE_CPU_IN_IP 0x3\n#define PSTORE_CPU_IN_IP 0x1\n\nstatic inline void\npstore_ftrace_encode_cpu(struct pstore_ftrace_record *rec, unsigned int cpu)\n{\n#ifndef PSTORE_CPU_IN_IP\n\trec->cpu = cpu;\n#else\n\trec->ip |= cpu;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "oops_in_progress"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/barrier.h>\n#include <linux/cache.h>\n#include <linux/err.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/irqflags.h>\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n\nstatic void notrace pstore_ftrace_call(unsigned long ip,\n\t\t\t\t       unsigned long parent_ip,\n\t\t\t\t       struct ftrace_ops *op,\n\t\t\t\t       struct pt_regs *regs)\n{\n\tunsigned long flags;\n\tstruct pstore_ftrace_record rec = {};\n\n\tif (unlikely(oops_in_progress))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\trec.ip = ip;\n\trec.parent_ip = parent_ip;\n\tpstore_ftrace_encode_cpu(&rec, raw_smp_processor_id());\n\tpsinfo->write_buf(PSTORE_TYPE_FTRACE, 0, NULL, 0, (void *)&rec,\n\t\t\t  0, sizeof(rec), psinfo);\n\n\tlocal_irq_restore(flags);\n}"
  }
]