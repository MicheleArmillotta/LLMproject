[
  {
    "function_name": "filelock_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2650-2666",
    "snippet": "static int __init filelock_init(void)\n{\n\tint i;\n\n\tflctx_cache = kmem_cache_create(\"file_lock_ctx\",\n\t\t\tsizeof(struct file_lock_context), 0, SLAB_PANIC, NULL);\n\n\tfilelock_cache = kmem_cache_create(\"file_lock_cache\",\n\t\t\tsizeof(struct file_lock), 0, SLAB_PANIC, NULL);\n\n\tlg_lock_init(&file_lock_lglock, \"file_lock_lglock\");\n\n\tfor_each_possible_cpu(i)\n\t\tINIT_HLIST_HEAD(per_cpu_ptr(&file_lock_list, i));\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct hlist_head, file_lock_list);",
      "static struct kmem_cache *flctx_cache",
      "static struct kmem_cache *filelock_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lg_lock_init",
          "args": [
            "&file_lock_lglock",
            "\"file_lock_lglock\""
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"file_lock_cache\"",
            "sizeof(struct file_lock)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"file_lock_ctx\"",
            "sizeof(struct file_lock_context)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 2654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct hlist_head, file_lock_list);\nstatic struct kmem_cache *flctx_cache;\nstatic struct kmem_cache *filelock_cache;\n\nstatic int __init filelock_init(void)\n{\n\tint i;\n\n\tflctx_cache = kmem_cache_create(\"file_lock_ctx\",\n\t\t\tsizeof(struct file_lock_context), 0, SLAB_PANIC, NULL);\n\n\tfilelock_cache = kmem_cache_create(\"file_lock_cache\",\n\t\t\tsizeof(struct file_lock), 0, SLAB_PANIC, NULL);\n\n\tlg_lock_init(&file_lock_lglock, \"file_lock_lglock\");\n\n\tfor_each_possible_cpu(i)\n\t\tINIT_HLIST_HEAD(per_cpu_ptr(&file_lock_list, i));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_locks_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2642-2646",
    "snippet": "static int __init proc_locks_init(void)\n{\n\tproc_create(\"locks\", 0, NULL, &proc_locks_operations);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"locks\"",
            "0",
            "NULL",
            "&proc_locks_operations"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "__proc_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "355-391",
          "snippet": "static struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\n\tent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\tatomic_set(&ent->count, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\nout:\n\treturn ent;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\n\tent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\tatomic_set(&ent->count, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\nout:\n\treturn ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int __init proc_locks_init(void)\n{\n\tproc_create(\"locks\", 0, NULL, &proc_locks_operations);\n\treturn 0;\n}"
  },
  {
    "function_name": "locks_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2629-2633",
    "snippet": "static int locks_open(struct inode *inode, struct file *filp)\n{\n\treturn seq_open_private(filp, &locks_seq_operations,\n\t\t\t\t\tsizeof(struct locks_iterator));\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open_private",
          "args": [
            "filp",
            "&locks_seq_operations",
            "sizeof(struct locks_iterator)"
          ],
          "line": 2631
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "641-645",
          "snippet": "int seq_open_private(struct file *filp, const struct seq_operations *ops,\n\t\tint psize)\n{\n\treturn __seq_open_private(filp, ops, psize) ? 0 : -ENOMEM;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open_private(struct file *filp, const struct seq_operations *ops,\n\t\tint psize)\n{\n\treturn __seq_open_private(filp, ops, psize) ? 0 : -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int locks_open(struct inode *inode, struct file *filp)\n{\n\treturn seq_open_private(filp, &locks_seq_operations,\n\t\t\t\t\tsizeof(struct locks_iterator));\n}"
  },
  {
    "function_name": "locks_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2615-2620",
    "snippet": "static void locks_stop(struct seq_file *f, void *v)\n\t__releases(&blocked_lock_lock)\n{\n\tspin_unlock(&blocked_lock_lock);\n\tlg_global_unlock(&file_lock_lglock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(blocked_lock_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lg_global_unlock",
          "args": [
            "&file_lock_lglock"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 2618
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_stop(struct seq_file *f, void *v)\n\t__releases(&blocked_lock_lock)\n{\n\tspin_unlock(&blocked_lock_lock);\n\tlg_global_unlock(&file_lock_lglock);\n}"
  },
  {
    "function_name": "locks_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2607-2613",
    "snippet": "static void *locks_next(struct seq_file *f, void *v, loff_t *pos)\n{\n\tstruct locks_iterator *iter = f->private;\n\n\t++iter->li_pos;\n\treturn seq_hlist_next_percpu(v, &file_lock_list, &iter->li_cpu, pos);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct hlist_head, file_lock_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_hlist_next_percpu",
          "args": [
            "v",
            "&file_lock_list",
            "&iter->li_cpu",
            "pos"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "seq_hlist_next_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "948-967",
          "snippet": "struct hlist_node *\nseq_hlist_next_percpu(void *v, struct hlist_head __percpu *head,\n\t\t\tint *cpu, loff_t *pos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*pos;\n\n\tif (node->next)\n\t\treturn node->next;\n\n\tfor (*cpu = cpumask_next(*cpu, cpu_possible_mask); *cpu < nr_cpu_ids;\n\t     *cpu = cpumask_next(*cpu, cpu_possible_mask)) {\n\t\tstruct hlist_head *bucket = per_cpu_ptr(head, *cpu);\n\n\t\tif (!hlist_empty(bucket))\n\t\t\treturn bucket->first;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct hlist_node *\nseq_hlist_next_percpu(void *v, struct hlist_head __percpu *head,\n\t\t\tint *cpu, loff_t *pos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*pos;\n\n\tif (node->next)\n\t\treturn node->next;\n\n\tfor (*cpu = cpumask_next(*cpu, cpu_possible_mask); *cpu < nr_cpu_ids;\n\t     *cpu = cpumask_next(*cpu, cpu_possible_mask)) {\n\t\tstruct hlist_head *bucket = per_cpu_ptr(head, *cpu);\n\n\t\tif (!hlist_empty(bucket))\n\t\t\treturn bucket->first;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct hlist_head, file_lock_list);\n\nstatic void *locks_next(struct seq_file *f, void *v, loff_t *pos)\n{\n\tstruct locks_iterator *iter = f->private;\n\n\t++iter->li_pos;\n\treturn seq_hlist_next_percpu(v, &file_lock_list, &iter->li_cpu, pos);\n}"
  },
  {
    "function_name": "locks_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2596-2605",
    "snippet": "static void *locks_start(struct seq_file *f, loff_t *pos)\n\t__acquires(&blocked_lock_lock)\n{\n\tstruct locks_iterator *iter = f->private;\n\n\titer->li_pos = *pos + 1;\n\tlg_global_lock(&file_lock_lglock);\n\tspin_lock(&blocked_lock_lock);\n\treturn seq_hlist_start_percpu(&file_lock_list, &iter->li_cpu, *pos);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct hlist_head, file_lock_list);",
      "static DEFINE_SPINLOCK(blocked_lock_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_hlist_start_percpu",
          "args": [
            "&file_lock_list",
            "&iter->li_cpu",
            "*pos"
          ],
          "line": 2604
        },
        "resolved": true,
        "details": {
          "function_name": "seq_hlist_start_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "924-936",
          "snippet": "struct hlist_node *\nseq_hlist_start_percpu(struct hlist_head __percpu *head, int *cpu, loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\tfor_each_possible_cpu(*cpu) {\n\t\thlist_for_each(node, per_cpu_ptr(head, *cpu)) {\n\t\t\tif (pos-- == 0)\n\t\t\t\treturn node;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct hlist_node *\nseq_hlist_start_percpu(struct hlist_head __percpu *head, int *cpu, loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\tfor_each_possible_cpu(*cpu) {\n\t\thlist_for_each(node, per_cpu_ptr(head, *cpu)) {\n\t\t\tif (pos-- == 0)\n\t\t\t\treturn node;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 2603
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lg_global_lock",
          "args": [
            "&file_lock_lglock"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct hlist_head, file_lock_list);\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void *locks_start(struct seq_file *f, loff_t *pos)\n\t__acquires(&blocked_lock_lock)\n{\n\tstruct locks_iterator *iter = f->private;\n\n\titer->li_pos = *pos + 1;\n\tlg_global_lock(&file_lock_lglock);\n\tspin_lock(&blocked_lock_lock);\n\treturn seq_hlist_start_percpu(&file_lock_list, &iter->li_cpu, *pos);\n}"
  },
  {
    "function_name": "locks_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2581-2594",
    "snippet": "static int locks_show(struct seq_file *f, void *v)\n{\n\tstruct locks_iterator *iter = f->private;\n\tstruct file_lock *fl, *bfl;\n\n\tfl = hlist_entry(v, struct file_lock, fl_link);\n\n\tlock_get_status(f, fl, iter->li_pos, \"\");\n\n\tlist_for_each_entry(bfl, &fl->fl_block, fl_block)\n\t\tlock_get_status(f, bfl, iter->li_pos, \" ->\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_get_status",
          "args": [
            "f",
            "bfl",
            "iter->li_pos",
            "\" ->\""
          ],
          "line": 2591
        },
        "resolved": true,
        "details": {
          "function_name": "lock_get_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2500-2579",
          "snippet": "static void lock_get_status(struct seq_file *f, struct file_lock *fl,\n\t\t\t    loff_t id, char *pfx)\n{\n\tstruct inode *inode = NULL;\n\tunsigned int fl_pid;\n\n\tif (fl->fl_nspid)\n\t\tfl_pid = pid_vnr(fl->fl_nspid);\n\telse\n\t\tfl_pid = fl->fl_pid;\n\n\tif (fl->fl_file != NULL)\n\t\tinode = file_inode(fl->fl_file);\n\n\tseq_printf(f, \"%lld:%s \", id, pfx);\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_flags & FL_ACCESS)\n\t\t\tseq_puts(f, \"ACCESS\");\n\t\telse if (IS_OFDLCK(fl))\n\t\t\tseq_puts(f, \"OFDLCK\");\n\t\telse\n\t\t\tseq_puts(f, \"POSIX \");\n\n\t\tseq_printf(f, \" %s \",\n\t\t\t     (inode == NULL) ? \"*NOINODE*\" :\n\t\t\t     mandatory_lock(inode) ? \"MANDATORY\" : \"ADVISORY \");\n\t} else if (IS_FLOCK(fl)) {\n\t\tif (fl->fl_type & LOCK_MAND) {\n\t\t\tseq_puts(f, \"FLOCK  MSNFS     \");\n\t\t} else {\n\t\t\tseq_puts(f, \"FLOCK  ADVISORY  \");\n\t\t}\n\t} else if (IS_LEASE(fl)) {\n\t\tif (fl->fl_flags & FL_DELEG)\n\t\t\tseq_puts(f, \"DELEG  \");\n\t\telse\n\t\t\tseq_puts(f, \"LEASE  \");\n\n\t\tif (lease_breaking(fl))\n\t\t\tseq_puts(f, \"BREAKING  \");\n\t\telse if (fl->fl_file)\n\t\t\tseq_puts(f, \"ACTIVE    \");\n\t\telse\n\t\t\tseq_puts(f, \"BREAKER   \");\n\t} else {\n\t\tseq_puts(f, \"UNKNOWN UNKNOWN  \");\n\t}\n\tif (fl->fl_type & LOCK_MAND) {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (fl->fl_type & LOCK_READ)\n\t\t\t       ? (fl->fl_type & LOCK_WRITE) ? \"RW   \" : \"READ \"\n\t\t\t       : (fl->fl_type & LOCK_WRITE) ? \"WRITE\" : \"NONE \");\n\t} else {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (lease_breaking(fl))\n\t\t\t       ? (fl->fl_type == F_UNLCK) ? \"UNLCK\" : \"READ \"\n\t\t\t       : (fl->fl_type == F_WRLCK) ? \"WRITE\" : \"READ \");\n\t}\n\tif (inode) {\n#ifdef WE_CAN_BREAK_LSLK_NOW\n\t\tseq_printf(f, \"%d %s:%ld \", fl_pid,\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n#else\n\t\t/* userspace relies on this representation of dev_t ;-( */\n\t\tseq_printf(f, \"%d %02x:%02x:%ld \", fl_pid,\n\t\t\t\tMAJOR(inode->i_sb->s_dev),\n\t\t\t\tMINOR(inode->i_sb->s_dev), inode->i_ino);\n#endif\n\t} else {\n\t\tseq_printf(f, \"%d <none>:0 \", fl_pid);\n\t}\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_end == OFFSET_MAX)\n\t\t\tseq_printf(f, \"%Ld EOF\\n\", fl->fl_start);\n\t\telse\n\t\t\tseq_printf(f, \"%Ld %Ld\\n\", fl->fl_start, fl->fl_end);\n\t} else {\n\t\tseq_puts(f, \"0 EOF\\n\");\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void lock_get_status(struct seq_file *f, struct file_lock *fl,\n\t\t\t    loff_t id, char *pfx)\n{\n\tstruct inode *inode = NULL;\n\tunsigned int fl_pid;\n\n\tif (fl->fl_nspid)\n\t\tfl_pid = pid_vnr(fl->fl_nspid);\n\telse\n\t\tfl_pid = fl->fl_pid;\n\n\tif (fl->fl_file != NULL)\n\t\tinode = file_inode(fl->fl_file);\n\n\tseq_printf(f, \"%lld:%s \", id, pfx);\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_flags & FL_ACCESS)\n\t\t\tseq_puts(f, \"ACCESS\");\n\t\telse if (IS_OFDLCK(fl))\n\t\t\tseq_puts(f, \"OFDLCK\");\n\t\telse\n\t\t\tseq_puts(f, \"POSIX \");\n\n\t\tseq_printf(f, \" %s \",\n\t\t\t     (inode == NULL) ? \"*NOINODE*\" :\n\t\t\t     mandatory_lock(inode) ? \"MANDATORY\" : \"ADVISORY \");\n\t} else if (IS_FLOCK(fl)) {\n\t\tif (fl->fl_type & LOCK_MAND) {\n\t\t\tseq_puts(f, \"FLOCK  MSNFS     \");\n\t\t} else {\n\t\t\tseq_puts(f, \"FLOCK  ADVISORY  \");\n\t\t}\n\t} else if (IS_LEASE(fl)) {\n\t\tif (fl->fl_flags & FL_DELEG)\n\t\t\tseq_puts(f, \"DELEG  \");\n\t\telse\n\t\t\tseq_puts(f, \"LEASE  \");\n\n\t\tif (lease_breaking(fl))\n\t\t\tseq_puts(f, \"BREAKING  \");\n\t\telse if (fl->fl_file)\n\t\t\tseq_puts(f, \"ACTIVE    \");\n\t\telse\n\t\t\tseq_puts(f, \"BREAKER   \");\n\t} else {\n\t\tseq_puts(f, \"UNKNOWN UNKNOWN  \");\n\t}\n\tif (fl->fl_type & LOCK_MAND) {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (fl->fl_type & LOCK_READ)\n\t\t\t       ? (fl->fl_type & LOCK_WRITE) ? \"RW   \" : \"READ \"\n\t\t\t       : (fl->fl_type & LOCK_WRITE) ? \"WRITE\" : \"NONE \");\n\t} else {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (lease_breaking(fl))\n\t\t\t       ? (fl->fl_type == F_UNLCK) ? \"UNLCK\" : \"READ \"\n\t\t\t       : (fl->fl_type == F_WRLCK) ? \"WRITE\" : \"READ \");\n\t}\n\tif (inode) {\n#ifdef WE_CAN_BREAK_LSLK_NOW\n\t\tseq_printf(f, \"%d %s:%ld \", fl_pid,\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n#else\n\t\t/* userspace relies on this representation of dev_t ;-( */\n\t\tseq_printf(f, \"%d %02x:%02x:%ld \", fl_pid,\n\t\t\t\tMAJOR(inode->i_sb->s_dev),\n\t\t\t\tMINOR(inode->i_sb->s_dev), inode->i_ino);\n#endif\n\t} else {\n\t\tseq_printf(f, \"%d <none>:0 \", fl_pid);\n\t}\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_end == OFFSET_MAX)\n\t\t\tseq_printf(f, \"%Ld EOF\\n\", fl->fl_start);\n\t\telse\n\t\t\tseq_printf(f, \"%Ld %Ld\\n\", fl->fl_start, fl->fl_end);\n\t} else {\n\t\tseq_puts(f, \"0 EOF\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "bfl",
            "&fl->fl_block",
            "fl_block"
          ],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "v",
            "structfile_lock",
            "fl_link"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int locks_show(struct seq_file *f, void *v)\n{\n\tstruct locks_iterator *iter = f->private;\n\tstruct file_lock *fl, *bfl;\n\n\tfl = hlist_entry(v, struct file_lock, fl_link);\n\n\tlock_get_status(f, fl, iter->li_pos, \"\");\n\n\tlist_for_each_entry(bfl, &fl->fl_block, fl_block)\n\t\tlock_get_status(f, bfl, iter->li_pos, \" ->\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lock_get_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2500-2579",
    "snippet": "static void lock_get_status(struct seq_file *f, struct file_lock *fl,\n\t\t\t    loff_t id, char *pfx)\n{\n\tstruct inode *inode = NULL;\n\tunsigned int fl_pid;\n\n\tif (fl->fl_nspid)\n\t\tfl_pid = pid_vnr(fl->fl_nspid);\n\telse\n\t\tfl_pid = fl->fl_pid;\n\n\tif (fl->fl_file != NULL)\n\t\tinode = file_inode(fl->fl_file);\n\n\tseq_printf(f, \"%lld:%s \", id, pfx);\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_flags & FL_ACCESS)\n\t\t\tseq_puts(f, \"ACCESS\");\n\t\telse if (IS_OFDLCK(fl))\n\t\t\tseq_puts(f, \"OFDLCK\");\n\t\telse\n\t\t\tseq_puts(f, \"POSIX \");\n\n\t\tseq_printf(f, \" %s \",\n\t\t\t     (inode == NULL) ? \"*NOINODE*\" :\n\t\t\t     mandatory_lock(inode) ? \"MANDATORY\" : \"ADVISORY \");\n\t} else if (IS_FLOCK(fl)) {\n\t\tif (fl->fl_type & LOCK_MAND) {\n\t\t\tseq_puts(f, \"FLOCK  MSNFS     \");\n\t\t} else {\n\t\t\tseq_puts(f, \"FLOCK  ADVISORY  \");\n\t\t}\n\t} else if (IS_LEASE(fl)) {\n\t\tif (fl->fl_flags & FL_DELEG)\n\t\t\tseq_puts(f, \"DELEG  \");\n\t\telse\n\t\t\tseq_puts(f, \"LEASE  \");\n\n\t\tif (lease_breaking(fl))\n\t\t\tseq_puts(f, \"BREAKING  \");\n\t\telse if (fl->fl_file)\n\t\t\tseq_puts(f, \"ACTIVE    \");\n\t\telse\n\t\t\tseq_puts(f, \"BREAKER   \");\n\t} else {\n\t\tseq_puts(f, \"UNKNOWN UNKNOWN  \");\n\t}\n\tif (fl->fl_type & LOCK_MAND) {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (fl->fl_type & LOCK_READ)\n\t\t\t       ? (fl->fl_type & LOCK_WRITE) ? \"RW   \" : \"READ \"\n\t\t\t       : (fl->fl_type & LOCK_WRITE) ? \"WRITE\" : \"NONE \");\n\t} else {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (lease_breaking(fl))\n\t\t\t       ? (fl->fl_type == F_UNLCK) ? \"UNLCK\" : \"READ \"\n\t\t\t       : (fl->fl_type == F_WRLCK) ? \"WRITE\" : \"READ \");\n\t}\n\tif (inode) {\n#ifdef WE_CAN_BREAK_LSLK_NOW\n\t\tseq_printf(f, \"%d %s:%ld \", fl_pid,\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n#else\n\t\t/* userspace relies on this representation of dev_t ;-( */\n\t\tseq_printf(f, \"%d %02x:%02x:%ld \", fl_pid,\n\t\t\t\tMAJOR(inode->i_sb->s_dev),\n\t\t\t\tMINOR(inode->i_sb->s_dev), inode->i_ino);\n#endif\n\t} else {\n\t\tseq_printf(f, \"%d <none>:0 \", fl_pid);\n\t}\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_end == OFFSET_MAX)\n\t\t\tseq_printf(f, \"%Ld EOF\\n\", fl->fl_start);\n\t\telse\n\t\t\tseq_printf(f, \"%Ld %Ld\\n\", fl->fl_start, fl->fl_end);\n\t} else {\n\t\tseq_puts(f, \"0 EOF\\n\");\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "f",
            "\"0 EOF\\n\""
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "f",
            "\"%Ld %Ld\\n\"",
            "fl->fl_start",
            "fl->fl_end"
          ],
          "line": 2575
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_POSIX",
          "args": [
            "fl"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "inode->i_sb->s_dev"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "inode->i_sb->s_dev"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lease_breaking",
          "args": [
            "fl"
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "lease_breaking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "143-146",
          "snippet": "static bool lease_breaking(struct file_lock *fl)\n{\n\treturn fl->fl_flags & (FL_UNLOCK_PENDING | FL_DOWNGRADE_PENDING);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic bool lease_breaking(struct file_lock *fl)\n{\n\treturn fl->fl_flags & (FL_UNLOCK_PENDING | FL_DOWNGRADE_PENDING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_LEASE",
          "args": [
            "fl"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FLOCK",
          "args": [
            "fl"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "locks_mandatory_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1199-1224",
          "snippet": "int locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = file_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = file_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_OFDLCK",
          "args": [
            "fl"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_POSIX",
          "args": [
            "fl"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "fl->fl_file"
          ],
          "line": 2512
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_vnr",
          "args": [
            "fl->fl_nspid"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void lock_get_status(struct seq_file *f, struct file_lock *fl,\n\t\t\t    loff_t id, char *pfx)\n{\n\tstruct inode *inode = NULL;\n\tunsigned int fl_pid;\n\n\tif (fl->fl_nspid)\n\t\tfl_pid = pid_vnr(fl->fl_nspid);\n\telse\n\t\tfl_pid = fl->fl_pid;\n\n\tif (fl->fl_file != NULL)\n\t\tinode = file_inode(fl->fl_file);\n\n\tseq_printf(f, \"%lld:%s \", id, pfx);\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_flags & FL_ACCESS)\n\t\t\tseq_puts(f, \"ACCESS\");\n\t\telse if (IS_OFDLCK(fl))\n\t\t\tseq_puts(f, \"OFDLCK\");\n\t\telse\n\t\t\tseq_puts(f, \"POSIX \");\n\n\t\tseq_printf(f, \" %s \",\n\t\t\t     (inode == NULL) ? \"*NOINODE*\" :\n\t\t\t     mandatory_lock(inode) ? \"MANDATORY\" : \"ADVISORY \");\n\t} else if (IS_FLOCK(fl)) {\n\t\tif (fl->fl_type & LOCK_MAND) {\n\t\t\tseq_puts(f, \"FLOCK  MSNFS     \");\n\t\t} else {\n\t\t\tseq_puts(f, \"FLOCK  ADVISORY  \");\n\t\t}\n\t} else if (IS_LEASE(fl)) {\n\t\tif (fl->fl_flags & FL_DELEG)\n\t\t\tseq_puts(f, \"DELEG  \");\n\t\telse\n\t\t\tseq_puts(f, \"LEASE  \");\n\n\t\tif (lease_breaking(fl))\n\t\t\tseq_puts(f, \"BREAKING  \");\n\t\telse if (fl->fl_file)\n\t\t\tseq_puts(f, \"ACTIVE    \");\n\t\telse\n\t\t\tseq_puts(f, \"BREAKER   \");\n\t} else {\n\t\tseq_puts(f, \"UNKNOWN UNKNOWN  \");\n\t}\n\tif (fl->fl_type & LOCK_MAND) {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (fl->fl_type & LOCK_READ)\n\t\t\t       ? (fl->fl_type & LOCK_WRITE) ? \"RW   \" : \"READ \"\n\t\t\t       : (fl->fl_type & LOCK_WRITE) ? \"WRITE\" : \"NONE \");\n\t} else {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (lease_breaking(fl))\n\t\t\t       ? (fl->fl_type == F_UNLCK) ? \"UNLCK\" : \"READ \"\n\t\t\t       : (fl->fl_type == F_WRLCK) ? \"WRITE\" : \"READ \");\n\t}\n\tif (inode) {\n#ifdef WE_CAN_BREAK_LSLK_NOW\n\t\tseq_printf(f, \"%d %s:%ld \", fl_pid,\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n#else\n\t\t/* userspace relies on this representation of dev_t ;-( */\n\t\tseq_printf(f, \"%d %02x:%02x:%ld \", fl_pid,\n\t\t\t\tMAJOR(inode->i_sb->s_dev),\n\t\t\t\tMINOR(inode->i_sb->s_dev), inode->i_ino);\n#endif\n\t} else {\n\t\tseq_printf(f, \"%d <none>:0 \", fl_pid);\n\t}\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_end == OFFSET_MAX)\n\t\t\tseq_printf(f, \"%Ld EOF\\n\", fl->fl_start);\n\t\telse\n\t\t\tseq_printf(f, \"%Ld %Ld\\n\", fl->fl_start, fl->fl_end);\n\t} else {\n\t\tseq_puts(f, \"0 EOF\\n\");\n\t}\n}"
  },
  {
    "function_name": "vfs_cancel_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2482-2487",
    "snippet": "int vfs_cancel_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_CANCELLK, fl);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filp->f_op->lock",
          "args": [
            "filp",
            "F_CANCELLK",
            "fl"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_cancel_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_CANCELLK, fl);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_unblock_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2460-2472",
    "snippet": "int\nposix_unblock_lock(struct file_lock *waiter)\n{\n\tint status = 0;\n\n\tspin_lock(&blocked_lock_lock);\n\tif (waiter->fl_next)\n\t\t__locks_delete_block(waiter);\n\telse\n\t\tstatus = -ENOENT;\n\tspin_unlock(&blocked_lock_lock);\n\treturn status;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(blocked_lock_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 2470
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__locks_delete_block",
          "args": [
            "waiter"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "__locks_delete_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "608-613",
          "snippet": "static void __locks_delete_block(struct file_lock *waiter)\n{\n\tlocks_delete_global_blocked(waiter);\n\tlist_del_init(&waiter->fl_block);\n\twaiter->fl_next = NULL;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void __locks_delete_block(struct file_lock *waiter)\n{\n\tlocks_delete_global_blocked(waiter);\n\tlist_del_init(&waiter->fl_block);\n\twaiter->fl_next = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nint\nposix_unblock_lock(struct file_lock *waiter)\n{\n\tint status = 0;\n\n\tspin_lock(&blocked_lock_lock);\n\tif (waiter->fl_next)\n\t\t__locks_delete_block(waiter);\n\telse\n\t\tstatus = -ENOENT;\n\tspin_unlock(&blocked_lock_lock);\n\treturn status;\n}"
  },
  {
    "function_name": "locks_remove_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2439-2452",
    "snippet": "void locks_remove_file(struct file *filp)\n{\n\tif (!file_inode(filp)->i_flctx)\n\t\treturn;\n\n\t/* remove any OFD locks */\n\tlocks_remove_posix(filp, filp);\n\n\t/* remove flock locks */\n\tlocks_remove_flock(filp);\n\n\t/* remove any leases */\n\tlocks_remove_lease(filp);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_remove_lease",
          "args": [
            "filp"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "locks_remove_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2417-2434",
          "snippet": "static void\nlocks_remove_lease(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\tLIST_HEAD(dispose);\n\n\tif (list_empty(&ctx->flc_lease))\n\t\treturn;\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list)\n\t\tif (filp == fl->fl_file)\n\t\t\tlease_modify(fl, F_UNLCK, &dispose);\n\tspin_unlock(&ctx->flc_lock);\n\tlocks_dispose_list(&dispose);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_remove_lease(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\tLIST_HEAD(dispose);\n\n\tif (list_empty(&ctx->flc_lease))\n\t\treturn;\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list)\n\t\tif (filp == fl->fl_file)\n\t\t\tlease_modify(fl, F_UNLCK, &dispose);\n\tspin_unlock(&ctx->flc_lock);\n\tlocks_dispose_list(&dispose);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_remove_flock",
          "args": [
            "filp"
          ],
          "line": 2448
        },
        "resolved": true,
        "details": {
          "function_name": "locks_remove_flock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2391-2414",
          "snippet": "static void\nlocks_remove_flock(struct file *filp)\n{\n\tstruct file_lock fl = {\n\t\t.fl_owner = filp,\n\t\t.fl_pid = current->tgid,\n\t\t.fl_file = filp,\n\t\t.fl_flags = FL_FLOCK,\n\t\t.fl_type = F_UNLCK,\n\t\t.fl_end = OFFSET_MAX,\n\t};\n\tstruct file_lock_context *flctx = file_inode(filp)->i_flctx;\n\n\tif (list_empty(&flctx->flc_flock))\n\t\treturn;\n\n\tif (filp->f_op->flock)\n\t\tfilp->f_op->flock(filp, F_SETLKW, &fl);\n\telse\n\t\tflock_lock_file(filp, &fl);\n\n\tif (fl.fl_ops && fl.fl_ops->fl_release_private)\n\t\tfl.fl_ops->fl_release_private(&fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_remove_flock(struct file *filp)\n{\n\tstruct file_lock fl = {\n\t\t.fl_owner = filp,\n\t\t.fl_pid = current->tgid,\n\t\t.fl_file = filp,\n\t\t.fl_flags = FL_FLOCK,\n\t\t.fl_type = F_UNLCK,\n\t\t.fl_end = OFFSET_MAX,\n\t};\n\tstruct file_lock_context *flctx = file_inode(filp)->i_flctx;\n\n\tif (list_empty(&flctx->flc_flock))\n\t\treturn;\n\n\tif (filp->f_op->flock)\n\t\tfilp->f_op->flock(filp, F_SETLKW, &fl);\n\telse\n\t\tflock_lock_file(filp, &fl);\n\n\tif (fl.fl_ops && fl.fl_ops->fl_release_private)\n\t\tfl.fl_ops->fl_release_private(&fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_remove_posix",
          "args": [
            "filp",
            "filp"
          ],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "locks_remove_posix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2359-2386",
          "snippet": "void locks_remove_posix(struct file *filp, fl_owner_t owner)\n{\n\tstruct file_lock lock;\n\tstruct file_lock_context *ctx = file_inode(filp)->i_flctx;\n\n\t/*\n\t * If there are no locks held on this file, we don't need to call\n\t * posix_lock_file().  Another process could be setting a lock on this\n\t * file at the same time, but we wouldn't remove that lock anyway.\n\t */\n\tif (!ctx || list_empty(&ctx->flc_posix))\n\t\treturn;\n\n\tlock.fl_type = F_UNLCK;\n\tlock.fl_flags = FL_POSIX | FL_CLOSE;\n\tlock.fl_start = 0;\n\tlock.fl_end = OFFSET_MAX;\n\tlock.fl_owner = owner;\n\tlock.fl_pid = current->tgid;\n\tlock.fl_file = filp;\n\tlock.fl_ops = NULL;\n\tlock.fl_lmops = NULL;\n\n\tvfs_lock_file(filp, F_SETLK, &lock, NULL);\n\n\tif (lock.fl_ops && lock.fl_ops->fl_release_private)\n\t\tlock.fl_ops->fl_release_private(&lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_remove_posix(struct file *filp, fl_owner_t owner)\n{\n\tstruct file_lock lock;\n\tstruct file_lock_context *ctx = file_inode(filp)->i_flctx;\n\n\t/*\n\t * If there are no locks held on this file, we don't need to call\n\t * posix_lock_file().  Another process could be setting a lock on this\n\t * file at the same time, but we wouldn't remove that lock anyway.\n\t */\n\tif (!ctx || list_empty(&ctx->flc_posix))\n\t\treturn;\n\n\tlock.fl_type = F_UNLCK;\n\tlock.fl_flags = FL_POSIX | FL_CLOSE;\n\tlock.fl_start = 0;\n\tlock.fl_end = OFFSET_MAX;\n\tlock.fl_owner = owner;\n\tlock.fl_pid = current->tgid;\n\tlock.fl_file = filp;\n\tlock.fl_ops = NULL;\n\tlock.fl_lmops = NULL;\n\n\tvfs_lock_file(filp, F_SETLK, &lock, NULL);\n\n\tif (lock.fl_ops && lock.fl_ops->fl_release_private)\n\t\tlock.fl_ops->fl_release_private(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 2441
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_remove_file(struct file *filp)\n{\n\tif (!file_inode(filp)->i_flctx)\n\t\treturn;\n\n\t/* remove any OFD locks */\n\tlocks_remove_posix(filp, filp);\n\n\t/* remove flock locks */\n\tlocks_remove_flock(filp);\n\n\t/* remove any leases */\n\tlocks_remove_lease(filp);\n}"
  },
  {
    "function_name": "locks_remove_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2417-2434",
    "snippet": "static void\nlocks_remove_lease(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\tLIST_HEAD(dispose);\n\n\tif (list_empty(&ctx->flc_lease))\n\t\treturn;\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list)\n\t\tif (filp == fl->fl_file)\n\t\t\tlease_modify(fl, F_UNLCK, &dispose);\n\tspin_unlock(&ctx->flc_lock);\n\tlocks_dispose_list(&dispose);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_dispose_list",
          "args": [
            "&dispose"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "locks_dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "299-309",
          "snippet": "static void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lease_modify",
          "args": [
            "fl",
            "F_UNLCK",
            "&dispose"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "lease_modify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1303-1324",
          "snippet": "int lease_modify(struct file_lock *fl, int arg, struct list_head *dispose)\n{\n\tint error = assign_type(fl, arg);\n\n\tif (error)\n\t\treturn error;\n\tlease_clear_pending(fl, arg);\n\tlocks_wake_up_blocks(fl);\n\tif (arg == F_UNLCK) {\n\t\tstruct file *filp = fl->fl_file;\n\n\t\tf_delown(filp);\n\t\tfilp->f_owner.signum = 0;\n\t\tfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\n\t\tif (fl->fl_fasync != NULL) {\n\t\t\tprintk(KERN_ERR \"locks_delete_lock: fasync == %p\\n\", fl->fl_fasync);\n\t\t\tfl->fl_fasync = NULL;\n\t\t}\n\t\tlocks_delete_lock_ctx(fl, dispose);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint lease_modify(struct file_lock *fl, int arg, struct list_head *dispose)\n{\n\tint error = assign_type(fl, arg);\n\n\tif (error)\n\t\treturn error;\n\tlease_clear_pending(fl, arg);\n\tlocks_wake_up_blocks(fl);\n\tif (arg == F_UNLCK) {\n\t\tstruct file *filp = fl->fl_file;\n\n\t\tf_delown(filp);\n\t\tfilp->f_owner.signum = 0;\n\t\tfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\n\t\tif (fl->fl_fasync != NULL) {\n\t\t\tprintk(KERN_ERR \"locks_delete_lock: fasync == %p\\n\", fl->fl_fasync);\n\t\t\tfl->fl_fasync = NULL;\n\t\t}\n\t\tlocks_delete_lock_ctx(fl, dispose);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "fl",
            "tmp",
            "&ctx->flc_lease",
            "fl_list"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 2428
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ctx->flc_lease"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_remove_lease(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\tLIST_HEAD(dispose);\n\n\tif (list_empty(&ctx->flc_lease))\n\t\treturn;\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list)\n\t\tif (filp == fl->fl_file)\n\t\t\tlease_modify(fl, F_UNLCK, &dispose);\n\tspin_unlock(&ctx->flc_lock);\n\tlocks_dispose_list(&dispose);\n}"
  },
  {
    "function_name": "locks_remove_flock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2391-2414",
    "snippet": "static void\nlocks_remove_flock(struct file *filp)\n{\n\tstruct file_lock fl = {\n\t\t.fl_owner = filp,\n\t\t.fl_pid = current->tgid,\n\t\t.fl_file = filp,\n\t\t.fl_flags = FL_FLOCK,\n\t\t.fl_type = F_UNLCK,\n\t\t.fl_end = OFFSET_MAX,\n\t};\n\tstruct file_lock_context *flctx = file_inode(filp)->i_flctx;\n\n\tif (list_empty(&flctx->flc_flock))\n\t\treturn;\n\n\tif (filp->f_op->flock)\n\t\tfilp->f_op->flock(filp, F_SETLKW, &fl);\n\telse\n\t\tflock_lock_file(filp, &fl);\n\n\tif (fl.fl_ops && fl.fl_ops->fl_release_private)\n\t\tfl.fl_ops->fl_release_private(&fl);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fl.fl_ops->fl_release_private",
          "args": [
            "&fl"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flock_lock_file",
          "args": [
            "filp",
            "&fl"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "flock_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1858-1874",
          "snippet": "int flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp->f_op->flock",
          "args": [
            "filp",
            "F_SETLKW",
            "&fl"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&flctx->flc_flock"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_remove_flock(struct file *filp)\n{\n\tstruct file_lock fl = {\n\t\t.fl_owner = filp,\n\t\t.fl_pid = current->tgid,\n\t\t.fl_file = filp,\n\t\t.fl_flags = FL_FLOCK,\n\t\t.fl_type = F_UNLCK,\n\t\t.fl_end = OFFSET_MAX,\n\t};\n\tstruct file_lock_context *flctx = file_inode(filp)->i_flctx;\n\n\tif (list_empty(&flctx->flc_flock))\n\t\treturn;\n\n\tif (filp->f_op->flock)\n\t\tfilp->f_op->flock(filp, F_SETLKW, &fl);\n\telse\n\t\tflock_lock_file(filp, &fl);\n\n\tif (fl.fl_ops && fl.fl_ops->fl_release_private)\n\t\tfl.fl_ops->fl_release_private(&fl);\n}"
  },
  {
    "function_name": "locks_remove_posix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2359-2386",
    "snippet": "void locks_remove_posix(struct file *filp, fl_owner_t owner)\n{\n\tstruct file_lock lock;\n\tstruct file_lock_context *ctx = file_inode(filp)->i_flctx;\n\n\t/*\n\t * If there are no locks held on this file, we don't need to call\n\t * posix_lock_file().  Another process could be setting a lock on this\n\t * file at the same time, but we wouldn't remove that lock anyway.\n\t */\n\tif (!ctx || list_empty(&ctx->flc_posix))\n\t\treturn;\n\n\tlock.fl_type = F_UNLCK;\n\tlock.fl_flags = FL_POSIX | FL_CLOSE;\n\tlock.fl_start = 0;\n\tlock.fl_end = OFFSET_MAX;\n\tlock.fl_owner = owner;\n\tlock.fl_pid = current->tgid;\n\tlock.fl_file = filp;\n\tlock.fl_ops = NULL;\n\tlock.fl_lmops = NULL;\n\n\tvfs_lock_file(filp, F_SETLK, &lock, NULL);\n\n\tif (lock.fl_ops && lock.fl_ops->fl_release_private)\n\t\tlock.fl_ops->fl_release_private(&lock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock.fl_ops->fl_release_private",
          "args": [
            "&lock"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_lock_file",
          "args": [
            "filp",
            "F_SETLK",
            "&lock",
            "NULL"
          ],
          "line": 2382
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2077-2083",
          "snippet": "int vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ctx->flc_posix"
          ],
          "line": 2369
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_remove_posix(struct file *filp, fl_owner_t owner)\n{\n\tstruct file_lock lock;\n\tstruct file_lock_context *ctx = file_inode(filp)->i_flctx;\n\n\t/*\n\t * If there are no locks held on this file, we don't need to call\n\t * posix_lock_file().  Another process could be setting a lock on this\n\t * file at the same time, but we wouldn't remove that lock anyway.\n\t */\n\tif (!ctx || list_empty(&ctx->flc_posix))\n\t\treturn;\n\n\tlock.fl_type = F_UNLCK;\n\tlock.fl_flags = FL_POSIX | FL_CLOSE;\n\tlock.fl_start = 0;\n\tlock.fl_end = OFFSET_MAX;\n\tlock.fl_owner = owner;\n\tlock.fl_pid = current->tgid;\n\tlock.fl_file = filp;\n\tlock.fl_ops = NULL;\n\tlock.fl_lmops = NULL;\n\n\tvfs_lock_file(filp, F_SETLK, &lock, NULL);\n\n\tif (lock.fl_ops && lock.fl_ops->fl_release_private)\n\t\tlock.fl_ops->fl_release_private(&lock);\n}"
  },
  {
    "function_name": "fcntl_setlk64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2269-2351",
    "snippet": "int fcntl_setlk64(unsigned int fd, struct file *filp, unsigned int cmd,\n\t\tstruct flock64 __user *l)\n{\n\tstruct file_lock *file_lock = locks_alloc_lock();\n\tstruct flock64 flock;\n\tstruct inode *inode;\n\tstruct file *f;\n\tint error;\n\n\tif (file_lock == NULL)\n\t\treturn -ENOLCK;\n\n\t/*\n\t * This might block, so we do it before checking the inode.\n\t */\n\terror = -EFAULT;\n\tif (copy_from_user(&flock, l, sizeof(flock)))\n\t\tgoto out;\n\n\tinode = file_inode(filp);\n\n\t/* Don't allow mandatory locks on files that may be memory mapped\n\t * and shared.\n\t */\n\tif (mandatory_lock(inode) && mapping_writably_mapped(filp->f_mapping)) {\n\t\terror = -EAGAIN;\n\t\tgoto out;\n\t}\n\nagain:\n\terror = flock64_to_posix_lock(filp, file_lock, &flock);\n\tif (error)\n\t\tgoto out;\n\n\terror = check_fmode_for_setlk(file_lock);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If the cmd is requesting file-private locks, then set the\n\t * FL_OFDLCK flag and override the owner.\n\t */\n\tswitch (cmd) {\n\tcase F_OFD_SETLK:\n\t\terror = -EINVAL;\n\t\tif (flock.l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLK64;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\tbreak;\n\tcase F_OFD_SETLKW:\n\t\terror = -EINVAL;\n\t\tif (flock.l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLKW64;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\t/* Fallthrough */\n\tcase F_SETLKW64:\n\t\tfile_lock->fl_flags |= FL_SLEEP;\n\t}\n\n\terror = do_lock_file_wait(filp, cmd, file_lock);\n\n\t/*\n\t * Attempt to detect a close/fcntl race and recover by\n\t * releasing the lock that was just acquired.\n\t */\n\tspin_lock(&current->files->file_lock);\n\tf = fcheck(fd);\n\tspin_unlock(&current->files->file_lock);\n\tif (!error && f != filp && flock.l_type != F_UNLCK) {\n\t\tflock.l_type = F_UNLCK;\n\t\tgoto again;\n\t}\n\nout:\n\tlocks_free_lock(file_lock);\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "file_lock"
          ],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "287-296",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&current->files->file_lock"
          ],
          "line": 2342
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcheck",
          "args": [
            "fd"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&current->files->file_lock"
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_lock_file_wait",
          "args": [
            "filp",
            "cmd",
            "file_lock"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "do_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2086-2108",
          "snippet": "static int do_lock_file_wait(struct file *filp, unsigned int cmd,\n\t\t\t     struct file_lock *fl)\n{\n\tint error;\n\n\terror = security_file_lock(filp, fl->fl_type);\n\tif (error)\n\t\treturn error;\n\n\tfor (;;) {\n\t\terror = vfs_lock_file(filp, cmd, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int do_lock_file_wait(struct file *filp, unsigned int cmd,\n\t\t\t     struct file_lock *fl)\n{\n\tint error;\n\n\terror = security_file_lock(filp, fl->fl_type);\n\tif (error)\n\t\treturn error;\n\n\tfor (;;) {\n\t\terror = vfs_lock_file(filp, cmd, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_fmode_for_setlk",
          "args": [
            "file_lock"
          ],
          "line": 2303
        },
        "resolved": true,
        "details": {
          "function_name": "check_fmode_for_setlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2111-2124",
          "snippet": "static int\ncheck_fmode_for_setlk(struct file_lock *fl)\n{\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int\ncheck_fmode_for_setlk(struct file_lock *fl)\n{\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock64_to_posix_lock",
          "args": [
            "filp",
            "file_lock",
            "&flock"
          ],
          "line": 2299
        },
        "resolved": true,
        "details": {
          "function_name": "flock64_to_posix_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "411-456",
          "snippet": "static int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t\t struct flock64 *l)\n{\n\tswitch (l->l_whence) {\n\tcase SEEK_SET:\n\t\tfl->fl_start = 0;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tfl->fl_start = filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tfl->fl_start = i_size_read(file_inode(filp));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (l->l_start > OFFSET_MAX - fl->fl_start)\n\t\treturn -EOVERFLOW;\n\tfl->fl_start += l->l_start;\n\tif (fl->fl_start < 0)\n\t\treturn -EINVAL;\n\n\t/* POSIX-1996 leaves the case l->l_len < 0 undefined;\n\t   POSIX-2001 defines it. */\n\tif (l->l_len > 0) {\n\t\tif (l->l_len - 1 > OFFSET_MAX - fl->fl_start)\n\t\t\treturn -EOVERFLOW;\n\t\tfl->fl_end = fl->fl_start + l->l_len - 1;\n\n\t} else if (l->l_len < 0) {\n\t\tif (fl->fl_start + l->l_len < 0)\n\t\t\treturn -EINVAL;\n\t\tfl->fl_end = fl->fl_start - 1;\n\t\tfl->fl_start += l->l_len;\n\t} else\n\t\tfl->fl_end = OFFSET_MAX;\n\n\tfl->fl_owner = current->files;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\n\treturn assign_type(fl, l->l_type);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t\t struct flock64 *l)\n{\n\tswitch (l->l_whence) {\n\tcase SEEK_SET:\n\t\tfl->fl_start = 0;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tfl->fl_start = filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tfl->fl_start = i_size_read(file_inode(filp));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (l->l_start > OFFSET_MAX - fl->fl_start)\n\t\treturn -EOVERFLOW;\n\tfl->fl_start += l->l_start;\n\tif (fl->fl_start < 0)\n\t\treturn -EINVAL;\n\n\t/* POSIX-1996 leaves the case l->l_len < 0 undefined;\n\t   POSIX-2001 defines it. */\n\tif (l->l_len > 0) {\n\t\tif (l->l_len - 1 > OFFSET_MAX - fl->fl_start)\n\t\t\treturn -EOVERFLOW;\n\t\tfl->fl_end = fl->fl_start + l->l_len - 1;\n\n\t} else if (l->l_len < 0) {\n\t\tif (fl->fl_start + l->l_len < 0)\n\t\t\treturn -EINVAL;\n\t\tfl->fl_end = fl->fl_start - 1;\n\t\tfl->fl_start += l->l_len;\n\t} else\n\t\tfl->fl_end = OFFSET_MAX;\n\n\tfl->fl_owner = current->files;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\n\treturn assign_type(fl, l->l_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_writably_mapped",
          "args": [
            "filp->f_mapping"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "locks_mandatory_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1199-1224",
          "snippet": "int locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = file_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = file_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&flock",
            "l",
            "sizeof(flock)"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "259-267",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint fcntl_setlk64(unsigned int fd, struct file *filp, unsigned int cmd,\n\t\tstruct flock64 __user *l)\n{\n\tstruct file_lock *file_lock = locks_alloc_lock();\n\tstruct flock64 flock;\n\tstruct inode *inode;\n\tstruct file *f;\n\tint error;\n\n\tif (file_lock == NULL)\n\t\treturn -ENOLCK;\n\n\t/*\n\t * This might block, so we do it before checking the inode.\n\t */\n\terror = -EFAULT;\n\tif (copy_from_user(&flock, l, sizeof(flock)))\n\t\tgoto out;\n\n\tinode = file_inode(filp);\n\n\t/* Don't allow mandatory locks on files that may be memory mapped\n\t * and shared.\n\t */\n\tif (mandatory_lock(inode) && mapping_writably_mapped(filp->f_mapping)) {\n\t\terror = -EAGAIN;\n\t\tgoto out;\n\t}\n\nagain:\n\terror = flock64_to_posix_lock(filp, file_lock, &flock);\n\tif (error)\n\t\tgoto out;\n\n\terror = check_fmode_for_setlk(file_lock);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If the cmd is requesting file-private locks, then set the\n\t * FL_OFDLCK flag and override the owner.\n\t */\n\tswitch (cmd) {\n\tcase F_OFD_SETLK:\n\t\terror = -EINVAL;\n\t\tif (flock.l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLK64;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\tbreak;\n\tcase F_OFD_SETLKW:\n\t\terror = -EINVAL;\n\t\tif (flock.l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLKW64;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\t/* Fallthrough */\n\tcase F_SETLKW64:\n\t\tfile_lock->fl_flags |= FL_SLEEP;\n\t}\n\n\terror = do_lock_file_wait(filp, cmd, file_lock);\n\n\t/*\n\t * Attempt to detect a close/fcntl race and recover by\n\t * releasing the lock that was just acquired.\n\t */\n\tspin_lock(&current->files->file_lock);\n\tf = fcheck(fd);\n\tspin_unlock(&current->files->file_lock);\n\tif (!error && f != filp && flock.l_type != F_UNLCK) {\n\t\tflock.l_type = F_UNLCK;\n\t\tgoto again;\n\t}\n\nout:\n\tlocks_free_lock(file_lock);\n\treturn error;\n}"
  },
  {
    "function_name": "fcntl_getlk64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2222-2264",
    "snippet": "int fcntl_getlk64(struct file *filp, unsigned int cmd, struct flock64 __user *l)\n{\n\tstruct file_lock file_lock;\n\tstruct flock64 flock;\n\tint error;\n\n\terror = -EFAULT;\n\tif (copy_from_user(&flock, l, sizeof(flock)))\n\t\tgoto out;\n\terror = -EINVAL;\n\tif ((flock.l_type != F_RDLCK) && (flock.l_type != F_WRLCK))\n\t\tgoto out;\n\n\terror = flock64_to_posix_lock(filp, &file_lock, &flock);\n\tif (error)\n\t\tgoto out;\n\n\tif (cmd == F_OFD_GETLK) {\n\t\terror = -EINVAL;\n\t\tif (flock.l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_GETLK64;\n\t\tfile_lock.fl_flags |= FL_OFDLCK;\n\t\tfile_lock.fl_owner = filp;\n\t}\n\n\terror = vfs_test_lock(filp, &file_lock);\n\tif (error)\n\t\tgoto out;\n\n\tflock.l_type = file_lock.fl_type;\n\tif (file_lock.fl_type != F_UNLCK)\n\t\tposix_lock_to_flock64(&flock, &file_lock);\n\n\terror = -EFAULT;\n\tif (!copy_to_user(l, &flock, sizeof(flock)))\n\t\terror = 0;\n\n\tlocks_release_private(&file_lock);\nout:\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_release_private",
          "args": [
            "&file_lock"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "locks_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "270-283",
          "snippet": "void locks_release_private(struct file_lock *fl)\n{\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_release_private)\n\t\t\tfl->fl_ops->fl_release_private(fl);\n\t\tfl->fl_ops = NULL;\n\t}\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_put_owner)\n\t\t\tfl->fl_lmops->lm_put_owner(fl);\n\t\tfl->fl_lmops = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_release_private(struct file_lock *fl)\n{\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_release_private)\n\t\t\tfl->fl_ops->fl_release_private(fl);\n\t\tfl->fl_ops = NULL;\n\t}\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_put_owner)\n\t\t\tfl->fl_lmops->lm_put_owner(fl);\n\t\tfl->fl_lmops = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "l",
            "&flock",
            "sizeof(flock)"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_lock_to_flock64",
          "args": [
            "&flock",
            "&file_lock"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_to_flock64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1984-1992",
          "snippet": "static void posix_lock_to_flock64(struct flock64 *flock, struct file_lock *fl)\n{\n\tflock->l_pid = IS_OFDLCK(fl) ? -1 : fl->fl_pid;\n\tflock->l_start = fl->fl_start;\n\tflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\n\t\tfl->fl_end - fl->fl_start + 1;\n\tflock->l_whence = 0;\n\tflock->l_type = fl->fl_type;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void posix_lock_to_flock64(struct flock64 *flock, struct file_lock *fl)\n{\n\tflock->l_pid = IS_OFDLCK(fl) ? -1 : fl->fl_pid;\n\tflock->l_start = fl->fl_start;\n\tflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\n\t\tfl->fl_end - fl->fl_start + 1;\n\tflock->l_whence = 0;\n\tflock->l_type = fl->fl_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_test_lock",
          "args": [
            "filp",
            "&file_lock"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_test_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1953-1959",
          "snippet": "int vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_GETLK, fl);\n\tposix_test_lock(filp, fl);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_GETLK, fl);\n\tposix_test_lock(filp, fl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock64_to_posix_lock",
          "args": [
            "filp",
            "&file_lock",
            "&flock"
          ],
          "line": 2235
        },
        "resolved": true,
        "details": {
          "function_name": "flock64_to_posix_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "411-456",
          "snippet": "static int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t\t struct flock64 *l)\n{\n\tswitch (l->l_whence) {\n\tcase SEEK_SET:\n\t\tfl->fl_start = 0;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tfl->fl_start = filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tfl->fl_start = i_size_read(file_inode(filp));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (l->l_start > OFFSET_MAX - fl->fl_start)\n\t\treturn -EOVERFLOW;\n\tfl->fl_start += l->l_start;\n\tif (fl->fl_start < 0)\n\t\treturn -EINVAL;\n\n\t/* POSIX-1996 leaves the case l->l_len < 0 undefined;\n\t   POSIX-2001 defines it. */\n\tif (l->l_len > 0) {\n\t\tif (l->l_len - 1 > OFFSET_MAX - fl->fl_start)\n\t\t\treturn -EOVERFLOW;\n\t\tfl->fl_end = fl->fl_start + l->l_len - 1;\n\n\t} else if (l->l_len < 0) {\n\t\tif (fl->fl_start + l->l_len < 0)\n\t\t\treturn -EINVAL;\n\t\tfl->fl_end = fl->fl_start - 1;\n\t\tfl->fl_start += l->l_len;\n\t} else\n\t\tfl->fl_end = OFFSET_MAX;\n\n\tfl->fl_owner = current->files;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\n\treturn assign_type(fl, l->l_type);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t\t struct flock64 *l)\n{\n\tswitch (l->l_whence) {\n\tcase SEEK_SET:\n\t\tfl->fl_start = 0;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tfl->fl_start = filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tfl->fl_start = i_size_read(file_inode(filp));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (l->l_start > OFFSET_MAX - fl->fl_start)\n\t\treturn -EOVERFLOW;\n\tfl->fl_start += l->l_start;\n\tif (fl->fl_start < 0)\n\t\treturn -EINVAL;\n\n\t/* POSIX-1996 leaves the case l->l_len < 0 undefined;\n\t   POSIX-2001 defines it. */\n\tif (l->l_len > 0) {\n\t\tif (l->l_len - 1 > OFFSET_MAX - fl->fl_start)\n\t\t\treturn -EOVERFLOW;\n\t\tfl->fl_end = fl->fl_start + l->l_len - 1;\n\n\t} else if (l->l_len < 0) {\n\t\tif (fl->fl_start + l->l_len < 0)\n\t\t\treturn -EINVAL;\n\t\tfl->fl_end = fl->fl_start - 1;\n\t\tfl->fl_start += l->l_len;\n\t} else\n\t\tfl->fl_end = OFFSET_MAX;\n\n\tfl->fl_owner = current->files;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\n\treturn assign_type(fl, l->l_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&flock",
            "l",
            "sizeof(flock)"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint fcntl_getlk64(struct file *filp, unsigned int cmd, struct flock64 __user *l)\n{\n\tstruct file_lock file_lock;\n\tstruct flock64 flock;\n\tint error;\n\n\terror = -EFAULT;\n\tif (copy_from_user(&flock, l, sizeof(flock)))\n\t\tgoto out;\n\terror = -EINVAL;\n\tif ((flock.l_type != F_RDLCK) && (flock.l_type != F_WRLCK))\n\t\tgoto out;\n\n\terror = flock64_to_posix_lock(filp, &file_lock, &flock);\n\tif (error)\n\t\tgoto out;\n\n\tif (cmd == F_OFD_GETLK) {\n\t\terror = -EINVAL;\n\t\tif (flock.l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_GETLK64;\n\t\tfile_lock.fl_flags |= FL_OFDLCK;\n\t\tfile_lock.fl_owner = filp;\n\t}\n\n\terror = vfs_test_lock(filp, &file_lock);\n\tif (error)\n\t\tgoto out;\n\n\tflock.l_type = file_lock.fl_type;\n\tif (file_lock.fl_type != F_UNLCK)\n\t\tposix_lock_to_flock64(&flock, &file_lock);\n\n\terror = -EFAULT;\n\tif (!copy_to_user(l, &flock, sizeof(flock)))\n\t\terror = 0;\n\n\tlocks_release_private(&file_lock);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "fcntl_setlk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2129-2216",
    "snippet": "int fcntl_setlk(unsigned int fd, struct file *filp, unsigned int cmd,\n\t\tstruct flock __user *l)\n{\n\tstruct file_lock *file_lock = locks_alloc_lock();\n\tstruct flock flock;\n\tstruct inode *inode;\n\tstruct file *f;\n\tint error;\n\n\tif (file_lock == NULL)\n\t\treturn -ENOLCK;\n\n\t/*\n\t * This might block, so we do it before checking the inode.\n\t */\n\terror = -EFAULT;\n\tif (copy_from_user(&flock, l, sizeof(flock)))\n\t\tgoto out;\n\n\tinode = file_inode(filp);\n\n\t/* Don't allow mandatory locks on files that may be memory mapped\n\t * and shared.\n\t */\n\tif (mandatory_lock(inode) && mapping_writably_mapped(filp->f_mapping)) {\n\t\terror = -EAGAIN;\n\t\tgoto out;\n\t}\n\nagain:\n\terror = flock_to_posix_lock(filp, file_lock, &flock);\n\tif (error)\n\t\tgoto out;\n\n\terror = check_fmode_for_setlk(file_lock);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If the cmd is requesting file-private locks, then set the\n\t * FL_OFDLCK flag and override the owner.\n\t */\n\tswitch (cmd) {\n\tcase F_OFD_SETLK:\n\t\terror = -EINVAL;\n\t\tif (flock.l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLK;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\tbreak;\n\tcase F_OFD_SETLKW:\n\t\terror = -EINVAL;\n\t\tif (flock.l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLKW;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\t/* Fallthrough */\n\tcase F_SETLKW:\n\t\tfile_lock->fl_flags |= FL_SLEEP;\n\t}\n\n\terror = do_lock_file_wait(filp, cmd, file_lock);\n\n\t/*\n\t * Attempt to detect a close/fcntl race and recover by\n\t * releasing the lock that was just acquired.\n\t */\n\t/*\n\t * we need that spin_lock here - it prevents reordering between\n\t * update of i_flctx->flc_posix and check for it done in close().\n\t * rcu_read_lock() wouldn't do.\n\t */\n\tspin_lock(&current->files->file_lock);\n\tf = fcheck(fd);\n\tspin_unlock(&current->files->file_lock);\n\tif (!error && f != filp && flock.l_type != F_UNLCK) {\n\t\tflock.l_type = F_UNLCK;\n\t\tgoto again;\n\t}\n\nout:\n\tlocks_free_lock(file_lock);\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "file_lock"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "287-296",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&current->files->file_lock"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcheck",
          "args": [
            "fd"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&current->files->file_lock"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_lock_file_wait",
          "args": [
            "filp",
            "cmd",
            "file_lock"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "do_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2086-2108",
          "snippet": "static int do_lock_file_wait(struct file *filp, unsigned int cmd,\n\t\t\t     struct file_lock *fl)\n{\n\tint error;\n\n\terror = security_file_lock(filp, fl->fl_type);\n\tif (error)\n\t\treturn error;\n\n\tfor (;;) {\n\t\terror = vfs_lock_file(filp, cmd, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int do_lock_file_wait(struct file *filp, unsigned int cmd,\n\t\t\t     struct file_lock *fl)\n{\n\tint error;\n\n\terror = security_file_lock(filp, fl->fl_type);\n\tif (error)\n\t\treturn error;\n\n\tfor (;;) {\n\t\terror = vfs_lock_file(filp, cmd, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_fmode_for_setlk",
          "args": [
            "file_lock"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "check_fmode_for_setlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2111-2124",
          "snippet": "static int\ncheck_fmode_for_setlk(struct file_lock *fl)\n{\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int\ncheck_fmode_for_setlk(struct file_lock *fl)\n{\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock_to_posix_lock",
          "args": [
            "filp",
            "file_lock",
            "&flock"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "flock_to_posix_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "461-472",
          "snippet": "static int flock_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t       struct flock *l)\n{\n\tstruct flock64 ll = {\n\t\t.l_type = l->l_type,\n\t\t.l_whence = l->l_whence,\n\t\t.l_start = l->l_start,\n\t\t.l_len = l->l_len,\n\t};\n\n\treturn flock64_to_posix_lock(filp, fl, &ll);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t       struct flock *l)\n{\n\tstruct flock64 ll = {\n\t\t.l_type = l->l_type,\n\t\t.l_whence = l->l_whence,\n\t\t.l_start = l->l_start,\n\t\t.l_len = l->l_len,\n\t};\n\n\treturn flock64_to_posix_lock(filp, fl, &ll);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_writably_mapped",
          "args": [
            "filp->f_mapping"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "locks_mandatory_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1199-1224",
          "snippet": "int locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = file_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = file_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&flock",
            "l",
            "sizeof(flock)"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "259-267",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint fcntl_setlk(unsigned int fd, struct file *filp, unsigned int cmd,\n\t\tstruct flock __user *l)\n{\n\tstruct file_lock *file_lock = locks_alloc_lock();\n\tstruct flock flock;\n\tstruct inode *inode;\n\tstruct file *f;\n\tint error;\n\n\tif (file_lock == NULL)\n\t\treturn -ENOLCK;\n\n\t/*\n\t * This might block, so we do it before checking the inode.\n\t */\n\terror = -EFAULT;\n\tif (copy_from_user(&flock, l, sizeof(flock)))\n\t\tgoto out;\n\n\tinode = file_inode(filp);\n\n\t/* Don't allow mandatory locks on files that may be memory mapped\n\t * and shared.\n\t */\n\tif (mandatory_lock(inode) && mapping_writably_mapped(filp->f_mapping)) {\n\t\terror = -EAGAIN;\n\t\tgoto out;\n\t}\n\nagain:\n\terror = flock_to_posix_lock(filp, file_lock, &flock);\n\tif (error)\n\t\tgoto out;\n\n\terror = check_fmode_for_setlk(file_lock);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If the cmd is requesting file-private locks, then set the\n\t * FL_OFDLCK flag and override the owner.\n\t */\n\tswitch (cmd) {\n\tcase F_OFD_SETLK:\n\t\terror = -EINVAL;\n\t\tif (flock.l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLK;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\tbreak;\n\tcase F_OFD_SETLKW:\n\t\terror = -EINVAL;\n\t\tif (flock.l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLKW;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\t/* Fallthrough */\n\tcase F_SETLKW:\n\t\tfile_lock->fl_flags |= FL_SLEEP;\n\t}\n\n\terror = do_lock_file_wait(filp, cmd, file_lock);\n\n\t/*\n\t * Attempt to detect a close/fcntl race and recover by\n\t * releasing the lock that was just acquired.\n\t */\n\t/*\n\t * we need that spin_lock here - it prevents reordering between\n\t * update of i_flctx->flc_posix and check for it done in close().\n\t * rcu_read_lock() wouldn't do.\n\t */\n\tspin_lock(&current->files->file_lock);\n\tf = fcheck(fd);\n\tspin_unlock(&current->files->file_lock);\n\tif (!error && f != filp && flock.l_type != F_UNLCK) {\n\t\tflock.l_type = F_UNLCK;\n\t\tgoto again;\n\t}\n\nout:\n\tlocks_free_lock(file_lock);\n\treturn error;\n}"
  },
  {
    "function_name": "check_fmode_for_setlk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2111-2124",
    "snippet": "static int\ncheck_fmode_for_setlk(struct file_lock *fl)\n{\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int\ncheck_fmode_for_setlk(struct file_lock *fl)\n{\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "do_lock_file_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2086-2108",
    "snippet": "static int do_lock_file_wait(struct file *filp, unsigned int cmd,\n\t\t\t     struct file_lock *fl)\n{\n\tint error;\n\n\terror = security_file_lock(filp, fl->fl_type);\n\tif (error)\n\t\treturn error;\n\n\tfor (;;) {\n\t\terror = vfs_lock_file(filp, cmd, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_delete_block",
          "args": [
            "fl"
          ],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "615-620",
          "snippet": "static void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "fl->fl_wait",
            "!fl->fl_next"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_lock_file",
          "args": [
            "filp",
            "cmd",
            "fl",
            "NULL"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2077-2083",
          "snippet": "int vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_file_lock",
          "args": [
            "filp",
            "fl->fl_type"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int do_lock_file_wait(struct file *filp, unsigned int cmd,\n\t\t\t     struct file_lock *fl)\n{\n\tint error;\n\n\terror = security_file_lock(filp, fl->fl_type);\n\tif (error)\n\t\treturn error;\n\n\tfor (;;) {\n\t\terror = vfs_lock_file(filp, cmd, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "vfs_lock_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "2077-2083",
    "snippet": "int vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_lock_file",
          "args": [
            "filp",
            "fl",
            "conf"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1157-1161",
          "snippet": "int posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn __posix_lock_file(file_inode(filp), fl, conflock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn __posix_lock_file(file_inode(filp), fl, conflock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp->f_op->lock",
          "args": [
            "filp",
            "cmd",
            "fl"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}"
  },
  {
    "function_name": "fcntl_getlk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1998-2042",
    "snippet": "int fcntl_getlk(struct file *filp, unsigned int cmd, struct flock __user *l)\n{\n\tstruct file_lock file_lock;\n\tstruct flock flock;\n\tint error;\n\n\terror = -EFAULT;\n\tif (copy_from_user(&flock, l, sizeof(flock)))\n\t\tgoto out;\n\terror = -EINVAL;\n\tif ((flock.l_type != F_RDLCK) && (flock.l_type != F_WRLCK))\n\t\tgoto out;\n\n\terror = flock_to_posix_lock(filp, &file_lock, &flock);\n\tif (error)\n\t\tgoto out;\n\n\tif (cmd == F_OFD_GETLK) {\n\t\terror = -EINVAL;\n\t\tif (flock.l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_GETLK;\n\t\tfile_lock.fl_flags |= FL_OFDLCK;\n\t\tfile_lock.fl_owner = filp;\n\t}\n\n\terror = vfs_test_lock(filp, &file_lock);\n\tif (error)\n\t\tgoto out;\n \n\tflock.l_type = file_lock.fl_type;\n\tif (file_lock.fl_type != F_UNLCK) {\n\t\terror = posix_lock_to_flock(&flock, &file_lock);\n\t\tif (error)\n\t\t\tgoto rel_priv;\n\t}\n\terror = -EFAULT;\n\tif (!copy_to_user(l, &flock, sizeof(flock)))\n\t\terror = 0;\nrel_priv:\n\tlocks_release_private(&file_lock);\nout:\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_release_private",
          "args": [
            "&file_lock"
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "locks_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "270-283",
          "snippet": "void locks_release_private(struct file_lock *fl)\n{\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_release_private)\n\t\t\tfl->fl_ops->fl_release_private(fl);\n\t\tfl->fl_ops = NULL;\n\t}\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_put_owner)\n\t\t\tfl->fl_lmops->lm_put_owner(fl);\n\t\tfl->fl_lmops = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_release_private(struct file_lock *fl)\n{\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_release_private)\n\t\t\tfl->fl_ops->fl_release_private(fl);\n\t\tfl->fl_ops = NULL;\n\t}\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_put_owner)\n\t\t\tfl->fl_lmops->lm_put_owner(fl);\n\t\tfl->fl_lmops = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "l",
            "&flock",
            "sizeof(flock)"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_lock_to_flock",
          "args": [
            "&flock",
            "&file_lock"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_to_flock64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1984-1992",
          "snippet": "static void posix_lock_to_flock64(struct flock64 *flock, struct file_lock *fl)\n{\n\tflock->l_pid = IS_OFDLCK(fl) ? -1 : fl->fl_pid;\n\tflock->l_start = fl->fl_start;\n\tflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\n\t\tfl->fl_end - fl->fl_start + 1;\n\tflock->l_whence = 0;\n\tflock->l_type = fl->fl_type;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void posix_lock_to_flock64(struct flock64 *flock, struct file_lock *fl)\n{\n\tflock->l_pid = IS_OFDLCK(fl) ? -1 : fl->fl_pid;\n\tflock->l_start = fl->fl_start;\n\tflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\n\t\tfl->fl_end - fl->fl_start + 1;\n\tflock->l_whence = 0;\n\tflock->l_type = fl->fl_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_test_lock",
          "args": [
            "filp",
            "&file_lock"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_test_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1953-1959",
          "snippet": "int vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_GETLK, fl);\n\tposix_test_lock(filp, fl);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_GETLK, fl);\n\tposix_test_lock(filp, fl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock_to_posix_lock",
          "args": [
            "filp",
            "&file_lock",
            "&flock"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "flock_to_posix_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "461-472",
          "snippet": "static int flock_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t       struct flock *l)\n{\n\tstruct flock64 ll = {\n\t\t.l_type = l->l_type,\n\t\t.l_whence = l->l_whence,\n\t\t.l_start = l->l_start,\n\t\t.l_len = l->l_len,\n\t};\n\n\treturn flock64_to_posix_lock(filp, fl, &ll);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t       struct flock *l)\n{\n\tstruct flock64 ll = {\n\t\t.l_type = l->l_type,\n\t\t.l_whence = l->l_whence,\n\t\t.l_start = l->l_start,\n\t\t.l_len = l->l_len,\n\t};\n\n\treturn flock64_to_posix_lock(filp, fl, &ll);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&flock",
            "l",
            "sizeof(flock)"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint fcntl_getlk(struct file *filp, unsigned int cmd, struct flock __user *l)\n{\n\tstruct file_lock file_lock;\n\tstruct flock flock;\n\tint error;\n\n\terror = -EFAULT;\n\tif (copy_from_user(&flock, l, sizeof(flock)))\n\t\tgoto out;\n\terror = -EINVAL;\n\tif ((flock.l_type != F_RDLCK) && (flock.l_type != F_WRLCK))\n\t\tgoto out;\n\n\terror = flock_to_posix_lock(filp, &file_lock, &flock);\n\tif (error)\n\t\tgoto out;\n\n\tif (cmd == F_OFD_GETLK) {\n\t\terror = -EINVAL;\n\t\tif (flock.l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_GETLK;\n\t\tfile_lock.fl_flags |= FL_OFDLCK;\n\t\tfile_lock.fl_owner = filp;\n\t}\n\n\terror = vfs_test_lock(filp, &file_lock);\n\tif (error)\n\t\tgoto out;\n \n\tflock.l_type = file_lock.fl_type;\n\tif (file_lock.fl_type != F_UNLCK) {\n\t\terror = posix_lock_to_flock(&flock, &file_lock);\n\t\tif (error)\n\t\t\tgoto rel_priv;\n\t}\n\terror = -EFAULT;\n\tif (!copy_to_user(l, &flock, sizeof(flock)))\n\t\terror = 0;\nrel_priv:\n\tlocks_release_private(&file_lock);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "posix_lock_to_flock64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1984-1992",
    "snippet": "static void posix_lock_to_flock64(struct flock64 *flock, struct file_lock *fl)\n{\n\tflock->l_pid = IS_OFDLCK(fl) ? -1 : fl->fl_pid;\n\tflock->l_start = fl->fl_start;\n\tflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\n\t\tfl->fl_end - fl->fl_start + 1;\n\tflock->l_whence = 0;\n\tflock->l_type = fl->fl_type;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_OFDLCK",
          "args": [
            "fl"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void posix_lock_to_flock64(struct flock64 *flock, struct file_lock *fl)\n{\n\tflock->l_pid = IS_OFDLCK(fl) ? -1 : fl->fl_pid;\n\tflock->l_start = fl->fl_start;\n\tflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\n\t\tfl->fl_end - fl->fl_start + 1;\n\tflock->l_whence = 0;\n\tflock->l_type = fl->fl_type;\n}"
  },
  {
    "function_name": "posix_lock_to_flock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1962-1981",
    "snippet": "static int posix_lock_to_flock(struct flock *flock, struct file_lock *fl)\n{\n\tflock->l_pid = IS_OFDLCK(fl) ? -1 : fl->fl_pid;\n#if BITS_PER_LONG == 32\n\t/*\n\t * Make sure we can represent the posix lock via\n\t * legacy 32bit flock.\n\t */\n\tif (fl->fl_start > OFFT_OFFSET_MAX)\n\t\treturn -EOVERFLOW;\n\tif (fl->fl_end != OFFSET_MAX && fl->fl_end > OFFT_OFFSET_MAX)\n\t\treturn -EOVERFLOW;\n#endif\n\tflock->l_start = fl->fl_start;\n\tflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\n\t\tfl->fl_end - fl->fl_start + 1;\n\tflock->l_whence = 0;\n\tflock->l_type = fl->fl_type;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_OFDLCK",
          "args": [
            "fl"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_lock_to_flock(struct flock *flock, struct file_lock *fl)\n{\n\tflock->l_pid = IS_OFDLCK(fl) ? -1 : fl->fl_pid;\n#if BITS_PER_LONG == 32\n\t/*\n\t * Make sure we can represent the posix lock via\n\t * legacy 32bit flock.\n\t */\n\tif (fl->fl_start > OFFT_OFFSET_MAX)\n\t\treturn -EOVERFLOW;\n\tif (fl->fl_end != OFFSET_MAX && fl->fl_end > OFFT_OFFSET_MAX)\n\t\treturn -EOVERFLOW;\n#endif\n\tflock->l_start = fl->fl_start;\n\tflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\n\t\tfl->fl_end - fl->fl_start + 1;\n\tflock->l_whence = 0;\n\tflock->l_type = fl->fl_type;\n\treturn 0;\n}"
  },
  {
    "function_name": "vfs_test_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1953-1959",
    "snippet": "int vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_GETLK, fl);\n\tposix_test_lock(filp, fl);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_test_lock",
          "args": [
            "filp",
            "fl"
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "posix_test_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "759-785",
          "snippet": "void\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = file_inode(filp);\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_locks_conflict(fl, cfl)) {\n\t\t\tlocks_copy_conflock(fl, cfl);\n\t\t\tif (cfl->fl_nspid)\n\t\t\t\tfl->fl_pid = pid_vnr(cfl->fl_nspid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = file_inode(filp);\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_locks_conflict(fl, cfl)) {\n\t\t\tlocks_copy_conflock(fl, cfl);\n\t\t\tif (cfl->fl_nspid)\n\t\t\t\tfl->fl_pid = pid_vnr(cfl->fl_nspid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp->f_op->lock",
          "args": [
            "filp",
            "F_GETLK",
            "fl"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_GETLK, fl);\n\tposix_test_lock(filp, fl);\n\treturn 0;\n}"
  },
  {
    "function_name": "flock_lock_file_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1858-1874",
    "snippet": "int flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_delete_block",
          "args": [
            "fl"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "615-620",
          "snippet": "static void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "fl->fl_wait",
            "!fl->fl_next"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flock_lock_file",
          "args": [
            "filp",
            "fl"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "flock_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1858-1874",
          "snippet": "int flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "fcntl_setlease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1844-1849",
    "snippet": "int fcntl_setlease(unsigned int fd, struct file *filp, long arg)\n{\n\tif (arg == F_UNLCK)\n\t\treturn vfs_setlease(filp, F_UNLCK, NULL, (void **)&filp);\n\treturn do_fcntl_add_lease(fd, filp, arg);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_fcntl_add_lease",
          "args": [
            "fd",
            "filp",
            "arg"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "do_fcntl_add_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1809-1832",
          "snippet": "static int do_fcntl_add_lease(unsigned int fd, struct file *filp, long arg)\n{\n\tstruct file_lock *fl;\n\tstruct fasync_struct *new;\n\tint error;\n\n\tfl = lease_alloc(filp, arg);\n\tif (IS_ERR(fl))\n\t\treturn PTR_ERR(fl);\n\n\tnew = fasync_alloc();\n\tif (!new) {\n\t\tlocks_free_lock(fl);\n\t\treturn -ENOMEM;\n\t}\n\tnew->fa_fd = fd;\n\n\terror = vfs_setlease(filp, arg, &fl, (void **)&new);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (new)\n\t\tfasync_free(new);\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int do_fcntl_add_lease(unsigned int fd, struct file *filp, long arg)\n{\n\tstruct file_lock *fl;\n\tstruct fasync_struct *new;\n\tint error;\n\n\tfl = lease_alloc(filp, arg);\n\tif (IS_ERR(fl))\n\t\treturn PTR_ERR(fl);\n\n\tnew = fasync_alloc();\n\tif (!new) {\n\t\tlocks_free_lock(fl);\n\t\treturn -ENOMEM;\n\t}\n\tnew->fa_fd = fd;\n\n\terror = vfs_setlease(filp, arg, &fl, (void **)&new);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (new)\n\t\tfasync_free(new);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_setlease",
          "args": [
            "filp",
            "F_UNLCK",
            "NULL",
            "(void **)&filp"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setlease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1799-1806",
          "snippet": "int\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint fcntl_setlease(unsigned int fd, struct file *filp, long arg)\n{\n\tif (arg == F_UNLCK)\n\t\treturn vfs_setlease(filp, F_UNLCK, NULL, (void **)&filp);\n\treturn do_fcntl_add_lease(fd, filp, arg);\n}"
  },
  {
    "function_name": "do_fcntl_add_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1809-1832",
    "snippet": "static int do_fcntl_add_lease(unsigned int fd, struct file *filp, long arg)\n{\n\tstruct file_lock *fl;\n\tstruct fasync_struct *new;\n\tint error;\n\n\tfl = lease_alloc(filp, arg);\n\tif (IS_ERR(fl))\n\t\treturn PTR_ERR(fl);\n\n\tnew = fasync_alloc();\n\tif (!new) {\n\t\tlocks_free_lock(fl);\n\t\treturn -ENOMEM;\n\t}\n\tnew->fa_fd = fd;\n\n\terror = vfs_setlease(filp, arg, &fl, (void **)&new);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (new)\n\t\tfasync_free(new);\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fasync_free",
          "args": [
            "new"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "fasync_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "611-614",
          "snippet": "void fasync_free(struct fasync_struct *new)\n{\n\tkmem_cache_free(fasync_cache, new);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fasync_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic struct kmem_cache *fasync_cache;\n\nvoid fasync_free(struct fasync_struct *new)\n{\n\tkmem_cache_free(fasync_cache, new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "fl"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "287-296",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_setlease",
          "args": [
            "filp",
            "arg",
            "&fl",
            "(void **)&new"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setlease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1799-1806",
          "snippet": "int\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fasync_alloc",
          "args": [],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "fasync_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "601-604",
          "snippet": "struct fasync_struct *fasync_alloc(void)\n{\n\treturn kmem_cache_alloc(fasync_cache, GFP_KERNEL);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fasync_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic struct kmem_cache *fasync_cache;\n\nstruct fasync_struct *fasync_alloc(void)\n{\n\treturn kmem_cache_alloc(fasync_cache, GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fl"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fl"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lease_alloc",
          "args": [
            "filp",
            "arg"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "lease_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "526-540",
          "snippet": "static struct file_lock *lease_alloc(struct file *filp, long type)\n{\n\tstruct file_lock *fl = locks_alloc_lock();\n\tint error = -ENOMEM;\n\n\tif (fl == NULL)\n\t\treturn ERR_PTR(error);\n\n\terror = lease_init(filp, type, fl);\n\tif (error) {\n\t\tlocks_free_lock(fl);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct file_lock *lease_alloc(struct file *filp, long type)\n{\n\tstruct file_lock *fl = locks_alloc_lock();\n\tint error = -ENOMEM;\n\n\tif (fl == NULL)\n\t\treturn ERR_PTR(error);\n\n\terror = lease_init(filp, type, fl);\n\tif (error) {\n\t\tlocks_free_lock(fl);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn fl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int do_fcntl_add_lease(unsigned int fd, struct file *filp, long arg)\n{\n\tstruct file_lock *fl;\n\tstruct fasync_struct *new;\n\tint error;\n\n\tfl = lease_alloc(filp, arg);\n\tif (IS_ERR(fl))\n\t\treturn PTR_ERR(fl);\n\n\tnew = fasync_alloc();\n\tif (!new) {\n\t\tlocks_free_lock(fl);\n\t\treturn -ENOMEM;\n\t}\n\tnew->fa_fd = fd;\n\n\terror = vfs_setlease(filp, arg, &fl, (void **)&new);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (new)\n\t\tfasync_free(new);\n\treturn error;\n}"
  },
  {
    "function_name": "vfs_setlease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1799-1806",
    "snippet": "int\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_setlease",
          "args": [
            "filp",
            "arg",
            "lease",
            "priv"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "generic_setlease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1750-1779",
          "snippet": "int generic_setlease(struct file *filp, long arg, struct file_lock **flp,\n\t\t\tvoid **priv)\n{\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif ((!uid_eq(current_fsuid(), inode->i_uid)) && !capable(CAP_LEASE))\n\t\treturn -EACCES;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\terror = security_file_lock(filp, arg);\n\tif (error)\n\t\treturn error;\n\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\treturn generic_delete_lease(filp, *priv);\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (!(*flp)->fl_lmops->lm_break) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn -ENOLCK;\n\t\t}\n\n\t\treturn generic_add_lease(filp, arg, flp, priv);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint generic_setlease(struct file *filp, long arg, struct file_lock **flp,\n\t\t\tvoid **priv)\n{\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif ((!uid_eq(current_fsuid(), inode->i_uid)) && !capable(CAP_LEASE))\n\t\treturn -EACCES;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\terror = security_file_lock(filp, arg);\n\tif (error)\n\t\treturn error;\n\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\treturn generic_delete_lease(filp, *priv);\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (!(*flp)->fl_lmops->lm_break) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn -ENOLCK;\n\t\t}\n\n\t\treturn generic_add_lease(filp, arg, flp, priv);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp->f_op->setlease",
          "args": [
            "filp",
            "arg",
            "lease",
            "priv"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}"
  },
  {
    "function_name": "generic_setlease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1750-1779",
    "snippet": "int generic_setlease(struct file *filp, long arg, struct file_lock **flp,\n\t\t\tvoid **priv)\n{\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif ((!uid_eq(current_fsuid(), inode->i_uid)) && !capable(CAP_LEASE))\n\t\treturn -EACCES;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\terror = security_file_lock(filp, arg);\n\tif (error)\n\t\treturn error;\n\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\treturn generic_delete_lease(filp, *priv);\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (!(*flp)->fl_lmops->lm_break) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn -ENOLCK;\n\t\t}\n\n\t\treturn generic_add_lease(filp, arg, flp, priv);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_add_lease",
          "args": [
            "filp",
            "arg",
            "flp",
            "priv"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "generic_add_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1595-1707",
          "snippet": "static int\ngeneric_add_lease(struct file *filp, long arg, struct file_lock **flp, void **priv)\n{\n\tstruct file_lock *fl, *my_fl = NULL, *lease;\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct file_lock_context *ctx;\n\tbool is_deleg = (*flp)->fl_flags & FL_DELEG;\n\tint error;\n\tLIST_HEAD(dispose);\n\n\tlease = *flp;\n\ttrace_generic_add_lease(inode, lease);\n\n\tctx = locks_get_lock_context(inode);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * In the delegation case we need mutual exclusion with\n\t * a number of operations that take the i_mutex.  We trylock\n\t * because delegations are an optional optimization, and if\n\t * there's some chance of a conflict--we'd rather not\n\t * bother, maybe that's a sign this just isn't a good file to\n\t * hand out a delegation on.\n\t */\n\tif (is_deleg && !mutex_trylock(&inode->i_mutex))\n\t\treturn -EAGAIN;\n\n\tif (is_deleg && arg == F_WRLCK) {\n\t\t/* Write delegations are not currently supported: */\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\ttime_out_leases(inode, &dispose);\n\terror = check_conflicting_open(dentry, arg, lease->fl_flags);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * At this point, we know that if there is an exclusive\n\t * lease on this file, then we hold it on this filp\n\t * (otherwise our open of this file would have blocked).\n\t * And if we are trying to acquire an exclusive lease,\n\t * then the file is not open by anyone (including us)\n\t * except for this filp.\n\t */\n\terror = -EAGAIN;\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_file == filp &&\n\t\t    fl->fl_owner == lease->fl_owner) {\n\t\t\tmy_fl = fl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * No exclusive leases if someone else has a lease on\n\t\t * this file:\n\t\t */\n\t\tif (arg == F_WRLCK)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Modifying our existing lease is OK, but no getting a\n\t\t * new lease if someone else is opening for write:\n\t\t */\n\t\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\t\tgoto out;\n\t}\n\n\tif (my_fl != NULL) {\n\t\tlease = my_fl;\n\t\terror = lease->fl_lmops->lm_change(lease, arg, &dispose);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tgoto out_setup;\n\t}\n\n\terror = -EINVAL;\n\tif (!leases_enable)\n\t\tgoto out;\n\n\tlocks_insert_lock_ctx(lease, &ctx->flc_lease);\n\t/*\n\t * The check in break_lease() is lockless. It's possible for another\n\t * open to race in after we did the earlier check for a conflicting\n\t * open but before the lease was inserted. Check again for a\n\t * conflicting open and cancel the lease if there is one.\n\t *\n\t * We also add a barrier here to ensure that the insertion of the lock\n\t * precedes these checks.\n\t */\n\tsmp_mb();\n\terror = check_conflicting_open(dentry, arg, lease->fl_flags);\n\tif (error) {\n\t\tlocks_unlink_lock_ctx(lease);\n\t\tgoto out;\n\t}\n\nout_setup:\n\tif (lease->fl_lmops->lm_setup)\n\t\tlease->fl_lmops->lm_setup(lease, priv);\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tlocks_dispose_list(&dispose);\n\tif (is_deleg)\n\t\tmutex_unlock(&inode->i_mutex);\n\tif (!error && !my_fl)\n\t\t*flp = NULL;\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int leases_enable = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint leases_enable = 1;\n\nstatic int\ngeneric_add_lease(struct file *filp, long arg, struct file_lock **flp, void **priv)\n{\n\tstruct file_lock *fl, *my_fl = NULL, *lease;\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct file_lock_context *ctx;\n\tbool is_deleg = (*flp)->fl_flags & FL_DELEG;\n\tint error;\n\tLIST_HEAD(dispose);\n\n\tlease = *flp;\n\ttrace_generic_add_lease(inode, lease);\n\n\tctx = locks_get_lock_context(inode);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * In the delegation case we need mutual exclusion with\n\t * a number of operations that take the i_mutex.  We trylock\n\t * because delegations are an optional optimization, and if\n\t * there's some chance of a conflict--we'd rather not\n\t * bother, maybe that's a sign this just isn't a good file to\n\t * hand out a delegation on.\n\t */\n\tif (is_deleg && !mutex_trylock(&inode->i_mutex))\n\t\treturn -EAGAIN;\n\n\tif (is_deleg && arg == F_WRLCK) {\n\t\t/* Write delegations are not currently supported: */\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\ttime_out_leases(inode, &dispose);\n\terror = check_conflicting_open(dentry, arg, lease->fl_flags);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * At this point, we know that if there is an exclusive\n\t * lease on this file, then we hold it on this filp\n\t * (otherwise our open of this file would have blocked).\n\t * And if we are trying to acquire an exclusive lease,\n\t * then the file is not open by anyone (including us)\n\t * except for this filp.\n\t */\n\terror = -EAGAIN;\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_file == filp &&\n\t\t    fl->fl_owner == lease->fl_owner) {\n\t\t\tmy_fl = fl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * No exclusive leases if someone else has a lease on\n\t\t * this file:\n\t\t */\n\t\tif (arg == F_WRLCK)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Modifying our existing lease is OK, but no getting a\n\t\t * new lease if someone else is opening for write:\n\t\t */\n\t\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\t\tgoto out;\n\t}\n\n\tif (my_fl != NULL) {\n\t\tlease = my_fl;\n\t\terror = lease->fl_lmops->lm_change(lease, arg, &dispose);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tgoto out_setup;\n\t}\n\n\terror = -EINVAL;\n\tif (!leases_enable)\n\t\tgoto out;\n\n\tlocks_insert_lock_ctx(lease, &ctx->flc_lease);\n\t/*\n\t * The check in break_lease() is lockless. It's possible for another\n\t * open to race in after we did the earlier check for a conflicting\n\t * open but before the lease was inserted. Check again for a\n\t * conflicting open and cancel the lease if there is one.\n\t *\n\t * We also add a barrier here to ensure that the insertion of the lock\n\t * precedes these checks.\n\t */\n\tsmp_mb();\n\terror = check_conflicting_open(dentry, arg, lease->fl_flags);\n\tif (error) {\n\t\tlocks_unlink_lock_ctx(lease);\n\t\tgoto out;\n\t}\n\nout_setup:\n\tif (lease->fl_lmops->lm_setup)\n\t\tlease->fl_lmops->lm_setup(lease, priv);\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tlocks_dispose_list(&dispose);\n\tif (is_deleg)\n\t\tmutex_unlock(&inode->i_mutex);\n\tif (!error && !my_fl)\n\t\t*flp = NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_delete_lease",
          "args": [
            "filp",
            "*priv"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "generic_delete_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1709-1737",
          "snippet": "static int generic_delete_lease(struct file *filp, void *owner)\n{\n\tint error = -EAGAIN;\n\tstruct file_lock *fl, *victim = NULL;\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tLIST_HEAD(dispose);\n\n\tif (!ctx) {\n\t\ttrace_generic_delete_lease(inode, NULL);\n\t\treturn error;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_file == filp &&\n\t\t    fl->fl_owner == owner) {\n\t\t\tvictim = fl;\n\t\t\tbreak;\n\t\t}\n\t}\n\ttrace_generic_delete_lease(inode, victim);\n\tif (victim)\n\t\terror = fl->fl_lmops->lm_change(victim, F_UNLCK, &dispose);\n\tspin_unlock(&ctx->flc_lock);\n\tlocks_dispose_list(&dispose);\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int generic_delete_lease(struct file *filp, void *owner)\n{\n\tint error = -EAGAIN;\n\tstruct file_lock *fl, *victim = NULL;\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tLIST_HEAD(dispose);\n\n\tif (!ctx) {\n\t\ttrace_generic_delete_lease(inode, NULL);\n\t\treturn error;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_file == filp &&\n\t\t    fl->fl_owner == owner) {\n\t\t\tvictim = fl;\n\t\t\tbreak;\n\t\t}\n\t}\n\ttrace_generic_delete_lease(inode, victim);\n\tif (victim)\n\t\terror = fl->fl_lmops->lm_change(victim, F_UNLCK, &dispose);\n\tspin_unlock(&ctx->flc_lock);\n\tlocks_dispose_list(&dispose);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_file_lock",
          "args": [
            "filp",
            "arg"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_LEASE"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "current_fsuid()",
            "inode->i_uid"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint generic_setlease(struct file *filp, long arg, struct file_lock **flp,\n\t\t\tvoid **priv)\n{\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif ((!uid_eq(current_fsuid(), inode->i_uid)) && !capable(CAP_LEASE))\n\t\treturn -EACCES;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\terror = security_file_lock(filp, arg);\n\tif (error)\n\t\treturn error;\n\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\treturn generic_delete_lease(filp, *priv);\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (!(*flp)->fl_lmops->lm_break) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn -ENOLCK;\n\t\t}\n\n\t\treturn generic_add_lease(filp, arg, flp, priv);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
  },
  {
    "function_name": "generic_delete_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1709-1737",
    "snippet": "static int generic_delete_lease(struct file *filp, void *owner)\n{\n\tint error = -EAGAIN;\n\tstruct file_lock *fl, *victim = NULL;\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tLIST_HEAD(dispose);\n\n\tif (!ctx) {\n\t\ttrace_generic_delete_lease(inode, NULL);\n\t\treturn error;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_file == filp &&\n\t\t    fl->fl_owner == owner) {\n\t\t\tvictim = fl;\n\t\t\tbreak;\n\t\t}\n\t}\n\ttrace_generic_delete_lease(inode, victim);\n\tif (victim)\n\t\terror = fl->fl_lmops->lm_change(victim, F_UNLCK, &dispose);\n\tspin_unlock(&ctx->flc_lock);\n\tlocks_dispose_list(&dispose);\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_dispose_list",
          "args": [
            "&dispose"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "locks_dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "299-309",
          "snippet": "static void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fl->fl_lmops->lm_change",
          "args": [
            "victim",
            "F_UNLCK",
            "&dispose"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_generic_delete_lease",
          "args": [
            "inode",
            "victim"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_lease",
            "fl_list"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_generic_delete_lease",
          "args": [
            "inode",
            "NULL"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int generic_delete_lease(struct file *filp, void *owner)\n{\n\tint error = -EAGAIN;\n\tstruct file_lock *fl, *victim = NULL;\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tLIST_HEAD(dispose);\n\n\tif (!ctx) {\n\t\ttrace_generic_delete_lease(inode, NULL);\n\t\treturn error;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_file == filp &&\n\t\t    fl->fl_owner == owner) {\n\t\t\tvictim = fl;\n\t\t\tbreak;\n\t\t}\n\t}\n\ttrace_generic_delete_lease(inode, victim);\n\tif (victim)\n\t\terror = fl->fl_lmops->lm_change(victim, F_UNLCK, &dispose);\n\tspin_unlock(&ctx->flc_lock);\n\tlocks_dispose_list(&dispose);\n\treturn error;\n}"
  },
  {
    "function_name": "generic_add_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1595-1707",
    "snippet": "static int\ngeneric_add_lease(struct file *filp, long arg, struct file_lock **flp, void **priv)\n{\n\tstruct file_lock *fl, *my_fl = NULL, *lease;\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct file_lock_context *ctx;\n\tbool is_deleg = (*flp)->fl_flags & FL_DELEG;\n\tint error;\n\tLIST_HEAD(dispose);\n\n\tlease = *flp;\n\ttrace_generic_add_lease(inode, lease);\n\n\tctx = locks_get_lock_context(inode);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * In the delegation case we need mutual exclusion with\n\t * a number of operations that take the i_mutex.  We trylock\n\t * because delegations are an optional optimization, and if\n\t * there's some chance of a conflict--we'd rather not\n\t * bother, maybe that's a sign this just isn't a good file to\n\t * hand out a delegation on.\n\t */\n\tif (is_deleg && !mutex_trylock(&inode->i_mutex))\n\t\treturn -EAGAIN;\n\n\tif (is_deleg && arg == F_WRLCK) {\n\t\t/* Write delegations are not currently supported: */\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\ttime_out_leases(inode, &dispose);\n\terror = check_conflicting_open(dentry, arg, lease->fl_flags);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * At this point, we know that if there is an exclusive\n\t * lease on this file, then we hold it on this filp\n\t * (otherwise our open of this file would have blocked).\n\t * And if we are trying to acquire an exclusive lease,\n\t * then the file is not open by anyone (including us)\n\t * except for this filp.\n\t */\n\terror = -EAGAIN;\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_file == filp &&\n\t\t    fl->fl_owner == lease->fl_owner) {\n\t\t\tmy_fl = fl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * No exclusive leases if someone else has a lease on\n\t\t * this file:\n\t\t */\n\t\tif (arg == F_WRLCK)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Modifying our existing lease is OK, but no getting a\n\t\t * new lease if someone else is opening for write:\n\t\t */\n\t\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\t\tgoto out;\n\t}\n\n\tif (my_fl != NULL) {\n\t\tlease = my_fl;\n\t\terror = lease->fl_lmops->lm_change(lease, arg, &dispose);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tgoto out_setup;\n\t}\n\n\terror = -EINVAL;\n\tif (!leases_enable)\n\t\tgoto out;\n\n\tlocks_insert_lock_ctx(lease, &ctx->flc_lease);\n\t/*\n\t * The check in break_lease() is lockless. It's possible for another\n\t * open to race in after we did the earlier check for a conflicting\n\t * open but before the lease was inserted. Check again for a\n\t * conflicting open and cancel the lease if there is one.\n\t *\n\t * We also add a barrier here to ensure that the insertion of the lock\n\t * precedes these checks.\n\t */\n\tsmp_mb();\n\terror = check_conflicting_open(dentry, arg, lease->fl_flags);\n\tif (error) {\n\t\tlocks_unlink_lock_ctx(lease);\n\t\tgoto out;\n\t}\n\nout_setup:\n\tif (lease->fl_lmops->lm_setup)\n\t\tlease->fl_lmops->lm_setup(lease, priv);\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tlocks_dispose_list(&dispose);\n\tif (is_deleg)\n\t\tmutex_unlock(&inode->i_mutex);\n\tif (!error && !my_fl)\n\t\t*flp = NULL;\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int leases_enable = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_dispose_list",
          "args": [
            "&dispose"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "locks_dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "299-309",
          "snippet": "static void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lease->fl_lmops->lm_setup",
          "args": [
            "lease",
            "priv"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_unlink_lock_ctx",
          "args": [
            "lease"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "locks_unlink_lock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "691-701",
          "snippet": "static void\nlocks_unlink_lock_ctx(struct file_lock *fl)\n{\n\tlocks_delete_global_locks(fl);\n\tlist_del_init(&fl->fl_list);\n\tif (fl->fl_nspid) {\n\t\tput_pid(fl->fl_nspid);\n\t\tfl->fl_nspid = NULL;\n\t}\n\tlocks_wake_up_blocks(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_unlink_lock_ctx(struct file_lock *fl)\n{\n\tlocks_delete_global_locks(fl);\n\tlist_del_init(&fl->fl_list);\n\tif (fl->fl_nspid) {\n\t\tput_pid(fl->fl_nspid);\n\t\tfl->fl_nspid = NULL;\n\t}\n\tlocks_wake_up_blocks(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_conflicting_open",
          "args": [
            "dentry",
            "arg",
            "lease->fl_flags"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "check_conflicting_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1576-1593",
          "snippet": "static int\ncheck_conflicting_open(const struct dentry *dentry, const long arg, int flags)\n{\n\tint ret = 0;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (flags & FL_LAYOUT)\n\t\treturn 0;\n\n\tif ((arg == F_RDLCK) && (atomic_read(&inode->i_writecount) > 0))\n\t\treturn -EAGAIN;\n\n\tif ((arg == F_WRLCK) && ((d_count(dentry) > 1) ||\n\t    (atomic_read(&inode->i_count) > 1)))\n\t\tret = -EAGAIN;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int\ncheck_conflicting_open(const struct dentry *dentry, const long arg, int flags)\n{\n\tint ret = 0;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (flags & FL_LAYOUT)\n\t\treturn 0;\n\n\tif ((arg == F_RDLCK) && (atomic_read(&inode->i_writecount) > 0))\n\t\treturn -EAGAIN;\n\n\tif ((arg == F_WRLCK) && ((d_count(dentry) > 1) ||\n\t    (atomic_read(&inode->i_count) > 1)))\n\t\tret = -EAGAIN;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_insert_lock_ctx",
          "args": [
            "lease",
            "&ctx->flc_lease"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "locks_insert_lock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "683-689",
          "snippet": "static void\nlocks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)\n{\n\tfl->fl_nspid = get_pid(task_tgid(current));\n\tlist_add_tail(&fl->fl_list, before);\n\tlocks_insert_global_locks(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)\n{\n\tfl->fl_nspid = get_pid(task_tgid(current));\n\tlist_add_tail(&fl->fl_list, before);\n\tlocks_insert_global_locks(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lease->fl_lmops->lm_change",
          "args": [
            "lease",
            "arg",
            "&dispose"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_lease",
            "fl_list"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_out_leases",
          "args": [
            "inode",
            "&dispose"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "time_out_leases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1335-1349",
          "snippet": "static void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_get_lock_context",
          "args": [
            "inode"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "locks_get_lock_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "205-237",
          "snippet": "static struct file_lock_context *\nlocks_get_lock_context(struct inode *inode)\n{\n\tstruct file_lock_context *new;\n\n\tif (likely(inode->i_flctx))\n\t\tgoto out;\n\n\tnew = kmem_cache_alloc(flctx_cache, GFP_KERNEL);\n\tif (!new)\n\t\tgoto out;\n\n\tspin_lock_init(&new->flc_lock);\n\tINIT_LIST_HEAD(&new->flc_flock);\n\tINIT_LIST_HEAD(&new->flc_posix);\n\tINIT_LIST_HEAD(&new->flc_lease);\n\n\t/*\n\t * Assign the pointer if it's not already assigned. If it is, then\n\t * free the context we just allocated.\n\t */\n\tspin_lock(&inode->i_lock);\n\tif (likely(!inode->i_flctx)) {\n\t\tinode->i_flctx = new;\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (new)\n\t\tkmem_cache_free(flctx_cache, new);\nout:\n\treturn inode->i_flctx;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *flctx_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *flctx_cache;\n\nstatic struct file_lock_context *\nlocks_get_lock_context(struct inode *inode)\n{\n\tstruct file_lock_context *new;\n\n\tif (likely(inode->i_flctx))\n\t\tgoto out;\n\n\tnew = kmem_cache_alloc(flctx_cache, GFP_KERNEL);\n\tif (!new)\n\t\tgoto out;\n\n\tspin_lock_init(&new->flc_lock);\n\tINIT_LIST_HEAD(&new->flc_flock);\n\tINIT_LIST_HEAD(&new->flc_posix);\n\tINIT_LIST_HEAD(&new->flc_lease);\n\n\t/*\n\t * Assign the pointer if it's not already assigned. If it is, then\n\t * free the context we just allocated.\n\t */\n\tspin_lock(&inode->i_lock);\n\tif (likely(!inode->i_flctx)) {\n\t\tinode->i_flctx = new;\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (new)\n\t\tkmem_cache_free(flctx_cache, new);\nout:\n\treturn inode->i_flctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_generic_add_lease",
          "args": [
            "inode",
            "lease"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint leases_enable = 1;\n\nstatic int\ngeneric_add_lease(struct file *filp, long arg, struct file_lock **flp, void **priv)\n{\n\tstruct file_lock *fl, *my_fl = NULL, *lease;\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct file_lock_context *ctx;\n\tbool is_deleg = (*flp)->fl_flags & FL_DELEG;\n\tint error;\n\tLIST_HEAD(dispose);\n\n\tlease = *flp;\n\ttrace_generic_add_lease(inode, lease);\n\n\tctx = locks_get_lock_context(inode);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * In the delegation case we need mutual exclusion with\n\t * a number of operations that take the i_mutex.  We trylock\n\t * because delegations are an optional optimization, and if\n\t * there's some chance of a conflict--we'd rather not\n\t * bother, maybe that's a sign this just isn't a good file to\n\t * hand out a delegation on.\n\t */\n\tif (is_deleg && !mutex_trylock(&inode->i_mutex))\n\t\treturn -EAGAIN;\n\n\tif (is_deleg && arg == F_WRLCK) {\n\t\t/* Write delegations are not currently supported: */\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\ttime_out_leases(inode, &dispose);\n\terror = check_conflicting_open(dentry, arg, lease->fl_flags);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * At this point, we know that if there is an exclusive\n\t * lease on this file, then we hold it on this filp\n\t * (otherwise our open of this file would have blocked).\n\t * And if we are trying to acquire an exclusive lease,\n\t * then the file is not open by anyone (including us)\n\t * except for this filp.\n\t */\n\terror = -EAGAIN;\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_file == filp &&\n\t\t    fl->fl_owner == lease->fl_owner) {\n\t\t\tmy_fl = fl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * No exclusive leases if someone else has a lease on\n\t\t * this file:\n\t\t */\n\t\tif (arg == F_WRLCK)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Modifying our existing lease is OK, but no getting a\n\t\t * new lease if someone else is opening for write:\n\t\t */\n\t\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\t\tgoto out;\n\t}\n\n\tif (my_fl != NULL) {\n\t\tlease = my_fl;\n\t\terror = lease->fl_lmops->lm_change(lease, arg, &dispose);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tgoto out_setup;\n\t}\n\n\terror = -EINVAL;\n\tif (!leases_enable)\n\t\tgoto out;\n\n\tlocks_insert_lock_ctx(lease, &ctx->flc_lease);\n\t/*\n\t * The check in break_lease() is lockless. It's possible for another\n\t * open to race in after we did the earlier check for a conflicting\n\t * open but before the lease was inserted. Check again for a\n\t * conflicting open and cancel the lease if there is one.\n\t *\n\t * We also add a barrier here to ensure that the insertion of the lock\n\t * precedes these checks.\n\t */\n\tsmp_mb();\n\terror = check_conflicting_open(dentry, arg, lease->fl_flags);\n\tif (error) {\n\t\tlocks_unlink_lock_ctx(lease);\n\t\tgoto out;\n\t}\n\nout_setup:\n\tif (lease->fl_lmops->lm_setup)\n\t\tlease->fl_lmops->lm_setup(lease, priv);\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tlocks_dispose_list(&dispose);\n\tif (is_deleg)\n\t\tmutex_unlock(&inode->i_mutex);\n\tif (!error && !my_fl)\n\t\t*flp = NULL;\n\treturn error;\n}"
  },
  {
    "function_name": "check_conflicting_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1576-1593",
    "snippet": "static int\ncheck_conflicting_open(const struct dentry *dentry, const long arg, int flags)\n{\n\tint ret = 0;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (flags & FL_LAYOUT)\n\t\treturn 0;\n\n\tif ((arg == F_RDLCK) && (atomic_read(&inode->i_writecount) > 0))\n\t\treturn -EAGAIN;\n\n\tif ((arg == F_WRLCK) && ((d_count(dentry) > 1) ||\n\t    (atomic_read(&inode->i_count) > 1)))\n\t\tret = -EAGAIN;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_count"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_count",
          "args": [
            "dentry"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_destroy_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "464-468",
          "snippet": "static void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_writecount"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int\ncheck_conflicting_open(const struct dentry *dentry, const long arg, int flags)\n{\n\tint ret = 0;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (flags & FL_LAYOUT)\n\t\treturn 0;\n\n\tif ((arg == F_RDLCK) && (atomic_read(&inode->i_writecount) > 0))\n\t\treturn -EAGAIN;\n\n\tif ((arg == F_WRLCK) && ((d_count(dentry) > 1) ||\n\t    (atomic_read(&inode->i_count) > 1)))\n\t\tret = -EAGAIN;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fcntl_getlease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1543-1564",
    "snippet": "int fcntl_getlease(struct file *filp)\n{\n\tstruct file_lock *fl;\n\tstruct inode *inode = file_inode(filp);\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tint type = F_UNLCK;\n\tLIST_HEAD(dispose);\n\n\tif (ctx && !list_empty_careful(&ctx->flc_lease)) {\n\t\tspin_lock(&ctx->flc_lock);\n\t\ttime_out_leases(file_inode(filp), &dispose);\n\t\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\t\tif (fl->fl_file != filp)\n\t\t\t\tcontinue;\n\t\t\ttype = target_leasetype(fl);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->flc_lock);\n\t\tlocks_dispose_list(&dispose);\n\t}\n\treturn type;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_dispose_list",
          "args": [
            "&dispose"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "locks_dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "299-309",
          "snippet": "static void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "target_leasetype",
          "args": [
            "fl"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "target_leasetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "148-155",
          "snippet": "static int target_leasetype(struct file_lock *fl)\n{\n\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\treturn F_UNLCK;\n\tif (fl->fl_flags & FL_DOWNGRADE_PENDING)\n\t\treturn F_RDLCK;\n\treturn fl->fl_type;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int target_leasetype(struct file_lock *fl)\n{\n\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\treturn F_UNLCK;\n\tif (fl->fl_flags & FL_DOWNGRADE_PENDING)\n\t\treturn F_RDLCK;\n\treturn fl->fl_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_lease",
            "fl_list"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_out_leases",
          "args": [
            "file_inode(filp)",
            "&dispose"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "time_out_leases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1335-1349",
          "snippet": "static void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&ctx->flc_lease"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint fcntl_getlease(struct file *filp)\n{\n\tstruct file_lock *fl;\n\tstruct inode *inode = file_inode(filp);\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tint type = F_UNLCK;\n\tLIST_HEAD(dispose);\n\n\tif (ctx && !list_empty_careful(&ctx->flc_lease)) {\n\t\tspin_lock(&ctx->flc_lock);\n\t\ttime_out_leases(file_inode(filp), &dispose);\n\t\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\t\tif (fl->fl_file != filp)\n\t\t\t\tcontinue;\n\t\t\ttype = target_leasetype(fl);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->flc_lock);\n\t\tlocks_dispose_list(&dispose);\n\t}\n\treturn type;\n}"
  },
  {
    "function_name": "lease_get_mtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1495-1516",
    "snippet": "void lease_get_mtime(struct inode *inode, struct timespec *time)\n{\n\tbool has_lease = false;\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tif (ctx && !list_empty_careful(&ctx->flc_lease)) {\n\t\tspin_lock(&ctx->flc_lock);\n\t\tif (!list_empty(&ctx->flc_lease)) {\n\t\t\tfl = list_first_entry(&ctx->flc_lease,\n\t\t\t\t\t\tstruct file_lock, fl_list);\n\t\t\tif (fl->fl_type == F_WRLCK)\n\t\t\t\thas_lease = true;\n\t\t}\n\t\tspin_unlock(&ctx->flc_lock);\n\t}\n\n\tif (has_lease)\n\t\t*time = current_fs_time(inode->i_sb);\n\telse\n\t\t*time = inode->i_mtime;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&ctx->flc_lease",
            "structfile_lock",
            "fl_list"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ctx->flc_lease"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&ctx->flc_lease"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid lease_get_mtime(struct inode *inode, struct timespec *time)\n{\n\tbool has_lease = false;\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tif (ctx && !list_empty_careful(&ctx->flc_lease)) {\n\t\tspin_lock(&ctx->flc_lock);\n\t\tif (!list_empty(&ctx->flc_lease)) {\n\t\t\tfl = list_first_entry(&ctx->flc_lease,\n\t\t\t\t\t\tstruct file_lock, fl_list);\n\t\t\tif (fl->fl_type == F_WRLCK)\n\t\t\t\thas_lease = true;\n\t\t}\n\t\tspin_unlock(&ctx->flc_lock);\n\t}\n\n\tif (has_lease)\n\t\t*time = current_fs_time(inode->i_sb);\n\telse\n\t\t*time = inode->i_mtime;\n}"
  },
  {
    "function_name": "__break_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1388-1482",
    "snippet": "int __break_lease(struct inode *inode, unsigned int mode, unsigned int type)\n{\n\tint error = 0;\n\tstruct file_lock *new_fl;\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\tunsigned long break_time;\n\tint want_write = (mode & O_ACCMODE) != O_RDONLY;\n\tLIST_HEAD(dispose);\n\n\tnew_fl = lease_alloc(NULL, want_write ? F_WRLCK : F_RDLCK);\n\tif (IS_ERR(new_fl))\n\t\treturn PTR_ERR(new_fl);\n\tnew_fl->fl_flags = type;\n\n\t/* typically we will check that ctx is non-NULL before calling */\n\tif (!ctx) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn error;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\n\ttime_out_leases(inode, &dispose);\n\n\tif (!any_leases_conflict(inode, new_fl))\n\t\tgoto out;\n\n\tbreak_time = 0;\n\tif (lease_break_time > 0) {\n\t\tbreak_time = jiffies + lease_break_time * HZ;\n\t\tif (break_time == 0)\n\t\t\tbreak_time++;\t/* so that 0 means no break time */\n\t}\n\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (!leases_conflict(fl, new_fl))\n\t\t\tcontinue;\n\t\tif (want_write) {\n\t\t\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\t\t\tcontinue;\n\t\t\tfl->fl_flags |= FL_UNLOCK_PENDING;\n\t\t\tfl->fl_break_time = break_time;\n\t\t} else {\n\t\t\tif (lease_breaking(fl))\n\t\t\t\tcontinue;\n\t\t\tfl->fl_flags |= FL_DOWNGRADE_PENDING;\n\t\t\tfl->fl_downgrade_time = break_time;\n\t\t}\n\t\tif (fl->fl_lmops->lm_break(fl))\n\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t}\n\n\tif (list_empty(&ctx->flc_lease))\n\t\tgoto out;\n\n\tif (mode & O_NONBLOCK) {\n\t\ttrace_break_lease_noblock(inode, new_fl);\n\t\terror = -EWOULDBLOCK;\n\t\tgoto out;\n\t}\n\nrestart:\n\tfl = list_first_entry(&ctx->flc_lease, struct file_lock, fl_list);\n\tbreak_time = fl->fl_break_time;\n\tif (break_time != 0)\n\t\tbreak_time -= jiffies;\n\tif (break_time == 0)\n\t\tbreak_time++;\n\tlocks_insert_block(fl, new_fl);\n\ttrace_break_lease_block(inode, new_fl);\n\tspin_unlock(&ctx->flc_lock);\n\tlocks_dispose_list(&dispose);\n\terror = wait_event_interruptible_timeout(new_fl->fl_wait,\n\t\t\t\t\t\t!new_fl->fl_next, break_time);\n\tspin_lock(&ctx->flc_lock);\n\ttrace_break_lease_unblock(inode, new_fl);\n\tlocks_delete_block(new_fl);\n\tif (error >= 0) {\n\t\t/*\n\t\t * Wait for the next conflicting lease that has not been\n\t\t * broken yet\n\t\t */\n\t\tif (error == 0)\n\t\t\ttime_out_leases(inode, &dispose);\n\t\tif (any_leases_conflict(inode, new_fl))\n\t\t\tgoto restart;\n\t\terror = 0;\n\t}\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tlocks_dispose_list(&dispose);\n\tlocks_free_lock(new_fl);\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int lease_break_time = 45;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "new_fl"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "287-296",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_dispose_list",
          "args": [
            "&dispose"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "locks_dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "299-309",
          "snippet": "static void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "any_leases_conflict",
          "args": [
            "inode",
            "new_fl"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "any_leases_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1360-1373",
          "snippet": "static bool\nany_leases_conflict(struct inode *inode, struct file_lock *breaker)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (leases_conflict(fl, breaker))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic bool\nany_leases_conflict(struct inode *inode, struct file_lock *breaker)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (leases_conflict(fl, breaker))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_out_leases",
          "args": [
            "inode",
            "&dispose"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "time_out_leases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1335-1349",
          "snippet": "static void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_delete_block",
          "args": [
            "new_fl"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "615-620",
          "snippet": "static void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_break_lease_unblock",
          "args": [
            "inode",
            "new_fl"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible_timeout",
          "args": [
            "new_fl->fl_wait",
            "!new_fl->fl_next",
            "break_time"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_break_lease_block",
          "args": [
            "inode",
            "new_fl"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_insert_block",
          "args": [
            "fl",
            "new_fl"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "locks_insert_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "643-649",
          "snippet": "static void locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_insert_block(blocker, waiter);\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_insert_block(blocker, waiter);\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&ctx->flc_lease",
            "structfile_lock",
            "fl_list"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_break_lease_noblock",
          "args": [
            "inode",
            "new_fl"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ctx->flc_lease"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_delete_lock_ctx",
          "args": [
            "fl",
            "&dispose"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_lock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "703-711",
          "snippet": "static void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fl->fl_lmops->lm_break",
          "args": [
            "fl"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lease_breaking",
          "args": [
            "fl"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "lease_breaking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "143-146",
          "snippet": "static bool lease_breaking(struct file_lock *fl)\n{\n\treturn fl->fl_flags & (FL_UNLOCK_PENDING | FL_DOWNGRADE_PENDING);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic bool lease_breaking(struct file_lock *fl)\n{\n\treturn fl->fl_flags & (FL_UNLOCK_PENDING | FL_DOWNGRADE_PENDING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_lease",
            "fl_list"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_fl"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_fl"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lease_alloc",
          "args": [
            "NULL",
            "want_write ? F_WRLCK : F_RDLCK"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "lease_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "526-540",
          "snippet": "static struct file_lock *lease_alloc(struct file *filp, long type)\n{\n\tstruct file_lock *fl = locks_alloc_lock();\n\tint error = -ENOMEM;\n\n\tif (fl == NULL)\n\t\treturn ERR_PTR(error);\n\n\terror = lease_init(filp, type, fl);\n\tif (error) {\n\t\tlocks_free_lock(fl);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct file_lock *lease_alloc(struct file *filp, long type)\n{\n\tstruct file_lock *fl = locks_alloc_lock();\n\tint error = -ENOMEM;\n\n\tif (fl == NULL)\n\t\treturn ERR_PTR(error);\n\n\terror = lease_init(filp, type, fl);\n\tif (error) {\n\t\tlocks_free_lock(fl);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn fl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint lease_break_time = 45;\n\nint __break_lease(struct inode *inode, unsigned int mode, unsigned int type)\n{\n\tint error = 0;\n\tstruct file_lock *new_fl;\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\tunsigned long break_time;\n\tint want_write = (mode & O_ACCMODE) != O_RDONLY;\n\tLIST_HEAD(dispose);\n\n\tnew_fl = lease_alloc(NULL, want_write ? F_WRLCK : F_RDLCK);\n\tif (IS_ERR(new_fl))\n\t\treturn PTR_ERR(new_fl);\n\tnew_fl->fl_flags = type;\n\n\t/* typically we will check that ctx is non-NULL before calling */\n\tif (!ctx) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn error;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\n\ttime_out_leases(inode, &dispose);\n\n\tif (!any_leases_conflict(inode, new_fl))\n\t\tgoto out;\n\n\tbreak_time = 0;\n\tif (lease_break_time > 0) {\n\t\tbreak_time = jiffies + lease_break_time * HZ;\n\t\tif (break_time == 0)\n\t\t\tbreak_time++;\t/* so that 0 means no break time */\n\t}\n\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (!leases_conflict(fl, new_fl))\n\t\t\tcontinue;\n\t\tif (want_write) {\n\t\t\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\t\t\tcontinue;\n\t\t\tfl->fl_flags |= FL_UNLOCK_PENDING;\n\t\t\tfl->fl_break_time = break_time;\n\t\t} else {\n\t\t\tif (lease_breaking(fl))\n\t\t\t\tcontinue;\n\t\t\tfl->fl_flags |= FL_DOWNGRADE_PENDING;\n\t\t\tfl->fl_downgrade_time = break_time;\n\t\t}\n\t\tif (fl->fl_lmops->lm_break(fl))\n\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t}\n\n\tif (list_empty(&ctx->flc_lease))\n\t\tgoto out;\n\n\tif (mode & O_NONBLOCK) {\n\t\ttrace_break_lease_noblock(inode, new_fl);\n\t\terror = -EWOULDBLOCK;\n\t\tgoto out;\n\t}\n\nrestart:\n\tfl = list_first_entry(&ctx->flc_lease, struct file_lock, fl_list);\n\tbreak_time = fl->fl_break_time;\n\tif (break_time != 0)\n\t\tbreak_time -= jiffies;\n\tif (break_time == 0)\n\t\tbreak_time++;\n\tlocks_insert_block(fl, new_fl);\n\ttrace_break_lease_block(inode, new_fl);\n\tspin_unlock(&ctx->flc_lock);\n\tlocks_dispose_list(&dispose);\n\terror = wait_event_interruptible_timeout(new_fl->fl_wait,\n\t\t\t\t\t\t!new_fl->fl_next, break_time);\n\tspin_lock(&ctx->flc_lock);\n\ttrace_break_lease_unblock(inode, new_fl);\n\tlocks_delete_block(new_fl);\n\tif (error >= 0) {\n\t\t/*\n\t\t * Wait for the next conflicting lease that has not been\n\t\t * broken yet\n\t\t */\n\t\tif (error == 0)\n\t\t\ttime_out_leases(inode, &dispose);\n\t\tif (any_leases_conflict(inode, new_fl))\n\t\t\tgoto restart;\n\t\terror = 0;\n\t}\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tlocks_dispose_list(&dispose);\n\tlocks_free_lock(new_fl);\n\treturn error;\n}"
  },
  {
    "function_name": "any_leases_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1360-1373",
    "snippet": "static bool\nany_leases_conflict(struct inode *inode, struct file_lock *breaker)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (leases_conflict(fl, breaker))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leases_conflict",
          "args": [
            "fl",
            "breaker"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "any_leases_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1360-1373",
          "snippet": "static bool\nany_leases_conflict(struct inode *inode, struct file_lock *breaker)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (leases_conflict(fl, breaker))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_lease",
            "fl_list"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic bool\nany_leases_conflict(struct inode *inode, struct file_lock *breaker)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (leases_conflict(fl, breaker))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "leases_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1351-1358",
    "snippet": "static bool leases_conflict(struct file_lock *lease, struct file_lock *breaker)\n{\n\tif ((breaker->fl_flags & FL_LAYOUT) != (lease->fl_flags & FL_LAYOUT))\n\t\treturn false;\n\tif ((breaker->fl_flags & FL_DELEG) && (lease->fl_flags & FL_LEASE))\n\t\treturn false;\n\treturn locks_conflict(breaker, lease);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_conflict",
          "args": [
            "breaker",
            "lease"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "flock_locks_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "746-757",
          "snippet": "static int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* FLOCK locks referring to the same filp do not conflict with\n\t * each other.\n\t */\n\tif (!IS_FLOCK(sys_fl) || (caller_fl->fl_file == sys_fl->fl_file))\n\t\treturn (0);\n\tif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* FLOCK locks referring to the same filp do not conflict with\n\t * each other.\n\t */\n\tif (!IS_FLOCK(sys_fl) || (caller_fl->fl_file == sys_fl->fl_file))\n\t\treturn (0);\n\tif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic bool leases_conflict(struct file_lock *lease, struct file_lock *breaker)\n{\n\tif ((breaker->fl_flags & FL_LAYOUT) != (lease->fl_flags & FL_LAYOUT))\n\t\treturn false;\n\tif ((breaker->fl_flags & FL_DELEG) && (lease->fl_flags & FL_LEASE))\n\t\treturn false;\n\treturn locks_conflict(breaker, lease);\n}"
  },
  {
    "function_name": "time_out_leases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1335-1349",
    "snippet": "static void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lease_modify",
          "args": [
            "fl",
            "F_UNLCK",
            "dispose"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "lease_modify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1303-1324",
          "snippet": "int lease_modify(struct file_lock *fl, int arg, struct list_head *dispose)\n{\n\tint error = assign_type(fl, arg);\n\n\tif (error)\n\t\treturn error;\n\tlease_clear_pending(fl, arg);\n\tlocks_wake_up_blocks(fl);\n\tif (arg == F_UNLCK) {\n\t\tstruct file *filp = fl->fl_file;\n\n\t\tf_delown(filp);\n\t\tfilp->f_owner.signum = 0;\n\t\tfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\n\t\tif (fl->fl_fasync != NULL) {\n\t\t\tprintk(KERN_ERR \"locks_delete_lock: fasync == %p\\n\", fl->fl_fasync);\n\t\t\tfl->fl_fasync = NULL;\n\t\t}\n\t\tlocks_delete_lock_ctx(fl, dispose);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint lease_modify(struct file_lock *fl, int arg, struct list_head *dispose)\n{\n\tint error = assign_type(fl, arg);\n\n\tif (error)\n\t\treturn error;\n\tlease_clear_pending(fl, arg);\n\tlocks_wake_up_blocks(fl);\n\tif (arg == F_UNLCK) {\n\t\tstruct file *filp = fl->fl_file;\n\n\t\tf_delown(filp);\n\t\tfilp->f_owner.signum = 0;\n\t\tfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\n\t\tif (fl->fl_fasync != NULL) {\n\t\t\tprintk(KERN_ERR \"locks_delete_lock: fasync == %p\\n\", fl->fl_fasync);\n\t\t\tfl->fl_fasync = NULL;\n\t\t}\n\t\tlocks_delete_lock_ctx(fl, dispose);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "past_time",
          "args": [
            "fl->fl_break_time"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "past_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1327-1333",
          "snippet": "static bool past_time(unsigned long then)\n{\n\tif (!then)\n\t\t/* 0 is a special value meaning \"this never expires\": */\n\t\treturn false;\n\treturn time_after(jiffies, then);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic bool past_time(unsigned long then)\n{\n\tif (!then)\n\t\t/* 0 is a special value meaning \"this never expires\": */\n\t\treturn false;\n\treturn time_after(jiffies, then);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_time_out_leases",
          "args": [
            "inode",
            "fl"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "fl",
            "tmp",
            "&ctx->flc_lease",
            "fl_list"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}"
  },
  {
    "function_name": "past_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1327-1333",
    "snippet": "static bool past_time(unsigned long then)\n{\n\tif (!then)\n\t\t/* 0 is a special value meaning \"this never expires\": */\n\t\treturn false;\n\treturn time_after(jiffies, then);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "then"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic bool past_time(unsigned long then)\n{\n\tif (!then)\n\t\t/* 0 is a special value meaning \"this never expires\": */\n\t\treturn false;\n\treturn time_after(jiffies, then);\n}"
  },
  {
    "function_name": "lease_modify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1303-1324",
    "snippet": "int lease_modify(struct file_lock *fl, int arg, struct list_head *dispose)\n{\n\tint error = assign_type(fl, arg);\n\n\tif (error)\n\t\treturn error;\n\tlease_clear_pending(fl, arg);\n\tlocks_wake_up_blocks(fl);\n\tif (arg == F_UNLCK) {\n\t\tstruct file *filp = fl->fl_file;\n\n\t\tf_delown(filp);\n\t\tfilp->f_owner.signum = 0;\n\t\tfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\n\t\tif (fl->fl_fasync != NULL) {\n\t\t\tprintk(KERN_ERR \"locks_delete_lock: fasync == %p\\n\", fl->fl_fasync);\n\t\t\tfl->fl_fasync = NULL;\n\t\t}\n\t\tlocks_delete_lock_ctx(fl, dispose);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_delete_lock_ctx",
          "args": [
            "fl",
            "dispose"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_lock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "703-711",
          "snippet": "static void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"locks_delete_lock: fasync == %p\\n\"",
            "fl->fl_fasync"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fasync_helper",
          "args": [
            "0",
            "fl->fl_file",
            "0",
            "&fl->fl_fasync"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "fasync_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "686-691",
          "snippet": "int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)\n{\n\tif (!on)\n\t\treturn fasync_remove_entry(filp, fapp);\n\treturn fasync_add_entry(fd, filp, fapp);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nint fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)\n{\n\tif (!on)\n\t\treturn fasync_remove_entry(filp, fapp);\n\treturn fasync_add_entry(fd, filp, fapp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f_delown",
          "args": [
            "filp"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "f_delown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "126-129",
          "snippet": "void f_delown(struct file *filp)\n{\n\tf_modown(filp, NULL, PIDTYPE_PID, 1);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid f_delown(struct file *filp)\n{\n\tf_modown(filp, NULL, PIDTYPE_PID, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_wake_up_blocks",
          "args": [
            "fl"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lease_clear_pending",
          "args": [
            "fl",
            "arg"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "lease_clear_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1291-1300",
          "snippet": "static void lease_clear_pending(struct file_lock *fl, int arg)\n{\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\tfl->fl_flags &= ~FL_UNLOCK_PENDING;\n\t\t/* fall through: */\n\tcase F_RDLCK:\n\t\tfl->fl_flags &= ~FL_DOWNGRADE_PENDING;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void lease_clear_pending(struct file_lock *fl, int arg)\n{\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\tfl->fl_flags &= ~FL_UNLOCK_PENDING;\n\t\t/* fall through: */\n\tcase F_RDLCK:\n\t\tfl->fl_flags &= ~FL_DOWNGRADE_PENDING;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assign_type",
          "args": [
            "fl",
            "arg"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "assign_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "397-409",
          "snippet": "static int assign_type(struct file_lock *fl, long type)\n{\n\tswitch (type) {\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\tcase F_UNLCK:\n\t\tfl->fl_type = type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int assign_type(struct file_lock *fl, long type)\n{\n\tswitch (type) {\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\tcase F_UNLCK:\n\t\tfl->fl_type = type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint lease_modify(struct file_lock *fl, int arg, struct list_head *dispose)\n{\n\tint error = assign_type(fl, arg);\n\n\tif (error)\n\t\treturn error;\n\tlease_clear_pending(fl, arg);\n\tlocks_wake_up_blocks(fl);\n\tif (arg == F_UNLCK) {\n\t\tstruct file *filp = fl->fl_file;\n\n\t\tf_delown(filp);\n\t\tfilp->f_owner.signum = 0;\n\t\tfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\n\t\tif (fl->fl_fasync != NULL) {\n\t\t\tprintk(KERN_ERR \"locks_delete_lock: fasync == %p\\n\", fl->fl_fasync);\n\t\t\tfl->fl_fasync = NULL;\n\t\t}\n\t\tlocks_delete_lock_ctx(fl, dispose);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lease_clear_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1291-1300",
    "snippet": "static void lease_clear_pending(struct file_lock *fl, int arg)\n{\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\tfl->fl_flags &= ~FL_UNLOCK_PENDING;\n\t\t/* fall through: */\n\tcase F_RDLCK:\n\t\tfl->fl_flags &= ~FL_DOWNGRADE_PENDING;\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void lease_clear_pending(struct file_lock *fl, int arg)\n{\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\tfl->fl_flags &= ~FL_UNLOCK_PENDING;\n\t\t/* fall through: */\n\tcase F_RDLCK:\n\t\tfl->fl_flags &= ~FL_DOWNGRADE_PENDING;\n\t}\n}"
  },
  {
    "function_name": "locks_mandatory_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1239-1287",
    "snippet": "int locks_mandatory_area(int read_write, struct inode *inode,\n\t\t\t struct file *filp, loff_t offset,\n\t\t\t size_t count)\n{\n\tstruct file_lock fl;\n\tint error;\n\tbool sleep = false;\n\n\tlocks_init_lock(&fl);\n\tfl.fl_pid = current->tgid;\n\tfl.fl_file = filp;\n\tfl.fl_flags = FL_POSIX | FL_ACCESS;\n\tif (filp && !(filp->f_flags & O_NONBLOCK))\n\t\tsleep = true;\n\tfl.fl_type = (read_write == FLOCK_VERIFY_WRITE) ? F_WRLCK : F_RDLCK;\n\tfl.fl_start = offset;\n\tfl.fl_end = offset + count - 1;\n\n\tfor (;;) {\n\t\tif (filp) {\n\t\t\tfl.fl_owner = filp;\n\t\t\tfl.fl_flags &= ~FL_SLEEP;\n\t\t\terror = __posix_lock_file(inode, &fl, NULL);\n\t\t\tif (!error)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (sleep)\n\t\t\tfl.fl_flags |= FL_SLEEP;\n\t\tfl.fl_owner = current->files;\n\t\terror = __posix_lock_file(inode, &fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl.fl_wait, !fl.fl_next);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * If we've been sleeping someone might have\n\t\t\t * changed the permissions behind our back.\n\t\t\t */\n\t\t\tif (__mandatory_lock(inode))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tlocks_delete_block(&fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_delete_block",
          "args": [
            "&fl"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "615-620",
          "snippet": "static void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "fl.fl_wait",
            "!fl.fl_next"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__posix_lock_file",
          "args": [
            "inode",
            "&fl",
            "NULL"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "__posix_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "930-1141",
          "snippet": "static int __posix_lock_file(struct inode *inode, struct file_lock *request, struct file_lock *conflock)\n{\n\tstruct file_lock *fl, *tmp;\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *new_fl2 = NULL;\n\tstruct file_lock *left = NULL;\n\tstruct file_lock *right = NULL;\n\tstruct file_lock_context *ctx;\n\tint error;\n\tbool added = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * We may need two file_lock structures for this operation,\n\t * so we get them in advance to avoid races.\n\t *\n\t * In some cases we can be sure, that no new locks will be needed\n\t */\n\tif (!(request->fl_flags & FL_ACCESS) &&\n\t    (request->fl_type != F_UNLCK ||\n\t     request->fl_start != 0 || request->fl_end != OFFSET_MAX)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tnew_fl2 = locks_alloc_lock();\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\t/*\n\t * New lock request. Walk all POSIX locks and look for conflicts. If\n\t * there are any, either return error or put the request on the\n\t * blocker's list of waiters and the global blocked_hash.\n\t */\n\tif (request->fl_type != F_UNLCK) {\n\t\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\t\tif (!IS_POSIX(fl))\n\t\t\t\tcontinue;\n\t\t\tif (!posix_locks_conflict(request, fl))\n\t\t\t\tcontinue;\n\t\t\tif (conflock)\n\t\t\t\tlocks_copy_conflock(conflock, fl);\n\t\t\terror = -EAGAIN;\n\t\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Deadlock detection and insertion into the blocked\n\t\t\t * locks list must be done while holding the same lock!\n\t\t\t */\n\t\t\terror = -EDEADLK;\n\t\t\tspin_lock(&blocked_lock_lock);\n\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {\n\t\t\t\terror = FILE_LOCK_DEFERRED;\n\t\t\t\t__locks_insert_block(fl, request);\n\t\t\t}\n\t\t\tspin_unlock(&blocked_lock_lock);\n\t\t\tgoto out;\n  \t\t}\n  \t}\n\n\t/* If we're just looking for a conflict, we're done. */\n\terror = 0;\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\n\t/* Find the first old lock with the same owner as the new lock */\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_same_owner(request, fl))\n\t\t\tbreak;\n\t}\n\n\t/* Process locks with this owner. */\n\tlist_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, fl_list) {\n\t\tif (!posix_same_owner(request, fl))\n\t\t\tbreak;\n\n\t\t/* Detect adjacent or overlapping regions (if same lock type) */\n\t\tif (request->fl_type == fl->fl_type) {\n\t\t\t/* In all comparisons of start vs end, use\n\t\t\t * \"start - 1\" rather than \"end + 1\". If end\n\t\t\t * is OFFSET_MAX, end + 1 will become negative.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start - 1)\n\t\t\t\tcontinue;\n\t\t\t/* If the next lock in the list has entirely bigger\n\t\t\t * addresses than the new one, insert the lock here.\n\t\t\t */\n\t\t\tif (fl->fl_start - 1 > request->fl_end)\n\t\t\t\tbreak;\n\n\t\t\t/* If we come here, the new and old lock are of the\n\t\t\t * same type and adjacent or overlapping. Make one\n\t\t\t * lock yielding from the lower start address of both\n\t\t\t * locks to the higher end address.\n\t\t\t */\n\t\t\tif (fl->fl_start > request->fl_start)\n\t\t\t\tfl->fl_start = request->fl_start;\n\t\t\telse\n\t\t\t\trequest->fl_start = fl->fl_start;\n\t\t\tif (fl->fl_end < request->fl_end)\n\t\t\t\tfl->fl_end = request->fl_end;\n\t\t\telse\n\t\t\t\trequest->fl_end = fl->fl_end;\n\t\t\tif (added) {\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trequest = fl;\n\t\t\tadded = true;\n\t\t} else {\n\t\t\t/* Processing for different lock types is a bit\n\t\t\t * more complex.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start)\n\t\t\t\tcontinue;\n\t\t\tif (fl->fl_start > request->fl_end)\n\t\t\t\tbreak;\n\t\t\tif (request->fl_type == F_UNLCK)\n\t\t\t\tadded = true;\n\t\t\tif (fl->fl_start < request->fl_start)\n\t\t\t\tleft = fl;\n\t\t\t/* If the next lock in the list has a higher end\n\t\t\t * address than the new one, insert the new one here.\n\t\t\t */\n\t\t\tif (fl->fl_end > request->fl_end) {\n\t\t\t\tright = fl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fl->fl_start >= request->fl_start) {\n\t\t\t\t/* The new lock completely replaces an old\n\t\t\t\t * one (This may happen several times).\n\t\t\t\t */\n\t\t\t\tif (added) {\n\t\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Replace the old lock with new_fl, and\n\t\t\t\t * remove the old one. It's safe to do the\n\t\t\t\t * insert here since we know that we won't be\n\t\t\t\t * using new_fl later, and that the lock is\n\t\t\t\t * just replacing an existing lock.\n\t\t\t\t */\n\t\t\t\terror = -ENOLCK;\n\t\t\t\tif (!new_fl)\n\t\t\t\t\tgoto out;\n\t\t\t\tlocks_copy_lock(new_fl, request);\n\t\t\t\trequest = new_fl;\n\t\t\t\tnew_fl = NULL;\n\t\t\t\tlocks_insert_lock_ctx(request, &fl->fl_list);\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The above code only modifies existing locks in case of merging or\n\t * replacing. If new lock(s) need to be inserted all modifications are\n\t * done below this, so it's safe yet to bail out.\n\t */\n\terror = -ENOLCK; /* \"no luck\" */\n\tif (right && left == right && !new_fl2)\n\t\tgoto out;\n\n\terror = 0;\n\tif (!added) {\n\t\tif (request->fl_type == F_UNLCK) {\n\t\t\tif (request->fl_flags & FL_EXISTS)\n\t\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!new_fl) {\n\t\t\terror = -ENOLCK;\n\t\t\tgoto out;\n\t\t}\n\t\tlocks_copy_lock(new_fl, request);\n\t\tlocks_insert_lock_ctx(new_fl, &fl->fl_list);\n\t\tfl = new_fl;\n\t\tnew_fl = NULL;\n\t}\n\tif (right) {\n\t\tif (left == right) {\n\t\t\t/* The new lock breaks the old one in two pieces,\n\t\t\t * so we have to use the second new lock.\n\t\t\t */\n\t\t\tleft = new_fl2;\n\t\t\tnew_fl2 = NULL;\n\t\t\tlocks_copy_lock(left, right);\n\t\t\tlocks_insert_lock_ctx(left, &fl->fl_list);\n\t\t}\n\t\tright->fl_start = request->fl_end + 1;\n\t\tlocks_wake_up_blocks(right);\n\t}\n\tif (left) {\n\t\tleft->fl_end = request->fl_start - 1;\n\t\tlocks_wake_up_blocks(left);\n\t}\n out:\n\tspin_unlock(&ctx->flc_lock);\n\t/*\n\t * Free any unused locks.\n\t */\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tif (new_fl2)\n\t\tlocks_free_lock(new_fl2);\n\tlocks_dispose_list(&dispose);\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic int __posix_lock_file(struct inode *inode, struct file_lock *request, struct file_lock *conflock)\n{\n\tstruct file_lock *fl, *tmp;\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *new_fl2 = NULL;\n\tstruct file_lock *left = NULL;\n\tstruct file_lock *right = NULL;\n\tstruct file_lock_context *ctx;\n\tint error;\n\tbool added = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * We may need two file_lock structures for this operation,\n\t * so we get them in advance to avoid races.\n\t *\n\t * In some cases we can be sure, that no new locks will be needed\n\t */\n\tif (!(request->fl_flags & FL_ACCESS) &&\n\t    (request->fl_type != F_UNLCK ||\n\t     request->fl_start != 0 || request->fl_end != OFFSET_MAX)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tnew_fl2 = locks_alloc_lock();\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\t/*\n\t * New lock request. Walk all POSIX locks and look for conflicts. If\n\t * there are any, either return error or put the request on the\n\t * blocker's list of waiters and the global blocked_hash.\n\t */\n\tif (request->fl_type != F_UNLCK) {\n\t\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\t\tif (!IS_POSIX(fl))\n\t\t\t\tcontinue;\n\t\t\tif (!posix_locks_conflict(request, fl))\n\t\t\t\tcontinue;\n\t\t\tif (conflock)\n\t\t\t\tlocks_copy_conflock(conflock, fl);\n\t\t\terror = -EAGAIN;\n\t\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Deadlock detection and insertion into the blocked\n\t\t\t * locks list must be done while holding the same lock!\n\t\t\t */\n\t\t\terror = -EDEADLK;\n\t\t\tspin_lock(&blocked_lock_lock);\n\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {\n\t\t\t\terror = FILE_LOCK_DEFERRED;\n\t\t\t\t__locks_insert_block(fl, request);\n\t\t\t}\n\t\t\tspin_unlock(&blocked_lock_lock);\n\t\t\tgoto out;\n  \t\t}\n  \t}\n\n\t/* If we're just looking for a conflict, we're done. */\n\terror = 0;\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\n\t/* Find the first old lock with the same owner as the new lock */\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_same_owner(request, fl))\n\t\t\tbreak;\n\t}\n\n\t/* Process locks with this owner. */\n\tlist_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, fl_list) {\n\t\tif (!posix_same_owner(request, fl))\n\t\t\tbreak;\n\n\t\t/* Detect adjacent or overlapping regions (if same lock type) */\n\t\tif (request->fl_type == fl->fl_type) {\n\t\t\t/* In all comparisons of start vs end, use\n\t\t\t * \"start - 1\" rather than \"end + 1\". If end\n\t\t\t * is OFFSET_MAX, end + 1 will become negative.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start - 1)\n\t\t\t\tcontinue;\n\t\t\t/* If the next lock in the list has entirely bigger\n\t\t\t * addresses than the new one, insert the lock here.\n\t\t\t */\n\t\t\tif (fl->fl_start - 1 > request->fl_end)\n\t\t\t\tbreak;\n\n\t\t\t/* If we come here, the new and old lock are of the\n\t\t\t * same type and adjacent or overlapping. Make one\n\t\t\t * lock yielding from the lower start address of both\n\t\t\t * locks to the higher end address.\n\t\t\t */\n\t\t\tif (fl->fl_start > request->fl_start)\n\t\t\t\tfl->fl_start = request->fl_start;\n\t\t\telse\n\t\t\t\trequest->fl_start = fl->fl_start;\n\t\t\tif (fl->fl_end < request->fl_end)\n\t\t\t\tfl->fl_end = request->fl_end;\n\t\t\telse\n\t\t\t\trequest->fl_end = fl->fl_end;\n\t\t\tif (added) {\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trequest = fl;\n\t\t\tadded = true;\n\t\t} else {\n\t\t\t/* Processing for different lock types is a bit\n\t\t\t * more complex.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start)\n\t\t\t\tcontinue;\n\t\t\tif (fl->fl_start > request->fl_end)\n\t\t\t\tbreak;\n\t\t\tif (request->fl_type == F_UNLCK)\n\t\t\t\tadded = true;\n\t\t\tif (fl->fl_start < request->fl_start)\n\t\t\t\tleft = fl;\n\t\t\t/* If the next lock in the list has a higher end\n\t\t\t * address than the new one, insert the new one here.\n\t\t\t */\n\t\t\tif (fl->fl_end > request->fl_end) {\n\t\t\t\tright = fl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fl->fl_start >= request->fl_start) {\n\t\t\t\t/* The new lock completely replaces an old\n\t\t\t\t * one (This may happen several times).\n\t\t\t\t */\n\t\t\t\tif (added) {\n\t\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Replace the old lock with new_fl, and\n\t\t\t\t * remove the old one. It's safe to do the\n\t\t\t\t * insert here since we know that we won't be\n\t\t\t\t * using new_fl later, and that the lock is\n\t\t\t\t * just replacing an existing lock.\n\t\t\t\t */\n\t\t\t\terror = -ENOLCK;\n\t\t\t\tif (!new_fl)\n\t\t\t\t\tgoto out;\n\t\t\t\tlocks_copy_lock(new_fl, request);\n\t\t\t\trequest = new_fl;\n\t\t\t\tnew_fl = NULL;\n\t\t\t\tlocks_insert_lock_ctx(request, &fl->fl_list);\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The above code only modifies existing locks in case of merging or\n\t * replacing. If new lock(s) need to be inserted all modifications are\n\t * done below this, so it's safe yet to bail out.\n\t */\n\terror = -ENOLCK; /* \"no luck\" */\n\tif (right && left == right && !new_fl2)\n\t\tgoto out;\n\n\terror = 0;\n\tif (!added) {\n\t\tif (request->fl_type == F_UNLCK) {\n\t\t\tif (request->fl_flags & FL_EXISTS)\n\t\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!new_fl) {\n\t\t\terror = -ENOLCK;\n\t\t\tgoto out;\n\t\t}\n\t\tlocks_copy_lock(new_fl, request);\n\t\tlocks_insert_lock_ctx(new_fl, &fl->fl_list);\n\t\tfl = new_fl;\n\t\tnew_fl = NULL;\n\t}\n\tif (right) {\n\t\tif (left == right) {\n\t\t\t/* The new lock breaks the old one in two pieces,\n\t\t\t * so we have to use the second new lock.\n\t\t\t */\n\t\t\tleft = new_fl2;\n\t\t\tnew_fl2 = NULL;\n\t\t\tlocks_copy_lock(left, right);\n\t\t\tlocks_insert_lock_ctx(left, &fl->fl_list);\n\t\t}\n\t\tright->fl_start = request->fl_end + 1;\n\t\tlocks_wake_up_blocks(right);\n\t}\n\tif (left) {\n\t\tleft->fl_end = request->fl_start - 1;\n\t\tlocks_wake_up_blocks(left);\n\t}\n out:\n\tspin_unlock(&ctx->flc_lock);\n\t/*\n\t * Free any unused locks.\n\t */\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tif (new_fl2)\n\t\tlocks_free_lock(new_fl2);\n\tlocks_dispose_list(&dispose);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_init_lock",
          "args": [
            "&fl"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "locks_init_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "311-315",
          "snippet": "void locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint locks_mandatory_area(int read_write, struct inode *inode,\n\t\t\t struct file *filp, loff_t offset,\n\t\t\t size_t count)\n{\n\tstruct file_lock fl;\n\tint error;\n\tbool sleep = false;\n\n\tlocks_init_lock(&fl);\n\tfl.fl_pid = current->tgid;\n\tfl.fl_file = filp;\n\tfl.fl_flags = FL_POSIX | FL_ACCESS;\n\tif (filp && !(filp->f_flags & O_NONBLOCK))\n\t\tsleep = true;\n\tfl.fl_type = (read_write == FLOCK_VERIFY_WRITE) ? F_WRLCK : F_RDLCK;\n\tfl.fl_start = offset;\n\tfl.fl_end = offset + count - 1;\n\n\tfor (;;) {\n\t\tif (filp) {\n\t\t\tfl.fl_owner = filp;\n\t\t\tfl.fl_flags &= ~FL_SLEEP;\n\t\t\terror = __posix_lock_file(inode, &fl, NULL);\n\t\t\tif (!error)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (sleep)\n\t\t\tfl.fl_flags |= FL_SLEEP;\n\t\tfl.fl_owner = current->files;\n\t\terror = __posix_lock_file(inode, &fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl.fl_wait, !fl.fl_next);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * If we've been sleeping someone might have\n\t\t\t * changed the permissions behind our back.\n\t\t\t */\n\t\t\tif (__mandatory_lock(inode))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tlocks_delete_block(&fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "locks_mandatory_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1199-1224",
    "snippet": "int locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = file_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_posix",
            "fl_list"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&ctx->flc_posix"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = file_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "posix_lock_file_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1173-1189",
    "snippet": "int posix_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_file(filp, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_delete_block",
          "args": [
            "fl"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "615-620",
          "snippet": "static void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "fl->fl_wait",
            "!fl->fl_next"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_lock_file",
          "args": [
            "filp",
            "fl",
            "NULL"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1157-1161",
          "snippet": "int posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn __posix_lock_file(file_inode(filp), fl, conflock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn __posix_lock_file(file_inode(filp), fl, conflock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_file(filp, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "posix_lock_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "1157-1161",
    "snippet": "int posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn __posix_lock_file(file_inode(filp), fl, conflock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__posix_lock_file",
          "args": [
            "file_inode(filp)",
            "fl",
            "conflock"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "__posix_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "930-1141",
          "snippet": "static int __posix_lock_file(struct inode *inode, struct file_lock *request, struct file_lock *conflock)\n{\n\tstruct file_lock *fl, *tmp;\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *new_fl2 = NULL;\n\tstruct file_lock *left = NULL;\n\tstruct file_lock *right = NULL;\n\tstruct file_lock_context *ctx;\n\tint error;\n\tbool added = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * We may need two file_lock structures for this operation,\n\t * so we get them in advance to avoid races.\n\t *\n\t * In some cases we can be sure, that no new locks will be needed\n\t */\n\tif (!(request->fl_flags & FL_ACCESS) &&\n\t    (request->fl_type != F_UNLCK ||\n\t     request->fl_start != 0 || request->fl_end != OFFSET_MAX)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tnew_fl2 = locks_alloc_lock();\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\t/*\n\t * New lock request. Walk all POSIX locks and look for conflicts. If\n\t * there are any, either return error or put the request on the\n\t * blocker's list of waiters and the global blocked_hash.\n\t */\n\tif (request->fl_type != F_UNLCK) {\n\t\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\t\tif (!IS_POSIX(fl))\n\t\t\t\tcontinue;\n\t\t\tif (!posix_locks_conflict(request, fl))\n\t\t\t\tcontinue;\n\t\t\tif (conflock)\n\t\t\t\tlocks_copy_conflock(conflock, fl);\n\t\t\terror = -EAGAIN;\n\t\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Deadlock detection and insertion into the blocked\n\t\t\t * locks list must be done while holding the same lock!\n\t\t\t */\n\t\t\terror = -EDEADLK;\n\t\t\tspin_lock(&blocked_lock_lock);\n\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {\n\t\t\t\terror = FILE_LOCK_DEFERRED;\n\t\t\t\t__locks_insert_block(fl, request);\n\t\t\t}\n\t\t\tspin_unlock(&blocked_lock_lock);\n\t\t\tgoto out;\n  \t\t}\n  \t}\n\n\t/* If we're just looking for a conflict, we're done. */\n\terror = 0;\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\n\t/* Find the first old lock with the same owner as the new lock */\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_same_owner(request, fl))\n\t\t\tbreak;\n\t}\n\n\t/* Process locks with this owner. */\n\tlist_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, fl_list) {\n\t\tif (!posix_same_owner(request, fl))\n\t\t\tbreak;\n\n\t\t/* Detect adjacent or overlapping regions (if same lock type) */\n\t\tif (request->fl_type == fl->fl_type) {\n\t\t\t/* In all comparisons of start vs end, use\n\t\t\t * \"start - 1\" rather than \"end + 1\". If end\n\t\t\t * is OFFSET_MAX, end + 1 will become negative.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start - 1)\n\t\t\t\tcontinue;\n\t\t\t/* If the next lock in the list has entirely bigger\n\t\t\t * addresses than the new one, insert the lock here.\n\t\t\t */\n\t\t\tif (fl->fl_start - 1 > request->fl_end)\n\t\t\t\tbreak;\n\n\t\t\t/* If we come here, the new and old lock are of the\n\t\t\t * same type and adjacent or overlapping. Make one\n\t\t\t * lock yielding from the lower start address of both\n\t\t\t * locks to the higher end address.\n\t\t\t */\n\t\t\tif (fl->fl_start > request->fl_start)\n\t\t\t\tfl->fl_start = request->fl_start;\n\t\t\telse\n\t\t\t\trequest->fl_start = fl->fl_start;\n\t\t\tif (fl->fl_end < request->fl_end)\n\t\t\t\tfl->fl_end = request->fl_end;\n\t\t\telse\n\t\t\t\trequest->fl_end = fl->fl_end;\n\t\t\tif (added) {\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trequest = fl;\n\t\t\tadded = true;\n\t\t} else {\n\t\t\t/* Processing for different lock types is a bit\n\t\t\t * more complex.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start)\n\t\t\t\tcontinue;\n\t\t\tif (fl->fl_start > request->fl_end)\n\t\t\t\tbreak;\n\t\t\tif (request->fl_type == F_UNLCK)\n\t\t\t\tadded = true;\n\t\t\tif (fl->fl_start < request->fl_start)\n\t\t\t\tleft = fl;\n\t\t\t/* If the next lock in the list has a higher end\n\t\t\t * address than the new one, insert the new one here.\n\t\t\t */\n\t\t\tif (fl->fl_end > request->fl_end) {\n\t\t\t\tright = fl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fl->fl_start >= request->fl_start) {\n\t\t\t\t/* The new lock completely replaces an old\n\t\t\t\t * one (This may happen several times).\n\t\t\t\t */\n\t\t\t\tif (added) {\n\t\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Replace the old lock with new_fl, and\n\t\t\t\t * remove the old one. It's safe to do the\n\t\t\t\t * insert here since we know that we won't be\n\t\t\t\t * using new_fl later, and that the lock is\n\t\t\t\t * just replacing an existing lock.\n\t\t\t\t */\n\t\t\t\terror = -ENOLCK;\n\t\t\t\tif (!new_fl)\n\t\t\t\t\tgoto out;\n\t\t\t\tlocks_copy_lock(new_fl, request);\n\t\t\t\trequest = new_fl;\n\t\t\t\tnew_fl = NULL;\n\t\t\t\tlocks_insert_lock_ctx(request, &fl->fl_list);\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The above code only modifies existing locks in case of merging or\n\t * replacing. If new lock(s) need to be inserted all modifications are\n\t * done below this, so it's safe yet to bail out.\n\t */\n\terror = -ENOLCK; /* \"no luck\" */\n\tif (right && left == right && !new_fl2)\n\t\tgoto out;\n\n\terror = 0;\n\tif (!added) {\n\t\tif (request->fl_type == F_UNLCK) {\n\t\t\tif (request->fl_flags & FL_EXISTS)\n\t\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!new_fl) {\n\t\t\terror = -ENOLCK;\n\t\t\tgoto out;\n\t\t}\n\t\tlocks_copy_lock(new_fl, request);\n\t\tlocks_insert_lock_ctx(new_fl, &fl->fl_list);\n\t\tfl = new_fl;\n\t\tnew_fl = NULL;\n\t}\n\tif (right) {\n\t\tif (left == right) {\n\t\t\t/* The new lock breaks the old one in two pieces,\n\t\t\t * so we have to use the second new lock.\n\t\t\t */\n\t\t\tleft = new_fl2;\n\t\t\tnew_fl2 = NULL;\n\t\t\tlocks_copy_lock(left, right);\n\t\t\tlocks_insert_lock_ctx(left, &fl->fl_list);\n\t\t}\n\t\tright->fl_start = request->fl_end + 1;\n\t\tlocks_wake_up_blocks(right);\n\t}\n\tif (left) {\n\t\tleft->fl_end = request->fl_start - 1;\n\t\tlocks_wake_up_blocks(left);\n\t}\n out:\n\tspin_unlock(&ctx->flc_lock);\n\t/*\n\t * Free any unused locks.\n\t */\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tif (new_fl2)\n\t\tlocks_free_lock(new_fl2);\n\tlocks_dispose_list(&dispose);\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic int __posix_lock_file(struct inode *inode, struct file_lock *request, struct file_lock *conflock)\n{\n\tstruct file_lock *fl, *tmp;\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *new_fl2 = NULL;\n\tstruct file_lock *left = NULL;\n\tstruct file_lock *right = NULL;\n\tstruct file_lock_context *ctx;\n\tint error;\n\tbool added = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * We may need two file_lock structures for this operation,\n\t * so we get them in advance to avoid races.\n\t *\n\t * In some cases we can be sure, that no new locks will be needed\n\t */\n\tif (!(request->fl_flags & FL_ACCESS) &&\n\t    (request->fl_type != F_UNLCK ||\n\t     request->fl_start != 0 || request->fl_end != OFFSET_MAX)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tnew_fl2 = locks_alloc_lock();\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\t/*\n\t * New lock request. Walk all POSIX locks and look for conflicts. If\n\t * there are any, either return error or put the request on the\n\t * blocker's list of waiters and the global blocked_hash.\n\t */\n\tif (request->fl_type != F_UNLCK) {\n\t\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\t\tif (!IS_POSIX(fl))\n\t\t\t\tcontinue;\n\t\t\tif (!posix_locks_conflict(request, fl))\n\t\t\t\tcontinue;\n\t\t\tif (conflock)\n\t\t\t\tlocks_copy_conflock(conflock, fl);\n\t\t\terror = -EAGAIN;\n\t\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Deadlock detection and insertion into the blocked\n\t\t\t * locks list must be done while holding the same lock!\n\t\t\t */\n\t\t\terror = -EDEADLK;\n\t\t\tspin_lock(&blocked_lock_lock);\n\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {\n\t\t\t\terror = FILE_LOCK_DEFERRED;\n\t\t\t\t__locks_insert_block(fl, request);\n\t\t\t}\n\t\t\tspin_unlock(&blocked_lock_lock);\n\t\t\tgoto out;\n  \t\t}\n  \t}\n\n\t/* If we're just looking for a conflict, we're done. */\n\terror = 0;\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\n\t/* Find the first old lock with the same owner as the new lock */\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_same_owner(request, fl))\n\t\t\tbreak;\n\t}\n\n\t/* Process locks with this owner. */\n\tlist_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, fl_list) {\n\t\tif (!posix_same_owner(request, fl))\n\t\t\tbreak;\n\n\t\t/* Detect adjacent or overlapping regions (if same lock type) */\n\t\tif (request->fl_type == fl->fl_type) {\n\t\t\t/* In all comparisons of start vs end, use\n\t\t\t * \"start - 1\" rather than \"end + 1\". If end\n\t\t\t * is OFFSET_MAX, end + 1 will become negative.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start - 1)\n\t\t\t\tcontinue;\n\t\t\t/* If the next lock in the list has entirely bigger\n\t\t\t * addresses than the new one, insert the lock here.\n\t\t\t */\n\t\t\tif (fl->fl_start - 1 > request->fl_end)\n\t\t\t\tbreak;\n\n\t\t\t/* If we come here, the new and old lock are of the\n\t\t\t * same type and adjacent or overlapping. Make one\n\t\t\t * lock yielding from the lower start address of both\n\t\t\t * locks to the higher end address.\n\t\t\t */\n\t\t\tif (fl->fl_start > request->fl_start)\n\t\t\t\tfl->fl_start = request->fl_start;\n\t\t\telse\n\t\t\t\trequest->fl_start = fl->fl_start;\n\t\t\tif (fl->fl_end < request->fl_end)\n\t\t\t\tfl->fl_end = request->fl_end;\n\t\t\telse\n\t\t\t\trequest->fl_end = fl->fl_end;\n\t\t\tif (added) {\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trequest = fl;\n\t\t\tadded = true;\n\t\t} else {\n\t\t\t/* Processing for different lock types is a bit\n\t\t\t * more complex.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start)\n\t\t\t\tcontinue;\n\t\t\tif (fl->fl_start > request->fl_end)\n\t\t\t\tbreak;\n\t\t\tif (request->fl_type == F_UNLCK)\n\t\t\t\tadded = true;\n\t\t\tif (fl->fl_start < request->fl_start)\n\t\t\t\tleft = fl;\n\t\t\t/* If the next lock in the list has a higher end\n\t\t\t * address than the new one, insert the new one here.\n\t\t\t */\n\t\t\tif (fl->fl_end > request->fl_end) {\n\t\t\t\tright = fl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fl->fl_start >= request->fl_start) {\n\t\t\t\t/* The new lock completely replaces an old\n\t\t\t\t * one (This may happen several times).\n\t\t\t\t */\n\t\t\t\tif (added) {\n\t\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Replace the old lock with new_fl, and\n\t\t\t\t * remove the old one. It's safe to do the\n\t\t\t\t * insert here since we know that we won't be\n\t\t\t\t * using new_fl later, and that the lock is\n\t\t\t\t * just replacing an existing lock.\n\t\t\t\t */\n\t\t\t\terror = -ENOLCK;\n\t\t\t\tif (!new_fl)\n\t\t\t\t\tgoto out;\n\t\t\t\tlocks_copy_lock(new_fl, request);\n\t\t\t\trequest = new_fl;\n\t\t\t\tnew_fl = NULL;\n\t\t\t\tlocks_insert_lock_ctx(request, &fl->fl_list);\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The above code only modifies existing locks in case of merging or\n\t * replacing. If new lock(s) need to be inserted all modifications are\n\t * done below this, so it's safe yet to bail out.\n\t */\n\terror = -ENOLCK; /* \"no luck\" */\n\tif (right && left == right && !new_fl2)\n\t\tgoto out;\n\n\terror = 0;\n\tif (!added) {\n\t\tif (request->fl_type == F_UNLCK) {\n\t\t\tif (request->fl_flags & FL_EXISTS)\n\t\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!new_fl) {\n\t\t\terror = -ENOLCK;\n\t\t\tgoto out;\n\t\t}\n\t\tlocks_copy_lock(new_fl, request);\n\t\tlocks_insert_lock_ctx(new_fl, &fl->fl_list);\n\t\tfl = new_fl;\n\t\tnew_fl = NULL;\n\t}\n\tif (right) {\n\t\tif (left == right) {\n\t\t\t/* The new lock breaks the old one in two pieces,\n\t\t\t * so we have to use the second new lock.\n\t\t\t */\n\t\t\tleft = new_fl2;\n\t\t\tnew_fl2 = NULL;\n\t\t\tlocks_copy_lock(left, right);\n\t\t\tlocks_insert_lock_ctx(left, &fl->fl_list);\n\t\t}\n\t\tright->fl_start = request->fl_end + 1;\n\t\tlocks_wake_up_blocks(right);\n\t}\n\tif (left) {\n\t\tleft->fl_end = request->fl_start - 1;\n\t\tlocks_wake_up_blocks(left);\n\t}\n out:\n\tspin_unlock(&ctx->flc_lock);\n\t/*\n\t * Free any unused locks.\n\t */\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tif (new_fl2)\n\t\tlocks_free_lock(new_fl2);\n\tlocks_dispose_list(&dispose);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn __posix_lock_file(file_inode(filp), fl, conflock);\n}"
  },
  {
    "function_name": "__posix_lock_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "930-1141",
    "snippet": "static int __posix_lock_file(struct inode *inode, struct file_lock *request, struct file_lock *conflock)\n{\n\tstruct file_lock *fl, *tmp;\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *new_fl2 = NULL;\n\tstruct file_lock *left = NULL;\n\tstruct file_lock *right = NULL;\n\tstruct file_lock_context *ctx;\n\tint error;\n\tbool added = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * We may need two file_lock structures for this operation,\n\t * so we get them in advance to avoid races.\n\t *\n\t * In some cases we can be sure, that no new locks will be needed\n\t */\n\tif (!(request->fl_flags & FL_ACCESS) &&\n\t    (request->fl_type != F_UNLCK ||\n\t     request->fl_start != 0 || request->fl_end != OFFSET_MAX)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tnew_fl2 = locks_alloc_lock();\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\t/*\n\t * New lock request. Walk all POSIX locks and look for conflicts. If\n\t * there are any, either return error or put the request on the\n\t * blocker's list of waiters and the global blocked_hash.\n\t */\n\tif (request->fl_type != F_UNLCK) {\n\t\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\t\tif (!IS_POSIX(fl))\n\t\t\t\tcontinue;\n\t\t\tif (!posix_locks_conflict(request, fl))\n\t\t\t\tcontinue;\n\t\t\tif (conflock)\n\t\t\t\tlocks_copy_conflock(conflock, fl);\n\t\t\terror = -EAGAIN;\n\t\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Deadlock detection and insertion into the blocked\n\t\t\t * locks list must be done while holding the same lock!\n\t\t\t */\n\t\t\terror = -EDEADLK;\n\t\t\tspin_lock(&blocked_lock_lock);\n\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {\n\t\t\t\terror = FILE_LOCK_DEFERRED;\n\t\t\t\t__locks_insert_block(fl, request);\n\t\t\t}\n\t\t\tspin_unlock(&blocked_lock_lock);\n\t\t\tgoto out;\n  \t\t}\n  \t}\n\n\t/* If we're just looking for a conflict, we're done. */\n\terror = 0;\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\n\t/* Find the first old lock with the same owner as the new lock */\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_same_owner(request, fl))\n\t\t\tbreak;\n\t}\n\n\t/* Process locks with this owner. */\n\tlist_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, fl_list) {\n\t\tif (!posix_same_owner(request, fl))\n\t\t\tbreak;\n\n\t\t/* Detect adjacent or overlapping regions (if same lock type) */\n\t\tif (request->fl_type == fl->fl_type) {\n\t\t\t/* In all comparisons of start vs end, use\n\t\t\t * \"start - 1\" rather than \"end + 1\". If end\n\t\t\t * is OFFSET_MAX, end + 1 will become negative.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start - 1)\n\t\t\t\tcontinue;\n\t\t\t/* If the next lock in the list has entirely bigger\n\t\t\t * addresses than the new one, insert the lock here.\n\t\t\t */\n\t\t\tif (fl->fl_start - 1 > request->fl_end)\n\t\t\t\tbreak;\n\n\t\t\t/* If we come here, the new and old lock are of the\n\t\t\t * same type and adjacent or overlapping. Make one\n\t\t\t * lock yielding from the lower start address of both\n\t\t\t * locks to the higher end address.\n\t\t\t */\n\t\t\tif (fl->fl_start > request->fl_start)\n\t\t\t\tfl->fl_start = request->fl_start;\n\t\t\telse\n\t\t\t\trequest->fl_start = fl->fl_start;\n\t\t\tif (fl->fl_end < request->fl_end)\n\t\t\t\tfl->fl_end = request->fl_end;\n\t\t\telse\n\t\t\t\trequest->fl_end = fl->fl_end;\n\t\t\tif (added) {\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trequest = fl;\n\t\t\tadded = true;\n\t\t} else {\n\t\t\t/* Processing for different lock types is a bit\n\t\t\t * more complex.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start)\n\t\t\t\tcontinue;\n\t\t\tif (fl->fl_start > request->fl_end)\n\t\t\t\tbreak;\n\t\t\tif (request->fl_type == F_UNLCK)\n\t\t\t\tadded = true;\n\t\t\tif (fl->fl_start < request->fl_start)\n\t\t\t\tleft = fl;\n\t\t\t/* If the next lock in the list has a higher end\n\t\t\t * address than the new one, insert the new one here.\n\t\t\t */\n\t\t\tif (fl->fl_end > request->fl_end) {\n\t\t\t\tright = fl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fl->fl_start >= request->fl_start) {\n\t\t\t\t/* The new lock completely replaces an old\n\t\t\t\t * one (This may happen several times).\n\t\t\t\t */\n\t\t\t\tif (added) {\n\t\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Replace the old lock with new_fl, and\n\t\t\t\t * remove the old one. It's safe to do the\n\t\t\t\t * insert here since we know that we won't be\n\t\t\t\t * using new_fl later, and that the lock is\n\t\t\t\t * just replacing an existing lock.\n\t\t\t\t */\n\t\t\t\terror = -ENOLCK;\n\t\t\t\tif (!new_fl)\n\t\t\t\t\tgoto out;\n\t\t\t\tlocks_copy_lock(new_fl, request);\n\t\t\t\trequest = new_fl;\n\t\t\t\tnew_fl = NULL;\n\t\t\t\tlocks_insert_lock_ctx(request, &fl->fl_list);\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The above code only modifies existing locks in case of merging or\n\t * replacing. If new lock(s) need to be inserted all modifications are\n\t * done below this, so it's safe yet to bail out.\n\t */\n\terror = -ENOLCK; /* \"no luck\" */\n\tif (right && left == right && !new_fl2)\n\t\tgoto out;\n\n\terror = 0;\n\tif (!added) {\n\t\tif (request->fl_type == F_UNLCK) {\n\t\t\tif (request->fl_flags & FL_EXISTS)\n\t\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!new_fl) {\n\t\t\terror = -ENOLCK;\n\t\t\tgoto out;\n\t\t}\n\t\tlocks_copy_lock(new_fl, request);\n\t\tlocks_insert_lock_ctx(new_fl, &fl->fl_list);\n\t\tfl = new_fl;\n\t\tnew_fl = NULL;\n\t}\n\tif (right) {\n\t\tif (left == right) {\n\t\t\t/* The new lock breaks the old one in two pieces,\n\t\t\t * so we have to use the second new lock.\n\t\t\t */\n\t\t\tleft = new_fl2;\n\t\t\tnew_fl2 = NULL;\n\t\t\tlocks_copy_lock(left, right);\n\t\t\tlocks_insert_lock_ctx(left, &fl->fl_list);\n\t\t}\n\t\tright->fl_start = request->fl_end + 1;\n\t\tlocks_wake_up_blocks(right);\n\t}\n\tif (left) {\n\t\tleft->fl_end = request->fl_start - 1;\n\t\tlocks_wake_up_blocks(left);\n\t}\n out:\n\tspin_unlock(&ctx->flc_lock);\n\t/*\n\t * Free any unused locks.\n\t */\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tif (new_fl2)\n\t\tlocks_free_lock(new_fl2);\n\tlocks_dispose_list(&dispose);\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(blocked_lock_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_dispose_list",
          "args": [
            "&dispose"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "locks_dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "299-309",
          "snippet": "static void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "new_fl2"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "287-296",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_wake_up_blocks",
          "args": [
            "left"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_insert_lock_ctx",
          "args": [
            "left",
            "&fl->fl_list"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "locks_insert_lock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "683-689",
          "snippet": "static void\nlocks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)\n{\n\tfl->fl_nspid = get_pid(task_tgid(current));\n\tlist_add_tail(&fl->fl_list, before);\n\tlocks_insert_global_locks(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)\n{\n\tfl->fl_nspid = get_pid(task_tgid(current));\n\tlist_add_tail(&fl->fl_list, before);\n\tlocks_insert_global_locks(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_copy_lock",
          "args": [
            "left",
            "right"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "locks_copy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "341-355",
          "snippet": "void locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\t/* \"new\" must be a freshly-initialized lock */\n\tWARN_ON_ONCE(new->fl_ops);\n\n\tlocks_copy_conflock(new, fl);\n\n\tnew->fl_file = fl->fl_file;\n\tnew->fl_ops = fl->fl_ops;\n\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_copy_lock)\n\t\t\tfl->fl_ops->fl_copy_lock(new, fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\t/* \"new\" must be a freshly-initialized lock */\n\tWARN_ON_ONCE(new->fl_ops);\n\n\tlocks_copy_conflock(new, fl);\n\n\tnew->fl_file = fl->fl_file;\n\tnew->fl_ops = fl->fl_ops;\n\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_copy_lock)\n\t\t\tfl->fl_ops->fl_copy_lock(new, fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_delete_lock_ctx",
          "args": [
            "fl",
            "&dispose"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_lock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "703-711",
          "snippet": "static void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_same_owner",
          "args": [
            "request",
            "fl"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "posix_same_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "553-559",
          "snippet": "static int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_from",
          "args": [
            "fl",
            "tmp",
            "&ctx->flc_posix",
            "fl_list"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_posix",
            "fl_list"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__locks_insert_block",
          "args": [
            "fl",
            "request"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "__locks_insert_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "632-640",
          "snippet": "static void __locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tBUG_ON(!list_empty(&waiter->fl_block));\n\twaiter->fl_next = blocker;\n\tlist_add_tail(&waiter->fl_block, &blocker->fl_block);\n\tif (IS_POSIX(blocker) && !IS_OFDLCK(blocker))\n\t\tlocks_insert_global_blocked(waiter);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void __locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tBUG_ON(!list_empty(&waiter->fl_block));\n\twaiter->fl_next = blocker;\n\tlist_add_tail(&waiter->fl_block, &blocker->fl_block);\n\tif (IS_POSIX(blocker) && !IS_OFDLCK(blocker))\n\t\tlocks_insert_global_blocked(waiter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!posix_locks_deadlock(request, fl)"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_locks_deadlock",
          "args": [
            "request",
            "fl"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "posix_locks_deadlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "836-855",
          "snippet": "static int posix_locks_deadlock(struct file_lock *caller_fl,\n\t\t\t\tstruct file_lock *block_fl)\n{\n\tint i = 0;\n\n\t/*\n\t * This deadlock detector can't reasonably detect deadlocks with\n\t * FL_OFDLCK locks, since they aren't owned by a process, per-se.\n\t */\n\tif (IS_OFDLCK(caller_fl))\n\t\treturn 0;\n\n\twhile ((block_fl = what_owner_is_waiting_for(block_fl))) {\n\t\tif (i++ > MAX_DEADLK_ITERATIONS)\n\t\t\treturn 0;\n\t\tif (posix_same_owner(caller_fl, block_fl))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define MAX_DEADLK_ITERATIONS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\n#define MAX_DEADLK_ITERATIONS 10\n\nstatic int posix_locks_deadlock(struct file_lock *caller_fl,\n\t\t\t\tstruct file_lock *block_fl)\n{\n\tint i = 0;\n\n\t/*\n\t * This deadlock detector can't reasonably detect deadlocks with\n\t * FL_OFDLCK locks, since they aren't owned by a process, per-se.\n\t */\n\tif (IS_OFDLCK(caller_fl))\n\t\treturn 0;\n\n\twhile ((block_fl = what_owner_is_waiting_for(block_fl))) {\n\t\tif (i++ > MAX_DEADLK_ITERATIONS)\n\t\t\treturn 0;\n\t\tif (posix_same_owner(caller_fl, block_fl))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_copy_conflock",
          "args": [
            "conflock",
            "fl"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "locks_copy_conflock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "322-338",
          "snippet": "void locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\tnew->fl_owner = fl->fl_owner;\n\tnew->fl_pid = fl->fl_pid;\n\tnew->fl_file = NULL;\n\tnew->fl_flags = fl->fl_flags;\n\tnew->fl_type = fl->fl_type;\n\tnew->fl_start = fl->fl_start;\n\tnew->fl_end = fl->fl_end;\n\tnew->fl_lmops = fl->fl_lmops;\n\tnew->fl_ops = NULL;\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_get_owner)\n\t\t\tfl->fl_lmops->lm_get_owner(new, fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\tnew->fl_owner = fl->fl_owner;\n\tnew->fl_pid = fl->fl_pid;\n\tnew->fl_file = NULL;\n\tnew->fl_flags = fl->fl_flags;\n\tnew->fl_type = fl->fl_type;\n\tnew->fl_start = fl->fl_start;\n\tnew->fl_end = fl->fl_end;\n\tnew->fl_lmops = fl->fl_lmops;\n\tnew->fl_ops = NULL;\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_get_owner)\n\t\t\tfl->fl_lmops->lm_get_owner(new, fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_locks_conflict",
          "args": [
            "request",
            "fl"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "posix_locks_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "728-741",
          "snippet": "static int posix_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* POSIX locks owned by the same process do not conflict with\n\t * each other.\n\t */\n\tif (!IS_POSIX(sys_fl) || posix_same_owner(caller_fl, sys_fl))\n\t\treturn (0);\n\n\t/* Check whether they overlap */\n\tif (!locks_overlap(caller_fl, sys_fl))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* POSIX locks owned by the same process do not conflict with\n\t * each other.\n\t */\n\tif (!IS_POSIX(sys_fl) || posix_same_owner(caller_fl, sys_fl))\n\t\treturn (0);\n\n\t/* Check whether they overlap */\n\tif (!locks_overlap(caller_fl, sys_fl))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_POSIX",
          "args": [
            "fl"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_posix",
            "fl_list"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "259-267",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_get_lock_context",
          "args": [
            "inode"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "locks_get_lock_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "205-237",
          "snippet": "static struct file_lock_context *\nlocks_get_lock_context(struct inode *inode)\n{\n\tstruct file_lock_context *new;\n\n\tif (likely(inode->i_flctx))\n\t\tgoto out;\n\n\tnew = kmem_cache_alloc(flctx_cache, GFP_KERNEL);\n\tif (!new)\n\t\tgoto out;\n\n\tspin_lock_init(&new->flc_lock);\n\tINIT_LIST_HEAD(&new->flc_flock);\n\tINIT_LIST_HEAD(&new->flc_posix);\n\tINIT_LIST_HEAD(&new->flc_lease);\n\n\t/*\n\t * Assign the pointer if it's not already assigned. If it is, then\n\t * free the context we just allocated.\n\t */\n\tspin_lock(&inode->i_lock);\n\tif (likely(!inode->i_flctx)) {\n\t\tinode->i_flctx = new;\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (new)\n\t\tkmem_cache_free(flctx_cache, new);\nout:\n\treturn inode->i_flctx;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *flctx_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *flctx_cache;\n\nstatic struct file_lock_context *\nlocks_get_lock_context(struct inode *inode)\n{\n\tstruct file_lock_context *new;\n\n\tif (likely(inode->i_flctx))\n\t\tgoto out;\n\n\tnew = kmem_cache_alloc(flctx_cache, GFP_KERNEL);\n\tif (!new)\n\t\tgoto out;\n\n\tspin_lock_init(&new->flc_lock);\n\tINIT_LIST_HEAD(&new->flc_flock);\n\tINIT_LIST_HEAD(&new->flc_posix);\n\tINIT_LIST_HEAD(&new->flc_lease);\n\n\t/*\n\t * Assign the pointer if it's not already assigned. If it is, then\n\t * free the context we just allocated.\n\t */\n\tspin_lock(&inode->i_lock);\n\tif (likely(!inode->i_flctx)) {\n\t\tinode->i_flctx = new;\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (new)\n\t\tkmem_cache_free(flctx_cache, new);\nout:\n\treturn inode->i_flctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic int __posix_lock_file(struct inode *inode, struct file_lock *request, struct file_lock *conflock)\n{\n\tstruct file_lock *fl, *tmp;\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *new_fl2 = NULL;\n\tstruct file_lock *left = NULL;\n\tstruct file_lock *right = NULL;\n\tstruct file_lock_context *ctx;\n\tint error;\n\tbool added = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * We may need two file_lock structures for this operation,\n\t * so we get them in advance to avoid races.\n\t *\n\t * In some cases we can be sure, that no new locks will be needed\n\t */\n\tif (!(request->fl_flags & FL_ACCESS) &&\n\t    (request->fl_type != F_UNLCK ||\n\t     request->fl_start != 0 || request->fl_end != OFFSET_MAX)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tnew_fl2 = locks_alloc_lock();\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\t/*\n\t * New lock request. Walk all POSIX locks and look for conflicts. If\n\t * there are any, either return error or put the request on the\n\t * blocker's list of waiters and the global blocked_hash.\n\t */\n\tif (request->fl_type != F_UNLCK) {\n\t\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\t\tif (!IS_POSIX(fl))\n\t\t\t\tcontinue;\n\t\t\tif (!posix_locks_conflict(request, fl))\n\t\t\t\tcontinue;\n\t\t\tif (conflock)\n\t\t\t\tlocks_copy_conflock(conflock, fl);\n\t\t\terror = -EAGAIN;\n\t\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Deadlock detection and insertion into the blocked\n\t\t\t * locks list must be done while holding the same lock!\n\t\t\t */\n\t\t\terror = -EDEADLK;\n\t\t\tspin_lock(&blocked_lock_lock);\n\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {\n\t\t\t\terror = FILE_LOCK_DEFERRED;\n\t\t\t\t__locks_insert_block(fl, request);\n\t\t\t}\n\t\t\tspin_unlock(&blocked_lock_lock);\n\t\t\tgoto out;\n  \t\t}\n  \t}\n\n\t/* If we're just looking for a conflict, we're done. */\n\terror = 0;\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\n\t/* Find the first old lock with the same owner as the new lock */\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_same_owner(request, fl))\n\t\t\tbreak;\n\t}\n\n\t/* Process locks with this owner. */\n\tlist_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, fl_list) {\n\t\tif (!posix_same_owner(request, fl))\n\t\t\tbreak;\n\n\t\t/* Detect adjacent or overlapping regions (if same lock type) */\n\t\tif (request->fl_type == fl->fl_type) {\n\t\t\t/* In all comparisons of start vs end, use\n\t\t\t * \"start - 1\" rather than \"end + 1\". If end\n\t\t\t * is OFFSET_MAX, end + 1 will become negative.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start - 1)\n\t\t\t\tcontinue;\n\t\t\t/* If the next lock in the list has entirely bigger\n\t\t\t * addresses than the new one, insert the lock here.\n\t\t\t */\n\t\t\tif (fl->fl_start - 1 > request->fl_end)\n\t\t\t\tbreak;\n\n\t\t\t/* If we come here, the new and old lock are of the\n\t\t\t * same type and adjacent or overlapping. Make one\n\t\t\t * lock yielding from the lower start address of both\n\t\t\t * locks to the higher end address.\n\t\t\t */\n\t\t\tif (fl->fl_start > request->fl_start)\n\t\t\t\tfl->fl_start = request->fl_start;\n\t\t\telse\n\t\t\t\trequest->fl_start = fl->fl_start;\n\t\t\tif (fl->fl_end < request->fl_end)\n\t\t\t\tfl->fl_end = request->fl_end;\n\t\t\telse\n\t\t\t\trequest->fl_end = fl->fl_end;\n\t\t\tif (added) {\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trequest = fl;\n\t\t\tadded = true;\n\t\t} else {\n\t\t\t/* Processing for different lock types is a bit\n\t\t\t * more complex.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start)\n\t\t\t\tcontinue;\n\t\t\tif (fl->fl_start > request->fl_end)\n\t\t\t\tbreak;\n\t\t\tif (request->fl_type == F_UNLCK)\n\t\t\t\tadded = true;\n\t\t\tif (fl->fl_start < request->fl_start)\n\t\t\t\tleft = fl;\n\t\t\t/* If the next lock in the list has a higher end\n\t\t\t * address than the new one, insert the new one here.\n\t\t\t */\n\t\t\tif (fl->fl_end > request->fl_end) {\n\t\t\t\tright = fl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fl->fl_start >= request->fl_start) {\n\t\t\t\t/* The new lock completely replaces an old\n\t\t\t\t * one (This may happen several times).\n\t\t\t\t */\n\t\t\t\tif (added) {\n\t\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Replace the old lock with new_fl, and\n\t\t\t\t * remove the old one. It's safe to do the\n\t\t\t\t * insert here since we know that we won't be\n\t\t\t\t * using new_fl later, and that the lock is\n\t\t\t\t * just replacing an existing lock.\n\t\t\t\t */\n\t\t\t\terror = -ENOLCK;\n\t\t\t\tif (!new_fl)\n\t\t\t\t\tgoto out;\n\t\t\t\tlocks_copy_lock(new_fl, request);\n\t\t\t\trequest = new_fl;\n\t\t\t\tnew_fl = NULL;\n\t\t\t\tlocks_insert_lock_ctx(request, &fl->fl_list);\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The above code only modifies existing locks in case of merging or\n\t * replacing. If new lock(s) need to be inserted all modifications are\n\t * done below this, so it's safe yet to bail out.\n\t */\n\terror = -ENOLCK; /* \"no luck\" */\n\tif (right && left == right && !new_fl2)\n\t\tgoto out;\n\n\terror = 0;\n\tif (!added) {\n\t\tif (request->fl_type == F_UNLCK) {\n\t\t\tif (request->fl_flags & FL_EXISTS)\n\t\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!new_fl) {\n\t\t\terror = -ENOLCK;\n\t\t\tgoto out;\n\t\t}\n\t\tlocks_copy_lock(new_fl, request);\n\t\tlocks_insert_lock_ctx(new_fl, &fl->fl_list);\n\t\tfl = new_fl;\n\t\tnew_fl = NULL;\n\t}\n\tif (right) {\n\t\tif (left == right) {\n\t\t\t/* The new lock breaks the old one in two pieces,\n\t\t\t * so we have to use the second new lock.\n\t\t\t */\n\t\t\tleft = new_fl2;\n\t\t\tnew_fl2 = NULL;\n\t\t\tlocks_copy_lock(left, right);\n\t\t\tlocks_insert_lock_ctx(left, &fl->fl_list);\n\t\t}\n\t\tright->fl_start = request->fl_end + 1;\n\t\tlocks_wake_up_blocks(right);\n\t}\n\tif (left) {\n\t\tleft->fl_end = request->fl_start - 1;\n\t\tlocks_wake_up_blocks(left);\n\t}\n out:\n\tspin_unlock(&ctx->flc_lock);\n\t/*\n\t * Free any unused locks.\n\t */\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tif (new_fl2)\n\t\tlocks_free_lock(new_fl2);\n\tlocks_dispose_list(&dispose);\n\treturn error;\n}"
  },
  {
    "function_name": "flock_lock_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "864-928",
    "snippet": "static int flock_lock_file(struct file *filp, struct file_lock *request)\n{\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *fl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = file_inode(filp);\n\tint error = 0;\n\tbool found = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tif (!(request->fl_flags & FL_ACCESS) && (request->fl_type != F_UNLCK)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tif (!new_fl)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto find_conflict;\n\n\tlist_for_each_entry(fl, &ctx->flc_flock, fl_list) {\n\t\tif (filp != fl->fl_file)\n\t\t\tcontinue;\n\t\tif (request->fl_type == fl->fl_type)\n\t\t\tgoto out;\n\t\tfound = true;\n\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\tbreak;\n\t}\n\n\tif (request->fl_type == F_UNLCK) {\n\t\tif ((request->fl_flags & FL_EXISTS) && !found)\n\t\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\nfind_conflict:\n\tlist_for_each_entry(fl, &ctx->flc_flock, fl_list) {\n\t\tif (!flock_locks_conflict(request, fl))\n\t\t\tcontinue;\n\t\terror = -EAGAIN;\n\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\tgoto out;\n\t\terror = FILE_LOCK_DEFERRED;\n\t\tlocks_insert_block(fl, request);\n\t\tgoto out;\n\t}\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\tlocks_copy_lock(new_fl, request);\n\tlocks_insert_lock_ctx(new_fl, &ctx->flc_flock);\n\tnew_fl = NULL;\n\terror = 0;\n\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tlocks_dispose_list(&dispose);\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_dispose_list",
          "args": [
            "&dispose"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "locks_dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "299-309",
          "snippet": "static void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "new_fl"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "287-296",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_insert_lock_ctx",
          "args": [
            "new_fl",
            "&ctx->flc_flock"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "locks_insert_lock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "683-689",
          "snippet": "static void\nlocks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)\n{\n\tfl->fl_nspid = get_pid(task_tgid(current));\n\tlist_add_tail(&fl->fl_list, before);\n\tlocks_insert_global_locks(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)\n{\n\tfl->fl_nspid = get_pid(task_tgid(current));\n\tlist_add_tail(&fl->fl_list, before);\n\tlocks_insert_global_locks(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_copy_lock",
          "args": [
            "new_fl",
            "request"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "locks_copy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "341-355",
          "snippet": "void locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\t/* \"new\" must be a freshly-initialized lock */\n\tWARN_ON_ONCE(new->fl_ops);\n\n\tlocks_copy_conflock(new, fl);\n\n\tnew->fl_file = fl->fl_file;\n\tnew->fl_ops = fl->fl_ops;\n\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_copy_lock)\n\t\t\tfl->fl_ops->fl_copy_lock(new, fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\t/* \"new\" must be a freshly-initialized lock */\n\tWARN_ON_ONCE(new->fl_ops);\n\n\tlocks_copy_conflock(new, fl);\n\n\tnew->fl_file = fl->fl_file;\n\tnew->fl_ops = fl->fl_ops;\n\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_copy_lock)\n\t\t\tfl->fl_ops->fl_copy_lock(new, fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_insert_block",
          "args": [
            "fl",
            "request"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "locks_insert_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "643-649",
          "snippet": "static void locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_insert_block(blocker, waiter);\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_insert_block(blocker, waiter);\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock_locks_conflict",
          "args": [
            "request",
            "fl"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "flock_locks_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "746-757",
          "snippet": "static int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* FLOCK locks referring to the same filp do not conflict with\n\t * each other.\n\t */\n\tif (!IS_FLOCK(sys_fl) || (caller_fl->fl_file == sys_fl->fl_file))\n\t\treturn (0);\n\tif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* FLOCK locks referring to the same filp do not conflict with\n\t * each other.\n\t */\n\tif (!IS_FLOCK(sys_fl) || (caller_fl->fl_file == sys_fl->fl_file))\n\t\treturn (0);\n\tif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_flock",
            "fl_list"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_delete_lock_ctx",
          "args": [
            "fl",
            "&dispose"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_lock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "703-711",
          "snippet": "static void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_flock",
            "fl_list"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "259-267",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_get_lock_context",
          "args": [
            "inode"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "locks_get_lock_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "205-237",
          "snippet": "static struct file_lock_context *\nlocks_get_lock_context(struct inode *inode)\n{\n\tstruct file_lock_context *new;\n\n\tif (likely(inode->i_flctx))\n\t\tgoto out;\n\n\tnew = kmem_cache_alloc(flctx_cache, GFP_KERNEL);\n\tif (!new)\n\t\tgoto out;\n\n\tspin_lock_init(&new->flc_lock);\n\tINIT_LIST_HEAD(&new->flc_flock);\n\tINIT_LIST_HEAD(&new->flc_posix);\n\tINIT_LIST_HEAD(&new->flc_lease);\n\n\t/*\n\t * Assign the pointer if it's not already assigned. If it is, then\n\t * free the context we just allocated.\n\t */\n\tspin_lock(&inode->i_lock);\n\tif (likely(!inode->i_flctx)) {\n\t\tinode->i_flctx = new;\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (new)\n\t\tkmem_cache_free(flctx_cache, new);\nout:\n\treturn inode->i_flctx;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *flctx_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *flctx_cache;\n\nstatic struct file_lock_context *\nlocks_get_lock_context(struct inode *inode)\n{\n\tstruct file_lock_context *new;\n\n\tif (likely(inode->i_flctx))\n\t\tgoto out;\n\n\tnew = kmem_cache_alloc(flctx_cache, GFP_KERNEL);\n\tif (!new)\n\t\tgoto out;\n\n\tspin_lock_init(&new->flc_lock);\n\tINIT_LIST_HEAD(&new->flc_flock);\n\tINIT_LIST_HEAD(&new->flc_posix);\n\tINIT_LIST_HEAD(&new->flc_lease);\n\n\t/*\n\t * Assign the pointer if it's not already assigned. If it is, then\n\t * free the context we just allocated.\n\t */\n\tspin_lock(&inode->i_lock);\n\tif (likely(!inode->i_flctx)) {\n\t\tinode->i_flctx = new;\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (new)\n\t\tkmem_cache_free(flctx_cache, new);\nout:\n\treturn inode->i_flctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock_lock_file(struct file *filp, struct file_lock *request)\n{\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *fl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = file_inode(filp);\n\tint error = 0;\n\tbool found = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tif (!(request->fl_flags & FL_ACCESS) && (request->fl_type != F_UNLCK)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tif (!new_fl)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto find_conflict;\n\n\tlist_for_each_entry(fl, &ctx->flc_flock, fl_list) {\n\t\tif (filp != fl->fl_file)\n\t\t\tcontinue;\n\t\tif (request->fl_type == fl->fl_type)\n\t\t\tgoto out;\n\t\tfound = true;\n\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\tbreak;\n\t}\n\n\tif (request->fl_type == F_UNLCK) {\n\t\tif ((request->fl_flags & FL_EXISTS) && !found)\n\t\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\nfind_conflict:\n\tlist_for_each_entry(fl, &ctx->flc_flock, fl_list) {\n\t\tif (!flock_locks_conflict(request, fl))\n\t\t\tcontinue;\n\t\terror = -EAGAIN;\n\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\tgoto out;\n\t\terror = FILE_LOCK_DEFERRED;\n\t\tlocks_insert_block(fl, request);\n\t\tgoto out;\n\t}\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\tlocks_copy_lock(new_fl, request);\n\tlocks_insert_lock_ctx(new_fl, &ctx->flc_flock);\n\tnew_fl = NULL;\n\terror = 0;\n\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tlocks_dispose_list(&dispose);\n\treturn error;\n}"
  },
  {
    "function_name": "posix_locks_deadlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "836-855",
    "snippet": "static int posix_locks_deadlock(struct file_lock *caller_fl,\n\t\t\t\tstruct file_lock *block_fl)\n{\n\tint i = 0;\n\n\t/*\n\t * This deadlock detector can't reasonably detect deadlocks with\n\t * FL_OFDLCK locks, since they aren't owned by a process, per-se.\n\t */\n\tif (IS_OFDLCK(caller_fl))\n\t\treturn 0;\n\n\twhile ((block_fl = what_owner_is_waiting_for(block_fl))) {\n\t\tif (i++ > MAX_DEADLK_ITERATIONS)\n\t\t\treturn 0;\n\t\tif (posix_same_owner(caller_fl, block_fl))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define MAX_DEADLK_ITERATIONS 10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_same_owner",
          "args": [
            "caller_fl",
            "block_fl"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "posix_same_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "553-559",
          "snippet": "static int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}"
        }
      },
      {
        "call_info": {
          "callee": "what_owner_is_waiting_for",
          "args": [
            "block_fl"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "what_owner_is_waiting_for",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "824-833",
          "snippet": "static struct file_lock *what_owner_is_waiting_for(struct file_lock *block_fl)\n{\n\tstruct file_lock *fl;\n\n\thash_for_each_possible(blocked_hash, fl, fl_link, posix_owner_key(block_fl)) {\n\t\tif (posix_same_owner(fl, block_fl))\n\t\t\treturn fl->fl_next;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct file_lock *what_owner_is_waiting_for(struct file_lock *block_fl)\n{\n\tstruct file_lock *fl;\n\n\thash_for_each_possible(blocked_hash, fl, fl_link, posix_owner_key(block_fl)) {\n\t\tif (posix_same_owner(fl, block_fl))\n\t\t\treturn fl->fl_next;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_OFDLCK",
          "args": [
            "caller_fl"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\n#define MAX_DEADLK_ITERATIONS 10\n\nstatic int posix_locks_deadlock(struct file_lock *caller_fl,\n\t\t\t\tstruct file_lock *block_fl)\n{\n\tint i = 0;\n\n\t/*\n\t * This deadlock detector can't reasonably detect deadlocks with\n\t * FL_OFDLCK locks, since they aren't owned by a process, per-se.\n\t */\n\tif (IS_OFDLCK(caller_fl))\n\t\treturn 0;\n\n\twhile ((block_fl = what_owner_is_waiting_for(block_fl))) {\n\t\tif (i++ > MAX_DEADLK_ITERATIONS)\n\t\t\treturn 0;\n\t\tif (posix_same_owner(caller_fl, block_fl))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "what_owner_is_waiting_for",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "824-833",
    "snippet": "static struct file_lock *what_owner_is_waiting_for(struct file_lock *block_fl)\n{\n\tstruct file_lock *fl;\n\n\thash_for_each_possible(blocked_hash, fl, fl_link, posix_owner_key(block_fl)) {\n\t\tif (posix_same_owner(fl, block_fl))\n\t\t\treturn fl->fl_next;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_same_owner",
          "args": [
            "fl",
            "block_fl"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "posix_same_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "553-559",
          "snippet": "static int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_for_each_possible",
          "args": [
            "blocked_hash",
            "fl",
            "fl_link",
            "posix_owner_key(block_fl)"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_owner_key",
          "args": [
            "block_fl"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "posix_owner_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "585-591",
          "snippet": "static unsigned long\nposix_owner_key(struct file_lock *fl)\n{\n\tif (fl->fl_lmops && fl->fl_lmops->lm_owner_key)\n\t\treturn fl->fl_lmops->lm_owner_key(fl);\n\treturn (unsigned long)fl->fl_owner;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic unsigned long\nposix_owner_key(struct file_lock *fl)\n{\n\tif (fl->fl_lmops && fl->fl_lmops->lm_owner_key)\n\t\treturn fl->fl_lmops->lm_owner_key(fl);\n\treturn (unsigned long)fl->fl_owner;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct file_lock *what_owner_is_waiting_for(struct file_lock *block_fl)\n{\n\tstruct file_lock *fl;\n\n\thash_for_each_possible(blocked_hash, fl, fl_link, posix_owner_key(block_fl)) {\n\t\tif (posix_same_owner(fl, block_fl))\n\t\t\treturn fl->fl_next;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "posix_test_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "759-785",
    "snippet": "void\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = file_inode(filp);\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_locks_conflict(fl, cfl)) {\n\t\t\tlocks_copy_conflock(fl, cfl);\n\t\t\tif (cfl->fl_nspid)\n\t\t\t\tfl->fl_pid = pid_vnr(cfl->fl_nspid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_vnr",
          "args": [
            "cfl->fl_nspid"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_copy_conflock",
          "args": [
            "fl",
            "cfl"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "locks_copy_conflock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "322-338",
          "snippet": "void locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\tnew->fl_owner = fl->fl_owner;\n\tnew->fl_pid = fl->fl_pid;\n\tnew->fl_file = NULL;\n\tnew->fl_flags = fl->fl_flags;\n\tnew->fl_type = fl->fl_type;\n\tnew->fl_start = fl->fl_start;\n\tnew->fl_end = fl->fl_end;\n\tnew->fl_lmops = fl->fl_lmops;\n\tnew->fl_ops = NULL;\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_get_owner)\n\t\t\tfl->fl_lmops->lm_get_owner(new, fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\tnew->fl_owner = fl->fl_owner;\n\tnew->fl_pid = fl->fl_pid;\n\tnew->fl_file = NULL;\n\tnew->fl_flags = fl->fl_flags;\n\tnew->fl_type = fl->fl_type;\n\tnew->fl_start = fl->fl_start;\n\tnew->fl_end = fl->fl_end;\n\tnew->fl_lmops = fl->fl_lmops;\n\tnew->fl_ops = NULL;\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_get_owner)\n\t\t\tfl->fl_lmops->lm_get_owner(new, fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_locks_conflict",
          "args": [
            "fl",
            "cfl"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "posix_locks_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "728-741",
          "snippet": "static int posix_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* POSIX locks owned by the same process do not conflict with\n\t * each other.\n\t */\n\tif (!IS_POSIX(sys_fl) || posix_same_owner(caller_fl, sys_fl))\n\t\treturn (0);\n\n\t/* Check whether they overlap */\n\tif (!locks_overlap(caller_fl, sys_fl))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* POSIX locks owned by the same process do not conflict with\n\t * each other.\n\t */\n\tif (!IS_POSIX(sys_fl) || posix_same_owner(caller_fl, sys_fl))\n\t\treturn (0);\n\n\t/* Check whether they overlap */\n\tif (!locks_overlap(caller_fl, sys_fl))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cfl",
            "&ctx->flc_posix",
            "fl_list"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&ctx->flc_posix"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = file_inode(filp);\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_locks_conflict(fl, cfl)) {\n\t\t\tlocks_copy_conflock(fl, cfl);\n\t\t\tif (cfl->fl_nspid)\n\t\t\t\tfl->fl_pid = pid_vnr(cfl->fl_nspid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}"
  },
  {
    "function_name": "flock_locks_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "746-757",
    "snippet": "static int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* FLOCK locks referring to the same filp do not conflict with\n\t * each other.\n\t */\n\tif (!IS_FLOCK(sys_fl) || (caller_fl->fl_file == sys_fl->fl_file))\n\t\treturn (0);\n\tif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_conflict",
          "args": [
            "caller_fl",
            "sys_fl"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "flock_locks_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "746-757",
          "snippet": "static int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* FLOCK locks referring to the same filp do not conflict with\n\t * each other.\n\t */\n\tif (!IS_FLOCK(sys_fl) || (caller_fl->fl_file == sys_fl->fl_file))\n\t\treturn (0);\n\tif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "IS_FLOCK",
          "args": [
            "sys_fl"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* FLOCK locks referring to the same filp do not conflict with\n\t * each other.\n\t */\n\tif (!IS_FLOCK(sys_fl) || (caller_fl->fl_file == sys_fl->fl_file))\n\t\treturn (0);\n\tif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}"
  },
  {
    "function_name": "posix_locks_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "728-741",
    "snippet": "static int posix_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* POSIX locks owned by the same process do not conflict with\n\t * each other.\n\t */\n\tif (!IS_POSIX(sys_fl) || posix_same_owner(caller_fl, sys_fl))\n\t\treturn (0);\n\n\t/* Check whether they overlap */\n\tif (!locks_overlap(caller_fl, sys_fl))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_conflict",
          "args": [
            "caller_fl",
            "sys_fl"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "flock_locks_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "746-757",
          "snippet": "static int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* FLOCK locks referring to the same filp do not conflict with\n\t * each other.\n\t */\n\tif (!IS_FLOCK(sys_fl) || (caller_fl->fl_file == sys_fl->fl_file))\n\t\treturn (0);\n\tif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* FLOCK locks referring to the same filp do not conflict with\n\t * each other.\n\t */\n\tif (!IS_FLOCK(sys_fl) || (caller_fl->fl_file == sys_fl->fl_file))\n\t\treturn (0);\n\tif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_overlap",
          "args": [
            "caller_fl",
            "sys_fl"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "locks_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "544-548",
          "snippet": "static inline int locks_overlap(struct file_lock *fl1, struct file_lock *fl2)\n{\n\treturn ((fl1->fl_end >= fl2->fl_start) &&\n\t\t(fl2->fl_end >= fl1->fl_start));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic inline int locks_overlap(struct file_lock *fl1, struct file_lock *fl2)\n{\n\treturn ((fl1->fl_end >= fl2->fl_start) &&\n\t\t(fl2->fl_end >= fl1->fl_start));\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_same_owner",
          "args": [
            "caller_fl",
            "sys_fl"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "posix_same_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "553-559",
          "snippet": "static int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_POSIX",
          "args": [
            "sys_fl"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* POSIX locks owned by the same process do not conflict with\n\t * each other.\n\t */\n\tif (!IS_POSIX(sys_fl) || posix_same_owner(caller_fl, sys_fl))\n\t\treturn (0);\n\n\t/* Check whether they overlap */\n\tif (!locks_overlap(caller_fl, sys_fl))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}"
  },
  {
    "function_name": "locks_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "716-723",
    "snippet": "static int locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\tif (sys_fl->fl_type == F_WRLCK)\n\t\treturn 1;\n\tif (caller_fl->fl_type == F_WRLCK)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\tif (sys_fl->fl_type == F_WRLCK)\n\t\treturn 1;\n\tif (caller_fl->fl_type == F_WRLCK)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "locks_delete_lock_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "703-711",
    "snippet": "static void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "fl"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "287-296",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&fl->fl_list",
            "dispose"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_unlink_lock_ctx",
          "args": [
            "fl"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "locks_unlink_lock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "691-701",
          "snippet": "static void\nlocks_unlink_lock_ctx(struct file_lock *fl)\n{\n\tlocks_delete_global_locks(fl);\n\tlist_del_init(&fl->fl_list);\n\tif (fl->fl_nspid) {\n\t\tput_pid(fl->fl_nspid);\n\t\tfl->fl_nspid = NULL;\n\t}\n\tlocks_wake_up_blocks(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_unlink_lock_ctx(struct file_lock *fl)\n{\n\tlocks_delete_global_locks(fl);\n\tlist_del_init(&fl->fl_list);\n\tif (fl->fl_nspid) {\n\t\tput_pid(fl->fl_nspid);\n\t\tfl->fl_nspid = NULL;\n\t}\n\tlocks_wake_up_blocks(fl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}"
  },
  {
    "function_name": "locks_unlink_lock_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "691-701",
    "snippet": "static void\nlocks_unlink_lock_ctx(struct file_lock *fl)\n{\n\tlocks_delete_global_locks(fl);\n\tlist_del_init(&fl->fl_list);\n\tif (fl->fl_nspid) {\n\t\tput_pid(fl->fl_nspid);\n\t\tfl->fl_nspid = NULL;\n\t}\n\tlocks_wake_up_blocks(fl);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_wake_up_blocks",
          "args": [
            "fl"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "fl->fl_nspid"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&fl->fl_list"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_delete_global_locks",
          "args": [
            "fl"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_global_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "571-583",
          "snippet": "static void locks_delete_global_locks(struct file_lock *fl)\n{\n\t/*\n\t * Avoid taking lock if already unhashed. This is safe since this check\n\t * is done while holding the flc_lock, and new insertions into the list\n\t * also require that it be held.\n\t */\n\tif (hlist_unhashed(&fl->fl_link))\n\t\treturn;\n\tlg_local_lock_cpu(&file_lock_lglock, fl->fl_link_cpu);\n\thlist_del_init(&fl->fl_link);\n\tlg_local_unlock_cpu(&file_lock_lglock, fl->fl_link_cpu);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void locks_delete_global_locks(struct file_lock *fl)\n{\n\t/*\n\t * Avoid taking lock if already unhashed. This is safe since this check\n\t * is done while holding the flc_lock, and new insertions into the list\n\t * also require that it be held.\n\t */\n\tif (hlist_unhashed(&fl->fl_link))\n\t\treturn;\n\tlg_local_lock_cpu(&file_lock_lglock, fl->fl_link_cpu);\n\thlist_del_init(&fl->fl_link);\n\tlg_local_unlock_cpu(&file_lock_lglock, fl->fl_link_cpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_unlink_lock_ctx(struct file_lock *fl)\n{\n\tlocks_delete_global_locks(fl);\n\tlist_del_init(&fl->fl_list);\n\tif (fl->fl_nspid) {\n\t\tput_pid(fl->fl_nspid);\n\t\tfl->fl_nspid = NULL;\n\t}\n\tlocks_wake_up_blocks(fl);\n}"
  },
  {
    "function_name": "locks_insert_lock_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "683-689",
    "snippet": "static void\nlocks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)\n{\n\tfl->fl_nspid = get_pid(task_tgid(current));\n\tlist_add_tail(&fl->fl_list, before);\n\tlocks_insert_global_locks(fl);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_insert_global_locks",
          "args": [
            "fl"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "locks_insert_global_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "562-568",
          "snippet": "static void locks_insert_global_locks(struct file_lock *fl)\n{\n\tlg_local_lock(&file_lock_lglock);\n\tfl->fl_link_cpu = smp_processor_id();\n\thlist_add_head(&fl->fl_link, this_cpu_ptr(&file_lock_list));\n\tlg_local_unlock(&file_lock_lglock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct hlist_head, file_lock_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct hlist_head, file_lock_list);\n\nstatic void locks_insert_global_locks(struct file_lock *fl)\n{\n\tlg_local_lock(&file_lock_lglock);\n\tfl->fl_link_cpu = smp_processor_id();\n\thlist_add_head(&fl->fl_link, this_cpu_ptr(&file_lock_list));\n\tlg_local_unlock(&file_lock_lglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&fl->fl_list",
            "before"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pid",
          "args": [
            "task_tgid(current)"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid",
          "args": [
            "current"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)\n{\n\tfl->fl_nspid = get_pid(task_tgid(current));\n\tlist_add_tail(&fl->fl_list, before);\n\tlocks_insert_global_locks(fl);\n}"
  },
  {
    "function_name": "locks_wake_up_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "656-681",
    "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(blocked_lock_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&waiter->fl_wait"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "waiter->fl_lmops->lm_notify",
          "args": [
            "waiter"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__locks_delete_block",
          "args": [
            "waiter"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "__locks_delete_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "608-613",
          "snippet": "static void __locks_delete_block(struct file_lock *waiter)\n{\n\tlocks_delete_global_blocked(waiter);\n\tlist_del_init(&waiter->fl_block);\n\twaiter->fl_next = NULL;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void __locks_delete_block(struct file_lock *waiter)\n{\n\tlocks_delete_global_blocked(waiter);\n\tlist_del_init(&waiter->fl_block);\n\twaiter->fl_next = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&blocker->fl_block",
            "structfile_lock",
            "fl_block"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&blocker->fl_block"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
  },
  {
    "function_name": "locks_insert_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "643-649",
    "snippet": "static void locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_insert_block(blocker, waiter);\n\tspin_unlock(&blocked_lock_lock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(blocked_lock_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__locks_insert_block",
          "args": [
            "blocker",
            "waiter"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "__locks_insert_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "632-640",
          "snippet": "static void __locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tBUG_ON(!list_empty(&waiter->fl_block));\n\twaiter->fl_next = blocker;\n\tlist_add_tail(&waiter->fl_block, &blocker->fl_block);\n\tif (IS_POSIX(blocker) && !IS_OFDLCK(blocker))\n\t\tlocks_insert_global_blocked(waiter);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void __locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tBUG_ON(!list_empty(&waiter->fl_block));\n\twaiter->fl_next = blocker;\n\tlist_add_tail(&waiter->fl_block, &blocker->fl_block);\n\tif (IS_POSIX(blocker) && !IS_OFDLCK(blocker))\n\t\tlocks_insert_global_blocked(waiter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_insert_block(blocker, waiter);\n\tspin_unlock(&blocked_lock_lock);\n}"
  },
  {
    "function_name": "__locks_insert_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "632-640",
    "snippet": "static void __locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tBUG_ON(!list_empty(&waiter->fl_block));\n\twaiter->fl_next = blocker;\n\tlist_add_tail(&waiter->fl_block, &blocker->fl_block);\n\tif (IS_POSIX(blocker) && !IS_OFDLCK(blocker))\n\t\tlocks_insert_global_blocked(waiter);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_insert_global_blocked",
          "args": [
            "waiter"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "locks_insert_global_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "593-596",
          "snippet": "static void locks_insert_global_blocked(struct file_lock *waiter)\n{\n\thash_add(blocked_hash, &waiter->fl_link, posix_owner_key(waiter));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void locks_insert_global_blocked(struct file_lock *waiter)\n{\n\thash_add(blocked_hash, &waiter->fl_link, posix_owner_key(waiter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_OFDLCK",
          "args": [
            "blocker"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_POSIX",
          "args": [
            "blocker"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&waiter->fl_block",
            "&blocker->fl_block"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&waiter->fl_block)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&waiter->fl_block"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void __locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tBUG_ON(!list_empty(&waiter->fl_block));\n\twaiter->fl_next = blocker;\n\tlist_add_tail(&waiter->fl_block, &blocker->fl_block);\n\tif (IS_POSIX(blocker) && !IS_OFDLCK(blocker))\n\t\tlocks_insert_global_blocked(waiter);\n}"
  },
  {
    "function_name": "locks_delete_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "615-620",
    "snippet": "static void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(blocked_lock_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__locks_delete_block",
          "args": [
            "waiter"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "__locks_delete_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "608-613",
          "snippet": "static void __locks_delete_block(struct file_lock *waiter)\n{\n\tlocks_delete_global_blocked(waiter);\n\tlist_del_init(&waiter->fl_block);\n\twaiter->fl_next = NULL;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void __locks_delete_block(struct file_lock *waiter)\n{\n\tlocks_delete_global_blocked(waiter);\n\tlist_del_init(&waiter->fl_block);\n\twaiter->fl_next = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}"
  },
  {
    "function_name": "__locks_delete_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "608-613",
    "snippet": "static void __locks_delete_block(struct file_lock *waiter)\n{\n\tlocks_delete_global_blocked(waiter);\n\tlist_del_init(&waiter->fl_block);\n\twaiter->fl_next = NULL;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&waiter->fl_block"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_delete_global_blocked",
          "args": [
            "waiter"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_global_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "598-601",
          "snippet": "static void locks_delete_global_blocked(struct file_lock *waiter)\n{\n\thash_del(&waiter->fl_link);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void locks_delete_global_blocked(struct file_lock *waiter)\n{\n\thash_del(&waiter->fl_link);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void __locks_delete_block(struct file_lock *waiter)\n{\n\tlocks_delete_global_blocked(waiter);\n\tlist_del_init(&waiter->fl_block);\n\twaiter->fl_next = NULL;\n}"
  },
  {
    "function_name": "locks_delete_global_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "598-601",
    "snippet": "static void locks_delete_global_blocked(struct file_lock *waiter)\n{\n\thash_del(&waiter->fl_link);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_del",
          "args": [
            "&waiter->fl_link"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_delegation_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "695-710",
          "snippet": "static void\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void locks_delete_global_blocked(struct file_lock *waiter)\n{\n\thash_del(&waiter->fl_link);\n}"
  },
  {
    "function_name": "locks_insert_global_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "593-596",
    "snippet": "static void locks_insert_global_blocked(struct file_lock *waiter)\n{\n\thash_add(blocked_hash, &waiter->fl_link, posix_owner_key(waiter));\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_add",
          "args": [
            "blocked_hash",
            "&waiter->fl_link",
            "posix_owner_key(waiter)"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_owner_key",
          "args": [
            "waiter"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "posix_owner_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "585-591",
          "snippet": "static unsigned long\nposix_owner_key(struct file_lock *fl)\n{\n\tif (fl->fl_lmops && fl->fl_lmops->lm_owner_key)\n\t\treturn fl->fl_lmops->lm_owner_key(fl);\n\treturn (unsigned long)fl->fl_owner;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic unsigned long\nposix_owner_key(struct file_lock *fl)\n{\n\tif (fl->fl_lmops && fl->fl_lmops->lm_owner_key)\n\t\treturn fl->fl_lmops->lm_owner_key(fl);\n\treturn (unsigned long)fl->fl_owner;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void locks_insert_global_blocked(struct file_lock *waiter)\n{\n\thash_add(blocked_hash, &waiter->fl_link, posix_owner_key(waiter));\n}"
  },
  {
    "function_name": "posix_owner_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "585-591",
    "snippet": "static unsigned long\nposix_owner_key(struct file_lock *fl)\n{\n\tif (fl->fl_lmops && fl->fl_lmops->lm_owner_key)\n\t\treturn fl->fl_lmops->lm_owner_key(fl);\n\treturn (unsigned long)fl->fl_owner;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fl->fl_lmops->lm_owner_key",
          "args": [
            "fl"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic unsigned long\nposix_owner_key(struct file_lock *fl)\n{\n\tif (fl->fl_lmops && fl->fl_lmops->lm_owner_key)\n\t\treturn fl->fl_lmops->lm_owner_key(fl);\n\treturn (unsigned long)fl->fl_owner;\n}"
  },
  {
    "function_name": "locks_delete_global_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "571-583",
    "snippet": "static void locks_delete_global_locks(struct file_lock *fl)\n{\n\t/*\n\t * Avoid taking lock if already unhashed. This is safe since this check\n\t * is done while holding the flc_lock, and new insertions into the list\n\t * also require that it be held.\n\t */\n\tif (hlist_unhashed(&fl->fl_link))\n\t\treturn;\n\tlg_local_lock_cpu(&file_lock_lglock, fl->fl_link_cpu);\n\thlist_del_init(&fl->fl_link);\n\tlg_local_unlock_cpu(&file_lock_lglock, fl->fl_link_cpu);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lg_local_unlock_cpu",
          "args": [
            "&file_lock_lglock",
            "fl->fl_link_cpu"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&fl->fl_link"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lg_local_lock_cpu",
          "args": [
            "&file_lock_lglock",
            "fl->fl_link_cpu"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&fl->fl_link"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void locks_delete_global_locks(struct file_lock *fl)\n{\n\t/*\n\t * Avoid taking lock if already unhashed. This is safe since this check\n\t * is done while holding the flc_lock, and new insertions into the list\n\t * also require that it be held.\n\t */\n\tif (hlist_unhashed(&fl->fl_link))\n\t\treturn;\n\tlg_local_lock_cpu(&file_lock_lglock, fl->fl_link_cpu);\n\thlist_del_init(&fl->fl_link);\n\tlg_local_unlock_cpu(&file_lock_lglock, fl->fl_link_cpu);\n}"
  },
  {
    "function_name": "locks_insert_global_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "562-568",
    "snippet": "static void locks_insert_global_locks(struct file_lock *fl)\n{\n\tlg_local_lock(&file_lock_lglock);\n\tfl->fl_link_cpu = smp_processor_id();\n\thlist_add_head(&fl->fl_link, this_cpu_ptr(&file_lock_list));\n\tlg_local_unlock(&file_lock_lglock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct hlist_head, file_lock_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lg_local_unlock",
          "args": [
            "&file_lock_lglock"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&fl->fl_link",
            "this_cpu_ptr(&file_lock_list)"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&file_lock_list"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lg_local_lock",
          "args": [
            "&file_lock_lglock"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct hlist_head, file_lock_list);\n\nstatic void locks_insert_global_locks(struct file_lock *fl)\n{\n\tlg_local_lock(&file_lock_lglock);\n\tfl->fl_link_cpu = smp_processor_id();\n\thlist_add_head(&fl->fl_link, this_cpu_ptr(&file_lock_list));\n\tlg_local_unlock(&file_lock_lglock);\n}"
  },
  {
    "function_name": "posix_same_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "553-559",
    "snippet": "static int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fl1->fl_lmops->lm_compare_owner",
          "args": [
            "fl1",
            "fl2"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}"
  },
  {
    "function_name": "locks_overlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "544-548",
    "snippet": "static inline int locks_overlap(struct file_lock *fl1, struct file_lock *fl2)\n{\n\treturn ((fl1->fl_end >= fl2->fl_start) &&\n\t\t(fl2->fl_end >= fl1->fl_start));\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic inline int locks_overlap(struct file_lock *fl1, struct file_lock *fl2)\n{\n\treturn ((fl1->fl_end >= fl2->fl_start) &&\n\t\t(fl2->fl_end >= fl1->fl_start));\n}"
  },
  {
    "function_name": "lease_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "526-540",
    "snippet": "static struct file_lock *lease_alloc(struct file *filp, long type)\n{\n\tstruct file_lock *fl = locks_alloc_lock();\n\tint error = -ENOMEM;\n\n\tif (fl == NULL)\n\t\treturn ERR_PTR(error);\n\n\terror = lease_init(filp, type, fl);\n\tif (error) {\n\t\tlocks_free_lock(fl);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn fl;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "fl"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "287-296",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lease_init",
          "args": [
            "filp",
            "type",
            "fl"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "lease_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "508-523",
          "snippet": "static int lease_init(struct file *filp, long type, struct file_lock *fl)\n {\n\tif (assign_type(fl, type) != 0)\n\t\treturn -EINVAL;\n\n\tfl->fl_owner = filp;\n\tfl->fl_pid = current->tgid;\n\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_LEASE;\n\tfl->fl_start = 0;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = &lease_manager_ops;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct lock_manager_operations lease_manager_ops = {\n\t.lm_break = lease_break_callback,\n\t.lm_change = lease_modify,\n\t.lm_setup = lease_setup,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic const struct lock_manager_operations lease_manager_ops = {\n\t.lm_break = lease_break_callback,\n\t.lm_change = lease_modify,\n\t.lm_setup = lease_setup,\n};\n\nstatic int lease_init(struct file *filp, long type, struct file_lock *fl)\n {\n\tif (assign_type(fl, type) != 0)\n\t\treturn -EINVAL;\n\n\tfl->fl_owner = filp;\n\tfl->fl_pid = current->tgid;\n\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_LEASE;\n\tfl->fl_start = 0;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = &lease_manager_ops;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "259-267",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct file_lock *lease_alloc(struct file *filp, long type)\n{\n\tstruct file_lock *fl = locks_alloc_lock();\n\tint error = -ENOMEM;\n\n\tif (fl == NULL)\n\t\treturn ERR_PTR(error);\n\n\terror = lease_init(filp, type, fl);\n\tif (error) {\n\t\tlocks_free_lock(fl);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn fl;\n}"
  },
  {
    "function_name": "lease_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "508-523",
    "snippet": "static int lease_init(struct file *filp, long type, struct file_lock *fl)\n {\n\tif (assign_type(fl, type) != 0)\n\t\treturn -EINVAL;\n\n\tfl->fl_owner = filp;\n\tfl->fl_pid = current->tgid;\n\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_LEASE;\n\tfl->fl_start = 0;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = &lease_manager_ops;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct lock_manager_operations lease_manager_ops = {\n\t.lm_break = lease_break_callback,\n\t.lm_change = lease_modify,\n\t.lm_setup = lease_setup,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assign_type",
          "args": [
            "fl",
            "type"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "assign_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "397-409",
          "snippet": "static int assign_type(struct file_lock *fl, long type)\n{\n\tswitch (type) {\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\tcase F_UNLCK:\n\t\tfl->fl_type = type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int assign_type(struct file_lock *fl, long type)\n{\n\tswitch (type) {\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\tcase F_UNLCK:\n\t\tfl->fl_type = type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic const struct lock_manager_operations lease_manager_ops = {\n\t.lm_break = lease_break_callback,\n\t.lm_change = lease_modify,\n\t.lm_setup = lease_setup,\n};\n\nstatic int lease_init(struct file *filp, long type, struct file_lock *fl)\n {\n\tif (assign_type(fl, type) != 0)\n\t\treturn -EINVAL;\n\n\tfl->fl_owner = filp;\n\tfl->fl_pid = current->tgid;\n\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_LEASE;\n\tfl->fl_start = 0;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = &lease_manager_ops;\n\treturn 0;\n}"
  },
  {
    "function_name": "lease_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "482-497",
    "snippet": "static void\nlease_setup(struct file_lock *fl, void **priv)\n{\n\tstruct file *filp = fl->fl_file;\n\tstruct fasync_struct *fa = *priv;\n\n\t/*\n\t * fasync_insert_entry() returns the old entry if any. If there was no\n\t * old entry, then it used \"priv\" and inserted it into the fasync list.\n\t * Clear the pointer to indicate that it shouldn't be freed.\n\t */\n\tif (!fasync_insert_entry(fa->fa_fd, filp, &fl->fl_fasync, fa))\n\t\t*priv = NULL;\n\n\t__f_setown(filp, task_pid(current), PIDTYPE_PID, 0);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__f_setown",
          "args": [
            "filp",
            "task_pid(current)",
            "PIDTYPE_PID",
            "0"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "__f_setown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "101-106",
          "snippet": "void __f_setown(struct file *filp, struct pid *pid, enum pid_type type,\n\t\tint force)\n{\n\tsecurity_file_set_fowner(filp);\n\tf_modown(filp, pid, type, force);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid __f_setown(struct file *filp, struct pid *pid, enum pid_type type,\n\t\tint force)\n{\n\tsecurity_file_set_fowner(filp);\n\tf_modown(filp, pid, type, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid",
          "args": [
            "current"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fasync_insert_entry",
          "args": [
            "fa->fa_fd",
            "filp",
            "&fl->fl_fasync",
            "fa"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "fasync_insert_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "623-651",
          "snippet": "struct fasync_struct *fasync_insert_entry(int fd, struct file *filp, struct fasync_struct **fapp, struct fasync_struct *new)\n{\n        struct fasync_struct *fa, **fp;\n\n\tspin_lock(&filp->f_lock);\n\tspin_lock(&fasync_lock);\n\tfor (fp = fapp; (fa = *fp) != NULL; fp = &fa->fa_next) {\n\t\tif (fa->fa_file != filp)\n\t\t\tcontinue;\n\n\t\tspin_lock_irq(&fa->fa_lock);\n\t\tfa->fa_fd = fd;\n\t\tspin_unlock_irq(&fa->fa_lock);\n\t\tgoto out;\n\t}\n\n\tspin_lock_init(&new->fa_lock);\n\tnew->magic = FASYNC_MAGIC;\n\tnew->fa_file = filp;\n\tnew->fa_fd = fd;\n\tnew->fa_next = *fapp;\n\trcu_assign_pointer(*fapp, new);\n\tfilp->f_flags |= FASYNC;\n\nout:\n\tspin_unlock(&fasync_lock);\n\tspin_unlock(&filp->f_lock);\n\treturn fa;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(fasync_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_SPINLOCK(fasync_lock);\n\nstruct fasync_struct *fasync_insert_entry(int fd, struct file *filp, struct fasync_struct **fapp, struct fasync_struct *new)\n{\n        struct fasync_struct *fa, **fp;\n\n\tspin_lock(&filp->f_lock);\n\tspin_lock(&fasync_lock);\n\tfor (fp = fapp; (fa = *fp) != NULL; fp = &fa->fa_next) {\n\t\tif (fa->fa_file != filp)\n\t\t\tcontinue;\n\n\t\tspin_lock_irq(&fa->fa_lock);\n\t\tfa->fa_fd = fd;\n\t\tspin_unlock_irq(&fa->fa_lock);\n\t\tgoto out;\n\t}\n\n\tspin_lock_init(&new->fa_lock);\n\tnew->magic = FASYNC_MAGIC;\n\tnew->fa_file = filp;\n\tnew->fa_fd = fd;\n\tnew->fa_next = *fapp;\n\trcu_assign_pointer(*fapp, new);\n\tfilp->f_flags |= FASYNC;\n\nout:\n\tspin_unlock(&fasync_lock);\n\tspin_unlock(&filp->f_lock);\n\treturn fa;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlease_setup(struct file_lock *fl, void **priv)\n{\n\tstruct file *filp = fl->fl_file;\n\tstruct fasync_struct *fa = *priv;\n\n\t/*\n\t * fasync_insert_entry() returns the old entry if any. If there was no\n\t * old entry, then it used \"priv\" and inserted it into the fasync list.\n\t * Clear the pointer to indicate that it shouldn't be freed.\n\t */\n\tif (!fasync_insert_entry(fa->fa_fd, filp, &fl->fl_fasync, fa))\n\t\t*priv = NULL;\n\n\t__f_setown(filp, task_pid(current), PIDTYPE_PID, 0);\n}"
  },
  {
    "function_name": "lease_break_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "475-480",
    "snippet": "static bool\nlease_break_callback(struct file_lock *fl)\n{\n\tkill_fasync(&fl->fl_fasync, SIGIO, POLL_MSG);\n\treturn false;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&fl->fl_fasync",
            "SIGIO",
            "POLL_MSG"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "723-733",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic bool\nlease_break_callback(struct file_lock *fl)\n{\n\tkill_fasync(&fl->fl_fasync, SIGIO, POLL_MSG);\n\treturn false;\n}"
  },
  {
    "function_name": "flock_to_posix_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "461-472",
    "snippet": "static int flock_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t       struct flock *l)\n{\n\tstruct flock64 ll = {\n\t\t.l_type = l->l_type,\n\t\t.l_whence = l->l_whence,\n\t\t.l_start = l->l_start,\n\t\t.l_len = l->l_len,\n\t};\n\n\treturn flock64_to_posix_lock(filp, fl, &ll);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flock64_to_posix_lock",
          "args": [
            "filp",
            "fl",
            "&ll"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "flock64_to_posix_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "411-456",
          "snippet": "static int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t\t struct flock64 *l)\n{\n\tswitch (l->l_whence) {\n\tcase SEEK_SET:\n\t\tfl->fl_start = 0;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tfl->fl_start = filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tfl->fl_start = i_size_read(file_inode(filp));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (l->l_start > OFFSET_MAX - fl->fl_start)\n\t\treturn -EOVERFLOW;\n\tfl->fl_start += l->l_start;\n\tif (fl->fl_start < 0)\n\t\treturn -EINVAL;\n\n\t/* POSIX-1996 leaves the case l->l_len < 0 undefined;\n\t   POSIX-2001 defines it. */\n\tif (l->l_len > 0) {\n\t\tif (l->l_len - 1 > OFFSET_MAX - fl->fl_start)\n\t\t\treturn -EOVERFLOW;\n\t\tfl->fl_end = fl->fl_start + l->l_len - 1;\n\n\t} else if (l->l_len < 0) {\n\t\tif (fl->fl_start + l->l_len < 0)\n\t\t\treturn -EINVAL;\n\t\tfl->fl_end = fl->fl_start - 1;\n\t\tfl->fl_start += l->l_len;\n\t} else\n\t\tfl->fl_end = OFFSET_MAX;\n\n\tfl->fl_owner = current->files;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\n\treturn assign_type(fl, l->l_type);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t\t struct flock64 *l)\n{\n\tswitch (l->l_whence) {\n\tcase SEEK_SET:\n\t\tfl->fl_start = 0;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tfl->fl_start = filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tfl->fl_start = i_size_read(file_inode(filp));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (l->l_start > OFFSET_MAX - fl->fl_start)\n\t\treturn -EOVERFLOW;\n\tfl->fl_start += l->l_start;\n\tif (fl->fl_start < 0)\n\t\treturn -EINVAL;\n\n\t/* POSIX-1996 leaves the case l->l_len < 0 undefined;\n\t   POSIX-2001 defines it. */\n\tif (l->l_len > 0) {\n\t\tif (l->l_len - 1 > OFFSET_MAX - fl->fl_start)\n\t\t\treturn -EOVERFLOW;\n\t\tfl->fl_end = fl->fl_start + l->l_len - 1;\n\n\t} else if (l->l_len < 0) {\n\t\tif (fl->fl_start + l->l_len < 0)\n\t\t\treturn -EINVAL;\n\t\tfl->fl_end = fl->fl_start - 1;\n\t\tfl->fl_start += l->l_len;\n\t} else\n\t\tfl->fl_end = OFFSET_MAX;\n\n\tfl->fl_owner = current->files;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\n\treturn assign_type(fl, l->l_type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t       struct flock *l)\n{\n\tstruct flock64 ll = {\n\t\t.l_type = l->l_type,\n\t\t.l_whence = l->l_whence,\n\t\t.l_start = l->l_start,\n\t\t.l_len = l->l_len,\n\t};\n\n\treturn flock64_to_posix_lock(filp, fl, &ll);\n}"
  },
  {
    "function_name": "flock64_to_posix_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "411-456",
    "snippet": "static int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t\t struct flock64 *l)\n{\n\tswitch (l->l_whence) {\n\tcase SEEK_SET:\n\t\tfl->fl_start = 0;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tfl->fl_start = filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tfl->fl_start = i_size_read(file_inode(filp));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (l->l_start > OFFSET_MAX - fl->fl_start)\n\t\treturn -EOVERFLOW;\n\tfl->fl_start += l->l_start;\n\tif (fl->fl_start < 0)\n\t\treturn -EINVAL;\n\n\t/* POSIX-1996 leaves the case l->l_len < 0 undefined;\n\t   POSIX-2001 defines it. */\n\tif (l->l_len > 0) {\n\t\tif (l->l_len - 1 > OFFSET_MAX - fl->fl_start)\n\t\t\treturn -EOVERFLOW;\n\t\tfl->fl_end = fl->fl_start + l->l_len - 1;\n\n\t} else if (l->l_len < 0) {\n\t\tif (fl->fl_start + l->l_len < 0)\n\t\t\treturn -EINVAL;\n\t\tfl->fl_end = fl->fl_start - 1;\n\t\tfl->fl_start += l->l_len;\n\t} else\n\t\tfl->fl_end = OFFSET_MAX;\n\n\tfl->fl_owner = current->files;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\n\treturn assign_type(fl, l->l_type);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assign_type",
          "args": [
            "fl",
            "l->l_type"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "assign_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "397-409",
          "snippet": "static int assign_type(struct file_lock *fl, long type)\n{\n\tswitch (type) {\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\tcase F_UNLCK:\n\t\tfl->fl_type = type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int assign_type(struct file_lock *fl, long type)\n{\n\tswitch (type) {\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\tcase F_UNLCK:\n\t\tfl->fl_type = type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "file_inode(filp)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t\t struct flock64 *l)\n{\n\tswitch (l->l_whence) {\n\tcase SEEK_SET:\n\t\tfl->fl_start = 0;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tfl->fl_start = filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tfl->fl_start = i_size_read(file_inode(filp));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (l->l_start > OFFSET_MAX - fl->fl_start)\n\t\treturn -EOVERFLOW;\n\tfl->fl_start += l->l_start;\n\tif (fl->fl_start < 0)\n\t\treturn -EINVAL;\n\n\t/* POSIX-1996 leaves the case l->l_len < 0 undefined;\n\t   POSIX-2001 defines it. */\n\tif (l->l_len > 0) {\n\t\tif (l->l_len - 1 > OFFSET_MAX - fl->fl_start)\n\t\t\treturn -EOVERFLOW;\n\t\tfl->fl_end = fl->fl_start + l->l_len - 1;\n\n\t} else if (l->l_len < 0) {\n\t\tif (fl->fl_start + l->l_len < 0)\n\t\t\treturn -EINVAL;\n\t\tfl->fl_end = fl->fl_start - 1;\n\t\tfl->fl_start += l->l_len;\n\t} else\n\t\tfl->fl_end = OFFSET_MAX;\n\n\tfl->fl_owner = current->files;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\n\treturn assign_type(fl, l->l_type);\n}"
  },
  {
    "function_name": "assign_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "397-409",
    "snippet": "static int assign_type(struct file_lock *fl, long type)\n{\n\tswitch (type) {\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\tcase F_UNLCK:\n\t\tfl->fl_type = type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int assign_type(struct file_lock *fl, long type)\n{\n\tswitch (type) {\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\tcase F_UNLCK:\n\t\tfl->fl_type = type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "flock_make_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "374-395",
    "snippet": "static struct file_lock *\nflock_make_lock(struct file *filp, unsigned int cmd)\n{\n\tstruct file_lock *fl;\n\tint type = flock_translate_cmd(cmd);\n\n\tif (type < 0)\n\t\treturn ERR_PTR(type);\n\t\n\tfl = locks_alloc_lock();\n\tif (fl == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfl->fl_file = filp;\n\tfl->fl_owner = filp;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_flags = FL_FLOCK;\n\tfl->fl_type = type;\n\tfl->fl_end = OFFSET_MAX;\n\t\n\treturn fl;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "259-267",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "type"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flock_translate_cmd",
          "args": [
            "cmd"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "flock_translate_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "359-371",
          "snippet": "static inline int flock_translate_cmd(int cmd) {\n\tif (cmd & LOCK_MAND)\n\t\treturn cmd & (LOCK_MAND | LOCK_RW);\n\tswitch (cmd) {\n\tcase LOCK_SH:\n\t\treturn F_RDLCK;\n\tcase LOCK_EX:\n\t\treturn F_WRLCK;\n\tcase LOCK_UN:\n\t\treturn F_UNLCK;\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic inline int flock_translate_cmd(int cmd) {\n\tif (cmd & LOCK_MAND)\n\t\treturn cmd & (LOCK_MAND | LOCK_RW);\n\tswitch (cmd) {\n\tcase LOCK_SH:\n\t\treturn F_RDLCK;\n\tcase LOCK_EX:\n\t\treturn F_WRLCK;\n\tcase LOCK_UN:\n\t\treturn F_UNLCK;\n\t}\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct file_lock *\nflock_make_lock(struct file *filp, unsigned int cmd)\n{\n\tstruct file_lock *fl;\n\tint type = flock_translate_cmd(cmd);\n\n\tif (type < 0)\n\t\treturn ERR_PTR(type);\n\t\n\tfl = locks_alloc_lock();\n\tif (fl == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfl->fl_file = filp;\n\tfl->fl_owner = filp;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_flags = FL_FLOCK;\n\tfl->fl_type = type;\n\tfl->fl_end = OFFSET_MAX;\n\t\n\treturn fl;\n}"
  },
  {
    "function_name": "flock_translate_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "359-371",
    "snippet": "static inline int flock_translate_cmd(int cmd) {\n\tif (cmd & LOCK_MAND)\n\t\treturn cmd & (LOCK_MAND | LOCK_RW);\n\tswitch (cmd) {\n\tcase LOCK_SH:\n\t\treturn F_RDLCK;\n\tcase LOCK_EX:\n\t\treturn F_WRLCK;\n\tcase LOCK_UN:\n\t\treturn F_UNLCK;\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic inline int flock_translate_cmd(int cmd) {\n\tif (cmd & LOCK_MAND)\n\t\treturn cmd & (LOCK_MAND | LOCK_RW);\n\tswitch (cmd) {\n\tcase LOCK_SH:\n\t\treturn F_RDLCK;\n\tcase LOCK_EX:\n\t\treturn F_WRLCK;\n\tcase LOCK_UN:\n\t\treturn F_UNLCK;\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "locks_copy_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "341-355",
    "snippet": "void locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\t/* \"new\" must be a freshly-initialized lock */\n\tWARN_ON_ONCE(new->fl_ops);\n\n\tlocks_copy_conflock(new, fl);\n\n\tnew->fl_file = fl->fl_file;\n\tnew->fl_ops = fl->fl_ops;\n\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_copy_lock)\n\t\t\tfl->fl_ops->fl_copy_lock(new, fl);\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fl->fl_ops->fl_copy_lock",
          "args": [
            "new",
            "fl"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_copy_conflock",
          "args": [
            "new",
            "fl"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "locks_copy_conflock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "322-338",
          "snippet": "void locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\tnew->fl_owner = fl->fl_owner;\n\tnew->fl_pid = fl->fl_pid;\n\tnew->fl_file = NULL;\n\tnew->fl_flags = fl->fl_flags;\n\tnew->fl_type = fl->fl_type;\n\tnew->fl_start = fl->fl_start;\n\tnew->fl_end = fl->fl_end;\n\tnew->fl_lmops = fl->fl_lmops;\n\tnew->fl_ops = NULL;\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_get_owner)\n\t\t\tfl->fl_lmops->lm_get_owner(new, fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\tnew->fl_owner = fl->fl_owner;\n\tnew->fl_pid = fl->fl_pid;\n\tnew->fl_file = NULL;\n\tnew->fl_flags = fl->fl_flags;\n\tnew->fl_type = fl->fl_type;\n\tnew->fl_start = fl->fl_start;\n\tnew->fl_end = fl->fl_end;\n\tnew->fl_lmops = fl->fl_lmops;\n\tnew->fl_ops = NULL;\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_get_owner)\n\t\t\tfl->fl_lmops->lm_get_owner(new, fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "new->fl_ops"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\t/* \"new\" must be a freshly-initialized lock */\n\tWARN_ON_ONCE(new->fl_ops);\n\n\tlocks_copy_conflock(new, fl);\n\n\tnew->fl_file = fl->fl_file;\n\tnew->fl_ops = fl->fl_ops;\n\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_copy_lock)\n\t\t\tfl->fl_ops->fl_copy_lock(new, fl);\n\t}\n}"
  },
  {
    "function_name": "locks_copy_conflock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "322-338",
    "snippet": "void locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\tnew->fl_owner = fl->fl_owner;\n\tnew->fl_pid = fl->fl_pid;\n\tnew->fl_file = NULL;\n\tnew->fl_flags = fl->fl_flags;\n\tnew->fl_type = fl->fl_type;\n\tnew->fl_start = fl->fl_start;\n\tnew->fl_end = fl->fl_end;\n\tnew->fl_lmops = fl->fl_lmops;\n\tnew->fl_ops = NULL;\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_get_owner)\n\t\t\tfl->fl_lmops->lm_get_owner(new, fl);\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fl->fl_lmops->lm_get_owner",
          "args": [
            "new",
            "fl"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\tnew->fl_owner = fl->fl_owner;\n\tnew->fl_pid = fl->fl_pid;\n\tnew->fl_file = NULL;\n\tnew->fl_flags = fl->fl_flags;\n\tnew->fl_type = fl->fl_type;\n\tnew->fl_start = fl->fl_start;\n\tnew->fl_end = fl->fl_end;\n\tnew->fl_lmops = fl->fl_lmops;\n\tnew->fl_ops = NULL;\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_get_owner)\n\t\t\tfl->fl_lmops->lm_get_owner(new, fl);\n\t}\n}"
  },
  {
    "function_name": "locks_init_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "311-315",
    "snippet": "void locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_init_lock_heads",
          "args": [
            "fl"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "locks_init_lock_heads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "250-256",
          "snippet": "static void locks_init_lock_heads(struct file_lock *fl)\n{\n\tINIT_HLIST_NODE(&fl->fl_link);\n\tINIT_LIST_HEAD(&fl->fl_list);\n\tINIT_LIST_HEAD(&fl->fl_block);\n\tinit_waitqueue_head(&fl->fl_wait);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void locks_init_lock_heads(struct file_lock *fl)\n{\n\tINIT_HLIST_NODE(&fl->fl_link);\n\tINIT_LIST_HEAD(&fl->fl_list);\n\tINIT_LIST_HEAD(&fl->fl_block);\n\tinit_waitqueue_head(&fl->fl_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fl",
            "0",
            "sizeof(struct file_lock)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}"
  },
  {
    "function_name": "locks_dispose_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "299-309",
    "snippet": "static void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "fl"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "287-296",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&fl->fl_list"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "dispose",
            "structfile_lock",
            "fl_list"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "dispose"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}"
  },
  {
    "function_name": "locks_free_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "287-296",
    "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *filelock_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "filelock_cache",
            "fl"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_release_private",
          "args": [
            "fl"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "locks_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "270-283",
          "snippet": "void locks_release_private(struct file_lock *fl)\n{\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_release_private)\n\t\t\tfl->fl_ops->fl_release_private(fl);\n\t\tfl->fl_ops = NULL;\n\t}\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_put_owner)\n\t\t\tfl->fl_lmops->lm_put_owner(fl);\n\t\tfl->fl_lmops = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_release_private(struct file_lock *fl)\n{\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_release_private)\n\t\t\tfl->fl_ops->fl_release_private(fl);\n\t\tfl->fl_ops = NULL;\n\t}\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_put_owner)\n\t\t\tfl->fl_lmops->lm_put_owner(fl);\n\t\tfl->fl_lmops = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!hlist_unhashed(&fl->fl_link)"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&fl->fl_link"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&fl->fl_block)"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fl->fl_block"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&fl->fl_list)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "waitqueue_active(&fl->fl_wait)"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&fl->fl_wait"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
  },
  {
    "function_name": "locks_release_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "270-283",
    "snippet": "void locks_release_private(struct file_lock *fl)\n{\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_release_private)\n\t\t\tfl->fl_ops->fl_release_private(fl);\n\t\tfl->fl_ops = NULL;\n\t}\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_put_owner)\n\t\t\tfl->fl_lmops->lm_put_owner(fl);\n\t\tfl->fl_lmops = NULL;\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fl->fl_lmops->lm_put_owner",
          "args": [
            "fl"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fl->fl_ops->fl_release_private",
          "args": [
            "fl"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_release_private(struct file_lock *fl)\n{\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_release_private)\n\t\t\tfl->fl_ops->fl_release_private(fl);\n\t\tfl->fl_ops = NULL;\n\t}\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_put_owner)\n\t\t\tfl->fl_lmops->lm_put_owner(fl);\n\t\tfl->fl_lmops = NULL;\n\t}\n}"
  },
  {
    "function_name": "locks_alloc_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "259-267",
    "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *filelock_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_init_lock_heads",
          "args": [
            "fl"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "locks_init_lock_heads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "250-256",
          "snippet": "static void locks_init_lock_heads(struct file_lock *fl)\n{\n\tINIT_HLIST_NODE(&fl->fl_link);\n\tINIT_LIST_HEAD(&fl->fl_list);\n\tINIT_LIST_HEAD(&fl->fl_block);\n\tinit_waitqueue_head(&fl->fl_wait);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void locks_init_lock_heads(struct file_lock *fl)\n{\n\tINIT_HLIST_NODE(&fl->fl_link);\n\tINIT_LIST_HEAD(&fl->fl_list);\n\tINIT_LIST_HEAD(&fl->fl_block);\n\tinit_waitqueue_head(&fl->fl_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "filelock_cache",
            "GFP_KERNEL"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
  },
  {
    "function_name": "locks_init_lock_heads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "250-256",
    "snippet": "static void locks_init_lock_heads(struct file_lock *fl)\n{\n\tINIT_HLIST_NODE(&fl->fl_link);\n\tINIT_LIST_HEAD(&fl->fl_list);\n\tINIT_LIST_HEAD(&fl->fl_block);\n\tinit_waitqueue_head(&fl->fl_wait);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&fl->fl_wait"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fl->fl_block"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fl->fl_list"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&fl->fl_link"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void locks_init_lock_heads(struct file_lock *fl)\n{\n\tINIT_HLIST_NODE(&fl->fl_link);\n\tINIT_LIST_HEAD(&fl->fl_list);\n\tINIT_LIST_HEAD(&fl->fl_block);\n\tinit_waitqueue_head(&fl->fl_wait);\n}"
  },
  {
    "function_name": "locks_free_lock_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "239-248",
    "snippet": "void\nlocks_free_lock_context(struct file_lock_context *ctx)\n{\n\tif (ctx) {\n\t\tWARN_ON_ONCE(!list_empty(&ctx->flc_flock));\n\t\tWARN_ON_ONCE(!list_empty(&ctx->flc_posix));\n\t\tWARN_ON_ONCE(!list_empty(&ctx->flc_lease));\n\t\tkmem_cache_free(flctx_cache, ctx);\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *flctx_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "flctx_cache",
            "ctx"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&ctx->flc_lease)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ctx->flc_lease"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&ctx->flc_posix)"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&ctx->flc_flock)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *flctx_cache;\n\nvoid\nlocks_free_lock_context(struct file_lock_context *ctx)\n{\n\tif (ctx) {\n\t\tWARN_ON_ONCE(!list_empty(&ctx->flc_flock));\n\t\tWARN_ON_ONCE(!list_empty(&ctx->flc_posix));\n\t\tWARN_ON_ONCE(!list_empty(&ctx->flc_lease));\n\t\tkmem_cache_free(flctx_cache, ctx);\n\t}\n}"
  },
  {
    "function_name": "locks_get_lock_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "205-237",
    "snippet": "static struct file_lock_context *\nlocks_get_lock_context(struct inode *inode)\n{\n\tstruct file_lock_context *new;\n\n\tif (likely(inode->i_flctx))\n\t\tgoto out;\n\n\tnew = kmem_cache_alloc(flctx_cache, GFP_KERNEL);\n\tif (!new)\n\t\tgoto out;\n\n\tspin_lock_init(&new->flc_lock);\n\tINIT_LIST_HEAD(&new->flc_flock);\n\tINIT_LIST_HEAD(&new->flc_posix);\n\tINIT_LIST_HEAD(&new->flc_lease);\n\n\t/*\n\t * Assign the pointer if it's not already assigned. If it is, then\n\t * free the context we just allocated.\n\t */\n\tspin_lock(&inode->i_lock);\n\tif (likely(!inode->i_flctx)) {\n\t\tinode->i_flctx = new;\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (new)\n\t\tkmem_cache_free(flctx_cache, new);\nout:\n\treturn inode->i_flctx;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *flctx_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "flctx_cache",
            "new"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!inode->i_flctx"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new->flc_lease"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new->flc_posix"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new->flc_flock"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&new->flc_lock"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "flctx_cache",
            "GFP_KERNEL"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "inode->i_flctx"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *flctx_cache;\n\nstatic struct file_lock_context *\nlocks_get_lock_context(struct inode *inode)\n{\n\tstruct file_lock_context *new;\n\n\tif (likely(inode->i_flctx))\n\t\tgoto out;\n\n\tnew = kmem_cache_alloc(flctx_cache, GFP_KERNEL);\n\tif (!new)\n\t\tgoto out;\n\n\tspin_lock_init(&new->flc_lock);\n\tINIT_LIST_HEAD(&new->flc_flock);\n\tINIT_LIST_HEAD(&new->flc_posix);\n\tINIT_LIST_HEAD(&new->flc_lease);\n\n\t/*\n\t * Assign the pointer if it's not already assigned. If it is, then\n\t * free the context we just allocated.\n\t */\n\tspin_lock(&inode->i_lock);\n\tif (likely(!inode->i_flctx)) {\n\t\tinode->i_flctx = new;\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (new)\n\t\tkmem_cache_free(flctx_cache, new);\nout:\n\treturn inode->i_flctx;\n}"
  },
  {
    "function_name": "target_leasetype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "148-155",
    "snippet": "static int target_leasetype(struct file_lock *fl)\n{\n\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\treturn F_UNLCK;\n\tif (fl->fl_flags & FL_DOWNGRADE_PENDING)\n\t\treturn F_RDLCK;\n\treturn fl->fl_type;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int target_leasetype(struct file_lock *fl)\n{\n\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\treturn F_UNLCK;\n\tif (fl->fl_flags & FL_DOWNGRADE_PENDING)\n\t\treturn F_RDLCK;\n\treturn fl->fl_type;\n}"
  },
  {
    "function_name": "lease_breaking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
    "lines": "143-146",
    "snippet": "static bool lease_breaking(struct file_lock *fl)\n{\n\treturn fl->fl_flags & (FL_UNLOCK_PENDING | FL_DOWNGRADE_PENDING);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/lglock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic bool lease_breaking(struct file_lock *fl)\n{\n\treturn fl->fl_flags & (FL_UNLOCK_PENDING | FL_DOWNGRADE_PENDING);\n}"
  }
]