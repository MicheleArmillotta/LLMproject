[
  {
    "function_name": "__cifs_fscache_invalidate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
    "lines": "233-241",
    "snippet": "void __cifs_fscache_invalidate_page(struct page *page, struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct fscache_cookie *cookie = cifsi->fscache;\n\n\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\", __func__, page, cookie);\n\tfscache_wait_on_page_write(cookie, page);\n\tfscache_uncache_page(cookie, page);\n}",
    "includes": [
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_uncache_page",
          "args": [
            "cookie",
            "page"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_uncache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1058-1102",
          "snippet": "void __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_wait_on_page_write",
          "args": [
            "cookie",
            "page"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_fscache_wait_on_page_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.h",
          "lines": "199-200",
          "snippet": "static inline void nfs_fscache_wait_on_page_write(struct nfs_inode *nfsi,\n\t\t\t\t\t\t  struct page *page) {}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void nfs_fscache_wait_on_page_write(struct nfs_inode *nfsi,\n\t\t\t\t\t\t  struct page *page) {}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: (0x%p/0x%p)\\n\"",
            "__func__",
            "page",
            "cookie"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid __cifs_fscache_invalidate_page(struct page *page, struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct fscache_cookie *cookie = cifsi->fscache;\n\n\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\", __func__, page, cookie);\n\tfscache_wait_on_page_write(cookie, page);\n\tfscache_uncache_page(cookie, page);\n}"
  },
  {
    "function_name": "__cifs_fscache_readpages_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
    "lines": "226-231",
    "snippet": "void __cifs_fscache_readpages_cancel(struct inode *inode, struct list_head *pages)\n{\n\tcifs_dbg(FYI, \"%s: (fsc: %p, i: %p)\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, inode);\n\tfscache_readpages_cancel(CIFS_I(inode)->fscache, pages);\n}",
    "includes": [
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_readpages_cancel",
          "args": [
            "CIFS_I(inode)->fscache",
            "pages"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "__cifs_fscache_readpages_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
          "lines": "226-231",
          "snippet": "void __cifs_fscache_readpages_cancel(struct inode *inode, struct list_head *pages)\n{\n\tcifs_dbg(FYI, \"%s: (fsc: %p, i: %p)\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, inode);\n\tfscache_readpages_cancel(CIFS_I(inode)->fscache, pages);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: (fsc: %p, i: %p)\\n\"",
            "__func__",
            "CIFS_I(inode)->fscache",
            "inode"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid __cifs_fscache_readpages_cancel(struct inode *inode, struct list_head *pages)\n{\n\tcifs_dbg(FYI, \"%s: (fsc: %p, i: %p)\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, inode);\n\tfscache_readpages_cancel(CIFS_I(inode)->fscache, pages);\n}"
  },
  {
    "function_name": "__cifs_readpage_to_fscache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
    "lines": "215-224",
    "snippet": "void __cifs_readpage_to_fscache(struct inode *inode, struct page *page)\n{\n\tint ret;\n\n\tcifs_dbg(FYI, \"%s: (fsc: %p, p: %p, i: %p)\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, page, inode);\n\tret = fscache_write_page(CIFS_I(inode)->fscache, page, GFP_KERNEL);\n\tif (ret != 0)\n\t\tfscache_uncache_page(CIFS_I(inode)->fscache, page);\n}",
    "includes": [
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_uncache_page",
          "args": [
            "CIFS_I(inode)->fscache",
            "page"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_uncache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1058-1102",
          "snippet": "void __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_write_page",
          "args": [
            "CIFS_I(inode)->fscache",
            "page",
            "GFP_KERNEL"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "922-1052",
          "snippet": "int __fscache_write_page(struct fscache_cookie *cookie,\n\t\t\t struct page *page,\n\t\t\t gfp_t gfp)\n{\n\tstruct fscache_storage *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%x,\", cookie, (u32) page->flags);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERT(PageFsCache(page));\n\n\tfscache_stat(&fscache_n_stores);\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\top = kzalloc(sizeof(*op), GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY);\n\tif (!op)\n\t\tgoto nomem;\n\n\tfscache_operation_init(&op->op, fscache_write_op,\n\t\t\t       fscache_release_write_op);\n\top->op.flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_WAITING) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tret = radix_tree_maybe_preload(gfp & ~__GFP_HIGHMEM);\n\tif (ret < 0)\n\t\tgoto nomem_free;\n\n\tret = -ENOBUFS;\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\tif (test_bit(FSCACHE_IOERROR, &object->cache->flags))\n\t\tgoto nobufs;\n\n\t/* add the page to the pending-storage radix tree on the backing\n\t * object */\n\tspin_lock(&object->lock);\n\tspin_lock(&cookie->stores_lock);\n\n\t_debug(\"store limit %llx\", (unsigned long long) object->store_limit);\n\n\tret = radix_tree_insert(&cookie->stores, page->index, page);\n\tif (ret < 0) {\n\t\tif (ret == -EEXIST)\n\t\t\tgoto already_queued;\n\t\t_debug(\"insert failed %d\", ret);\n\t\tgoto nobufs_unlock_obj;\n\t}\n\n\tradix_tree_tag_set(&cookie->stores, page->index,\n\t\t\t   FSCACHE_COOKIE_PENDING_TAG);\n\tpage_cache_get(page);\n\n\t/* we only want one writer at a time, but we do need to queue new\n\t * writers after exclusive ops */\n\tif (test_and_set_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags))\n\t\tgoto already_pending;\n\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\n\top->op.debug_id\t= atomic_inc_return(&fscache_op_debug_id);\n\top->store_limit = object->store_limit;\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto submit_failed;\n\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tfscache_stat(&fscache_n_store_ops);\n\tfscache_stat(&fscache_n_stores_ok);\n\n\t/* the work queue now carries its own ref on the object */\n\tfscache_put_operation(&op->op);\n\t_leave(\" = 0\");\n\treturn 0;\n\nalready_queued:\n\tfscache_stat(&fscache_n_stores_again);\nalready_pending:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tfscache_stat(&fscache_n_stores_ok);\n\t_leave(\" = 0\");\n\treturn 0;\n\nsubmit_failed:\n\tspin_lock(&cookie->stores_lock);\n\tradix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\twake_cookie = __fscache_unuse_cookie(cookie);\n\tpage_cache_release(page);\n\tret = -ENOBUFS;\n\tgoto nobufs;\n\nnobufs_unlock_obj:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\nnobufs:\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tfscache_stat(&fscache_n_stores_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n\nnomem_free:\n\tkfree(op);\nnomem:\n\tfscache_stat(&fscache_n_stores_oom);\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_write_page(struct fscache_cookie *cookie,\n\t\t\t struct page *page,\n\t\t\t gfp_t gfp)\n{\n\tstruct fscache_storage *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%x,\", cookie, (u32) page->flags);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERT(PageFsCache(page));\n\n\tfscache_stat(&fscache_n_stores);\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\top = kzalloc(sizeof(*op), GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY);\n\tif (!op)\n\t\tgoto nomem;\n\n\tfscache_operation_init(&op->op, fscache_write_op,\n\t\t\t       fscache_release_write_op);\n\top->op.flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_WAITING) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tret = radix_tree_maybe_preload(gfp & ~__GFP_HIGHMEM);\n\tif (ret < 0)\n\t\tgoto nomem_free;\n\n\tret = -ENOBUFS;\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\tif (test_bit(FSCACHE_IOERROR, &object->cache->flags))\n\t\tgoto nobufs;\n\n\t/* add the page to the pending-storage radix tree on the backing\n\t * object */\n\tspin_lock(&object->lock);\n\tspin_lock(&cookie->stores_lock);\n\n\t_debug(\"store limit %llx\", (unsigned long long) object->store_limit);\n\n\tret = radix_tree_insert(&cookie->stores, page->index, page);\n\tif (ret < 0) {\n\t\tif (ret == -EEXIST)\n\t\t\tgoto already_queued;\n\t\t_debug(\"insert failed %d\", ret);\n\t\tgoto nobufs_unlock_obj;\n\t}\n\n\tradix_tree_tag_set(&cookie->stores, page->index,\n\t\t\t   FSCACHE_COOKIE_PENDING_TAG);\n\tpage_cache_get(page);\n\n\t/* we only want one writer at a time, but we do need to queue new\n\t * writers after exclusive ops */\n\tif (test_and_set_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags))\n\t\tgoto already_pending;\n\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\n\top->op.debug_id\t= atomic_inc_return(&fscache_op_debug_id);\n\top->store_limit = object->store_limit;\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto submit_failed;\n\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tfscache_stat(&fscache_n_store_ops);\n\tfscache_stat(&fscache_n_stores_ok);\n\n\t/* the work queue now carries its own ref on the object */\n\tfscache_put_operation(&op->op);\n\t_leave(\" = 0\");\n\treturn 0;\n\nalready_queued:\n\tfscache_stat(&fscache_n_stores_again);\nalready_pending:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tfscache_stat(&fscache_n_stores_ok);\n\t_leave(\" = 0\");\n\treturn 0;\n\nsubmit_failed:\n\tspin_lock(&cookie->stores_lock);\n\tradix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\twake_cookie = __fscache_unuse_cookie(cookie);\n\tpage_cache_release(page);\n\tret = -ENOBUFS;\n\tgoto nobufs;\n\nnobufs_unlock_obj:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\nnobufs:\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tfscache_stat(&fscache_n_stores_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n\nnomem_free:\n\tkfree(op);\nnomem:\n\tfscache_stat(&fscache_n_stores_oom);\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: (fsc: %p, p: %p, i: %p)\\n\"",
            "__func__",
            "CIFS_I(inode)->fscache",
            "page",
            "inode"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid __cifs_readpage_to_fscache(struct inode *inode, struct page *page)\n{\n\tint ret;\n\n\tcifs_dbg(FYI, \"%s: (fsc: %p, p: %p, i: %p)\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, page, inode);\n\tret = fscache_write_page(CIFS_I(inode)->fscache, page, GFP_KERNEL);\n\tif (ret != 0)\n\t\tfscache_uncache_page(CIFS_I(inode)->fscache, page);\n}"
  },
  {
    "function_name": "__cifs_readpages_from_fscache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
    "lines": "184-213",
    "snippet": "int __cifs_readpages_from_fscache(struct inode *inode,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tstruct list_head *pages,\n\t\t\t\tunsigned *nr_pages)\n{\n\tint ret;\n\n\tcifs_dbg(FYI, \"%s: (0x%p/%u/0x%p)\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, *nr_pages, inode);\n\tret = fscache_read_or_alloc_pages(CIFS_I(inode)->fscache, mapping,\n\t\t\t\t\t  pages, nr_pages,\n\t\t\t\t\t  cifs_readpage_from_fscache_complete,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  mapping_gfp_mask(mapping));\n\tswitch (ret) {\n\tcase 0:\t/* read submitted to the cache for all pages */\n\t\tcifs_dbg(FYI, \"%s: submitted\\n\", __func__);\n\t\treturn ret;\n\n\tcase -ENOBUFS:\t/* some pages are not cached and can't be */\n\tcase -ENODATA:\t/* some pages are not cached */\n\t\tcifs_dbg(FYI, \"%s: no page\\n\", __func__);\n\t\treturn 1;\n\n\tdefault:\n\t\tcifs_dbg(FYI, \"unknown error ret = %d\\n\", ret);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"unknown error ret = %d\\n\"",
            "ret"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: no page\\n\"",
            "__func__"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: submitted\\n\"",
            "__func__"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_read_or_alloc_pages",
          "args": [
            "CIFS_I(inode)->fscache",
            "mapping",
            "pages",
            "nr_pages",
            "cifs_readpage_from_fscache_complete",
            "NULL",
            "mapping_gfp_mask(mapping)"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_read_or_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "532-642",
          "snippet": "int __fscache_read_or_alloc_pages(struct fscache_cookie *cookie,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct list_head *pages,\n\t\t\t\t  unsigned *nr_pages,\n\t\t\t\t  fscache_rw_complete_t end_io_func,\n\t\t\t\t  void *context,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,,%d,,,\", cookie, *nr_pages);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(*nr_pages, >, 0);\n\tASSERT(!list_empty(pages));\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, mapping, end_io_func, context);\n\tif (!op)\n\t\treturn -ENOMEM;\n\tatomic_set(&op->n_pages, *nr_pages);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_pages);\n\t\tret = object->cache->ops->allocate_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_pages);\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_pages);\n\t\tret = object->cache->ops->read_or_alloc_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_pages);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_read_or_alloc_pages(struct fscache_cookie *cookie,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct list_head *pages,\n\t\t\t\t  unsigned *nr_pages,\n\t\t\t\t  fscache_rw_complete_t end_io_func,\n\t\t\t\t  void *context,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,,%d,,,\", cookie, *nr_pages);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(*nr_pages, >, 0);\n\tASSERT(!list_empty(pages));\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, mapping, end_io_func, context);\n\tif (!op)\n\t\treturn -ENOMEM;\n\tatomic_set(&op->n_pages, *nr_pages);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_pages);\n\t\tret = object->cache->ops->allocate_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_pages);\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_pages);\n\t\tret = object->cache->ops->read_or_alloc_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_pages);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "mapping"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: (0x%p/%u/0x%p)\\n\"",
            "__func__",
            "CIFS_I(inode)->fscache",
            "*nr_pages",
            "inode"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nint __cifs_readpages_from_fscache(struct inode *inode,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tstruct list_head *pages,\n\t\t\t\tunsigned *nr_pages)\n{\n\tint ret;\n\n\tcifs_dbg(FYI, \"%s: (0x%p/%u/0x%p)\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, *nr_pages, inode);\n\tret = fscache_read_or_alloc_pages(CIFS_I(inode)->fscache, mapping,\n\t\t\t\t\t  pages, nr_pages,\n\t\t\t\t\t  cifs_readpage_from_fscache_complete,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  mapping_gfp_mask(mapping));\n\tswitch (ret) {\n\tcase 0:\t/* read submitted to the cache for all pages */\n\t\tcifs_dbg(FYI, \"%s: submitted\\n\", __func__);\n\t\treturn ret;\n\n\tcase -ENOBUFS:\t/* some pages are not cached and can't be */\n\tcase -ENODATA:\t/* some pages are not cached */\n\t\tcifs_dbg(FYI, \"%s: no page\\n\", __func__);\n\t\treturn 1;\n\n\tdefault:\n\t\tcifs_dbg(FYI, \"unknown error ret = %d\\n\", ret);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__cifs_readpage_from_fscache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
    "lines": "155-179",
    "snippet": "int __cifs_readpage_from_fscache(struct inode *inode, struct page *page)\n{\n\tint ret;\n\n\tcifs_dbg(FYI, \"%s: (fsc:%p, p:%p, i:0x%p\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, page, inode);\n\tret = fscache_read_or_alloc_page(CIFS_I(inode)->fscache, page,\n\t\t\t\t\t cifs_readpage_from_fscache_complete,\n\t\t\t\t\t NULL,\n\t\t\t\t\t GFP_KERNEL);\n\tswitch (ret) {\n\n\tcase 0: /* page found in fscache, read submitted */\n\t\tcifs_dbg(FYI, \"%s: submitted\\n\", __func__);\n\t\treturn ret;\n\tcase -ENOBUFS:\t/* page won't be cached */\n\tcase -ENODATA:\t/* page not in cache */\n\t\tcifs_dbg(FYI, \"%s: %d\\n\", __func__, ret);\n\t\treturn 1;\n\n\tdefault:\n\t\tcifs_dbg(VFS, \"unknown error ret = %d\\n\", ret);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"unknown error ret = %d\\n\"",
            "ret"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: %d\\n\"",
            "__func__",
            "ret"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: submitted\\n\"",
            "__func__"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_read_or_alloc_page",
          "args": [
            "CIFS_I(inode)->fscache",
            "page",
            "cifs_readpage_from_fscache_complete",
            "NULL",
            "GFP_KERNEL"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_read_or_alloc_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "399-511",
          "snippet": "int __fscache_read_or_alloc_page(struct fscache_cookie *cookie,\n\t\t\t\t struct page *page,\n\t\t\t\t fscache_rw_complete_t end_io_func,\n\t\t\t\t void *context,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%p,,,\", cookie, page);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, page->mapping,\n\t\t\t\t     end_io_func, context);\n\tif (!op) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\tatomic_set(&op->n_pages, 1);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\tASSERT(test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags));\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_page);\n\t\tret = object->cache->ops->allocate_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_page);\n\t\tif (ret == 0)\n\t\t\tret = -ENODATA;\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_page);\n\t\tret = object->cache->ops->read_or_alloc_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_page);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tkfree(op);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_read_or_alloc_page(struct fscache_cookie *cookie,\n\t\t\t\t struct page *page,\n\t\t\t\t fscache_rw_complete_t end_io_func,\n\t\t\t\t void *context,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%p,,,\", cookie, page);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, page->mapping,\n\t\t\t\t     end_io_func, context);\n\tif (!op) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\tatomic_set(&op->n_pages, 1);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\tASSERT(test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags));\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_page);\n\t\tret = object->cache->ops->allocate_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_page);\n\t\tif (ret == 0)\n\t\t\tret = -ENODATA;\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_page);\n\t\tret = object->cache->ops->read_or_alloc_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_page);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tkfree(op);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: (fsc:%p, p:%p, i:0x%p\\n\"",
            "__func__",
            "CIFS_I(inode)->fscache",
            "page",
            "inode"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nint __cifs_readpage_from_fscache(struct inode *inode, struct page *page)\n{\n\tint ret;\n\n\tcifs_dbg(FYI, \"%s: (fsc:%p, p:%p, i:0x%p\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, page, inode);\n\tret = fscache_read_or_alloc_page(CIFS_I(inode)->fscache, page,\n\t\t\t\t\t cifs_readpage_from_fscache_complete,\n\t\t\t\t\t NULL,\n\t\t\t\t\t GFP_KERNEL);\n\tswitch (ret) {\n\n\tcase 0: /* page found in fscache, read submitted */\n\t\tcifs_dbg(FYI, \"%s: submitted\\n\", __func__);\n\t\treturn ret;\n\tcase -ENOBUFS:\t/* page won't be cached */\n\tcase -ENODATA:\t/* page not in cache */\n\t\tcifs_dbg(FYI, \"%s: %d\\n\", __func__, ret);\n\t\treturn 1;\n\n\tdefault:\n\t\tcifs_dbg(VFS, \"unknown error ret = %d\\n\", ret);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "cifs_readpage_from_fscache_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
    "lines": "143-150",
    "snippet": "static void cifs_readpage_from_fscache_complete(struct page *page, void *ctx,\n\t\t\t\t\t\tint error)\n{\n\tcifs_dbg(FYI, \"%s: (0x%p/%d)\\n\", __func__, page, error);\n\tif (!error)\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n}",
    "includes": [
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: (0x%p/%d)\\n\"",
            "__func__",
            "page",
            "error"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nstatic void cifs_readpage_from_fscache_complete(struct page *page, void *ctx,\n\t\t\t\t\t\tint error)\n{\n\tcifs_dbg(FYI, \"%s: (0x%p/%d)\\n\", __func__, page, error);\n\tif (!error)\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n}"
  },
  {
    "function_name": "cifs_fscache_release_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
    "lines": "128-141",
    "snippet": "int cifs_fscache_release_page(struct page *page, gfp_t gfp)\n{\n\tif (PageFsCache(page)) {\n\t\tstruct inode *inode = page->mapping->host;\n\t\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\n\t\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\",\n\t\t\t __func__, page, cifsi->fscache);\n\t\tif (!fscache_maybe_release_page(cifsi->fscache, page, gfp))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_maybe_release_page",
          "args": [
            "cifsi->fscache",
            "page",
            "gfp"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_maybe_release_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "63-137",
          "snippet": "bool __fscache_maybe_release_page(struct fscache_cookie *cookie,\n\t\t\t\t  struct page *page,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct page *xpage;\n\tvoid *val;\n\n\t_enter(\"%p,%p,%x\", cookie, page, gfp);\n\ntry_again:\n\trcu_read_lock();\n\tval = radix_tree_lookup(&cookie->stores, page->index);\n\tif (!val) {\n\t\trcu_read_unlock();\n\t\tfscache_stat(&fscache_n_store_vmscan_not_storing);\n\t\t__fscache_uncache_page(cookie, page);\n\t\treturn true;\n\t}\n\n\t/* see if the page is actually undergoing storage - if so we can't get\n\t * rid of it till the cache has finished with it */\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\trcu_read_unlock();\n\t\tgoto page_busy;\n\t}\n\n\t/* the page is pending storage, so we attempt to cancel the store and\n\t * discard the store request so that the page can be reclaimed */\n\tspin_lock(&cookie->stores_lock);\n\trcu_read_unlock();\n\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\t/* the page started to undergo storage whilst we were looking,\n\t\t * so now we can only wait or return */\n\t\tspin_unlock(&cookie->stores_lock);\n\t\tgoto page_busy;\n\t}\n\n\txpage = radix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\n\tif (xpage) {\n\t\tfscache_stat(&fscache_n_store_vmscan_cancelled);\n\t\tfscache_stat(&fscache_n_store_radix_deletes);\n\t\tASSERTCMP(xpage, ==, page);\n\t} else {\n\t\tfscache_stat(&fscache_n_store_vmscan_gone);\n\t}\n\n\twake_up_bit(&cookie->flags, 0);\n\tif (xpage)\n\t\tpage_cache_release(xpage);\n\t__fscache_uncache_page(cookie, page);\n\treturn true;\n\npage_busy:\n\t/* We will wait here if we're allowed to, but that could deadlock the\n\t * allocator as the work threads writing to the cache may all end up\n\t * sleeping on memory allocation, so we may need to impose a timeout\n\t * too. */\n\tif (!(gfp & __GFP_WAIT) || !(gfp & __GFP_FS)) {\n\t\tfscache_stat(&fscache_n_store_vmscan_busy);\n\t\treturn false;\n\t}\n\n\tfscache_stat(&fscache_n_store_vmscan_wait);\n\tif (!release_page_wait_timeout(cookie, page))\n\t\t_debug(\"fscache writeout timeout page: %p{%lx}\",\n\t\t\tpage, page->index);\n\n\tgfp &= ~__GFP_WAIT;\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nbool __fscache_maybe_release_page(struct fscache_cookie *cookie,\n\t\t\t\t  struct page *page,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct page *xpage;\n\tvoid *val;\n\n\t_enter(\"%p,%p,%x\", cookie, page, gfp);\n\ntry_again:\n\trcu_read_lock();\n\tval = radix_tree_lookup(&cookie->stores, page->index);\n\tif (!val) {\n\t\trcu_read_unlock();\n\t\tfscache_stat(&fscache_n_store_vmscan_not_storing);\n\t\t__fscache_uncache_page(cookie, page);\n\t\treturn true;\n\t}\n\n\t/* see if the page is actually undergoing storage - if so we can't get\n\t * rid of it till the cache has finished with it */\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\trcu_read_unlock();\n\t\tgoto page_busy;\n\t}\n\n\t/* the page is pending storage, so we attempt to cancel the store and\n\t * discard the store request so that the page can be reclaimed */\n\tspin_lock(&cookie->stores_lock);\n\trcu_read_unlock();\n\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\t/* the page started to undergo storage whilst we were looking,\n\t\t * so now we can only wait or return */\n\t\tspin_unlock(&cookie->stores_lock);\n\t\tgoto page_busy;\n\t}\n\n\txpage = radix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\n\tif (xpage) {\n\t\tfscache_stat(&fscache_n_store_vmscan_cancelled);\n\t\tfscache_stat(&fscache_n_store_radix_deletes);\n\t\tASSERTCMP(xpage, ==, page);\n\t} else {\n\t\tfscache_stat(&fscache_n_store_vmscan_gone);\n\t}\n\n\twake_up_bit(&cookie->flags, 0);\n\tif (xpage)\n\t\tpage_cache_release(xpage);\n\t__fscache_uncache_page(cookie, page);\n\treturn true;\n\npage_busy:\n\t/* We will wait here if we're allowed to, but that could deadlock the\n\t * allocator as the work threads writing to the cache may all end up\n\t * sleeping on memory allocation, so we may need to impose a timeout\n\t * too. */\n\tif (!(gfp & __GFP_WAIT) || !(gfp & __GFP_FS)) {\n\t\tfscache_stat(&fscache_n_store_vmscan_busy);\n\t\treturn false;\n\t}\n\n\tfscache_stat(&fscache_n_store_vmscan_wait);\n\tif (!release_page_wait_timeout(cookie, page))\n\t\t_debug(\"fscache writeout timeout page: %p{%lx}\",\n\t\t\tpage, page->index);\n\n\tgfp &= ~__GFP_WAIT;\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: (0x%p/0x%p)\\n\"",
            "__func__",
            "page",
            "cifsi->fscache"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageFsCache",
          "args": [
            "page"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nint cifs_fscache_release_page(struct page *page, gfp_t gfp)\n{\n\tif (PageFsCache(page)) {\n\t\tstruct inode *inode = page->mapping->host;\n\t\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\n\t\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\",\n\t\t\t __func__, page, cifsi->fscache);\n\t\tif (!fscache_maybe_release_page(cifsi->fscache, page, gfp))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "cifs_fscache_reset_inode_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
    "lines": "109-126",
    "snippet": "void cifs_fscache_reset_inode_cookie(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct fscache_cookie *old = cifsi->fscache;\n\n\tif (cifsi->fscache) {\n\t\t/* retire the current fscache cache and get a new one */\n\t\tfscache_relinquish_cookie(cifsi->fscache, 1);\n\n\t\tcifsi->fscache = fscache_acquire_cookie(\n\t\t\t\t\tcifs_sb_master_tcon(cifs_sb)->fscache,\n\t\t\t\t\t&cifs_fscache_inode_object_def,\n\t\t\t\t\tcifsi, true);\n\t\tcifs_dbg(FYI, \"%s: new cookie 0x%p oldcookie 0x%p\\n\",\n\t\t\t __func__, cifsi->fscache, old);\n\t}\n}",
    "includes": [
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: new cookie 0x%p oldcookie 0x%p\\n\"",
            "__func__",
            "cifsi->fscache",
            "old"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_acquire_cookie",
          "args": [
            "cifs_sb_master_tcon(cifs_sb)->fscache",
            "&cifs_fscache_inode_object_def",
            "cifsi",
            "true"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_acquire_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "58-150",
          "snippet": "struct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *fscache_cookie_jar;",
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct kmem_cache *fscache_cookie_jar;\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstruct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_sb_master_tcon",
          "args": [
            "cifs_sb"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_master_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3948-3952",
          "snippet": "struct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_relinquish_cookie",
          "args": [
            "cifsi->fscache",
            "1"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_relinquish_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "581-618",
          "snippet": "void __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid cifs_fscache_reset_inode_cookie(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct fscache_cookie *old = cifsi->fscache;\n\n\tif (cifsi->fscache) {\n\t\t/* retire the current fscache cache and get a new one */\n\t\tfscache_relinquish_cookie(cifsi->fscache, 1);\n\n\t\tcifsi->fscache = fscache_acquire_cookie(\n\t\t\t\t\tcifs_sb_master_tcon(cifs_sb)->fscache,\n\t\t\t\t\t&cifs_fscache_inode_object_def,\n\t\t\t\t\tcifsi, true);\n\t\tcifs_dbg(FYI, \"%s: new cookie 0x%p oldcookie 0x%p\\n\",\n\t\t\t __func__, cifsi->fscache, old);\n\t}\n}"
  },
  {
    "function_name": "cifs_fscache_set_inode_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
    "lines": "101-107",
    "snippet": "void cifs_fscache_set_inode_cookie(struct inode *inode, struct file *filp)\n{\n\tif ((filp->f_flags & O_ACCMODE) != O_RDONLY)\n\t\tcifs_fscache_disable_inode_cookie(inode);\n\telse\n\t\tcifs_fscache_enable_inode_cookie(inode);\n}",
    "includes": [
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_fscache_enable_inode_cookie",
          "args": [
            "inode"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fscache_enable_inode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
          "lines": "61-76",
          "snippet": "static void cifs_fscache_enable_inode_cookie(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\n\tif (cifsi->fscache)\n\t\treturn;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_FSCACHE) {\n\t\tcifsi->fscache = fscache_acquire_cookie(tcon->fscache,\n\t\t\t\t&cifs_fscache_inode_object_def, cifsi, true);\n\t\tcifs_dbg(FYI, \"%s: got FH cookie (0x%p/0x%p)\\n\",\n\t\t\t __func__, tcon->fscache, cifsi->fscache);\n\t}\n}",
          "includes": [
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nstatic void cifs_fscache_enable_inode_cookie(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\n\tif (cifsi->fscache)\n\t\treturn;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_FSCACHE) {\n\t\tcifsi->fscache = fscache_acquire_cookie(tcon->fscache,\n\t\t\t\t&cifs_fscache_inode_object_def, cifsi, true);\n\t\tcifs_dbg(FYI, \"%s: got FH cookie (0x%p/0x%p)\\n\",\n\t\t\t __func__, tcon->fscache, cifsi->fscache);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_fscache_disable_inode_cookie",
          "args": [
            "inode"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fscache_disable_inode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
          "lines": "89-99",
          "snippet": "static void cifs_fscache_disable_inode_cookie(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\n\tif (cifsi->fscache) {\n\t\tcifs_dbg(FYI, \"%s: (0x%p)\\n\", __func__, cifsi->fscache);\n\t\tfscache_uncache_all_inode_pages(cifsi->fscache, inode);\n\t\tfscache_relinquish_cookie(cifsi->fscache, 1);\n\t\tcifsi->fscache = NULL;\n\t}\n}",
          "includes": [
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nstatic void cifs_fscache_disable_inode_cookie(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\n\tif (cifsi->fscache) {\n\t\tcifs_dbg(FYI, \"%s: (0x%p)\\n\", __func__, cifsi->fscache);\n\t\tfscache_uncache_all_inode_pages(cifsi->fscache, inode);\n\t\tfscache_relinquish_cookie(cifsi->fscache, 1);\n\t\tcifsi->fscache = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid cifs_fscache_set_inode_cookie(struct inode *inode, struct file *filp)\n{\n\tif ((filp->f_flags & O_ACCMODE) != O_RDONLY)\n\t\tcifs_fscache_disable_inode_cookie(inode);\n\telse\n\t\tcifs_fscache_enable_inode_cookie(inode);\n}"
  },
  {
    "function_name": "cifs_fscache_disable_inode_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
    "lines": "89-99",
    "snippet": "static void cifs_fscache_disable_inode_cookie(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\n\tif (cifsi->fscache) {\n\t\tcifs_dbg(FYI, \"%s: (0x%p)\\n\", __func__, cifsi->fscache);\n\t\tfscache_uncache_all_inode_pages(cifsi->fscache, inode);\n\t\tfscache_relinquish_cookie(cifsi->fscache, 1);\n\t\tcifsi->fscache = NULL;\n\t}\n}",
    "includes": [
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_relinquish_cookie",
          "args": [
            "cifsi->fscache",
            "1"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_relinquish_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "581-618",
          "snippet": "void __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_uncache_all_inode_pages",
          "args": [
            "cifsi->fscache",
            "inode"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_uncache_all_inode_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1161-1194",
          "snippet": "void __fscache_uncache_all_inode_pages(struct fscache_cookie *cookie,\n\t\t\t\t       struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct pagevec pvec;\n\tpgoff_t next;\n\tint i;\n\n\t_enter(\"%p,%p\", cookie, inode);\n\n\tif (!mapping || mapping->nrpages == 0) {\n\t\t_leave(\" [no pages]\");\n\t\treturn;\n\t}\n\n\tpagevec_init(&pvec, 0);\n\tnext = 0;\n\tdo {\n\t\tif (!pagevec_lookup(&pvec, mapping, next, PAGEVEC_SIZE))\n\t\t\tbreak;\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tnext = page->index;\n\t\t\tif (PageFsCache(page)) {\n\t\t\t\t__fscache_wait_on_page_write(cookie, page);\n\t\t\t\t__fscache_uncache_page(cookie, page);\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t} while (++next);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid __fscache_uncache_all_inode_pages(struct fscache_cookie *cookie,\n\t\t\t\t       struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct pagevec pvec;\n\tpgoff_t next;\n\tint i;\n\n\t_enter(\"%p,%p\", cookie, inode);\n\n\tif (!mapping || mapping->nrpages == 0) {\n\t\t_leave(\" [no pages]\");\n\t\treturn;\n\t}\n\n\tpagevec_init(&pvec, 0);\n\tnext = 0;\n\tdo {\n\t\tif (!pagevec_lookup(&pvec, mapping, next, PAGEVEC_SIZE))\n\t\t\tbreak;\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tnext = page->index;\n\t\t\tif (PageFsCache(page)) {\n\t\t\t\t__fscache_wait_on_page_write(cookie, page);\n\t\t\t\t__fscache_uncache_page(cookie, page);\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t} while (++next);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: (0x%p)\\n\"",
            "__func__",
            "cifsi->fscache"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nstatic void cifs_fscache_disable_inode_cookie(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\n\tif (cifsi->fscache) {\n\t\tcifs_dbg(FYI, \"%s: (0x%p)\\n\", __func__, cifsi->fscache);\n\t\tfscache_uncache_all_inode_pages(cifsi->fscache, inode);\n\t\tfscache_relinquish_cookie(cifsi->fscache, 1);\n\t\tcifsi->fscache = NULL;\n\t}\n}"
  },
  {
    "function_name": "cifs_fscache_release_inode_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
    "lines": "78-87",
    "snippet": "void cifs_fscache_release_inode_cookie(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\n\tif (cifsi->fscache) {\n\t\tcifs_dbg(FYI, \"%s: (0x%p)\\n\", __func__, cifsi->fscache);\n\t\tfscache_relinquish_cookie(cifsi->fscache, 0);\n\t\tcifsi->fscache = NULL;\n\t}\n}",
    "includes": [
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_relinquish_cookie",
          "args": [
            "cifsi->fscache",
            "0"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_relinquish_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "581-618",
          "snippet": "void __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: (0x%p)\\n\"",
            "__func__",
            "cifsi->fscache"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid cifs_fscache_release_inode_cookie(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\n\tif (cifsi->fscache) {\n\t\tcifs_dbg(FYI, \"%s: (0x%p)\\n\", __func__, cifsi->fscache);\n\t\tfscache_relinquish_cookie(cifsi->fscache, 0);\n\t\tcifsi->fscache = NULL;\n\t}\n}"
  },
  {
    "function_name": "cifs_fscache_enable_inode_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
    "lines": "61-76",
    "snippet": "static void cifs_fscache_enable_inode_cookie(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\n\tif (cifsi->fscache)\n\t\treturn;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_FSCACHE) {\n\t\tcifsi->fscache = fscache_acquire_cookie(tcon->fscache,\n\t\t\t\t&cifs_fscache_inode_object_def, cifsi, true);\n\t\tcifs_dbg(FYI, \"%s: got FH cookie (0x%p/0x%p)\\n\",\n\t\t\t __func__, tcon->fscache, cifsi->fscache);\n\t}\n}",
    "includes": [
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: got FH cookie (0x%p/0x%p)\\n\"",
            "__func__",
            "tcon->fscache",
            "cifsi->fscache"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_acquire_cookie",
          "args": [
            "tcon->fscache",
            "&cifs_fscache_inode_object_def",
            "cifsi",
            "true"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_acquire_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "58-150",
          "snippet": "struct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *fscache_cookie_jar;",
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct kmem_cache *fscache_cookie_jar;\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstruct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_sb_master_tcon",
          "args": [
            "cifs_sb"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_master_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3948-3952",
          "snippet": "struct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nstatic void cifs_fscache_enable_inode_cookie(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\n\tif (cifsi->fscache)\n\t\treturn;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_FSCACHE) {\n\t\tcifsi->fscache = fscache_acquire_cookie(tcon->fscache,\n\t\t\t\t&cifs_fscache_inode_object_def, cifsi, true);\n\t\tcifs_dbg(FYI, \"%s: got FH cookie (0x%p/0x%p)\\n\",\n\t\t\t __func__, tcon->fscache, cifsi->fscache);\n\t}\n}"
  },
  {
    "function_name": "cifs_fscache_release_super_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
    "lines": "54-59",
    "snippet": "void cifs_fscache_release_super_cookie(struct cifs_tcon *tcon)\n{\n\tcifs_dbg(FYI, \"%s: (0x%p)\\n\", __func__, tcon->fscache);\n\tfscache_relinquish_cookie(tcon->fscache, 0);\n\ttcon->fscache = NULL;\n}",
    "includes": [
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_relinquish_cookie",
          "args": [
            "tcon->fscache",
            "0"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_relinquish_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "581-618",
          "snippet": "void __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: (0x%p)\\n\"",
            "__func__",
            "tcon->fscache"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid cifs_fscache_release_super_cookie(struct cifs_tcon *tcon)\n{\n\tcifs_dbg(FYI, \"%s: (0x%p)\\n\", __func__, tcon->fscache);\n\tfscache_relinquish_cookie(tcon->fscache, 0);\n\ttcon->fscache = NULL;\n}"
  },
  {
    "function_name": "cifs_fscache_get_super_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
    "lines": "43-52",
    "snippet": "void cifs_fscache_get_super_cookie(struct cifs_tcon *tcon)\n{\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\ttcon->fscache =\n\t\tfscache_acquire_cookie(server->fscache,\n\t\t\t\t&cifs_fscache_super_index_def, tcon, true);\n\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\",\n\t\t __func__, server->fscache, tcon->fscache);\n}",
    "includes": [
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: (0x%p/0x%p)\\n\"",
            "__func__",
            "server->fscache",
            "tcon->fscache"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_acquire_cookie",
          "args": [
            "server->fscache",
            "&cifs_fscache_super_index_def",
            "tcon",
            "true"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_acquire_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "58-150",
          "snippet": "struct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *fscache_cookie_jar;",
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct kmem_cache *fscache_cookie_jar;\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstruct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid cifs_fscache_get_super_cookie(struct cifs_tcon *tcon)\n{\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\ttcon->fscache =\n\t\tfscache_acquire_cookie(server->fscache,\n\t\t\t\t&cifs_fscache_super_index_def, tcon, true);\n\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\",\n\t\t __func__, server->fscache, tcon->fscache);\n}"
  },
  {
    "function_name": "cifs_fscache_release_client_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
    "lines": "35-41",
    "snippet": "void cifs_fscache_release_client_cookie(struct TCP_Server_Info *server)\n{\n\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\",\n\t\t __func__, server, server->fscache);\n\tfscache_relinquish_cookie(server->fscache, 0);\n\tserver->fscache = NULL;\n}",
    "includes": [
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_relinquish_cookie",
          "args": [
            "server->fscache",
            "0"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_relinquish_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "581-618",
          "snippet": "void __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: (0x%p/0x%p)\\n\"",
            "__func__",
            "server",
            "server->fscache"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid cifs_fscache_release_client_cookie(struct TCP_Server_Info *server)\n{\n\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\",\n\t\t __func__, server, server->fscache);\n\tfscache_relinquish_cookie(server->fscache, 0);\n\tserver->fscache = NULL;\n}"
  },
  {
    "function_name": "cifs_fscache_get_client_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
    "lines": "26-33",
    "snippet": "void cifs_fscache_get_client_cookie(struct TCP_Server_Info *server)\n{\n\tserver->fscache =\n\t\tfscache_acquire_cookie(cifs_fscache_netfs.primary_index,\n\t\t\t\t&cifs_fscache_server_index_def, server, true);\n\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\",\n\t\t __func__, server, server->fscache);\n}",
    "includes": [
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: (0x%p/0x%p)\\n\"",
            "__func__",
            "server",
            "server->fscache"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_acquire_cookie",
          "args": [
            "cifs_fscache_netfs.primary_index",
            "&cifs_fscache_server_index_def",
            "server",
            "true"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_acquire_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "58-150",
          "snippet": "struct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *fscache_cookie_jar;",
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct kmem_cache *fscache_cookie_jar;\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstruct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid cifs_fscache_get_client_cookie(struct TCP_Server_Info *server)\n{\n\tserver->fscache =\n\t\tfscache_acquire_cookie(cifs_fscache_netfs.primary_index,\n\t\t\t\t&cifs_fscache_server_index_def, server, true);\n\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\",\n\t\t __func__, server, server->fscache);\n}"
  }
]