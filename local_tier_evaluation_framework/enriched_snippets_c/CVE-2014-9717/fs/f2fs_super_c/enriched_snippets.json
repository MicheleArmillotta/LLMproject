[
  {
    "function_name": "exit_f2fs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "1307-1318",
    "snippet": "static void __exit exit_f2fs_fs(void)\n{\n\tremove_proc_entry(\"fs/f2fs\", NULL);\n\tf2fs_destroy_root_stats();\n\tunregister_filesystem(&f2fs_fs_type);\n\tdestroy_checkpoint_caches();\n\tdestroy_segment_manager_caches();\n\tdestroy_node_manager_caches();\n\tdestroy_inodecache();\n\tkset_unregister(f2fs_kset);\n\tf2fs_destroy_trace_ios();\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kset *f2fs_kset;",
      "static struct file_system_type f2fs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"f2fs\",\n\t.mount\t\t= f2fs_mount,\n\t.kill_sb\t= kill_f2fs_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_destroy_trace_ios",
          "args": [],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_destroy_trace_ios",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/trace.c",
          "lines": "144-159",
          "snippet": "void f2fs_destroy_trace_ios(void)\n{\n\tpid_t pid[PIDVEC_SIZE];\n\tpid_t next_pid = 0;\n\tunsigned int found;\n\n\tspin_lock(&pids_lock);\n\twhile ((found = gang_lookup_pids(pid, next_pid, PIDVEC_SIZE))) {\n\t\tunsigned idx;\n\n\t\tnext_pid = pid[found - 1] + 1;\n\t\tfor (idx = 0; idx < found; idx++)\n\t\t\tradix_tree_delete(&pids, pid[idx]);\n\t}\n\tspin_unlock(&pids_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/radix-tree.h>",
            "#include <linux/sched.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define PIDVEC_SIZE\t128"
          ],
          "globals_used": [
            "static spinlock_t pids_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"f2fs.h\"\n#include <linux/radix-tree.h>\n#include <linux/sched.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\n#define PIDVEC_SIZE\t128\n\nstatic spinlock_t pids_lock;\n\nvoid f2fs_destroy_trace_ios(void)\n{\n\tpid_t pid[PIDVEC_SIZE];\n\tpid_t next_pid = 0;\n\tunsigned int found;\n\n\tspin_lock(&pids_lock);\n\twhile ((found = gang_lookup_pids(pid, next_pid, PIDVEC_SIZE))) {\n\t\tunsigned idx;\n\n\t\tnext_pid = pid[found - 1] + 1;\n\t\tfor (idx = 0; idx < found; idx++)\n\t\t\tradix_tree_delete(&pids, pid[idx]);\n\t}\n\tspin_unlock(&pids_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kset_unregister",
          "args": [
            "f2fs_kset"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "1253-1261",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(f2fs_inode_cachep);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *f2fs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *f2fs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(f2fs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_node_manager_caches",
          "args": [],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_node_manager_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "2065-2070",
          "snippet": "void destroy_node_manager_caches(void)\n{\n\tkmem_cache_destroy(nat_entry_set_slab);\n\tkmem_cache_destroy(free_nid_slab);\n\tkmem_cache_destroy(nat_entry_slab);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nat_entry_slab;",
            "static struct kmem_cache *free_nid_slab;",
            "static struct kmem_cache *nat_entry_set_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *nat_entry_slab;\nstatic struct kmem_cache *free_nid_slab;\nstatic struct kmem_cache *nat_entry_set_slab;\n\nvoid destroy_node_manager_caches(void)\n{\n\tkmem_cache_destroy(nat_entry_set_slab);\n\tkmem_cache_destroy(free_nid_slab);\n\tkmem_cache_destroy(nat_entry_slab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_segment_manager_caches",
          "args": [],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_segment_manager_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "2295-2300",
          "snippet": "void destroy_segment_manager_caches(void)\n{\n\tkmem_cache_destroy(sit_entry_set_slab);\n\tkmem_cache_destroy(discard_entry_slab);\n\tkmem_cache_destroy(inmem_entry_slab);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *discard_entry_slab;",
            "static struct kmem_cache *sit_entry_set_slab;",
            "static struct kmem_cache *inmem_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *discard_entry_slab;\nstatic struct kmem_cache *sit_entry_set_slab;\nstatic struct kmem_cache *inmem_entry_slab;\n\nvoid destroy_segment_manager_caches(void)\n{\n\tkmem_cache_destroy(sit_entry_set_slab);\n\tkmem_cache_destroy(discard_entry_slab);\n\tkmem_cache_destroy(inmem_entry_slab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_checkpoint_caches",
          "args": [],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_checkpoint_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "1131-1135",
          "snippet": "void destroy_checkpoint_caches(void)\n{\n\tkmem_cache_destroy(ino_entry_slab);\n\tkmem_cache_destroy(inode_entry_slab);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ino_entry_slab;",
            "struct kmem_cache *inode_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *ino_entry_slab;\nstruct kmem_cache *inode_entry_slab;\n\nvoid destroy_checkpoint_caches(void)\n{\n\tkmem_cache_destroy(ino_entry_slab);\n\tkmem_cache_destroy(inode_entry_slab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&f2fs_fs_type"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_destroy_root_stats",
          "args": [],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_destroy_root_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1672-1672",
          "snippet": "static inline void f2fs_destroy_root_stats(void) { }",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_destroy_root_stats(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"fs/f2fs\"",
            "NULL"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "523-554",
          "snippet": "void remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kset *f2fs_kset;\nstatic struct file_system_type f2fs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"f2fs\",\n\t.mount\t\t= f2fs_mount,\n\t.kill_sb\t= kill_f2fs_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_f2fs_fs(void)\n{\n\tremove_proc_entry(\"fs/f2fs\", NULL);\n\tf2fs_destroy_root_stats();\n\tunregister_filesystem(&f2fs_fs_type);\n\tdestroy_checkpoint_caches();\n\tdestroy_segment_manager_caches();\n\tdestroy_node_manager_caches();\n\tdestroy_inodecache();\n\tkset_unregister(f2fs_kset);\n\tf2fs_destroy_trace_ios();\n}"
  },
  {
    "function_name": "init_f2fs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "1263-1305",
    "snippet": "static int __init init_f2fs_fs(void)\n{\n\tint err;\n\n\tf2fs_build_trace_ios();\n\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto fail;\n\terr = create_node_manager_caches();\n\tif (err)\n\t\tgoto free_inodecache;\n\terr = create_segment_manager_caches();\n\tif (err)\n\t\tgoto free_node_manager_caches;\n\terr = create_checkpoint_caches();\n\tif (err)\n\t\tgoto free_segment_manager_caches;\n\tf2fs_kset = kset_create_and_add(\"f2fs\", NULL, fs_kobj);\n\tif (!f2fs_kset) {\n\t\terr = -ENOMEM;\n\t\tgoto free_checkpoint_caches;\n\t}\n\terr = register_filesystem(&f2fs_fs_type);\n\tif (err)\n\t\tgoto free_kset;\n\tf2fs_create_root_stats();\n\tf2fs_proc_root = proc_mkdir(\"fs/f2fs\", NULL);\n\treturn 0;\n\nfree_kset:\n\tkset_unregister(f2fs_kset);\nfree_checkpoint_caches:\n\tdestroy_checkpoint_caches();\nfree_segment_manager_caches:\n\tdestroy_segment_manager_caches();\nfree_node_manager_caches:\n\tdestroy_node_manager_caches();\nfree_inodecache:\n\tdestroy_inodecache();\nfail:\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct proc_dir_entry *f2fs_proc_root;",
      "static struct kset *f2fs_kset;",
      "static struct file_system_type f2fs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"f2fs\",\n\t.mount\t\t= f2fs_mount,\n\t.kill_sb\t= kill_f2fs_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "1253-1261",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(f2fs_inode_cachep);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *f2fs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *f2fs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(f2fs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_node_manager_caches",
          "args": [],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_node_manager_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "2065-2070",
          "snippet": "void destroy_node_manager_caches(void)\n{\n\tkmem_cache_destroy(nat_entry_set_slab);\n\tkmem_cache_destroy(free_nid_slab);\n\tkmem_cache_destroy(nat_entry_slab);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nat_entry_slab;",
            "static struct kmem_cache *free_nid_slab;",
            "static struct kmem_cache *nat_entry_set_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *nat_entry_slab;\nstatic struct kmem_cache *free_nid_slab;\nstatic struct kmem_cache *nat_entry_set_slab;\n\nvoid destroy_node_manager_caches(void)\n{\n\tkmem_cache_destroy(nat_entry_set_slab);\n\tkmem_cache_destroy(free_nid_slab);\n\tkmem_cache_destroy(nat_entry_slab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_segment_manager_caches",
          "args": [],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_segment_manager_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "2295-2300",
          "snippet": "void destroy_segment_manager_caches(void)\n{\n\tkmem_cache_destroy(sit_entry_set_slab);\n\tkmem_cache_destroy(discard_entry_slab);\n\tkmem_cache_destroy(inmem_entry_slab);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *discard_entry_slab;",
            "static struct kmem_cache *sit_entry_set_slab;",
            "static struct kmem_cache *inmem_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *discard_entry_slab;\nstatic struct kmem_cache *sit_entry_set_slab;\nstatic struct kmem_cache *inmem_entry_slab;\n\nvoid destroy_segment_manager_caches(void)\n{\n\tkmem_cache_destroy(sit_entry_set_slab);\n\tkmem_cache_destroy(discard_entry_slab);\n\tkmem_cache_destroy(inmem_entry_slab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_checkpoint_caches",
          "args": [],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_checkpoint_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "1131-1135",
          "snippet": "void destroy_checkpoint_caches(void)\n{\n\tkmem_cache_destroy(ino_entry_slab);\n\tkmem_cache_destroy(inode_entry_slab);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ino_entry_slab;",
            "struct kmem_cache *inode_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *ino_entry_slab;\nstruct kmem_cache *inode_entry_slab;\n\nvoid destroy_checkpoint_caches(void)\n{\n\tkmem_cache_destroy(ino_entry_slab);\n\tkmem_cache_destroy(inode_entry_slab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kset_unregister",
          "args": [
            "f2fs_kset"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "\"fs/f2fs\"",
            "NULL"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "451-455",
          "snippet": "struct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstruct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_create_root_stats",
          "args": [],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_create_root_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1671-1671",
          "snippet": "static inline void __init f2fs_create_root_stats(void) { }",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void __init f2fs_create_root_stats(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&f2fs_fs_type"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kset_create_and_add",
          "args": [
            "\"f2fs\"",
            "NULL",
            "fs_kobj"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_checkpoint_caches",
          "args": [],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "create_checkpoint_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "1116-1129",
          "snippet": "int __init create_checkpoint_caches(void)\n{\n\tino_entry_slab = f2fs_kmem_cache_create(\"f2fs_ino_entry\",\n\t\t\tsizeof(struct ino_entry));\n\tif (!ino_entry_slab)\n\t\treturn -ENOMEM;\n\tinode_entry_slab = f2fs_kmem_cache_create(\"f2fs_inode_entry\",\n\t\t\tsizeof(struct inode_entry));\n\tif (!inode_entry_slab) {\n\t\tkmem_cache_destroy(ino_entry_slab);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ino_entry_slab;",
            "struct kmem_cache *inode_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *ino_entry_slab;\nstruct kmem_cache *inode_entry_slab;\n\nint __init create_checkpoint_caches(void)\n{\n\tino_entry_slab = f2fs_kmem_cache_create(\"f2fs_ino_entry\",\n\t\t\tsizeof(struct ino_entry));\n\tif (!ino_entry_slab)\n\t\treturn -ENOMEM;\n\tinode_entry_slab = f2fs_kmem_cache_create(\"f2fs_inode_entry\",\n\t\t\tsizeof(struct inode_entry));\n\tif (!inode_entry_slab) {\n\t\tkmem_cache_destroy(ino_entry_slab);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_segment_manager_caches",
          "args": [],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "create_segment_manager_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "2269-2293",
          "snippet": "int __init create_segment_manager_caches(void)\n{\n\tdiscard_entry_slab = f2fs_kmem_cache_create(\"discard_entry\",\n\t\t\tsizeof(struct discard_entry));\n\tif (!discard_entry_slab)\n\t\tgoto fail;\n\n\tsit_entry_set_slab = f2fs_kmem_cache_create(\"sit_entry_set\",\n\t\t\tsizeof(struct sit_entry_set));\n\tif (!sit_entry_set_slab)\n\t\tgoto destory_discard_entry;\n\n\tinmem_entry_slab = f2fs_kmem_cache_create(\"inmem_page_entry\",\n\t\t\tsizeof(struct inmem_pages));\n\tif (!inmem_entry_slab)\n\t\tgoto destroy_sit_entry_set;\n\treturn 0;\n\ndestroy_sit_entry_set:\n\tkmem_cache_destroy(sit_entry_set_slab);\ndestory_discard_entry:\n\tkmem_cache_destroy(discard_entry_slab);\nfail:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *discard_entry_slab;",
            "static struct kmem_cache *sit_entry_set_slab;",
            "static struct kmem_cache *inmem_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *discard_entry_slab;\nstatic struct kmem_cache *sit_entry_set_slab;\nstatic struct kmem_cache *inmem_entry_slab;\n\nint __init create_segment_manager_caches(void)\n{\n\tdiscard_entry_slab = f2fs_kmem_cache_create(\"discard_entry\",\n\t\t\tsizeof(struct discard_entry));\n\tif (!discard_entry_slab)\n\t\tgoto fail;\n\n\tsit_entry_set_slab = f2fs_kmem_cache_create(\"sit_entry_set\",\n\t\t\tsizeof(struct sit_entry_set));\n\tif (!sit_entry_set_slab)\n\t\tgoto destory_discard_entry;\n\n\tinmem_entry_slab = f2fs_kmem_cache_create(\"inmem_page_entry\",\n\t\t\tsizeof(struct inmem_pages));\n\tif (!inmem_entry_slab)\n\t\tgoto destroy_sit_entry_set;\n\treturn 0;\n\ndestroy_sit_entry_set:\n\tkmem_cache_destroy(sit_entry_set_slab);\ndestory_discard_entry:\n\tkmem_cache_destroy(discard_entry_slab);\nfail:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_node_manager_caches",
          "args": [],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "create_node_manager_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "2039-2063",
          "snippet": "int __init create_node_manager_caches(void)\n{\n\tnat_entry_slab = f2fs_kmem_cache_create(\"nat_entry\",\n\t\t\tsizeof(struct nat_entry));\n\tif (!nat_entry_slab)\n\t\tgoto fail;\n\n\tfree_nid_slab = f2fs_kmem_cache_create(\"free_nid\",\n\t\t\tsizeof(struct free_nid));\n\tif (!free_nid_slab)\n\t\tgoto destroy_nat_entry;\n\n\tnat_entry_set_slab = f2fs_kmem_cache_create(\"nat_entry_set\",\n\t\t\tsizeof(struct nat_entry_set));\n\tif (!nat_entry_set_slab)\n\t\tgoto destroy_free_nid;\n\treturn 0;\n\ndestroy_free_nid:\n\tkmem_cache_destroy(free_nid_slab);\ndestroy_nat_entry:\n\tkmem_cache_destroy(nat_entry_slab);\nfail:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nat_entry_slab;",
            "static struct kmem_cache *free_nid_slab;",
            "static struct kmem_cache *nat_entry_set_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *nat_entry_slab;\nstatic struct kmem_cache *free_nid_slab;\nstatic struct kmem_cache *nat_entry_set_slab;\n\nint __init create_node_manager_caches(void)\n{\n\tnat_entry_slab = f2fs_kmem_cache_create(\"nat_entry\",\n\t\t\tsizeof(struct nat_entry));\n\tif (!nat_entry_slab)\n\t\tgoto fail;\n\n\tfree_nid_slab = f2fs_kmem_cache_create(\"free_nid\",\n\t\t\tsizeof(struct free_nid));\n\tif (!free_nid_slab)\n\t\tgoto destroy_nat_entry;\n\n\tnat_entry_set_slab = f2fs_kmem_cache_create(\"nat_entry_set\",\n\t\t\tsizeof(struct nat_entry_set));\n\tif (!nat_entry_set_slab)\n\t\tgoto destroy_free_nid;\n\treturn 0;\n\ndestroy_free_nid:\n\tkmem_cache_destroy(free_nid_slab);\ndestroy_nat_entry:\n\tkmem_cache_destroy(nat_entry_slab);\nfail:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodecache",
          "args": [],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "1244-1251",
          "snippet": "static int __init init_inodecache(void)\n{\n\tf2fs_inode_cachep = f2fs_kmem_cache_create(\"f2fs_inode_cache\",\n\t\t\tsizeof(struct f2fs_inode_info));\n\tif (!f2fs_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *f2fs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *f2fs_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\tf2fs_inode_cachep = f2fs_kmem_cache_create(\"f2fs_inode_cache\",\n\t\t\tsizeof(struct f2fs_inode_info));\n\tif (!f2fs_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_build_trace_ios",
          "args": [],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_build_trace_ios",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/trace.c",
          "lines": "120-123",
          "snippet": "void f2fs_build_trace_ios(void)\n{\n\tspin_lock_init(&pids_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/radix-tree.h>",
            "#include <linux/sched.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static spinlock_t pids_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"f2fs.h\"\n#include <linux/radix-tree.h>\n#include <linux/sched.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic spinlock_t pids_lock;\n\nvoid f2fs_build_trace_ios(void)\n{\n\tspin_lock_init(&pids_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct proc_dir_entry *f2fs_proc_root;\nstatic struct kset *f2fs_kset;\nstatic struct file_system_type f2fs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"f2fs\",\n\t.mount\t\t= f2fs_mount,\n\t.kill_sb\t= kill_f2fs_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_f2fs_fs(void)\n{\n\tint err;\n\n\tf2fs_build_trace_ios();\n\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto fail;\n\terr = create_node_manager_caches();\n\tif (err)\n\t\tgoto free_inodecache;\n\terr = create_segment_manager_caches();\n\tif (err)\n\t\tgoto free_node_manager_caches;\n\terr = create_checkpoint_caches();\n\tif (err)\n\t\tgoto free_segment_manager_caches;\n\tf2fs_kset = kset_create_and_add(\"f2fs\", NULL, fs_kobj);\n\tif (!f2fs_kset) {\n\t\terr = -ENOMEM;\n\t\tgoto free_checkpoint_caches;\n\t}\n\terr = register_filesystem(&f2fs_fs_type);\n\tif (err)\n\t\tgoto free_kset;\n\tf2fs_create_root_stats();\n\tf2fs_proc_root = proc_mkdir(\"fs/f2fs\", NULL);\n\treturn 0;\n\nfree_kset:\n\tkset_unregister(f2fs_kset);\nfree_checkpoint_caches:\n\tdestroy_checkpoint_caches();\nfree_segment_manager_caches:\n\tdestroy_segment_manager_caches();\nfree_node_manager_caches:\n\tdestroy_node_manager_caches();\nfree_inodecache:\n\tdestroy_inodecache();\nfail:\n\treturn err;\n}"
  },
  {
    "function_name": "destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "1253-1261",
    "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(f2fs_inode_cachep);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *f2fs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "f2fs_inode_cachep"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *f2fs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(f2fs_inode_cachep);\n}"
  },
  {
    "function_name": "init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "1244-1251",
    "snippet": "static int __init init_inodecache(void)\n{\n\tf2fs_inode_cachep = f2fs_kmem_cache_create(\"f2fs_inode_cache\",\n\t\t\tsizeof(struct f2fs_inode_info));\n\tif (!f2fs_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *f2fs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_kmem_cache_create",
          "args": [
            "\"f2fs_inode_cache\"",
            "sizeof(struct f2fs_inode_info)"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1058-1062",
          "snippet": "static inline struct kmem_cache *f2fs_kmem_cache_create(const char *name,\n\t\t\t\t\tsize_t size)\n{\n\treturn kmem_cache_create(name, size, 0, SLAB_RECLAIM_ACCOUNT, NULL);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct kmem_cache *f2fs_kmem_cache_create(const char *name,\n\t\t\t\t\tsize_t size)\n{\n\treturn kmem_cache_create(name, size, 0, SLAB_RECLAIM_ACCOUNT, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *f2fs_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\tf2fs_inode_cachep = f2fs_kmem_cache_create(\"f2fs_inode_cache\",\n\t\t\tsizeof(struct f2fs_inode_info));\n\tif (!f2fs_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "kill_f2fs_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "1228-1233",
    "snippet": "static void kill_f2fs_super(struct super_block *sb)\n{\n\tif (sb->s_root)\n\t\tset_sbi_flag(F2FS_SB(sb), SBI_IS_CLOSE);\n\tkill_block_super(sb);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_block_super",
          "args": [
            "sb"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_kill_block_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "629-638",
          "snippet": "static void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_sb_info_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstruct kmem_cache *ecryptfs_sb_info_cache;\n\nstatic void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_sbi_flag",
          "args": [
            "F2FS_SB(sb)",
            "SBI_IS_CLOSE"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "set_sbi_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "720-723",
          "snippet": "static inline void set_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag |= (0x01 << type);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag |= (0x01 << type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_SB",
          "args": [
            "sb"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "640-643",
          "snippet": "static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void kill_f2fs_super(struct super_block *sb)\n{\n\tif (sb->s_root)\n\t\tset_sbi_flag(F2FS_SB(sb), SBI_IS_CLOSE);\n\tkill_block_super(sb);\n}"
  },
  {
    "function_name": "f2fs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "1222-1226",
    "snippet": "static struct dentry *f2fs_mount(struct file_system_type *fs_type, int flags,\n\t\t\tconst char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, f2fs_fill_super);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "f2fs_fill_super"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct dentry *f2fs_mount(struct file_system_type *fs_type, int flags,\n\t\t\tconst char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, f2fs_fill_super);\n}"
  },
  {
    "function_name": "f2fs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "955-1220",
    "snippet": "static int f2fs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct f2fs_sb_info *sbi;\n\tstruct f2fs_super_block *raw_super = NULL;\n\tstruct buffer_head *raw_super_buf;\n\tstruct inode *root;\n\tlong err = -EINVAL;\n\tbool retry = true;\n\tchar *options = NULL;\n\tint i;\n\ntry_onemore:\n\t/* allocate memory for f2fs-specific super block info */\n\tsbi = kzalloc(sizeof(struct f2fs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\t/* set a block size */\n\tif (unlikely(!sb_set_blocksize(sb, F2FS_BLKSIZE))) {\n\t\tf2fs_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto free_sbi;\n\t}\n\n\terr = read_raw_super_block(sb, &raw_super, &raw_super_buf);\n\tif (err)\n\t\tgoto free_sbi;\n\n\tsb->s_fs_info = sbi;\n\t/* init some FS parameters */\n\tsbi->active_logs = NR_CURSEG_TYPE;\n\n\tset_opt(sbi, BG_GC);\n\n#ifdef CONFIG_F2FS_FS_XATTR\n\tset_opt(sbi, XATTR_USER);\n#endif\n#ifdef CONFIG_F2FS_FS_POSIX_ACL\n\tset_opt(sbi, POSIX_ACL);\n#endif\n\t/* parse mount options */\n\toptions = kstrdup((const char *)data, GFP_KERNEL);\n\tif (data && !options) {\n\t\terr = -ENOMEM;\n\t\tgoto free_sb_buf;\n\t}\n\n\terr = parse_options(sb, options);\n\tif (err)\n\t\tgoto free_options;\n\n\tsb->s_maxbytes = max_file_size(le32_to_cpu(raw_super->log_blocksize));\n\tsb->s_max_links = F2FS_LINK_MAX;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\n\tsb->s_op = &f2fs_sops;\n\tsb->s_xattr = f2fs_xattr_handlers;\n\tsb->s_export_op = &f2fs_export_ops;\n\tsb->s_magic = F2FS_SUPER_MAGIC;\n\tsb->s_time_gran = 1;\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sbi, POSIX_ACL) ? MS_POSIXACL : 0);\n\tmemcpy(sb->s_uuid, raw_super->uuid, sizeof(raw_super->uuid));\n\n\t/* init f2fs-specific super block info */\n\tsbi->sb = sb;\n\tsbi->raw_super = raw_super;\n\tsbi->raw_super_buf = raw_super_buf;\n\tmutex_init(&sbi->gc_mutex);\n\tmutex_init(&sbi->writepages);\n\tmutex_init(&sbi->cp_mutex);\n\tinit_rwsem(&sbi->node_write);\n\tclear_sbi_flag(sbi, SBI_POR_DOING);\n\tspin_lock_init(&sbi->stat_lock);\n\n\tinit_rwsem(&sbi->read_io.io_rwsem);\n\tsbi->read_io.sbi = sbi;\n\tsbi->read_io.bio = NULL;\n\tfor (i = 0; i < NR_PAGE_TYPE; i++) {\n\t\tinit_rwsem(&sbi->write_io[i].io_rwsem);\n\t\tsbi->write_io[i].sbi = sbi;\n\t\tsbi->write_io[i].bio = NULL;\n\t}\n\n\tinit_rwsem(&sbi->cp_rwsem);\n\tinit_waitqueue_head(&sbi->cp_wait);\n\tinit_sb_info(sbi);\n\n\t/* get an inode for meta space */\n\tsbi->meta_inode = f2fs_iget(sb, F2FS_META_INO(sbi));\n\tif (IS_ERR(sbi->meta_inode)) {\n\t\tf2fs_msg(sb, KERN_ERR, \"Failed to read F2FS meta data inode\");\n\t\terr = PTR_ERR(sbi->meta_inode);\n\t\tgoto free_options;\n\t}\n\n\terr = get_valid_checkpoint(sbi);\n\tif (err) {\n\t\tf2fs_msg(sb, KERN_ERR, \"Failed to get valid F2FS checkpoint\");\n\t\tgoto free_meta_inode;\n\t}\n\n\t/* sanity checking of checkpoint */\n\terr = -EINVAL;\n\tif (sanity_check_ckpt(sbi)) {\n\t\tf2fs_msg(sb, KERN_ERR, \"Invalid F2FS checkpoint\");\n\t\tgoto free_cp;\n\t}\n\n\tsbi->total_valid_node_count =\n\t\t\t\tle32_to_cpu(sbi->ckpt->valid_node_count);\n\tsbi->total_valid_inode_count =\n\t\t\t\tle32_to_cpu(sbi->ckpt->valid_inode_count);\n\tsbi->user_block_count = le64_to_cpu(sbi->ckpt->user_block_count);\n\tsbi->total_valid_block_count =\n\t\t\t\tle64_to_cpu(sbi->ckpt->valid_block_count);\n\tsbi->last_valid_block_count = sbi->total_valid_block_count;\n\tsbi->alloc_valid_block_count = 0;\n\tINIT_LIST_HEAD(&sbi->dir_inode_list);\n\tspin_lock_init(&sbi->dir_inode_lock);\n\n\tinit_ino_entry_info(sbi);\n\n\t/* setup f2fs internal modules */\n\terr = build_segment_manager(sbi);\n\tif (err) {\n\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t\"Failed to initialize F2FS segment manager\");\n\t\tgoto free_sm;\n\t}\n\terr = build_node_manager(sbi);\n\tif (err) {\n\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t\"Failed to initialize F2FS node manager\");\n\t\tgoto free_nm;\n\t}\n\n\tbuild_gc_manager(sbi);\n\n\t/* get an inode for node space */\n\tsbi->node_inode = f2fs_iget(sb, F2FS_NODE_INO(sbi));\n\tif (IS_ERR(sbi->node_inode)) {\n\t\tf2fs_msg(sb, KERN_ERR, \"Failed to read node inode\");\n\t\terr = PTR_ERR(sbi->node_inode);\n\t\tgoto free_nm;\n\t}\n\n\t/* if there are nt orphan nodes free them */\n\trecover_orphan_inodes(sbi);\n\n\t/* read root inode and dentry */\n\troot = f2fs_iget(sb, F2FS_ROOT_INO(sbi));\n\tif (IS_ERR(root)) {\n\t\tf2fs_msg(sb, KERN_ERR, \"Failed to read root inode\");\n\t\terr = PTR_ERR(root);\n\t\tgoto free_node_inode;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\tiput(root);\n\t\terr = -EINVAL;\n\t\tgoto free_node_inode;\n\t}\n\n\tsb->s_root = d_make_root(root); /* allocate root dentry */\n\tif (!sb->s_root) {\n\t\terr = -ENOMEM;\n\t\tgoto free_root_inode;\n\t}\n\n\terr = f2fs_build_stats(sbi);\n\tif (err)\n\t\tgoto free_root_inode;\n\n\tif (f2fs_proc_root)\n\t\tsbi->s_proc = proc_mkdir(sb->s_id, f2fs_proc_root);\n\n\tif (sbi->s_proc)\n\t\tproc_create_data(\"segment_info\", S_IRUGO, sbi->s_proc,\n\t\t\t\t &f2fs_seq_segment_info_fops, sb);\n\n\tif (test_opt(sbi, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\tf2fs_msg(sb, KERN_WARNING,\n\t\t\t\t\t\"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t\t\"the device does not support discard\");\n\t}\n\n\tsbi->s_kobj.kset = f2fs_kset;\n\tinit_completion(&sbi->s_kobj_unregister);\n\terr = kobject_init_and_add(&sbi->s_kobj, &f2fs_ktype, NULL,\n\t\t\t\t\t\t\t\"%s\", sb->s_id);\n\tif (err)\n\t\tgoto free_proc;\n\n\tif (!retry)\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\n\t/* recover fsynced data */\n\tif (!test_opt(sbi, DISABLE_ROLL_FORWARD)) {\n\t\t/*\n\t\t * mount should be failed, when device has readonly mode, and\n\t\t * previous checkpoint was not done by clean system shutdown.\n\t\t */\n\t\tif (bdev_read_only(sb->s_bdev) &&\n\t\t\t\t!is_set_ckpt_flags(sbi->ckpt, CP_UMOUNT_FLAG)) {\n\t\t\terr = -EROFS;\n\t\t\tgoto free_kobj;\n\t\t}\n\t\terr = recover_fsync_data(sbi);\n\t\tif (err) {\n\t\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t\t\"Cannot recover all fsync data errno=%ld\", err);\n\t\t\tgoto free_kobj;\n\t\t}\n\t}\n\n\t/*\n\t * If filesystem is not mounted as read-only then\n\t * do start the gc_thread.\n\t */\n\tif (test_opt(sbi, BG_GC) && !f2fs_readonly(sb)) {\n\t\t/* After POR, we can run background GC thread.*/\n\t\terr = start_gc_thread(sbi);\n\t\tif (err)\n\t\t\tgoto free_kobj;\n\t}\n\tkfree(options);\n\treturn 0;\n\nfree_kobj:\n\tkobject_del(&sbi->s_kobj);\nfree_proc:\n\tif (sbi->s_proc) {\n\t\tremove_proc_entry(\"segment_info\", sbi->s_proc);\n\t\tremove_proc_entry(sb->s_id, f2fs_proc_root);\n\t}\n\tf2fs_destroy_stats(sbi);\nfree_root_inode:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfree_node_inode:\n\tiput(sbi->node_inode);\nfree_nm:\n\tdestroy_node_manager(sbi);\nfree_sm:\n\tdestroy_segment_manager(sbi);\nfree_cp:\n\tkfree(sbi->ckpt);\nfree_meta_inode:\n\tmake_bad_inode(sbi->meta_inode);\n\tiput(sbi->meta_inode);\nfree_options:\n\tkfree(options);\nfree_sb_buf:\n\tbrelse(raw_super_buf);\nfree_sbi:\n\tkfree(sbi);\n\n\t/* give only one another chance */\n\tif (retry) {\n\t\tretry = 0;\n\t\tshrink_dcache_sb(sb);\n\t\tgoto try_onemore;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct proc_dir_entry *f2fs_proc_root;",
      "static struct kset *f2fs_kset;",
      "static struct kobj_type f2fs_ktype = {\n\t.default_attrs\t= f2fs_attrs,\n\t.sysfs_ops\t= &f2fs_attr_ops,\n\t.release\t= f2fs_sb_release,\n};",
      "static const struct file_operations f2fs_seq_segment_info_fops = {\n\t.owner = THIS_MODULE,\n\t.open = segment_info_open_fs,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};",
      "static struct super_operations f2fs_sops = {\n\t.alloc_inode\t= f2fs_alloc_inode,\n\t.drop_inode\t= f2fs_drop_inode,\n\t.destroy_inode\t= f2fs_destroy_inode,\n\t.write_inode\t= f2fs_write_inode,\n\t.dirty_inode\t= f2fs_dirty_inode,\n\t.show_options\t= f2fs_show_options,\n\t.evict_inode\t= f2fs_evict_inode,\n\t.put_super\t= f2fs_put_super,\n\t.sync_fs\t= f2fs_sync_fs,\n\t.freeze_fs\t= f2fs_freeze,\n\t.unfreeze_fs\t= f2fs_unfreeze,\n\t.statfs\t\t= f2fs_statfs,\n\t.remount_fs\t= f2fs_remount,\n};",
      "static const struct export_operations f2fs_export_ops = {\n\t.fh_to_dentry = f2fs_fh_to_dentry,\n\t.fh_to_parent = f2fs_fh_to_parent,\n\t.get_parent = f2fs_get_parent,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shrink_dcache_sb",
          "args": [
            "sb"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dcache_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1094-1107",
          "snippet": "void shrink_dcache_sb(struct super_block *sb)\n{\n\tlong freed;\n\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tfreed = list_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, UINT_MAX);\n\n\t\tthis_cpu_sub(nr_dentry_unused, freed);\n\t\tshrink_dentry_list(&dispose);\n\t} while (freed > 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(long, nr_dentry_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nvoid shrink_dcache_sb(struct super_block *sb)\n{\n\tlong freed;\n\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tfreed = list_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, UINT_MAX);\n\n\t\tthis_cpu_sub(nr_dentry_unused, freed);\n\t\tshrink_dentry_list(&dispose);\n\t} while (freed > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "raw_super_buf"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "options"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "sbi->meta_inode"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "sbi->meta_inode"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "170-179",
          "snippet": "void make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};",
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nvoid make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->ckpt"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_segment_manager",
          "args": [
            "sbi"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_segment_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "2254-2267",
          "snippet": "void destroy_segment_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_sm_info *sm_info = SM_I(sbi);\n\n\tif (!sm_info)\n\t\treturn;\n\tdestroy_flush_cmd_control(sbi);\n\tdestroy_dirty_segmap(sbi);\n\tdestroy_curseg(sbi);\n\tdestroy_free_segmap(sbi);\n\tdestroy_sit_info(sbi);\n\tsbi->sm_info = NULL;\n\tkfree(sm_info);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid destroy_segment_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_sm_info *sm_info = SM_I(sbi);\n\n\tif (!sm_info)\n\t\treturn;\n\tdestroy_flush_cmd_control(sbi);\n\tdestroy_dirty_segmap(sbi);\n\tdestroy_curseg(sbi);\n\tdestroy_free_segmap(sbi);\n\tdestroy_sit_info(sbi);\n\tsbi->sm_info = NULL;\n\tkfree(sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_node_manager",
          "args": [
            "sbi"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_node_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1981-2037",
          "snippet": "void destroy_node_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i, *next_i;\n\tstruct nat_entry *natvec[NATVEC_SIZE];\n\tstruct nat_entry_set *setvec[SETVEC_SIZE];\n\tnid_t nid = 0;\n\tunsigned int found;\n\n\tif (!nm_i)\n\t\treturn;\n\n\t/* destroy free nid list */\n\tspin_lock(&nm_i->free_nid_list_lock);\n\tlist_for_each_entry_safe(i, next_i, &nm_i->free_nid_list, list) {\n\t\tf2fs_bug_on(sbi, i->state == NID_ALLOC);\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tnm_i->fcnt--;\n\t\tspin_unlock(&nm_i->free_nid_list_lock);\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\tspin_lock(&nm_i->free_nid_list_lock);\n\t}\n\tf2fs_bug_on(sbi, nm_i->fcnt);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\t/* destroy nat cache */\n\tdown_write(&nm_i->nat_tree_lock);\n\twhile ((found = __gang_lookup_nat_cache(nm_i,\n\t\t\t\t\tnid, NATVEC_SIZE, natvec))) {\n\t\tunsigned idx;\n\n\t\tnid = nat_get_nid(natvec[found - 1]) + 1;\n\t\tfor (idx = 0; idx < found; idx++)\n\t\t\t__del_from_nat_cache(nm_i, natvec[idx]);\n\t}\n\tf2fs_bug_on(sbi, nm_i->nat_cnt);\n\n\t/* destroy nat set cache */\n\tnid = 0;\n\twhile ((found = __gang_lookup_nat_set(nm_i,\n\t\t\t\t\tnid, SETVEC_SIZE, setvec))) {\n\t\tunsigned idx;\n\n\t\tnid = setvec[found - 1]->set + 1;\n\t\tfor (idx = 0; idx < found; idx++) {\n\t\t\t/* entry_cnt is not zero, when cp_error was occurred */\n\t\t\tf2fs_bug_on(sbi, !list_empty(&setvec[idx]->entry_list));\n\t\t\tradix_tree_delete(&nm_i->nat_set_root, setvec[idx]->set);\n\t\t\tkmem_cache_free(nat_entry_set_slab, setvec[idx]);\n\t\t}\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n\n\tkfree(nm_i->nat_bitmap);\n\tsbi->nm_info = NULL;\n\tkfree(nm_i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;",
            "static struct kmem_cache *nat_entry_set_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\nstatic struct kmem_cache *nat_entry_set_slab;\n\nvoid destroy_node_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i, *next_i;\n\tstruct nat_entry *natvec[NATVEC_SIZE];\n\tstruct nat_entry_set *setvec[SETVEC_SIZE];\n\tnid_t nid = 0;\n\tunsigned int found;\n\n\tif (!nm_i)\n\t\treturn;\n\n\t/* destroy free nid list */\n\tspin_lock(&nm_i->free_nid_list_lock);\n\tlist_for_each_entry_safe(i, next_i, &nm_i->free_nid_list, list) {\n\t\tf2fs_bug_on(sbi, i->state == NID_ALLOC);\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tnm_i->fcnt--;\n\t\tspin_unlock(&nm_i->free_nid_list_lock);\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\tspin_lock(&nm_i->free_nid_list_lock);\n\t}\n\tf2fs_bug_on(sbi, nm_i->fcnt);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\t/* destroy nat cache */\n\tdown_write(&nm_i->nat_tree_lock);\n\twhile ((found = __gang_lookup_nat_cache(nm_i,\n\t\t\t\t\tnid, NATVEC_SIZE, natvec))) {\n\t\tunsigned idx;\n\n\t\tnid = nat_get_nid(natvec[found - 1]) + 1;\n\t\tfor (idx = 0; idx < found; idx++)\n\t\t\t__del_from_nat_cache(nm_i, natvec[idx]);\n\t}\n\tf2fs_bug_on(sbi, nm_i->nat_cnt);\n\n\t/* destroy nat set cache */\n\tnid = 0;\n\twhile ((found = __gang_lookup_nat_set(nm_i,\n\t\t\t\t\tnid, SETVEC_SIZE, setvec))) {\n\t\tunsigned idx;\n\n\t\tnid = setvec[found - 1]->set + 1;\n\t\tfor (idx = 0; idx < found; idx++) {\n\t\t\t/* entry_cnt is not zero, when cp_error was occurred */\n\t\t\tf2fs_bug_on(sbi, !list_empty(&setvec[idx]->entry_list));\n\t\t\tradix_tree_delete(&nm_i->nat_set_root, setvec[idx]->set);\n\t\t\tkmem_cache_free(nat_entry_set_slab, setvec[idx]);\n\t\t}\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n\n\tkfree(nm_i->nat_bitmap);\n\tsbi->nm_info = NULL;\n\tkfree(nm_i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "sb->s_root"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_destroy_stats",
          "args": [
            "sbi"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_destroy_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1670-1670",
          "snippet": "static inline void f2fs_destroy_stats(struct f2fs_sb_info *sbi) { }",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_destroy_stats(struct f2fs_sb_info *sbi) { }"
        }
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "sb->s_id",
            "f2fs_proc_root"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "523-554",
          "snippet": "void remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_del",
          "args": [
            "&sbi->s_kobj"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "options"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_gc_thread",
          "args": [
            "sbi"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "start_gc_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "91-120",
          "snippet": "int start_gc_thread(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_gc_kthread *gc_th;\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tint err = 0;\n\n\tgc_th = kmalloc(sizeof(struct f2fs_gc_kthread), GFP_KERNEL);\n\tif (!gc_th) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tgc_th->min_sleep_time = DEF_GC_THREAD_MIN_SLEEP_TIME;\n\tgc_th->max_sleep_time = DEF_GC_THREAD_MAX_SLEEP_TIME;\n\tgc_th->no_gc_sleep_time = DEF_GC_THREAD_NOGC_SLEEP_TIME;\n\n\tgc_th->gc_idle = 0;\n\n\tsbi->gc_thread = gc_th;\n\tinit_waitqueue_head(&sbi->gc_thread->gc_wait_queue_head);\n\tsbi->gc_thread->f2fs_gc_task = kthread_run(gc_thread_func, sbi,\n\t\t\t\"f2fs_gc-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(gc_th->f2fs_gc_task)) {\n\t\terr = PTR_ERR(gc_th->f2fs_gc_task);\n\t\tkfree(gc_th);\n\t\tsbi->gc_thread = NULL;\n\t}\nout:\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nint start_gc_thread(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_gc_kthread *gc_th;\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tint err = 0;\n\n\tgc_th = kmalloc(sizeof(struct f2fs_gc_kthread), GFP_KERNEL);\n\tif (!gc_th) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tgc_th->min_sleep_time = DEF_GC_THREAD_MIN_SLEEP_TIME;\n\tgc_th->max_sleep_time = DEF_GC_THREAD_MAX_SLEEP_TIME;\n\tgc_th->no_gc_sleep_time = DEF_GC_THREAD_NOGC_SLEEP_TIME;\n\n\tgc_th->gc_idle = 0;\n\n\tsbi->gc_thread = gc_th;\n\tinit_waitqueue_head(&sbi->gc_thread->gc_wait_queue_head);\n\tsbi->gc_thread->f2fs_gc_task = kthread_run(gc_thread_func, sbi,\n\t\t\t\"f2fs_gc-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(gc_th->f2fs_gc_task)) {\n\t\terr = PTR_ERR(gc_th->f2fs_gc_task);\n\t\tkfree(gc_th);\n\t\tsbi->gc_thread = NULL;\n\t}\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_readonly",
          "args": [
            "sb"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1305-1308",
          "snippet": "static inline int f2fs_readonly(struct super_block *sb)\n{\n\treturn sb->s_flags & MS_RDONLY;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_readonly(struct super_block *sb)\n{\n\treturn sb->s_flags & MS_RDONLY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "BG_GC"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"Cannot recover all fsync data errno=%ld\"",
            "err"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "235-245",
          "snippet": "void f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_fsync_data",
          "args": [
            "sbi"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "recover_fsync_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
          "lines": "495-563",
          "snippet": "int recover_fsync_data(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_WARM_NODE);\n\tstruct list_head inode_list;\n\tblock_t blkaddr;\n\tint err;\n\tbool need_writecp = false;\n\n\tfsync_entry_slab = f2fs_kmem_cache_create(\"f2fs_fsync_inode_entry\",\n\t\t\tsizeof(struct fsync_inode_entry));\n\tif (!fsync_entry_slab)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&inode_list);\n\n\t/* step #1: find fsynced inode numbers */\n\tset_sbi_flag(sbi, SBI_POR_DOING);\n\n\t/* prevent checkpoint */\n\tmutex_lock(&sbi->cp_mutex);\n\n\tblkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\terr = find_fsync_dnodes(sbi, &inode_list);\n\tif (err)\n\t\tgoto out;\n\n\tif (list_empty(&inode_list))\n\t\tgoto out;\n\n\tneed_writecp = true;\n\n\t/* step #2: recover data */\n\terr = recover_data(sbi, &inode_list, CURSEG_WARM_NODE);\n\tif (!err)\n\t\tf2fs_bug_on(sbi, !list_empty(&inode_list));\nout:\n\tdestroy_fsync_dnodes(&inode_list);\n\tkmem_cache_destroy(fsync_entry_slab);\n\n\t/* truncate meta pages to be used by the recovery */\n\ttruncate_inode_pages_range(META_MAPPING(sbi),\n\t\t\tMAIN_BLKADDR(sbi) << PAGE_CACHE_SHIFT, -1);\n\n\tif (err) {\n\t\ttruncate_inode_pages_final(NODE_MAPPING(sbi));\n\t\ttruncate_inode_pages_final(META_MAPPING(sbi));\n\t}\n\n\tclear_sbi_flag(sbi, SBI_POR_DOING);\n\tif (err) {\n\t\tdiscard_next_dnode(sbi, blkaddr);\n\n\t\t/* Flush all the NAT/SIT pages */\n\t\twhile (get_pages(sbi, F2FS_DIRTY_META))\n\t\t\tsync_meta_pages(sbi, META, LONG_MAX);\n\t\tset_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n\t\tmutex_unlock(&sbi->cp_mutex);\n\t} else if (need_writecp) {\n\t\tstruct cp_control cpc = {\n\t\t\t.reason = CP_SYNC,\n\t\t};\n\t\tmutex_unlock(&sbi->cp_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t} else {\n\t\tmutex_unlock(&sbi->cp_mutex);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fsync_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *fsync_entry_slab;\n\nint recover_fsync_data(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_WARM_NODE);\n\tstruct list_head inode_list;\n\tblock_t blkaddr;\n\tint err;\n\tbool need_writecp = false;\n\n\tfsync_entry_slab = f2fs_kmem_cache_create(\"f2fs_fsync_inode_entry\",\n\t\t\tsizeof(struct fsync_inode_entry));\n\tif (!fsync_entry_slab)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&inode_list);\n\n\t/* step #1: find fsynced inode numbers */\n\tset_sbi_flag(sbi, SBI_POR_DOING);\n\n\t/* prevent checkpoint */\n\tmutex_lock(&sbi->cp_mutex);\n\n\tblkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\terr = find_fsync_dnodes(sbi, &inode_list);\n\tif (err)\n\t\tgoto out;\n\n\tif (list_empty(&inode_list))\n\t\tgoto out;\n\n\tneed_writecp = true;\n\n\t/* step #2: recover data */\n\terr = recover_data(sbi, &inode_list, CURSEG_WARM_NODE);\n\tif (!err)\n\t\tf2fs_bug_on(sbi, !list_empty(&inode_list));\nout:\n\tdestroy_fsync_dnodes(&inode_list);\n\tkmem_cache_destroy(fsync_entry_slab);\n\n\t/* truncate meta pages to be used by the recovery */\n\ttruncate_inode_pages_range(META_MAPPING(sbi),\n\t\t\tMAIN_BLKADDR(sbi) << PAGE_CACHE_SHIFT, -1);\n\n\tif (err) {\n\t\ttruncate_inode_pages_final(NODE_MAPPING(sbi));\n\t\ttruncate_inode_pages_final(META_MAPPING(sbi));\n\t}\n\n\tclear_sbi_flag(sbi, SBI_POR_DOING);\n\tif (err) {\n\t\tdiscard_next_dnode(sbi, blkaddr);\n\n\t\t/* Flush all the NAT/SIT pages */\n\t\twhile (get_pages(sbi, F2FS_DIRTY_META))\n\t\t\tsync_meta_pages(sbi, META, LONG_MAX);\n\t\tset_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n\t\tmutex_unlock(&sbi->cp_mutex);\n\t} else if (need_writecp) {\n\t\tstruct cp_control cpc = {\n\t\t\t.reason = CP_SYNC,\n\t\t};\n\t\tmutex_unlock(&sbi->cp_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t} else {\n\t\tmutex_unlock(&sbi->cp_mutex);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_set_ckpt_flags",
          "args": [
            "sbi->ckpt",
            "CP_UMOUNT_FLAG"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "is_set_ckpt_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "735-739",
          "snippet": "static inline bool is_set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\treturn ckpt_flags & f;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool is_set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\treturn ckpt_flags & f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_read_only",
          "args": [
            "sb->s_bdev"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "DISABLE_ROLL_FORWARD"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sbi_flag",
          "args": [
            "sbi",
            "SBI_NEED_FSCK"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "set_sbi_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "720-723",
          "snippet": "static inline void set_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag |= (0x01 << type);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag |= (0x01 << type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_init_and_add",
          "args": [
            "&sbi->s_kobj",
            "&f2fs_ktype",
            "NULL",
            "\"%s\"",
            "sb->s_id"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&sbi->s_kobj_unregister"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_queue_discard",
          "args": [
            "q"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "sb->s_bdev"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "DISCARD"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_data",
          "args": [
            "\"segment_info\"",
            "S_IRUGO",
            "sbi->s_proc",
            "&f2fs_seq_segment_info_fops",
            "sb"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "proc_create_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "458-489",
          "snippet": "struct proc_dir_entry *proc_create_data(const char *name, umode_t mode,\n\t\t\t\t\tstruct proc_dir_entry *parent,\n\t\t\t\t\tconst struct file_operations *proc_fops,\n\t\t\t\t\tvoid *data)\n{\n\tstruct proc_dir_entry *pde;\n\tif ((mode & S_IFMT) == 0)\n\t\tmode |= S_IFREG;\n\n\tif (!S_ISREG(mode)) {\n\t\tWARN_ON(1);\t/* use proc_mkdir() */\n\t\treturn NULL;\n\t}\n\n\tBUG_ON(proc_fops == NULL);\n\n\tif ((mode & S_IALLUGO) == 0)\n\t\tmode |= S_IRUGO;\n\tpde = __proc_create(&parent, name, mode, 1);\n\tif (!pde)\n\t\tgoto out;\n\tpde->proc_fops = proc_fops;\n\tpde->data = data;\n\tpde->proc_iops = &proc_file_inode_operations;\n\tif (proc_register(parent, pde) < 0)\n\t\tgoto out_free;\n\treturn pde;\nout_free:\n\tkfree(pde);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations proc_file_inode_operations = {\n\t.setattr\t= proc_notify_change,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic const struct inode_operations proc_file_inode_operations = {\n\t.setattr\t= proc_notify_change,\n};\n\nstruct proc_dir_entry *proc_create_data(const char *name, umode_t mode,\n\t\t\t\t\tstruct proc_dir_entry *parent,\n\t\t\t\t\tconst struct file_operations *proc_fops,\n\t\t\t\t\tvoid *data)\n{\n\tstruct proc_dir_entry *pde;\n\tif ((mode & S_IFMT) == 0)\n\t\tmode |= S_IFREG;\n\n\tif (!S_ISREG(mode)) {\n\t\tWARN_ON(1);\t/* use proc_mkdir() */\n\t\treturn NULL;\n\t}\n\n\tBUG_ON(proc_fops == NULL);\n\n\tif ((mode & S_IALLUGO) == 0)\n\t\tmode |= S_IRUGO;\n\tpde = __proc_create(&parent, name, mode, 1);\n\tif (!pde)\n\t\tgoto out;\n\tpde->proc_fops = proc_fops;\n\tpde->data = data;\n\tpde->proc_iops = &proc_file_inode_operations;\n\tif (proc_register(parent, pde) < 0)\n\t\tgoto out_free;\n\treturn pde;\nout_free:\n\tkfree(pde);\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "sb->s_id",
            "f2fs_proc_root"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "451-455",
          "snippet": "struct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstruct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_build_stats",
          "args": [
            "sbi"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_build_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1669-1669",
          "snippet": "static inline int f2fs_build_stats(struct f2fs_sb_info *sbi) { return 0; }",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_build_stats(struct f2fs_sb_info *sbi) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "root->i_mode"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_iget",
          "args": [
            "sb",
            "F2FS_ROOT_INO(sbi)"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "151-206",
          "snippet": "struct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_ROOT_INO",
          "args": [
            "sbi"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recover_orphan_inodes",
          "args": [
            "sbi"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "recover_orphan_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "465-495",
          "snippet": "void recover_orphan_inodes(struct f2fs_sb_info *sbi)\n{\n\tblock_t start_blk, orphan_blkaddr, i, j;\n\n\tif (!is_set_ckpt_flags(F2FS_CKPT(sbi), CP_ORPHAN_PRESENT_FLAG))\n\t\treturn;\n\n\tset_sbi_flag(sbi, SBI_POR_DOING);\n\n\tstart_blk = __start_cp_addr(sbi) + 1 +\n\t\tle32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload);\n\torphan_blkaddr = __start_sum_addr(sbi) - 1;\n\n\tra_meta_pages(sbi, start_blk, orphan_blkaddr, META_CP);\n\n\tfor (i = 0; i < orphan_blkaddr; i++) {\n\t\tstruct page *page = get_meta_page(sbi, start_blk + i);\n\t\tstruct f2fs_orphan_block *orphan_blk;\n\n\t\torphan_blk = (struct f2fs_orphan_block *)page_address(page);\n\t\tfor (j = 0; j < le32_to_cpu(orphan_blk->entry_count); j++) {\n\t\t\tnid_t ino = le32_to_cpu(orphan_blk->ino[j]);\n\t\t\trecover_orphan_inode(sbi, ino);\n\t\t}\n\t\tf2fs_put_page(page, 1);\n\t}\n\t/* clear Orphan Flag */\n\tclear_ckpt_flags(F2FS_CKPT(sbi), CP_ORPHAN_PRESENT_FLAG);\n\tclear_sbi_flag(sbi, SBI_POR_DOING);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid recover_orphan_inodes(struct f2fs_sb_info *sbi)\n{\n\tblock_t start_blk, orphan_blkaddr, i, j;\n\n\tif (!is_set_ckpt_flags(F2FS_CKPT(sbi), CP_ORPHAN_PRESENT_FLAG))\n\t\treturn;\n\n\tset_sbi_flag(sbi, SBI_POR_DOING);\n\n\tstart_blk = __start_cp_addr(sbi) + 1 +\n\t\tle32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload);\n\torphan_blkaddr = __start_sum_addr(sbi) - 1;\n\n\tra_meta_pages(sbi, start_blk, orphan_blkaddr, META_CP);\n\n\tfor (i = 0; i < orphan_blkaddr; i++) {\n\t\tstruct page *page = get_meta_page(sbi, start_blk + i);\n\t\tstruct f2fs_orphan_block *orphan_blk;\n\n\t\torphan_blk = (struct f2fs_orphan_block *)page_address(page);\n\t\tfor (j = 0; j < le32_to_cpu(orphan_blk->entry_count); j++) {\n\t\t\tnid_t ino = le32_to_cpu(orphan_blk->ino[j]);\n\t\t\trecover_orphan_inode(sbi, ino);\n\t\t}\n\t\tf2fs_put_page(page, 1);\n\t}\n\t/* clear Orphan Flag */\n\tclear_ckpt_flags(F2FS_CKPT(sbi), CP_ORPHAN_PRESENT_FLAG);\n\tclear_sbi_flag(sbi, SBI_POR_DOING);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sbi->node_inode"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sbi->node_inode"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_NODE_INO",
          "args": [
            "sbi"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_gc_manager",
          "args": [
            "sbi"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "build_gc_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "743-746",
          "snippet": "void build_gc_manager(struct f2fs_sb_info *sbi)\n{\n\tDIRTY_I(sbi)->v_ops = &default_v_ops;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct victim_selection default_v_ops = {\n\t.get_victim = get_victim_by_default,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic const struct victim_selection default_v_ops = {\n\t.get_victim = get_victim_by_default,\n};\n\nvoid build_gc_manager(struct f2fs_sb_info *sbi)\n{\n\tDIRTY_I(sbi)->v_ops = &default_v_ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_node_manager",
          "args": [
            "sbi"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "build_node_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1965-1979",
          "snippet": "int build_node_manager(struct f2fs_sb_info *sbi)\n{\n\tint err;\n\n\tsbi->nm_info = kzalloc(sizeof(struct f2fs_nm_info), GFP_KERNEL);\n\tif (!sbi->nm_info)\n\t\treturn -ENOMEM;\n\n\terr = init_node_manager(sbi);\n\tif (err)\n\t\treturn err;\n\n\tbuild_free_nids(sbi);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint build_node_manager(struct f2fs_sb_info *sbi)\n{\n\tint err;\n\n\tsbi->nm_info = kzalloc(sizeof(struct f2fs_nm_info), GFP_KERNEL);\n\tif (!sbi->nm_info)\n\t\treturn -ENOMEM;\n\n\terr = init_node_manager(sbi);\n\tif (err)\n\t\treturn err;\n\n\tbuild_free_nids(sbi);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_segment_manager",
          "args": [
            "sbi"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "build_segment_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "2109-2169",
          "snippet": "int build_segment_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_sm_info *sm_info;\n\tint err;\n\n\tsm_info = kzalloc(sizeof(struct f2fs_sm_info), GFP_KERNEL);\n\tif (!sm_info)\n\t\treturn -ENOMEM;\n\n\t/* init sm info */\n\tsbi->sm_info = sm_info;\n\tsm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);\n\tsm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);\n\tsm_info->segment_count = le32_to_cpu(raw_super->segment_count);\n\tsm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);\n\tsm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);\n\tsm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);\n\tsm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);\n\tsm_info->rec_prefree_segments = sm_info->main_segments *\n\t\t\t\t\tDEF_RECLAIM_PREFREE_SEGMENTS / 100;\n\tsm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;\n\tsm_info->min_ipu_util = DEF_MIN_IPU_UTIL;\n\tsm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;\n\n\tINIT_LIST_HEAD(&sm_info->discard_list);\n\tsm_info->nr_discards = 0;\n\tsm_info->max_discards = 0;\n\n\tsm_info->trim_sections = DEF_BATCHED_TRIM_SECTIONS;\n\n\tINIT_LIST_HEAD(&sm_info->sit_entry_set);\n\n\tif (test_opt(sbi, FLUSH_MERGE) && !f2fs_readonly(sbi->sb)) {\n\t\terr = create_flush_cmd_control(sbi);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = build_sit_info(sbi);\n\tif (err)\n\t\treturn err;\n\terr = build_free_segmap(sbi);\n\tif (err)\n\t\treturn err;\n\terr = build_curseg(sbi);\n\tif (err)\n\t\treturn err;\n\n\t/* reinit free segmap based on SIT */\n\tbuild_sit_entries(sbi);\n\n\tinit_free_segmap(sbi);\n\terr = build_dirty_segmap(sbi);\n\tif (err)\n\t\treturn err;\n\n\tinit_min_max_mtime(sbi);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint build_segment_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_sm_info *sm_info;\n\tint err;\n\n\tsm_info = kzalloc(sizeof(struct f2fs_sm_info), GFP_KERNEL);\n\tif (!sm_info)\n\t\treturn -ENOMEM;\n\n\t/* init sm info */\n\tsbi->sm_info = sm_info;\n\tsm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);\n\tsm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);\n\tsm_info->segment_count = le32_to_cpu(raw_super->segment_count);\n\tsm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);\n\tsm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);\n\tsm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);\n\tsm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);\n\tsm_info->rec_prefree_segments = sm_info->main_segments *\n\t\t\t\t\tDEF_RECLAIM_PREFREE_SEGMENTS / 100;\n\tsm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;\n\tsm_info->min_ipu_util = DEF_MIN_IPU_UTIL;\n\tsm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;\n\n\tINIT_LIST_HEAD(&sm_info->discard_list);\n\tsm_info->nr_discards = 0;\n\tsm_info->max_discards = 0;\n\n\tsm_info->trim_sections = DEF_BATCHED_TRIM_SECTIONS;\n\n\tINIT_LIST_HEAD(&sm_info->sit_entry_set);\n\n\tif (test_opt(sbi, FLUSH_MERGE) && !f2fs_readonly(sbi->sb)) {\n\t\terr = create_flush_cmd_control(sbi);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = build_sit_info(sbi);\n\tif (err)\n\t\treturn err;\n\terr = build_free_segmap(sbi);\n\tif (err)\n\t\treturn err;\n\terr = build_curseg(sbi);\n\tif (err)\n\t\treturn err;\n\n\t/* reinit free segmap based on SIT */\n\tbuild_sit_entries(sbi);\n\n\tinit_free_segmap(sbi);\n\terr = build_dirty_segmap(sbi);\n\tif (err)\n\t\treturn err;\n\n\tinit_min_max_mtime(sbi);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_ino_entry_info",
          "args": [
            "sbi"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "init_ino_entry_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "1093-1114",
          "snippet": "void init_ino_entry_info(struct f2fs_sb_info *sbi)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_INO_ENTRY; i++) {\n\t\tstruct inode_management *im = &sbi->im[i];\n\n\t\tINIT_RADIX_TREE(&im->ino_root, GFP_ATOMIC);\n\t\tspin_lock_init(&im->ino_lock);\n\t\tINIT_LIST_HEAD(&im->ino_list);\n\t\tim->ino_num = 0;\n\t}\n\n\t/*\n\t * considering 512 blocks in a segment 8 blocks are needed for cp\n\t * and log segment summaries. Remaining blocks are used to keep\n\t * orphan entries with the limitation one reserved segment\n\t * for cp pack we can have max 1020*504 orphan entries\n\t */\n\tsbi->max_orphans = (sbi->blocks_per_seg - F2FS_CP_PACKS -\n\t\t\tNR_CURSEG_TYPE) * F2FS_ORPHANS_PER_BLOCK;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid init_ino_entry_info(struct f2fs_sb_info *sbi)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_INO_ENTRY; i++) {\n\t\tstruct inode_management *im = &sbi->im[i];\n\n\t\tINIT_RADIX_TREE(&im->ino_root, GFP_ATOMIC);\n\t\tspin_lock_init(&im->ino_lock);\n\t\tINIT_LIST_HEAD(&im->ino_list);\n\t\tim->ino_num = 0;\n\t}\n\n\t/*\n\t * considering 512 blocks in a segment 8 blocks are needed for cp\n\t * and log segment summaries. Remaining blocks are used to keep\n\t * orphan entries with the limitation one reserved segment\n\t * for cp pack we can have max 1020*504 orphan entries\n\t */\n\tsbi->max_orphans = (sbi->blocks_per_seg - F2FS_CP_PACKS -\n\t\t\tNR_CURSEG_TYPE) * F2FS_ORPHANS_PER_BLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->dir_inode_lock"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sbi->dir_inode_list"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "sbi->ckpt->valid_block_count"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbi->ckpt->valid_inode_count"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sanity_check_ckpt",
          "args": [
            "sbi"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "sanity_check_ckpt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "858-879",
          "snippet": "static int sanity_check_ckpt(struct f2fs_sb_info *sbi)\n{\n\tunsigned int total, fsmeta;\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\n\ttotal = le32_to_cpu(raw_super->segment_count);\n\tfsmeta = le32_to_cpu(raw_super->segment_count_ckpt);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_sit);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_nat);\n\tfsmeta += le32_to_cpu(ckpt->rsvd_segment_count);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_ssa);\n\n\tif (unlikely(fsmeta >= total))\n\t\treturn 1;\n\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\tf2fs_msg(sbi->sb, KERN_ERR, \"A bug case: need to run fsck\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int sanity_check_ckpt(struct f2fs_sb_info *sbi)\n{\n\tunsigned int total, fsmeta;\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\n\ttotal = le32_to_cpu(raw_super->segment_count);\n\tfsmeta = le32_to_cpu(raw_super->segment_count_ckpt);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_sit);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_nat);\n\tfsmeta += le32_to_cpu(ckpt->rsvd_segment_count);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_ssa);\n\n\tif (unlikely(fsmeta >= total))\n\t\treturn 1;\n\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\tf2fs_msg(sbi->sb, KERN_ERR, \"A bug case: need to run fsck\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_valid_checkpoint",
          "args": [
            "sbi"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "get_valid_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "610-677",
          "snippet": "int get_valid_checkpoint(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_checkpoint *cp_block;\n\tstruct f2fs_super_block *fsb = sbi->raw_super;\n\tstruct page *cp1, *cp2, *cur_page;\n\tunsigned long blk_size = sbi->blocksize;\n\tunsigned long long cp1_version = 0, cp2_version = 0;\n\tunsigned long long cp_start_blk_no;\n\tunsigned int cp_blks = 1 + le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload);\n\tblock_t cp_blk_no;\n\tint i;\n\n\tsbi->ckpt = kzalloc(cp_blks * blk_size, GFP_KERNEL);\n\tif (!sbi->ckpt)\n\t\treturn -ENOMEM;\n\t/*\n\t * Finding out valid cp block involves read both\n\t * sets( cp pack1 and cp pack 2)\n\t */\n\tcp_start_blk_no = le32_to_cpu(fsb->cp_blkaddr);\n\tcp1 = validate_checkpoint(sbi, cp_start_blk_no, &cp1_version);\n\n\t/* The second checkpoint pack should start at the next segment */\n\tcp_start_blk_no += ((unsigned long long)1) <<\n\t\t\t\tle32_to_cpu(fsb->log_blocks_per_seg);\n\tcp2 = validate_checkpoint(sbi, cp_start_blk_no, &cp2_version);\n\n\tif (cp1 && cp2) {\n\t\tif (ver_after(cp2_version, cp1_version))\n\t\t\tcur_page = cp2;\n\t\telse\n\t\t\tcur_page = cp1;\n\t} else if (cp1) {\n\t\tcur_page = cp1;\n\t} else if (cp2) {\n\t\tcur_page = cp2;\n\t} else {\n\t\tgoto fail_no_cp;\n\t}\n\n\tcp_block = (struct f2fs_checkpoint *)page_address(cur_page);\n\tmemcpy(sbi->ckpt, cp_block, blk_size);\n\n\tif (cp_blks <= 1)\n\t\tgoto done;\n\n\tcp_blk_no = le32_to_cpu(fsb->cp_blkaddr);\n\tif (cur_page == cp2)\n\t\tcp_blk_no += 1 << le32_to_cpu(fsb->log_blocks_per_seg);\n\n\tfor (i = 1; i < cp_blks; i++) {\n\t\tvoid *sit_bitmap_ptr;\n\t\tunsigned char *ckpt = (unsigned char *)sbi->ckpt;\n\n\t\tcur_page = get_meta_page(sbi, cp_blk_no + i);\n\t\tsit_bitmap_ptr = page_address(cur_page);\n\t\tmemcpy(ckpt + i * blk_size, sit_bitmap_ptr, blk_size);\n\t\tf2fs_put_page(cur_page, 1);\n\t}\ndone:\n\tf2fs_put_page(cp1, 1);\n\tf2fs_put_page(cp2, 1);\n\treturn 0;\n\nfail_no_cp:\n\tkfree(sbi->ckpt);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nint get_valid_checkpoint(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_checkpoint *cp_block;\n\tstruct f2fs_super_block *fsb = sbi->raw_super;\n\tstruct page *cp1, *cp2, *cur_page;\n\tunsigned long blk_size = sbi->blocksize;\n\tunsigned long long cp1_version = 0, cp2_version = 0;\n\tunsigned long long cp_start_blk_no;\n\tunsigned int cp_blks = 1 + le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload);\n\tblock_t cp_blk_no;\n\tint i;\n\n\tsbi->ckpt = kzalloc(cp_blks * blk_size, GFP_KERNEL);\n\tif (!sbi->ckpt)\n\t\treturn -ENOMEM;\n\t/*\n\t * Finding out valid cp block involves read both\n\t * sets( cp pack1 and cp pack 2)\n\t */\n\tcp_start_blk_no = le32_to_cpu(fsb->cp_blkaddr);\n\tcp1 = validate_checkpoint(sbi, cp_start_blk_no, &cp1_version);\n\n\t/* The second checkpoint pack should start at the next segment */\n\tcp_start_blk_no += ((unsigned long long)1) <<\n\t\t\t\tle32_to_cpu(fsb->log_blocks_per_seg);\n\tcp2 = validate_checkpoint(sbi, cp_start_blk_no, &cp2_version);\n\n\tif (cp1 && cp2) {\n\t\tif (ver_after(cp2_version, cp1_version))\n\t\t\tcur_page = cp2;\n\t\telse\n\t\t\tcur_page = cp1;\n\t} else if (cp1) {\n\t\tcur_page = cp1;\n\t} else if (cp2) {\n\t\tcur_page = cp2;\n\t} else {\n\t\tgoto fail_no_cp;\n\t}\n\n\tcp_block = (struct f2fs_checkpoint *)page_address(cur_page);\n\tmemcpy(sbi->ckpt, cp_block, blk_size);\n\n\tif (cp_blks <= 1)\n\t\tgoto done;\n\n\tcp_blk_no = le32_to_cpu(fsb->cp_blkaddr);\n\tif (cur_page == cp2)\n\t\tcp_blk_no += 1 << le32_to_cpu(fsb->log_blocks_per_seg);\n\n\tfor (i = 1; i < cp_blks; i++) {\n\t\tvoid *sit_bitmap_ptr;\n\t\tunsigned char *ckpt = (unsigned char *)sbi->ckpt;\n\n\t\tcur_page = get_meta_page(sbi, cp_blk_no + i);\n\t\tsit_bitmap_ptr = page_address(cur_page);\n\t\tmemcpy(ckpt + i * blk_size, sit_bitmap_ptr, blk_size);\n\t\tf2fs_put_page(cur_page, 1);\n\t}\ndone:\n\tf2fs_put_page(cp1, 1);\n\tf2fs_put_page(cp2, 1);\n\treturn 0;\n\nfail_no_cp:\n\tkfree(sbi->ckpt);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sbi->meta_inode"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sbi->meta_inode"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_META_INO",
          "args": [
            "sbi"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sb_info",
          "args": [
            "sbi"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "init_sb_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "881-909",
          "snippet": "static void init_sb_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = sbi->raw_super;\n\tint i;\n\n\tsbi->log_sectors_per_block =\n\t\tle32_to_cpu(raw_super->log_sectors_per_block);\n\tsbi->log_blocksize = le32_to_cpu(raw_super->log_blocksize);\n\tsbi->blocksize = 1 << sbi->log_blocksize;\n\tsbi->log_blocks_per_seg = le32_to_cpu(raw_super->log_blocks_per_seg);\n\tsbi->blocks_per_seg = 1 << sbi->log_blocks_per_seg;\n\tsbi->segs_per_sec = le32_to_cpu(raw_super->segs_per_sec);\n\tsbi->secs_per_zone = le32_to_cpu(raw_super->secs_per_zone);\n\tsbi->total_sections = le32_to_cpu(raw_super->section_count);\n\tsbi->total_node_count =\n\t\t(le32_to_cpu(raw_super->segment_count_nat) / 2)\n\t\t\t* sbi->blocks_per_seg * NAT_ENTRY_PER_BLOCK;\n\tsbi->root_ino_num = le32_to_cpu(raw_super->root_ino);\n\tsbi->node_ino_num = le32_to_cpu(raw_super->node_ino);\n\tsbi->meta_ino_num = le32_to_cpu(raw_super->meta_ino);\n\tsbi->cur_victim_sec = NULL_SECNO;\n\tsbi->max_victim_search = DEF_MAX_VICTIM_SEARCH;\n\n\tfor (i = 0; i < NR_COUNT_TYPE; i++)\n\t\tatomic_set(&sbi->nr_pages[i], 0);\n\n\tsbi->dir_level = DEF_DIR_LEVEL;\n\tclear_sbi_flag(sbi, SBI_NEED_FSCK);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void init_sb_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = sbi->raw_super;\n\tint i;\n\n\tsbi->log_sectors_per_block =\n\t\tle32_to_cpu(raw_super->log_sectors_per_block);\n\tsbi->log_blocksize = le32_to_cpu(raw_super->log_blocksize);\n\tsbi->blocksize = 1 << sbi->log_blocksize;\n\tsbi->log_blocks_per_seg = le32_to_cpu(raw_super->log_blocks_per_seg);\n\tsbi->blocks_per_seg = 1 << sbi->log_blocks_per_seg;\n\tsbi->segs_per_sec = le32_to_cpu(raw_super->segs_per_sec);\n\tsbi->secs_per_zone = le32_to_cpu(raw_super->secs_per_zone);\n\tsbi->total_sections = le32_to_cpu(raw_super->section_count);\n\tsbi->total_node_count =\n\t\t(le32_to_cpu(raw_super->segment_count_nat) / 2)\n\t\t\t* sbi->blocks_per_seg * NAT_ENTRY_PER_BLOCK;\n\tsbi->root_ino_num = le32_to_cpu(raw_super->root_ino);\n\tsbi->node_ino_num = le32_to_cpu(raw_super->node_ino);\n\tsbi->meta_ino_num = le32_to_cpu(raw_super->meta_ino);\n\tsbi->cur_victim_sec = NULL_SECNO;\n\tsbi->max_victim_search = DEF_MAX_VICTIM_SEARCH;\n\n\tfor (i = 0; i < NR_COUNT_TYPE; i++)\n\t\tatomic_set(&sbi->nr_pages[i], 0);\n\n\tsbi->dir_level = DEF_DIR_LEVEL;\n\tclear_sbi_flag(sbi, SBI_NEED_FSCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&sbi->cp_wait"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&sbi->cp_rwsem"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&sbi->write_io[i].io_rwsem"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&sbi->read_io.io_rwsem"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->stat_lock"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_sbi_flag",
          "args": [
            "sbi",
            "SBI_POR_DOING"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "clear_sbi_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "725-728",
          "snippet": "static inline void clear_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag &= ~(0x01 << type);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag &= ~(0x01 << type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&sbi->node_write"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->cp_mutex"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->writepages"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->gc_mutex"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sb->s_uuid",
            "raw_super->uuid",
            "sizeof(raw_super->uuid)"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "POSIX_ACL"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "&sbi->s_next_generation",
            "sizeof(u32)"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_file_size",
          "args": [
            "le32_to_cpu(raw_super->log_blocksize)"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "max_file_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "788-806",
          "snippet": "static loff_t max_file_size(unsigned bits)\n{\n\tloff_t result = (DEF_ADDRS_PER_INODE - F2FS_INLINE_XATTR_ADDRS);\n\tloff_t leaf_count = ADDRS_PER_BLOCK;\n\n\t/* two direct node blocks */\n\tresult += (leaf_count * 2);\n\n\t/* two indirect node blocks */\n\tleaf_count *= NIDS_PER_BLOCK;\n\tresult += (leaf_count * 2);\n\n\t/* one double indirect node block */\n\tleaf_count *= NIDS_PER_BLOCK;\n\tresult += leaf_count;\n\n\tresult <<= bits;\n\treturn result;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic loff_t max_file_size(unsigned bits)\n{\n\tloff_t result = (DEF_ADDRS_PER_INODE - F2FS_INLINE_XATTR_ADDRS);\n\tloff_t leaf_count = ADDRS_PER_BLOCK;\n\n\t/* two direct node blocks */\n\tresult += (leaf_count * 2);\n\n\t/* two indirect node blocks */\n\tleaf_count *= NIDS_PER_BLOCK;\n\tresult += (leaf_count * 2);\n\n\t/* one double indirect node block */\n\tleaf_count *= NIDS_PER_BLOCK;\n\tresult += leaf_count;\n\n\tresult <<= bits;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "sb",
            "options"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "254-378",
          "snippet": "static int parse_options(struct super_block *sb, char *options)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p, *name;\n\tint arg = 0;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, f2fs_tokens, args);\n\n\t\tswitch (token) {\n\t\tcase Opt_gc_background:\n\t\t\tname = match_strdup(&args[0]);\n\n\t\t\tif (!name)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (strlen(name) == 2 && !strncmp(name, \"on\", 2))\n\t\t\t\tset_opt(sbi, BG_GC);\n\t\t\telse if (strlen(name) == 3 && !strncmp(name, \"off\", 3))\n\t\t\t\tclear_opt(sbi, BG_GC);\n\t\t\telse {\n\t\t\t\tkfree(name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tkfree(name);\n\t\t\tbreak;\n\t\tcase Opt_disable_roll_forward:\n\t\t\tset_opt(sbi, DISABLE_ROLL_FORWARD);\n\t\t\tbreak;\n\t\tcase Opt_norecovery:\n\t\t\t/* this option mounts f2fs with ro */\n\t\t\tset_opt(sbi, DISABLE_ROLL_FORWARD);\n\t\t\tif (!f2fs_readonly(sb))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tset_opt(sbi, DISCARD);\n\t\t\tbreak;\n\t\tcase Opt_noheap:\n\t\t\tset_opt(sbi, NOHEAP);\n\t\t\tbreak;\n#ifdef CONFIG_F2FS_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt(sbi, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt(sbi, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_inline_xattr:\n\t\t\tset_opt(sbi, INLINE_XATTR);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\t\"user_xattr options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\t\"nouser_xattr options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_inline_xattr:\n\t\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\t\"inline_xattr options not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_F2FS_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\t\tf2fs_msg(sb, KERN_INFO, \"acl options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tf2fs_msg(sb, KERN_INFO, \"noacl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_active_logs:\n\t\t\tif (args->from && match_int(args, &arg))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (arg != 2 && arg != 4 && arg != NR_CURSEG_TYPE)\n\t\t\t\treturn -EINVAL;\n\t\t\tsbi->active_logs = arg;\n\t\t\tbreak;\n\t\tcase Opt_disable_ext_identify:\n\t\t\tset_opt(sbi, DISABLE_EXT_IDENTIFY);\n\t\t\tbreak;\n\t\tcase Opt_inline_data:\n\t\t\tset_opt(sbi, INLINE_DATA);\n\t\t\tbreak;\n\t\tcase Opt_inline_dentry:\n\t\t\tset_opt(sbi, INLINE_DENTRY);\n\t\t\tbreak;\n\t\tcase Opt_flush_merge:\n\t\t\tset_opt(sbi, FLUSH_MERGE);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tset_opt(sbi, NOBARRIER);\n\t\t\tbreak;\n\t\tcase Opt_fastboot:\n\t\t\tset_opt(sbi, FASTBOOT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t\t\"Unrecognized mount option \\\"%s\\\" or missing value\",\n\t\t\t\tp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static match_table_t f2fs_tokens = {\n\t{Opt_gc_background, \"background_gc=%s\"},\n\t{Opt_disable_roll_forward, \"disable_roll_forward\"},\n\t{Opt_norecovery, \"norecovery\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_noheap, \"no_heap\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_active_logs, \"active_logs=%u\"},\n\t{Opt_disable_ext_identify, \"disable_ext_identify\"},\n\t{Opt_inline_xattr, \"inline_xattr\"},\n\t{Opt_inline_data, \"inline_data\"},\n\t{Opt_inline_dentry, \"inline_dentry\"},\n\t{Opt_flush_merge, \"flush_merge\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_fastboot, \"fastboot\"},\n\t{Opt_err, NULL},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic match_table_t f2fs_tokens = {\n\t{Opt_gc_background, \"background_gc=%s\"},\n\t{Opt_disable_roll_forward, \"disable_roll_forward\"},\n\t{Opt_norecovery, \"norecovery\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_noheap, \"no_heap\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_active_logs, \"active_logs=%u\"},\n\t{Opt_disable_ext_identify, \"disable_ext_identify\"},\n\t{Opt_inline_xattr, \"inline_xattr\"},\n\t{Opt_inline_data, \"inline_data\"},\n\t{Opt_inline_dentry, \"inline_dentry\"},\n\t{Opt_flush_merge, \"flush_merge\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_fastboot, \"fastboot\"},\n\t{Opt_err, NULL},\n};\n\nstatic int parse_options(struct super_block *sb, char *options)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p, *name;\n\tint arg = 0;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, f2fs_tokens, args);\n\n\t\tswitch (token) {\n\t\tcase Opt_gc_background:\n\t\t\tname = match_strdup(&args[0]);\n\n\t\t\tif (!name)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (strlen(name) == 2 && !strncmp(name, \"on\", 2))\n\t\t\t\tset_opt(sbi, BG_GC);\n\t\t\telse if (strlen(name) == 3 && !strncmp(name, \"off\", 3))\n\t\t\t\tclear_opt(sbi, BG_GC);\n\t\t\telse {\n\t\t\t\tkfree(name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tkfree(name);\n\t\t\tbreak;\n\t\tcase Opt_disable_roll_forward:\n\t\t\tset_opt(sbi, DISABLE_ROLL_FORWARD);\n\t\t\tbreak;\n\t\tcase Opt_norecovery:\n\t\t\t/* this option mounts f2fs with ro */\n\t\t\tset_opt(sbi, DISABLE_ROLL_FORWARD);\n\t\t\tif (!f2fs_readonly(sb))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tset_opt(sbi, DISCARD);\n\t\t\tbreak;\n\t\tcase Opt_noheap:\n\t\t\tset_opt(sbi, NOHEAP);\n\t\t\tbreak;\n#ifdef CONFIG_F2FS_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt(sbi, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt(sbi, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_inline_xattr:\n\t\t\tset_opt(sbi, INLINE_XATTR);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\t\"user_xattr options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\t\"nouser_xattr options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_inline_xattr:\n\t\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\t\"inline_xattr options not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_F2FS_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\t\tf2fs_msg(sb, KERN_INFO, \"acl options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tf2fs_msg(sb, KERN_INFO, \"noacl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_active_logs:\n\t\t\tif (args->from && match_int(args, &arg))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (arg != 2 && arg != 4 && arg != NR_CURSEG_TYPE)\n\t\t\t\treturn -EINVAL;\n\t\t\tsbi->active_logs = arg;\n\t\t\tbreak;\n\t\tcase Opt_disable_ext_identify:\n\t\t\tset_opt(sbi, DISABLE_EXT_IDENTIFY);\n\t\t\tbreak;\n\t\tcase Opt_inline_data:\n\t\t\tset_opt(sbi, INLINE_DATA);\n\t\t\tbreak;\n\t\tcase Opt_inline_dentry:\n\t\t\tset_opt(sbi, INLINE_DENTRY);\n\t\t\tbreak;\n\t\tcase Opt_flush_merge:\n\t\t\tset_opt(sbi, FLUSH_MERGE);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tset_opt(sbi, NOBARRIER);\n\t\t\tbreak;\n\t\tcase Opt_fastboot:\n\t\t\tset_opt(sbi, FASTBOOT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t\t\"Unrecognized mount option \\\"%s\\\" or missing value\",\n\t\t\t\tp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "(const char *)data",
            "GFP_KERNEL"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_opt",
          "args": [
            "sbi",
            "POSIX_ACL"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_set_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1239-1271",
          "snippet": "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_raw_super_block",
          "args": [
            "sb",
            "&raw_super",
            "&raw_super_buf"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "read_raw_super_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "916-953",
          "snippet": "static int read_raw_super_block(struct super_block *sb,\n\t\t\tstruct f2fs_super_block **raw_super,\n\t\t\tstruct buffer_head **raw_super_buf)\n{\n\tint block = 0;\n\nretry:\n\t*raw_super_buf = sb_bread(sb, block);\n\tif (!*raw_super_buf) {\n\t\tf2fs_msg(sb, KERN_ERR, \"Unable to read %dth superblock\",\n\t\t\t\tblock + 1);\n\t\tif (block == 0) {\n\t\t\tblock++;\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t*raw_super = (struct f2fs_super_block *)\n\t\t((char *)(*raw_super_buf)->b_data + F2FS_SUPER_OFFSET);\n\n\t/* sanity checking of raw super */\n\tif (sanity_check_raw_super(sb, *raw_super)) {\n\t\tbrelse(*raw_super_buf);\n\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t\"Can't find valid F2FS filesystem in %dth superblock\",\n\t\t\t\t\t\t\t\tblock + 1);\n\t\tif (block == 0) {\n\t\t\tblock++;\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int read_raw_super_block(struct super_block *sb,\n\t\t\tstruct f2fs_super_block **raw_super,\n\t\t\tstruct buffer_head **raw_super_buf)\n{\n\tint block = 0;\n\nretry:\n\t*raw_super_buf = sb_bread(sb, block);\n\tif (!*raw_super_buf) {\n\t\tf2fs_msg(sb, KERN_ERR, \"Unable to read %dth superblock\",\n\t\t\t\tblock + 1);\n\t\tif (block == 0) {\n\t\t\tblock++;\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t*raw_super = (struct f2fs_super_block *)\n\t\t((char *)(*raw_super_buf)->b_data + F2FS_SUPER_OFFSET);\n\n\t/* sanity checking of raw super */\n\tif (sanity_check_raw_super(sb, *raw_super)) {\n\t\tbrelse(*raw_super_buf);\n\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t\"Can't find valid F2FS filesystem in %dth superblock\",\n\t\t\t\t\t\t\t\tblock + 1);\n\t\tif (block == 0) {\n\t\t\tblock++;\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!sb_set_blocksize(sb, F2FS_BLKSIZE)"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "F2FS_BLKSIZE"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct f2fs_sb_info)",
            "GFP_KERNEL"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct proc_dir_entry *f2fs_proc_root;\nstatic struct kset *f2fs_kset;\nstatic struct kobj_type f2fs_ktype = {\n\t.default_attrs\t= f2fs_attrs,\n\t.sysfs_ops\t= &f2fs_attr_ops,\n\t.release\t= f2fs_sb_release,\n};\nstatic const struct file_operations f2fs_seq_segment_info_fops = {\n\t.owner = THIS_MODULE,\n\t.open = segment_info_open_fs,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\nstatic struct super_operations f2fs_sops = {\n\t.alloc_inode\t= f2fs_alloc_inode,\n\t.drop_inode\t= f2fs_drop_inode,\n\t.destroy_inode\t= f2fs_destroy_inode,\n\t.write_inode\t= f2fs_write_inode,\n\t.dirty_inode\t= f2fs_dirty_inode,\n\t.show_options\t= f2fs_show_options,\n\t.evict_inode\t= f2fs_evict_inode,\n\t.put_super\t= f2fs_put_super,\n\t.sync_fs\t= f2fs_sync_fs,\n\t.freeze_fs\t= f2fs_freeze,\n\t.unfreeze_fs\t= f2fs_unfreeze,\n\t.statfs\t\t= f2fs_statfs,\n\t.remount_fs\t= f2fs_remount,\n};\nstatic const struct export_operations f2fs_export_ops = {\n\t.fh_to_dentry = f2fs_fh_to_dentry,\n\t.fh_to_parent = f2fs_fh_to_parent,\n\t.get_parent = f2fs_get_parent,\n};\n\nstatic int f2fs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct f2fs_sb_info *sbi;\n\tstruct f2fs_super_block *raw_super = NULL;\n\tstruct buffer_head *raw_super_buf;\n\tstruct inode *root;\n\tlong err = -EINVAL;\n\tbool retry = true;\n\tchar *options = NULL;\n\tint i;\n\ntry_onemore:\n\t/* allocate memory for f2fs-specific super block info */\n\tsbi = kzalloc(sizeof(struct f2fs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\t/* set a block size */\n\tif (unlikely(!sb_set_blocksize(sb, F2FS_BLKSIZE))) {\n\t\tf2fs_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto free_sbi;\n\t}\n\n\terr = read_raw_super_block(sb, &raw_super, &raw_super_buf);\n\tif (err)\n\t\tgoto free_sbi;\n\n\tsb->s_fs_info = sbi;\n\t/* init some FS parameters */\n\tsbi->active_logs = NR_CURSEG_TYPE;\n\n\tset_opt(sbi, BG_GC);\n\n#ifdef CONFIG_F2FS_FS_XATTR\n\tset_opt(sbi, XATTR_USER);\n#endif\n#ifdef CONFIG_F2FS_FS_POSIX_ACL\n\tset_opt(sbi, POSIX_ACL);\n#endif\n\t/* parse mount options */\n\toptions = kstrdup((const char *)data, GFP_KERNEL);\n\tif (data && !options) {\n\t\terr = -ENOMEM;\n\t\tgoto free_sb_buf;\n\t}\n\n\terr = parse_options(sb, options);\n\tif (err)\n\t\tgoto free_options;\n\n\tsb->s_maxbytes = max_file_size(le32_to_cpu(raw_super->log_blocksize));\n\tsb->s_max_links = F2FS_LINK_MAX;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\n\tsb->s_op = &f2fs_sops;\n\tsb->s_xattr = f2fs_xattr_handlers;\n\tsb->s_export_op = &f2fs_export_ops;\n\tsb->s_magic = F2FS_SUPER_MAGIC;\n\tsb->s_time_gran = 1;\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sbi, POSIX_ACL) ? MS_POSIXACL : 0);\n\tmemcpy(sb->s_uuid, raw_super->uuid, sizeof(raw_super->uuid));\n\n\t/* init f2fs-specific super block info */\n\tsbi->sb = sb;\n\tsbi->raw_super = raw_super;\n\tsbi->raw_super_buf = raw_super_buf;\n\tmutex_init(&sbi->gc_mutex);\n\tmutex_init(&sbi->writepages);\n\tmutex_init(&sbi->cp_mutex);\n\tinit_rwsem(&sbi->node_write);\n\tclear_sbi_flag(sbi, SBI_POR_DOING);\n\tspin_lock_init(&sbi->stat_lock);\n\n\tinit_rwsem(&sbi->read_io.io_rwsem);\n\tsbi->read_io.sbi = sbi;\n\tsbi->read_io.bio = NULL;\n\tfor (i = 0; i < NR_PAGE_TYPE; i++) {\n\t\tinit_rwsem(&sbi->write_io[i].io_rwsem);\n\t\tsbi->write_io[i].sbi = sbi;\n\t\tsbi->write_io[i].bio = NULL;\n\t}\n\n\tinit_rwsem(&sbi->cp_rwsem);\n\tinit_waitqueue_head(&sbi->cp_wait);\n\tinit_sb_info(sbi);\n\n\t/* get an inode for meta space */\n\tsbi->meta_inode = f2fs_iget(sb, F2FS_META_INO(sbi));\n\tif (IS_ERR(sbi->meta_inode)) {\n\t\tf2fs_msg(sb, KERN_ERR, \"Failed to read F2FS meta data inode\");\n\t\terr = PTR_ERR(sbi->meta_inode);\n\t\tgoto free_options;\n\t}\n\n\terr = get_valid_checkpoint(sbi);\n\tif (err) {\n\t\tf2fs_msg(sb, KERN_ERR, \"Failed to get valid F2FS checkpoint\");\n\t\tgoto free_meta_inode;\n\t}\n\n\t/* sanity checking of checkpoint */\n\terr = -EINVAL;\n\tif (sanity_check_ckpt(sbi)) {\n\t\tf2fs_msg(sb, KERN_ERR, \"Invalid F2FS checkpoint\");\n\t\tgoto free_cp;\n\t}\n\n\tsbi->total_valid_node_count =\n\t\t\t\tle32_to_cpu(sbi->ckpt->valid_node_count);\n\tsbi->total_valid_inode_count =\n\t\t\t\tle32_to_cpu(sbi->ckpt->valid_inode_count);\n\tsbi->user_block_count = le64_to_cpu(sbi->ckpt->user_block_count);\n\tsbi->total_valid_block_count =\n\t\t\t\tle64_to_cpu(sbi->ckpt->valid_block_count);\n\tsbi->last_valid_block_count = sbi->total_valid_block_count;\n\tsbi->alloc_valid_block_count = 0;\n\tINIT_LIST_HEAD(&sbi->dir_inode_list);\n\tspin_lock_init(&sbi->dir_inode_lock);\n\n\tinit_ino_entry_info(sbi);\n\n\t/* setup f2fs internal modules */\n\terr = build_segment_manager(sbi);\n\tif (err) {\n\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t\"Failed to initialize F2FS segment manager\");\n\t\tgoto free_sm;\n\t}\n\terr = build_node_manager(sbi);\n\tif (err) {\n\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t\"Failed to initialize F2FS node manager\");\n\t\tgoto free_nm;\n\t}\n\n\tbuild_gc_manager(sbi);\n\n\t/* get an inode for node space */\n\tsbi->node_inode = f2fs_iget(sb, F2FS_NODE_INO(sbi));\n\tif (IS_ERR(sbi->node_inode)) {\n\t\tf2fs_msg(sb, KERN_ERR, \"Failed to read node inode\");\n\t\terr = PTR_ERR(sbi->node_inode);\n\t\tgoto free_nm;\n\t}\n\n\t/* if there are nt orphan nodes free them */\n\trecover_orphan_inodes(sbi);\n\n\t/* read root inode and dentry */\n\troot = f2fs_iget(sb, F2FS_ROOT_INO(sbi));\n\tif (IS_ERR(root)) {\n\t\tf2fs_msg(sb, KERN_ERR, \"Failed to read root inode\");\n\t\terr = PTR_ERR(root);\n\t\tgoto free_node_inode;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\tiput(root);\n\t\terr = -EINVAL;\n\t\tgoto free_node_inode;\n\t}\n\n\tsb->s_root = d_make_root(root); /* allocate root dentry */\n\tif (!sb->s_root) {\n\t\terr = -ENOMEM;\n\t\tgoto free_root_inode;\n\t}\n\n\terr = f2fs_build_stats(sbi);\n\tif (err)\n\t\tgoto free_root_inode;\n\n\tif (f2fs_proc_root)\n\t\tsbi->s_proc = proc_mkdir(sb->s_id, f2fs_proc_root);\n\n\tif (sbi->s_proc)\n\t\tproc_create_data(\"segment_info\", S_IRUGO, sbi->s_proc,\n\t\t\t\t &f2fs_seq_segment_info_fops, sb);\n\n\tif (test_opt(sbi, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\tf2fs_msg(sb, KERN_WARNING,\n\t\t\t\t\t\"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t\t\"the device does not support discard\");\n\t}\n\n\tsbi->s_kobj.kset = f2fs_kset;\n\tinit_completion(&sbi->s_kobj_unregister);\n\terr = kobject_init_and_add(&sbi->s_kobj, &f2fs_ktype, NULL,\n\t\t\t\t\t\t\t\"%s\", sb->s_id);\n\tif (err)\n\t\tgoto free_proc;\n\n\tif (!retry)\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\n\t/* recover fsynced data */\n\tif (!test_opt(sbi, DISABLE_ROLL_FORWARD)) {\n\t\t/*\n\t\t * mount should be failed, when device has readonly mode, and\n\t\t * previous checkpoint was not done by clean system shutdown.\n\t\t */\n\t\tif (bdev_read_only(sb->s_bdev) &&\n\t\t\t\t!is_set_ckpt_flags(sbi->ckpt, CP_UMOUNT_FLAG)) {\n\t\t\terr = -EROFS;\n\t\t\tgoto free_kobj;\n\t\t}\n\t\terr = recover_fsync_data(sbi);\n\t\tif (err) {\n\t\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t\t\"Cannot recover all fsync data errno=%ld\", err);\n\t\t\tgoto free_kobj;\n\t\t}\n\t}\n\n\t/*\n\t * If filesystem is not mounted as read-only then\n\t * do start the gc_thread.\n\t */\n\tif (test_opt(sbi, BG_GC) && !f2fs_readonly(sb)) {\n\t\t/* After POR, we can run background GC thread.*/\n\t\terr = start_gc_thread(sbi);\n\t\tif (err)\n\t\t\tgoto free_kobj;\n\t}\n\tkfree(options);\n\treturn 0;\n\nfree_kobj:\n\tkobject_del(&sbi->s_kobj);\nfree_proc:\n\tif (sbi->s_proc) {\n\t\tremove_proc_entry(\"segment_info\", sbi->s_proc);\n\t\tremove_proc_entry(sb->s_id, f2fs_proc_root);\n\t}\n\tf2fs_destroy_stats(sbi);\nfree_root_inode:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfree_node_inode:\n\tiput(sbi->node_inode);\nfree_nm:\n\tdestroy_node_manager(sbi);\nfree_sm:\n\tdestroy_segment_manager(sbi);\nfree_cp:\n\tkfree(sbi->ckpt);\nfree_meta_inode:\n\tmake_bad_inode(sbi->meta_inode);\n\tiput(sbi->meta_inode);\nfree_options:\n\tkfree(options);\nfree_sb_buf:\n\tbrelse(raw_super_buf);\nfree_sbi:\n\tkfree(sbi);\n\n\t/* give only one another chance */\n\tif (retry) {\n\t\tretry = 0;\n\t\tshrink_dcache_sb(sb);\n\t\tgoto try_onemore;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "read_raw_super_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "916-953",
    "snippet": "static int read_raw_super_block(struct super_block *sb,\n\t\t\tstruct f2fs_super_block **raw_super,\n\t\t\tstruct buffer_head **raw_super_buf)\n{\n\tint block = 0;\n\nretry:\n\t*raw_super_buf = sb_bread(sb, block);\n\tif (!*raw_super_buf) {\n\t\tf2fs_msg(sb, KERN_ERR, \"Unable to read %dth superblock\",\n\t\t\t\tblock + 1);\n\t\tif (block == 0) {\n\t\t\tblock++;\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t*raw_super = (struct f2fs_super_block *)\n\t\t((char *)(*raw_super_buf)->b_data + F2FS_SUPER_OFFSET);\n\n\t/* sanity checking of raw super */\n\tif (sanity_check_raw_super(sb, *raw_super)) {\n\t\tbrelse(*raw_super_buf);\n\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t\"Can't find valid F2FS filesystem in %dth superblock\",\n\t\t\t\t\t\t\t\tblock + 1);\n\t\tif (block == 0) {\n\t\t\tblock++;\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"Can't find valid F2FS filesystem in %dth superblock\"",
            "block + 1"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "235-245",
          "snippet": "void f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "*raw_super_buf"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sanity_check_raw_super",
          "args": [
            "sb",
            "*raw_super"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "sanity_check_raw_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "808-856",
          "snippet": "static int sanity_check_raw_super(struct super_block *sb,\n\t\t\tstruct f2fs_super_block *raw_super)\n{\n\tunsigned int blocksize;\n\n\tif (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super->magic)) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\tF2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn 1;\n\t}\n\n\t/* Currently, support only 4KB page cache size */\n\tif (F2FS_BLKSIZE != PAGE_CACHE_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid page_cache_size (%lu), supports only 4KB\\n\",\n\t\t\tPAGE_CACHE_SIZE);\n\t\treturn 1;\n\t}\n\n\t/* Currently, support only 4KB block size */\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid blocksize (%u), supports only 4KB\\n\",\n\t\t\tblocksize);\n\t\treturn 1;\n\t}\n\n\t/* Currently, support 512/1024/2048/4096 bytes sector size */\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO, \"Invalid log sectorsize (%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int sanity_check_raw_super(struct super_block *sb,\n\t\t\tstruct f2fs_super_block *raw_super)\n{\n\tunsigned int blocksize;\n\n\tif (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super->magic)) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\tF2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn 1;\n\t}\n\n\t/* Currently, support only 4KB page cache size */\n\tif (F2FS_BLKSIZE != PAGE_CACHE_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid page_cache_size (%lu), supports only 4KB\\n\",\n\t\t\tPAGE_CACHE_SIZE);\n\t\treturn 1;\n\t}\n\n\t/* Currently, support only 4KB block size */\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid blocksize (%u), supports only 4KB\\n\",\n\t\t\tblocksize);\n\t\treturn 1;\n\t}\n\n\t/* Currently, support 512/1024/2048/4096 bytes sector size */\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO, \"Invalid log sectorsize (%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "block"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int read_raw_super_block(struct super_block *sb,\n\t\t\tstruct f2fs_super_block **raw_super,\n\t\t\tstruct buffer_head **raw_super_buf)\n{\n\tint block = 0;\n\nretry:\n\t*raw_super_buf = sb_bread(sb, block);\n\tif (!*raw_super_buf) {\n\t\tf2fs_msg(sb, KERN_ERR, \"Unable to read %dth superblock\",\n\t\t\t\tblock + 1);\n\t\tif (block == 0) {\n\t\t\tblock++;\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t*raw_super = (struct f2fs_super_block *)\n\t\t((char *)(*raw_super_buf)->b_data + F2FS_SUPER_OFFSET);\n\n\t/* sanity checking of raw super */\n\tif (sanity_check_raw_super(sb, *raw_super)) {\n\t\tbrelse(*raw_super_buf);\n\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t\"Can't find valid F2FS filesystem in %dth superblock\",\n\t\t\t\t\t\t\t\tblock + 1);\n\t\tif (block == 0) {\n\t\t\tblock++;\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "init_sb_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "881-909",
    "snippet": "static void init_sb_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = sbi->raw_super;\n\tint i;\n\n\tsbi->log_sectors_per_block =\n\t\tle32_to_cpu(raw_super->log_sectors_per_block);\n\tsbi->log_blocksize = le32_to_cpu(raw_super->log_blocksize);\n\tsbi->blocksize = 1 << sbi->log_blocksize;\n\tsbi->log_blocks_per_seg = le32_to_cpu(raw_super->log_blocks_per_seg);\n\tsbi->blocks_per_seg = 1 << sbi->log_blocks_per_seg;\n\tsbi->segs_per_sec = le32_to_cpu(raw_super->segs_per_sec);\n\tsbi->secs_per_zone = le32_to_cpu(raw_super->secs_per_zone);\n\tsbi->total_sections = le32_to_cpu(raw_super->section_count);\n\tsbi->total_node_count =\n\t\t(le32_to_cpu(raw_super->segment_count_nat) / 2)\n\t\t\t* sbi->blocks_per_seg * NAT_ENTRY_PER_BLOCK;\n\tsbi->root_ino_num = le32_to_cpu(raw_super->root_ino);\n\tsbi->node_ino_num = le32_to_cpu(raw_super->node_ino);\n\tsbi->meta_ino_num = le32_to_cpu(raw_super->meta_ino);\n\tsbi->cur_victim_sec = NULL_SECNO;\n\tsbi->max_victim_search = DEF_MAX_VICTIM_SEARCH;\n\n\tfor (i = 0; i < NR_COUNT_TYPE; i++)\n\t\tatomic_set(&sbi->nr_pages[i], 0);\n\n\tsbi->dir_level = DEF_DIR_LEVEL;\n\tclear_sbi_flag(sbi, SBI_NEED_FSCK);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_sbi_flag",
          "args": [
            "sbi",
            "SBI_NEED_FSCK"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "clear_sbi_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "725-728",
          "snippet": "static inline void clear_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag &= ~(0x01 << type);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag &= ~(0x01 << type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sbi->nr_pages[i]",
            "0"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "raw_super->meta_ino"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void init_sb_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = sbi->raw_super;\n\tint i;\n\n\tsbi->log_sectors_per_block =\n\t\tle32_to_cpu(raw_super->log_sectors_per_block);\n\tsbi->log_blocksize = le32_to_cpu(raw_super->log_blocksize);\n\tsbi->blocksize = 1 << sbi->log_blocksize;\n\tsbi->log_blocks_per_seg = le32_to_cpu(raw_super->log_blocks_per_seg);\n\tsbi->blocks_per_seg = 1 << sbi->log_blocks_per_seg;\n\tsbi->segs_per_sec = le32_to_cpu(raw_super->segs_per_sec);\n\tsbi->secs_per_zone = le32_to_cpu(raw_super->secs_per_zone);\n\tsbi->total_sections = le32_to_cpu(raw_super->section_count);\n\tsbi->total_node_count =\n\t\t(le32_to_cpu(raw_super->segment_count_nat) / 2)\n\t\t\t* sbi->blocks_per_seg * NAT_ENTRY_PER_BLOCK;\n\tsbi->root_ino_num = le32_to_cpu(raw_super->root_ino);\n\tsbi->node_ino_num = le32_to_cpu(raw_super->node_ino);\n\tsbi->meta_ino_num = le32_to_cpu(raw_super->meta_ino);\n\tsbi->cur_victim_sec = NULL_SECNO;\n\tsbi->max_victim_search = DEF_MAX_VICTIM_SEARCH;\n\n\tfor (i = 0; i < NR_COUNT_TYPE; i++)\n\t\tatomic_set(&sbi->nr_pages[i], 0);\n\n\tsbi->dir_level = DEF_DIR_LEVEL;\n\tclear_sbi_flag(sbi, SBI_NEED_FSCK);\n}"
  },
  {
    "function_name": "sanity_check_ckpt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "858-879",
    "snippet": "static int sanity_check_ckpt(struct f2fs_sb_info *sbi)\n{\n\tunsigned int total, fsmeta;\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\n\ttotal = le32_to_cpu(raw_super->segment_count);\n\tfsmeta = le32_to_cpu(raw_super->segment_count_ckpt);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_sit);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_nat);\n\tfsmeta += le32_to_cpu(ckpt->rsvd_segment_count);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_ssa);\n\n\tif (unlikely(fsmeta >= total))\n\t\treturn 1;\n\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\tf2fs_msg(sbi->sb, KERN_ERR, \"A bug case: need to run fsck\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_msg",
          "args": [
            "sbi->sb",
            "KERN_ERR",
            "\"A bug case: need to run fsck\""
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "235-245",
          "snippet": "void f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "f2fs_cp_error(sbi)"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_cp_error",
          "args": [
            "sbi"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_cp_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1310-1313",
          "snippet": "static inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fsmeta >= total"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "raw_super->segment_count_ssa"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_CKPT",
          "args": [
            "sbi"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_CKPT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "665-668",
          "snippet": "static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_RAW_SUPER",
          "args": [
            "sbi"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_RAW_SUPER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "660-663",
          "snippet": "static inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_super_block *)(sbi->raw_super);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_super_block *)(sbi->raw_super);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int sanity_check_ckpt(struct f2fs_sb_info *sbi)\n{\n\tunsigned int total, fsmeta;\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\n\ttotal = le32_to_cpu(raw_super->segment_count);\n\tfsmeta = le32_to_cpu(raw_super->segment_count_ckpt);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_sit);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_nat);\n\tfsmeta += le32_to_cpu(ckpt->rsvd_segment_count);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_ssa);\n\n\tif (unlikely(fsmeta >= total))\n\t\treturn 1;\n\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\tf2fs_msg(sbi->sb, KERN_ERR, \"A bug case: need to run fsck\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "sanity_check_raw_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "808-856",
    "snippet": "static int sanity_check_raw_super(struct super_block *sb,\n\t\t\tstruct f2fs_super_block *raw_super)\n{\n\tunsigned int blocksize;\n\n\tif (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super->magic)) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\tF2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn 1;\n\t}\n\n\t/* Currently, support only 4KB page cache size */\n\tif (F2FS_BLKSIZE != PAGE_CACHE_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid page_cache_size (%lu), supports only 4KB\\n\",\n\t\t\tPAGE_CACHE_SIZE);\n\t\treturn 1;\n\t}\n\n\t/* Currently, support only 4KB block size */\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid blocksize (%u), supports only 4KB\\n\",\n\t\t\tblocksize);\n\t\treturn 1;\n\t}\n\n\t/* Currently, support 512/1024/2048/4096 bytes sector size */\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO, \"Invalid log sectorsize (%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_msg",
          "args": [
            "sb",
            "KERN_INFO",
            "\"Invalid log sectors per block(%u) log sectorsize(%u)\"",
            "le32_to_cpu(raw_super->log_sectors_per_block)",
            "le32_to_cpu(raw_super->log_sectorsize)"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "235-245",
          "snippet": "void f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "raw_super->log_sectorsize"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int sanity_check_raw_super(struct super_block *sb,\n\t\t\tstruct f2fs_super_block *raw_super)\n{\n\tunsigned int blocksize;\n\n\tif (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super->magic)) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\tF2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn 1;\n\t}\n\n\t/* Currently, support only 4KB page cache size */\n\tif (F2FS_BLKSIZE != PAGE_CACHE_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid page_cache_size (%lu), supports only 4KB\\n\",\n\t\t\tPAGE_CACHE_SIZE);\n\t\treturn 1;\n\t}\n\n\t/* Currently, support only 4KB block size */\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid blocksize (%u), supports only 4KB\\n\",\n\t\t\tblocksize);\n\t\treturn 1;\n\t}\n\n\t/* Currently, support 512/1024/2048/4096 bytes sector size */\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO, \"Invalid log sectorsize (%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "max_file_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "788-806",
    "snippet": "static loff_t max_file_size(unsigned bits)\n{\n\tloff_t result = (DEF_ADDRS_PER_INODE - F2FS_INLINE_XATTR_ADDRS);\n\tloff_t leaf_count = ADDRS_PER_BLOCK;\n\n\t/* two direct node blocks */\n\tresult += (leaf_count * 2);\n\n\t/* two indirect node blocks */\n\tleaf_count *= NIDS_PER_BLOCK;\n\tresult += (leaf_count * 2);\n\n\t/* one double indirect node block */\n\tleaf_count *= NIDS_PER_BLOCK;\n\tresult += leaf_count;\n\n\tresult <<= bits;\n\treturn result;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic loff_t max_file_size(unsigned bits)\n{\n\tloff_t result = (DEF_ADDRS_PER_INODE - F2FS_INLINE_XATTR_ADDRS);\n\tloff_t leaf_count = ADDRS_PER_BLOCK;\n\n\t/* two direct node blocks */\n\tresult += (leaf_count * 2);\n\n\t/* two indirect node blocks */\n\tleaf_count *= NIDS_PER_BLOCK;\n\tresult += (leaf_count * 2);\n\n\t/* one double indirect node block */\n\tleaf_count *= NIDS_PER_BLOCK;\n\tresult += leaf_count;\n\n\tresult <<= bits;\n\treturn result;\n}"
  },
  {
    "function_name": "f2fs_fh_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "775-780",
    "snippet": "static struct dentry *f2fs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    f2fs_nfs_get_inode);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_parent",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "f2fs_nfs_get_inode"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "906-923",
          "snippet": "struct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct dentry *f2fs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    f2fs_nfs_get_inode);\n}"
  },
  {
    "function_name": "f2fs_fh_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "768-773",
    "snippet": "static struct dentry *f2fs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    f2fs_nfs_get_inode);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_dentry",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "f2fs_nfs_get_inode"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "873-890",
          "snippet": "struct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct dentry *f2fs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    f2fs_nfs_get_inode);\n}"
  },
  {
    "function_name": "f2fs_nfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "743-766",
    "snippet": "static struct inode *f2fs_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\n\tif (check_nid_range(sbi, ino))\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/*\n\t * f2fs_iget isn't quite right if the inode is currently unallocated!\n\t * However f2fs_iget currently does appropriate checks to handle stale\n\t * inodes so everything is OK.\n\t */\n\tinode = f2fs_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (unlikely(generation && inode->i_generation != generation)) {\n\t\t/* we didn't find the right inode.. */\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "generation && inode->i_generation != generation"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_iget",
          "args": [
            "sb",
            "ino"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "151-206",
          "snippet": "struct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_nid_range",
          "args": [
            "sbi",
            "ino"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "check_nid_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "800-807",
          "snippet": "static inline int check_nid_range(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tif (unlikely(nid < F2FS_ROOT_INO(sbi)))\n\t\treturn -EINVAL;\n\tif (unlikely(nid >= NM_I(sbi)->max_nid))\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int check_nid_range(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tif (unlikely(nid < F2FS_ROOT_INO(sbi)))\n\t\treturn -EINVAL;\n\tif (unlikely(nid >= NM_I(sbi)->max_nid))\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_SB",
          "args": [
            "sb"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "640-643",
          "snippet": "static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *f2fs_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\n\tif (check_nid_range(sbi, ino))\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/*\n\t * f2fs_iget isn't quite right if the inode is currently unallocated!\n\t * However f2fs_iget currently does appropriate checks to handle stale\n\t * inodes so everything is OK.\n\t */\n\tinode = f2fs_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (unlikely(generation && inode->i_generation != generation)) {\n\t\t/* we didn't find the right inode.. */\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "f2fs_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "647-725",
    "snippet": "static int f2fs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct f2fs_mount_info org_mount_opt;\n\tint err, active_logs;\n\tbool need_restart_gc = false;\n\tbool need_stop_gc = false;\n\n\tsync_filesystem(sb);\n\n\t/*\n\t * Save the old mount options in case we\n\t * need to restore them.\n\t */\n\torg_mount_opt = sbi->mount_opt;\n\tactive_logs = sbi->active_logs;\n\n\tsbi->mount_opt.opt = 0;\n\tsbi->active_logs = NR_CURSEG_TYPE;\n\n\t/* parse mount options */\n\terr = parse_options(sb, data);\n\tif (err)\n\t\tgoto restore_opts;\n\n\t/*\n\t * Previous and new state of filesystem is RO,\n\t * so skip checking GC and FLUSH_MERGE conditions.\n\t */\n\tif (f2fs_readonly(sb) && (*flags & MS_RDONLY))\n\t\tgoto skip;\n\n\t/*\n\t * We stop the GC thread if FS is mounted as RO\n\t * or if background_gc = off is passed in mount\n\t * option. Also sync the filesystem.\n\t */\n\tif ((*flags & MS_RDONLY) || !test_opt(sbi, BG_GC)) {\n\t\tif (sbi->gc_thread) {\n\t\t\tstop_gc_thread(sbi);\n\t\t\tf2fs_sync_fs(sb, 1);\n\t\t\tneed_restart_gc = true;\n\t\t}\n\t} else if (!sbi->gc_thread) {\n\t\terr = start_gc_thread(sbi);\n\t\tif (err)\n\t\t\tgoto restore_opts;\n\t\tneed_stop_gc = true;\n\t}\n\n\t/*\n\t * We stop issue flush thread if FS is mounted as RO\n\t * or if flush_merge is not passed in mount option.\n\t */\n\tif ((*flags & MS_RDONLY) || !test_opt(sbi, FLUSH_MERGE)) {\n\t\tdestroy_flush_cmd_control(sbi);\n\t} else if (!SM_I(sbi)->cmd_control_info) {\n\t\terr = create_flush_cmd_control(sbi);\n\t\tif (err)\n\t\t\tgoto restore_gc;\n\t}\nskip:\n\t/* Update the POSIXACL Flag */\n\t sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sbi, POSIX_ACL) ? MS_POSIXACL : 0);\n\treturn 0;\nrestore_gc:\n\tif (need_restart_gc) {\n\t\tif (start_gc_thread(sbi))\n\t\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t\t\"background gc thread has stopped\");\n\t} else if (need_stop_gc) {\n\t\tstop_gc_thread(sbi);\n\t}\nrestore_opts:\n\tsbi->mount_opt = org_mount_opt;\n\tsbi->active_logs = active_logs;\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_gc_thread",
          "args": [
            "sbi"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "stop_gc_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "122-130",
          "snippet": "void stop_gc_thread(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_gc_kthread *gc_th = sbi->gc_thread;\n\tif (!gc_th)\n\t\treturn;\n\tkthread_stop(gc_th->f2fs_gc_task);\n\tkfree(gc_th);\n\tsbi->gc_thread = NULL;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid stop_gc_thread(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_gc_kthread *gc_th = sbi->gc_thread;\n\tif (!gc_th)\n\t\treturn;\n\tkthread_stop(gc_th->f2fs_gc_task);\n\tkfree(gc_th);\n\tsbi->gc_thread = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_msg",
          "args": [
            "sbi->sb",
            "KERN_WARNING",
            "\"background gc thread has stopped\""
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "235-245",
          "snippet": "void f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_gc_thread",
          "args": [
            "sbi"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "start_gc_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "91-120",
          "snippet": "int start_gc_thread(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_gc_kthread *gc_th;\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tint err = 0;\n\n\tgc_th = kmalloc(sizeof(struct f2fs_gc_kthread), GFP_KERNEL);\n\tif (!gc_th) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tgc_th->min_sleep_time = DEF_GC_THREAD_MIN_SLEEP_TIME;\n\tgc_th->max_sleep_time = DEF_GC_THREAD_MAX_SLEEP_TIME;\n\tgc_th->no_gc_sleep_time = DEF_GC_THREAD_NOGC_SLEEP_TIME;\n\n\tgc_th->gc_idle = 0;\n\n\tsbi->gc_thread = gc_th;\n\tinit_waitqueue_head(&sbi->gc_thread->gc_wait_queue_head);\n\tsbi->gc_thread->f2fs_gc_task = kthread_run(gc_thread_func, sbi,\n\t\t\t\"f2fs_gc-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(gc_th->f2fs_gc_task)) {\n\t\terr = PTR_ERR(gc_th->f2fs_gc_task);\n\t\tkfree(gc_th);\n\t\tsbi->gc_thread = NULL;\n\t}\nout:\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nint start_gc_thread(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_gc_kthread *gc_th;\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tint err = 0;\n\n\tgc_th = kmalloc(sizeof(struct f2fs_gc_kthread), GFP_KERNEL);\n\tif (!gc_th) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tgc_th->min_sleep_time = DEF_GC_THREAD_MIN_SLEEP_TIME;\n\tgc_th->max_sleep_time = DEF_GC_THREAD_MAX_SLEEP_TIME;\n\tgc_th->no_gc_sleep_time = DEF_GC_THREAD_NOGC_SLEEP_TIME;\n\n\tgc_th->gc_idle = 0;\n\n\tsbi->gc_thread = gc_th;\n\tinit_waitqueue_head(&sbi->gc_thread->gc_wait_queue_head);\n\tsbi->gc_thread->f2fs_gc_task = kthread_run(gc_thread_func, sbi,\n\t\t\t\"f2fs_gc-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(gc_th->f2fs_gc_task)) {\n\t\terr = PTR_ERR(gc_th->f2fs_gc_task);\n\t\tkfree(gc_th);\n\t\tsbi->gc_thread = NULL;\n\t}\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "POSIX_ACL"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_flush_cmd_control",
          "args": [
            "sbi"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "create_flush_cmd_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "347-369",
          "snippet": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tinit_waitqueue_head(&fcc->flush_wait_queue);\n\tinit_llist_head(&fcc->issue_list);\n\tSM_I(sbi)->cmd_control_info = fcc;\n\tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n\t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->cmd_control_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tinit_waitqueue_head(&fcc->flush_wait_queue);\n\tinit_llist_head(&fcc->issue_list);\n\tSM_I(sbi)->cmd_control_info = fcc;\n\tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n\t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->cmd_control_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_flush_cmd_control",
          "args": [
            "sbi"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_flush_cmd_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "371-379",
          "snippet": "void destroy_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tstruct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;\n\n\tif (fcc && fcc->f2fs_issue_flush)\n\t\tkthread_stop(fcc->f2fs_issue_flush);\n\tkfree(fcc);\n\tSM_I(sbi)->cmd_control_info = NULL;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid destroy_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tstruct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;\n\n\tif (fcc && fcc->f2fs_issue_flush)\n\t\tkthread_stop(fcc->f2fs_issue_flush);\n\tkfree(fcc);\n\tSM_I(sbi)->cmd_control_info = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "FLUSH_MERGE"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_sync_fs",
          "args": [
            "sb",
            "1"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "496-516",
          "snippet": "int f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "BG_GC"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_readonly",
          "args": [
            "sb"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1305-1308",
          "snippet": "static inline int f2fs_readonly(struct super_block *sb)\n{\n\treturn sb->s_flags & MS_RDONLY;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_readonly(struct super_block *sb)\n{\n\treturn sb->s_flags & MS_RDONLY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "sb",
            "data"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "254-378",
          "snippet": "static int parse_options(struct super_block *sb, char *options)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p, *name;\n\tint arg = 0;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, f2fs_tokens, args);\n\n\t\tswitch (token) {\n\t\tcase Opt_gc_background:\n\t\t\tname = match_strdup(&args[0]);\n\n\t\t\tif (!name)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (strlen(name) == 2 && !strncmp(name, \"on\", 2))\n\t\t\t\tset_opt(sbi, BG_GC);\n\t\t\telse if (strlen(name) == 3 && !strncmp(name, \"off\", 3))\n\t\t\t\tclear_opt(sbi, BG_GC);\n\t\t\telse {\n\t\t\t\tkfree(name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tkfree(name);\n\t\t\tbreak;\n\t\tcase Opt_disable_roll_forward:\n\t\t\tset_opt(sbi, DISABLE_ROLL_FORWARD);\n\t\t\tbreak;\n\t\tcase Opt_norecovery:\n\t\t\t/* this option mounts f2fs with ro */\n\t\t\tset_opt(sbi, DISABLE_ROLL_FORWARD);\n\t\t\tif (!f2fs_readonly(sb))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tset_opt(sbi, DISCARD);\n\t\t\tbreak;\n\t\tcase Opt_noheap:\n\t\t\tset_opt(sbi, NOHEAP);\n\t\t\tbreak;\n#ifdef CONFIG_F2FS_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt(sbi, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt(sbi, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_inline_xattr:\n\t\t\tset_opt(sbi, INLINE_XATTR);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\t\"user_xattr options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\t\"nouser_xattr options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_inline_xattr:\n\t\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\t\"inline_xattr options not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_F2FS_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\t\tf2fs_msg(sb, KERN_INFO, \"acl options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tf2fs_msg(sb, KERN_INFO, \"noacl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_active_logs:\n\t\t\tif (args->from && match_int(args, &arg))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (arg != 2 && arg != 4 && arg != NR_CURSEG_TYPE)\n\t\t\t\treturn -EINVAL;\n\t\t\tsbi->active_logs = arg;\n\t\t\tbreak;\n\t\tcase Opt_disable_ext_identify:\n\t\t\tset_opt(sbi, DISABLE_EXT_IDENTIFY);\n\t\t\tbreak;\n\t\tcase Opt_inline_data:\n\t\t\tset_opt(sbi, INLINE_DATA);\n\t\t\tbreak;\n\t\tcase Opt_inline_dentry:\n\t\t\tset_opt(sbi, INLINE_DENTRY);\n\t\t\tbreak;\n\t\tcase Opt_flush_merge:\n\t\t\tset_opt(sbi, FLUSH_MERGE);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tset_opt(sbi, NOBARRIER);\n\t\t\tbreak;\n\t\tcase Opt_fastboot:\n\t\t\tset_opt(sbi, FASTBOOT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t\t\"Unrecognized mount option \\\"%s\\\" or missing value\",\n\t\t\t\tp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static match_table_t f2fs_tokens = {\n\t{Opt_gc_background, \"background_gc=%s\"},\n\t{Opt_disable_roll_forward, \"disable_roll_forward\"},\n\t{Opt_norecovery, \"norecovery\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_noheap, \"no_heap\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_active_logs, \"active_logs=%u\"},\n\t{Opt_disable_ext_identify, \"disable_ext_identify\"},\n\t{Opt_inline_xattr, \"inline_xattr\"},\n\t{Opt_inline_data, \"inline_data\"},\n\t{Opt_inline_dentry, \"inline_dentry\"},\n\t{Opt_flush_merge, \"flush_merge\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_fastboot, \"fastboot\"},\n\t{Opt_err, NULL},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic match_table_t f2fs_tokens = {\n\t{Opt_gc_background, \"background_gc=%s\"},\n\t{Opt_disable_roll_forward, \"disable_roll_forward\"},\n\t{Opt_norecovery, \"norecovery\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_noheap, \"no_heap\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_active_logs, \"active_logs=%u\"},\n\t{Opt_disable_ext_identify, \"disable_ext_identify\"},\n\t{Opt_inline_xattr, \"inline_xattr\"},\n\t{Opt_inline_data, \"inline_data\"},\n\t{Opt_inline_dentry, \"inline_dentry\"},\n\t{Opt_flush_merge, \"flush_merge\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_fastboot, \"fastboot\"},\n\t{Opt_err, NULL},\n};\n\nstatic int parse_options(struct super_block *sb, char *options)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p, *name;\n\tint arg = 0;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, f2fs_tokens, args);\n\n\t\tswitch (token) {\n\t\tcase Opt_gc_background:\n\t\t\tname = match_strdup(&args[0]);\n\n\t\t\tif (!name)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (strlen(name) == 2 && !strncmp(name, \"on\", 2))\n\t\t\t\tset_opt(sbi, BG_GC);\n\t\t\telse if (strlen(name) == 3 && !strncmp(name, \"off\", 3))\n\t\t\t\tclear_opt(sbi, BG_GC);\n\t\t\telse {\n\t\t\t\tkfree(name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tkfree(name);\n\t\t\tbreak;\n\t\tcase Opt_disable_roll_forward:\n\t\t\tset_opt(sbi, DISABLE_ROLL_FORWARD);\n\t\t\tbreak;\n\t\tcase Opt_norecovery:\n\t\t\t/* this option mounts f2fs with ro */\n\t\t\tset_opt(sbi, DISABLE_ROLL_FORWARD);\n\t\t\tif (!f2fs_readonly(sb))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tset_opt(sbi, DISCARD);\n\t\t\tbreak;\n\t\tcase Opt_noheap:\n\t\t\tset_opt(sbi, NOHEAP);\n\t\t\tbreak;\n#ifdef CONFIG_F2FS_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt(sbi, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt(sbi, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_inline_xattr:\n\t\t\tset_opt(sbi, INLINE_XATTR);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\t\"user_xattr options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\t\"nouser_xattr options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_inline_xattr:\n\t\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\t\"inline_xattr options not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_F2FS_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\t\tf2fs_msg(sb, KERN_INFO, \"acl options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tf2fs_msg(sb, KERN_INFO, \"noacl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_active_logs:\n\t\t\tif (args->from && match_int(args, &arg))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (arg != 2 && arg != 4 && arg != NR_CURSEG_TYPE)\n\t\t\t\treturn -EINVAL;\n\t\t\tsbi->active_logs = arg;\n\t\t\tbreak;\n\t\tcase Opt_disable_ext_identify:\n\t\t\tset_opt(sbi, DISABLE_EXT_IDENTIFY);\n\t\t\tbreak;\n\t\tcase Opt_inline_data:\n\t\t\tset_opt(sbi, INLINE_DATA);\n\t\t\tbreak;\n\t\tcase Opt_inline_dentry:\n\t\t\tset_opt(sbi, INLINE_DENTRY);\n\t\t\tbreak;\n\t\tcase Opt_flush_merge:\n\t\t\tset_opt(sbi, FLUSH_MERGE);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tset_opt(sbi, NOBARRIER);\n\t\t\tbreak;\n\t\tcase Opt_fastboot:\n\t\t\tset_opt(sbi, FASTBOOT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t\t\"Unrecognized mount option \\\"%s\\\" or missing value\",\n\t\t\t\tp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_SB",
          "args": [
            "sb"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "640-643",
          "snippet": "static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int f2fs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct f2fs_mount_info org_mount_opt;\n\tint err, active_logs;\n\tbool need_restart_gc = false;\n\tbool need_stop_gc = false;\n\n\tsync_filesystem(sb);\n\n\t/*\n\t * Save the old mount options in case we\n\t * need to restore them.\n\t */\n\torg_mount_opt = sbi->mount_opt;\n\tactive_logs = sbi->active_logs;\n\n\tsbi->mount_opt.opt = 0;\n\tsbi->active_logs = NR_CURSEG_TYPE;\n\n\t/* parse mount options */\n\terr = parse_options(sb, data);\n\tif (err)\n\t\tgoto restore_opts;\n\n\t/*\n\t * Previous and new state of filesystem is RO,\n\t * so skip checking GC and FLUSH_MERGE conditions.\n\t */\n\tif (f2fs_readonly(sb) && (*flags & MS_RDONLY))\n\t\tgoto skip;\n\n\t/*\n\t * We stop the GC thread if FS is mounted as RO\n\t * or if background_gc = off is passed in mount\n\t * option. Also sync the filesystem.\n\t */\n\tif ((*flags & MS_RDONLY) || !test_opt(sbi, BG_GC)) {\n\t\tif (sbi->gc_thread) {\n\t\t\tstop_gc_thread(sbi);\n\t\t\tf2fs_sync_fs(sb, 1);\n\t\t\tneed_restart_gc = true;\n\t\t}\n\t} else if (!sbi->gc_thread) {\n\t\terr = start_gc_thread(sbi);\n\t\tif (err)\n\t\t\tgoto restore_opts;\n\t\tneed_stop_gc = true;\n\t}\n\n\t/*\n\t * We stop issue flush thread if FS is mounted as RO\n\t * or if flush_merge is not passed in mount option.\n\t */\n\tif ((*flags & MS_RDONLY) || !test_opt(sbi, FLUSH_MERGE)) {\n\t\tdestroy_flush_cmd_control(sbi);\n\t} else if (!SM_I(sbi)->cmd_control_info) {\n\t\terr = create_flush_cmd_control(sbi);\n\t\tif (err)\n\t\t\tgoto restore_gc;\n\t}\nskip:\n\t/* Update the POSIXACL Flag */\n\t sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sbi, POSIX_ACL) ? MS_POSIXACL : 0);\n\treturn 0;\nrestore_gc:\n\tif (need_restart_gc) {\n\t\tif (start_gc_thread(sbi))\n\t\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t\t\"background gc thread has stopped\");\n\t} else if (need_stop_gc) {\n\t\tstop_gc_thread(sbi);\n\t}\nrestore_opts:\n\tsbi->mount_opt = org_mount_opt;\n\tsbi->active_logs = active_logs;\n\treturn err;\n}"
  },
  {
    "function_name": "segment_info_open_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "634-637",
    "snippet": "static int segment_info_open_fs(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, segment_info_seq_show, PDE_DATA(inode));\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "segment_info_seq_show",
            "PDE_DATA(inode)"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "single_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "557-575",
          "snippet": "int single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDE_DATA",
          "args": [
            "inode"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "__PDE_DATA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "85-88",
          "snippet": "static inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int segment_info_open_fs(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, segment_info_seq_show, PDE_DATA(inode));\n}"
  },
  {
    "function_name": "segment_info_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "607-632",
    "snippet": "static int segment_info_seq_show(struct seq_file *seq, void *offset)\n{\n\tstruct super_block *sb = seq->private;\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tunsigned int total_segs =\n\t\t\tle32_to_cpu(sbi->raw_super->segment_count_main);\n\tint i;\n\n\tseq_puts(seq, \"format: segment_type|valid_blocks\\n\"\n\t\t\"segment_type(0:HD, 1:WD, 2:CD, 3:HN, 4:WN, 5:CN)\\n\");\n\n\tfor (i = 0; i < total_segs; i++) {\n\t\tstruct seg_entry *se = get_seg_entry(sbi, i);\n\n\t\tif ((i % 10) == 0)\n\t\t\tseq_printf(seq, \"%-5d\", i);\n\t\tseq_printf(seq, \"%d|%-3u\", se->type,\n\t\t\t\t\tget_valid_blocks(sbi, i, 1));\n\t\tif ((i % 10) == 9 || i == (total_segs - 1))\n\t\t\tseq_putc(seq, '\\n');\n\t\telse\n\t\t\tseq_putc(seq, ' ');\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "seq",
            "' '"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%d|%-3u\"",
            "se->type",
            "get_valid_blocks(sbi, i, 1)"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_valid_blocks",
          "args": [
            "sbi",
            "i",
            "1"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "get_valid_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "282-293",
          "snippet": "static inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seg_entry",
          "args": [
            "sbi",
            "i"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "get_seg_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "268-273",
          "snippet": "static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\"format: segment_type|valid_blocks\\n\"\n\t\t\"segment_type(0:HD, 1:WD, 2:CD, 3:HN, 4:WN, 5:CN)\\n\""
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbi->raw_super->segment_count_main"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_SB",
          "args": [
            "sb"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "640-643",
          "snippet": "static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int segment_info_seq_show(struct seq_file *seq, void *offset)\n{\n\tstruct super_block *sb = seq->private;\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tunsigned int total_segs =\n\t\t\tle32_to_cpu(sbi->raw_super->segment_count_main);\n\tint i;\n\n\tseq_puts(seq, \"format: segment_type|valid_blocks\\n\"\n\t\t\"segment_type(0:HD, 1:WD, 2:CD, 3:HN, 4:WN, 5:CN)\\n\");\n\n\tfor (i = 0; i < total_segs; i++) {\n\t\tstruct seg_entry *se = get_seg_entry(sbi, i);\n\n\t\tif ((i % 10) == 0)\n\t\t\tseq_printf(seq, \"%-5d\", i);\n\t\tseq_printf(seq, \"%d|%-3u\", se->type,\n\t\t\t\t\tget_valid_blocks(sbi, i, 1));\n\t\tif ((i % 10) == 9 || i == (total_segs - 1))\n\t\t\tseq_putc(seq, '\\n');\n\t\telse\n\t\t\tseq_putc(seq, ' ');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "562-605",
    "snippet": "static int f2fs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(root->d_sb);\n\n\tif (!f2fs_readonly(sbi->sb) && test_opt(sbi, BG_GC))\n\t\tseq_printf(seq, \",background_gc=%s\", \"on\");\n\telse\n\t\tseq_printf(seq, \",background_gc=%s\", \"off\");\n\tif (test_opt(sbi, DISABLE_ROLL_FORWARD))\n\t\tseq_puts(seq, \",disable_roll_forward\");\n\tif (test_opt(sbi, DISCARD))\n\t\tseq_puts(seq, \",discard\");\n\tif (test_opt(sbi, NOHEAP))\n\t\tseq_puts(seq, \",no_heap_alloc\");\n#ifdef CONFIG_F2FS_FS_XATTR\n\tif (test_opt(sbi, XATTR_USER))\n\t\tseq_puts(seq, \",user_xattr\");\n\telse\n\t\tseq_puts(seq, \",nouser_xattr\");\n\tif (test_opt(sbi, INLINE_XATTR))\n\t\tseq_puts(seq, \",inline_xattr\");\n#endif\n#ifdef CONFIG_F2FS_FS_POSIX_ACL\n\tif (test_opt(sbi, POSIX_ACL))\n\t\tseq_puts(seq, \",acl\");\n\telse\n\t\tseq_puts(seq, \",noacl\");\n#endif\n\tif (test_opt(sbi, DISABLE_EXT_IDENTIFY))\n\t\tseq_puts(seq, \",disable_ext_identify\");\n\tif (test_opt(sbi, INLINE_DATA))\n\t\tseq_puts(seq, \",inline_data\");\n\tif (test_opt(sbi, INLINE_DENTRY))\n\t\tseq_puts(seq, \",inline_dentry\");\n\tif (!f2fs_readonly(sbi->sb) && test_opt(sbi, FLUSH_MERGE))\n\t\tseq_puts(seq, \",flush_merge\");\n\tif (test_opt(sbi, NOBARRIER))\n\t\tseq_puts(seq, \",nobarrier\");\n\tif (test_opt(sbi, FASTBOOT))\n\t\tseq_puts(seq, \",fastboot\");\n\tseq_printf(seq, \",active_logs=%u\", sbi->active_logs);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\",active_logs=%u\"",
            "sbi->active_logs"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\",fastboot\""
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "FASTBOOT"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "NOBARRIER"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "FLUSH_MERGE"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_readonly",
          "args": [
            "sbi->sb"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1305-1308",
          "snippet": "static inline int f2fs_readonly(struct super_block *sb)\n{\n\treturn sb->s_flags & MS_RDONLY;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_readonly(struct super_block *sb)\n{\n\treturn sb->s_flags & MS_RDONLY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "INLINE_DENTRY"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "INLINE_DATA"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "DISABLE_EXT_IDENTIFY"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "POSIX_ACL"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "INLINE_XATTR"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "XATTR_USER"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "NOHEAP"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "DISCARD"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "DISABLE_ROLL_FORWARD"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "BG_GC"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_SB",
          "args": [
            "root->d_sb"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "640-643",
          "snippet": "static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int f2fs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(root->d_sb);\n\n\tif (!f2fs_readonly(sbi->sb) && test_opt(sbi, BG_GC))\n\t\tseq_printf(seq, \",background_gc=%s\", \"on\");\n\telse\n\t\tseq_printf(seq, \",background_gc=%s\", \"off\");\n\tif (test_opt(sbi, DISABLE_ROLL_FORWARD))\n\t\tseq_puts(seq, \",disable_roll_forward\");\n\tif (test_opt(sbi, DISCARD))\n\t\tseq_puts(seq, \",discard\");\n\tif (test_opt(sbi, NOHEAP))\n\t\tseq_puts(seq, \",no_heap_alloc\");\n#ifdef CONFIG_F2FS_FS_XATTR\n\tif (test_opt(sbi, XATTR_USER))\n\t\tseq_puts(seq, \",user_xattr\");\n\telse\n\t\tseq_puts(seq, \",nouser_xattr\");\n\tif (test_opt(sbi, INLINE_XATTR))\n\t\tseq_puts(seq, \",inline_xattr\");\n#endif\n#ifdef CONFIG_F2FS_FS_POSIX_ACL\n\tif (test_opt(sbi, POSIX_ACL))\n\t\tseq_puts(seq, \",acl\");\n\telse\n\t\tseq_puts(seq, \",noacl\");\n#endif\n\tif (test_opt(sbi, DISABLE_EXT_IDENTIFY))\n\t\tseq_puts(seq, \",disable_ext_identify\");\n\tif (test_opt(sbi, INLINE_DATA))\n\t\tseq_puts(seq, \",inline_data\");\n\tif (test_opt(sbi, INLINE_DENTRY))\n\t\tseq_puts(seq, \",inline_dentry\");\n\tif (!f2fs_readonly(sbi->sb) && test_opt(sbi, FLUSH_MERGE))\n\t\tseq_puts(seq, \",flush_merge\");\n\tif (test_opt(sbi, NOBARRIER))\n\t\tseq_puts(seq, \",nobarrier\");\n\tif (test_opt(sbi, FASTBOOT))\n\t\tseq_puts(seq, \",fastboot\");\n\tseq_printf(seq, \",active_logs=%u\", sbi->active_logs);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "534-560",
    "snippet": "static int f2fs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\tblock_t total_count, user_block_count, start_count, ovp_count;\n\n\ttotal_count = le64_to_cpu(sbi->raw_super->block_count);\n\tuser_block_count = sbi->user_block_count;\n\tstart_count = le32_to_cpu(sbi->raw_super->segment0_blkaddr);\n\tovp_count = SM_I(sbi)->ovp_segments << sbi->log_blocks_per_seg;\n\tbuf->f_type = F2FS_SUPER_MAGIC;\n\tbuf->f_bsize = sbi->blocksize;\n\n\tbuf->f_blocks = total_count - start_count;\n\tbuf->f_bfree = buf->f_blocks - valid_user_blocks(sbi) - ovp_count;\n\tbuf->f_bavail = user_block_count - valid_user_blocks(sbi);\n\n\tbuf->f_files = sbi->total_node_count - F2FS_RESERVED_NODE_NUM;\n\tbuf->f_ffree = buf->f_files - valid_inode_count(sbi);\n\n\tbuf->f_namelen = F2FS_NAME_LEN;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_inode_count",
          "args": [
            "sbi"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "valid_inode_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1031-1034",
          "snippet": "static inline unsigned int valid_inode_count(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->total_valid_inode_count;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline unsigned int valid_inode_count(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->total_valid_inode_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_user_blocks",
          "args": [
            "sbi"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "valid_user_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "905-908",
          "snippet": "static inline block_t valid_user_blocks(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->total_valid_block_count;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline block_t valid_user_blocks(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->total_valid_block_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbi->raw_super->segment0_blkaddr"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "sbi->raw_super->block_count"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "sb->s_bdev->bd_dev"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_SB",
          "args": [
            "sb"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "640-643",
          "snippet": "static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int f2fs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\tblock_t total_count, user_block_count, start_count, ovp_count;\n\n\ttotal_count = le64_to_cpu(sbi->raw_super->block_count);\n\tuser_block_count = sbi->user_block_count;\n\tstart_count = le32_to_cpu(sbi->raw_super->segment0_blkaddr);\n\tovp_count = SM_I(sbi)->ovp_segments << sbi->log_blocks_per_seg;\n\tbuf->f_type = F2FS_SUPER_MAGIC;\n\tbuf->f_bsize = sbi->blocksize;\n\n\tbuf->f_blocks = total_count - start_count;\n\tbuf->f_bfree = buf->f_blocks - valid_user_blocks(sbi) - ovp_count;\n\tbuf->f_bavail = user_block_count - valid_user_blocks(sbi);\n\n\tbuf->f_files = sbi->total_node_count - F2FS_RESERVED_NODE_NUM;\n\tbuf->f_ffree = buf->f_files - valid_inode_count(sbi);\n\n\tbuf->f_namelen = F2FS_NAME_LEN;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_unfreeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "529-532",
    "snippet": "static int f2fs_unfreeze(struct super_block *sb)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int f2fs_unfreeze(struct super_block *sb)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_freeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "518-527",
    "snippet": "static int f2fs_freeze(struct super_block *sb)\n{\n\tint err;\n\n\tif (f2fs_readonly(sb))\n\t\treturn 0;\n\n\terr = f2fs_sync_fs(sb, 1);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_sync_fs",
          "args": [
            "sb",
            "1"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "496-516",
          "snippet": "int f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_readonly",
          "args": [
            "sb"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1305-1308",
          "snippet": "static inline int f2fs_readonly(struct super_block *sb)\n{\n\treturn sb->s_flags & MS_RDONLY;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_readonly(struct super_block *sb)\n{\n\treturn sb->s_flags & MS_RDONLY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int f2fs_freeze(struct super_block *sb)\n{\n\tint err;\n\n\tif (f2fs_readonly(sb))\n\t\treturn 0;\n\n\terr = f2fs_sync_fs(sb, 1);\n\treturn err;\n}"
  },
  {
    "function_name": "f2fs_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "496-516",
    "snippet": "int f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_trace_ios",
          "args": [
            "NULL",
            "NULL",
            "1"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_trace_ios",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/trace.c",
          "lines": "83-118",
          "snippet": "void f2fs_trace_ios(struct page *page, struct f2fs_io_info *fio, int flush)\n{\n\tstruct inode *inode;\n\tpid_t pid;\n\tint major, minor;\n\n\tif (flush) {\n\t\t__print_last_io();\n\t\treturn;\n\t}\n\n\tinode = page->mapping->host;\n\tpid = page_private(page);\n\n\tmajor = MAJOR(inode->i_sb->s_dev);\n\tminor = MINOR(inode->i_sb->s_dev);\n\n\tif (last_io.major == major && last_io.minor == minor &&\n\t\t\tlast_io.pid == pid &&\n\t\t\tlast_io.type == __file_type(inode, pid) &&\n\t\t\tlast_io.fio.rw == fio->rw &&\n\t\t\tlast_io.fio.blk_addr + last_io.len == fio->blk_addr) {\n\t\tlast_io.len++;\n\t\treturn;\n\t}\n\n\t__print_last_io();\n\n\tlast_io.major = major;\n\tlast_io.minor = minor;\n\tlast_io.pid = pid;\n\tlast_io.type = __file_type(inode, pid);\n\tlast_io.fio = *fio;\n\tlast_io.len = 1;\n\treturn;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/radix-tree.h>",
            "#include <linux/sched.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct last_io_info last_io;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"f2fs.h\"\n#include <linux/radix-tree.h>\n#include <linux/sched.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct last_io_info last_io;\n\nvoid f2fs_trace_ios(struct page *page, struct f2fs_io_info *fio, int flush)\n{\n\tstruct inode *inode;\n\tpid_t pid;\n\tint major, minor;\n\n\tif (flush) {\n\t\t__print_last_io();\n\t\treturn;\n\t}\n\n\tinode = page->mapping->host;\n\tpid = page_private(page);\n\n\tmajor = MAJOR(inode->i_sb->s_dev);\n\tminor = MINOR(inode->i_sb->s_dev);\n\n\tif (last_io.major == major && last_io.minor == minor &&\n\t\t\tlast_io.pid == pid &&\n\t\t\tlast_io.type == __file_type(inode, pid) &&\n\t\t\tlast_io.fio.rw == fio->rw &&\n\t\t\tlast_io.fio.blk_addr + last_io.len == fio->blk_addr) {\n\t\tlast_io.len++;\n\t\treturn;\n\t}\n\n\t__print_last_io();\n\n\tlast_io.major = major;\n\tlast_io.minor = minor;\n\tlast_io.pid = pid;\n\tlast_io.type = __file_type(inode, pid);\n\tlast_io.fio = *fio;\n\tlast_io.len = 1;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->gc_mutex"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_checkpoint",
          "args": [
            "sbi",
            "&cpc"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "write_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "1046-1091",
          "snippet": "void write_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_ver;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"start block_ops\");\n\n\tmutex_lock(&sbi->cp_mutex);\n\n\tif (!is_sbi_flag_set(sbi, SBI_IS_DIRTY) &&\n\t\t\tcpc->reason != CP_DISCARD && cpc->reason != CP_UMOUNT)\n\t\tgoto out;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto out;\n\tif (f2fs_readonly(sbi->sb))\n\t\tgoto out;\n\tif (block_operations(sbi))\n\t\tgoto out;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish block_ops\");\n\n\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\tf2fs_submit_merged_bio(sbi, META, WRITE);\n\n\t/*\n\t * update checkpoint pack index\n\t * Increase the version number so that\n\t * SIT entries and seg summaries are written at correct place\n\t */\n\tckpt_ver = cur_cp_version(ckpt);\n\tckpt->checkpoint_ver = cpu_to_le64(++ckpt_ver);\n\n\t/* write cached NAT/SIT entries to NAT/SIT area */\n\tflush_nat_entries(sbi);\n\tflush_sit_entries(sbi, cpc);\n\n\t/* unlock all the fs_lock[] in do_checkpoint() */\n\tdo_checkpoint(sbi, cpc);\n\n\tunblock_operations(sbi);\n\tstat_inc_cp_count(sbi->stat_info);\nout:\n\tmutex_unlock(&sbi->cp_mutex);\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish checkpoint\");\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid write_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_ver;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"start block_ops\");\n\n\tmutex_lock(&sbi->cp_mutex);\n\n\tif (!is_sbi_flag_set(sbi, SBI_IS_DIRTY) &&\n\t\t\tcpc->reason != CP_DISCARD && cpc->reason != CP_UMOUNT)\n\t\tgoto out;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto out;\n\tif (f2fs_readonly(sbi->sb))\n\t\tgoto out;\n\tif (block_operations(sbi))\n\t\tgoto out;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish block_ops\");\n\n\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\tf2fs_submit_merged_bio(sbi, META, WRITE);\n\n\t/*\n\t * update checkpoint pack index\n\t * Increase the version number so that\n\t * SIT entries and seg summaries are written at correct place\n\t */\n\tckpt_ver = cur_cp_version(ckpt);\n\tckpt->checkpoint_ver = cpu_to_le64(++ckpt_ver);\n\n\t/* write cached NAT/SIT entries to NAT/SIT area */\n\tflush_nat_entries(sbi);\n\tflush_sit_entries(sbi, cpc);\n\n\t/* unlock all the fs_lock[] in do_checkpoint() */\n\tdo_checkpoint(sbi, cpc);\n\n\tunblock_operations(sbi);\n\tstat_inc_cp_count(sbi->stat_info);\nout:\n\tmutex_unlock(&sbi->cp_mutex);\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish checkpoint\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->gc_mutex"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_cp_reason",
          "args": [
            "sbi"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "__get_cp_reason",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "775-784",
          "snippet": "static inline int __get_cp_reason(struct f2fs_sb_info *sbi)\n{\n\tint reason = CP_SYNC;\n\n\tif (test_opt(sbi, FASTBOOT))\n\t\treason = CP_FASTBOOT;\n\tif (is_sbi_flag_set(sbi, SBI_IS_CLOSE))\n\t\treason = CP_UMOUNT;\n\treturn reason;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int __get_cp_reason(struct f2fs_sb_info *sbi)\n{\n\tint reason = CP_SYNC;\n\n\tif (test_opt(sbi, FASTBOOT))\n\t\treason = CP_FASTBOOT;\n\tif (is_sbi_flag_set(sbi, SBI_IS_CLOSE))\n\t\treason = CP_UMOUNT;\n\treturn reason;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_sync_fs",
          "args": [
            "sb",
            "sync"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_SB",
          "args": [
            "sb"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "640-643",
          "snippet": "static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "447-494",
    "snippet": "static void f2fs_put_super(struct super_block *sb)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\tif (sbi->s_proc) {\n\t\tremove_proc_entry(\"segment_info\", sbi->s_proc);\n\t\tremove_proc_entry(sb->s_id, f2fs_proc_root);\n\t}\n\tkobject_del(&sbi->s_kobj);\n\n\tf2fs_destroy_stats(sbi);\n\tstop_gc_thread(sbi);\n\n\t/*\n\t * We don't need to do checkpoint when superblock is clean.\n\t * But, the previous checkpoint was not done by umount, it needs to do\n\t * clean checkpoint again.\n\t */\n\tif (is_sbi_flag_set(sbi, SBI_IS_DIRTY) ||\n\t\t\t!is_set_ckpt_flags(F2FS_CKPT(sbi), CP_UMOUNT_FLAG)) {\n\t\tstruct cp_control cpc = {\n\t\t\t.reason = CP_UMOUNT,\n\t\t};\n\t\twrite_checkpoint(sbi, &cpc);\n\t}\n\n\t/*\n\t * normally superblock is clean, so we need to release this.\n\t * In addition, EIO will skip do checkpoint, we need this as well.\n\t */\n\trelease_dirty_inode(sbi);\n\trelease_discard_addrs(sbi);\n\n\tiput(sbi->node_inode);\n\tiput(sbi->meta_inode);\n\n\t/* destroy f2fs internal modules */\n\tdestroy_node_manager(sbi);\n\tdestroy_segment_manager(sbi);\n\n\tkfree(sbi->ckpt);\n\tkobject_put(&sbi->s_kobj);\n\twait_for_completion(&sbi->s_kobj_unregister);\n\n\tsb->s_fs_info = NULL;\n\tbrelse(sbi->raw_super_buf);\n\tkfree(sbi);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct proc_dir_entry *f2fs_proc_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sbi->raw_super_buf"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&sbi->s_kobj_unregister"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&sbi->s_kobj"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->ckpt"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_segment_manager",
          "args": [
            "sbi"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_segment_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "2254-2267",
          "snippet": "void destroy_segment_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_sm_info *sm_info = SM_I(sbi);\n\n\tif (!sm_info)\n\t\treturn;\n\tdestroy_flush_cmd_control(sbi);\n\tdestroy_dirty_segmap(sbi);\n\tdestroy_curseg(sbi);\n\tdestroy_free_segmap(sbi);\n\tdestroy_sit_info(sbi);\n\tsbi->sm_info = NULL;\n\tkfree(sm_info);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid destroy_segment_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_sm_info *sm_info = SM_I(sbi);\n\n\tif (!sm_info)\n\t\treturn;\n\tdestroy_flush_cmd_control(sbi);\n\tdestroy_dirty_segmap(sbi);\n\tdestroy_curseg(sbi);\n\tdestroy_free_segmap(sbi);\n\tdestroy_sit_info(sbi);\n\tsbi->sm_info = NULL;\n\tkfree(sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_node_manager",
          "args": [
            "sbi"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_node_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1981-2037",
          "snippet": "void destroy_node_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i, *next_i;\n\tstruct nat_entry *natvec[NATVEC_SIZE];\n\tstruct nat_entry_set *setvec[SETVEC_SIZE];\n\tnid_t nid = 0;\n\tunsigned int found;\n\n\tif (!nm_i)\n\t\treturn;\n\n\t/* destroy free nid list */\n\tspin_lock(&nm_i->free_nid_list_lock);\n\tlist_for_each_entry_safe(i, next_i, &nm_i->free_nid_list, list) {\n\t\tf2fs_bug_on(sbi, i->state == NID_ALLOC);\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tnm_i->fcnt--;\n\t\tspin_unlock(&nm_i->free_nid_list_lock);\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\tspin_lock(&nm_i->free_nid_list_lock);\n\t}\n\tf2fs_bug_on(sbi, nm_i->fcnt);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\t/* destroy nat cache */\n\tdown_write(&nm_i->nat_tree_lock);\n\twhile ((found = __gang_lookup_nat_cache(nm_i,\n\t\t\t\t\tnid, NATVEC_SIZE, natvec))) {\n\t\tunsigned idx;\n\n\t\tnid = nat_get_nid(natvec[found - 1]) + 1;\n\t\tfor (idx = 0; idx < found; idx++)\n\t\t\t__del_from_nat_cache(nm_i, natvec[idx]);\n\t}\n\tf2fs_bug_on(sbi, nm_i->nat_cnt);\n\n\t/* destroy nat set cache */\n\tnid = 0;\n\twhile ((found = __gang_lookup_nat_set(nm_i,\n\t\t\t\t\tnid, SETVEC_SIZE, setvec))) {\n\t\tunsigned idx;\n\n\t\tnid = setvec[found - 1]->set + 1;\n\t\tfor (idx = 0; idx < found; idx++) {\n\t\t\t/* entry_cnt is not zero, when cp_error was occurred */\n\t\t\tf2fs_bug_on(sbi, !list_empty(&setvec[idx]->entry_list));\n\t\t\tradix_tree_delete(&nm_i->nat_set_root, setvec[idx]->set);\n\t\t\tkmem_cache_free(nat_entry_set_slab, setvec[idx]);\n\t\t}\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n\n\tkfree(nm_i->nat_bitmap);\n\tsbi->nm_info = NULL;\n\tkfree(nm_i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;",
            "static struct kmem_cache *nat_entry_set_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\nstatic struct kmem_cache *nat_entry_set_slab;\n\nvoid destroy_node_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i, *next_i;\n\tstruct nat_entry *natvec[NATVEC_SIZE];\n\tstruct nat_entry_set *setvec[SETVEC_SIZE];\n\tnid_t nid = 0;\n\tunsigned int found;\n\n\tif (!nm_i)\n\t\treturn;\n\n\t/* destroy free nid list */\n\tspin_lock(&nm_i->free_nid_list_lock);\n\tlist_for_each_entry_safe(i, next_i, &nm_i->free_nid_list, list) {\n\t\tf2fs_bug_on(sbi, i->state == NID_ALLOC);\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tnm_i->fcnt--;\n\t\tspin_unlock(&nm_i->free_nid_list_lock);\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\tspin_lock(&nm_i->free_nid_list_lock);\n\t}\n\tf2fs_bug_on(sbi, nm_i->fcnt);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\t/* destroy nat cache */\n\tdown_write(&nm_i->nat_tree_lock);\n\twhile ((found = __gang_lookup_nat_cache(nm_i,\n\t\t\t\t\tnid, NATVEC_SIZE, natvec))) {\n\t\tunsigned idx;\n\n\t\tnid = nat_get_nid(natvec[found - 1]) + 1;\n\t\tfor (idx = 0; idx < found; idx++)\n\t\t\t__del_from_nat_cache(nm_i, natvec[idx]);\n\t}\n\tf2fs_bug_on(sbi, nm_i->nat_cnt);\n\n\t/* destroy nat set cache */\n\tnid = 0;\n\twhile ((found = __gang_lookup_nat_set(nm_i,\n\t\t\t\t\tnid, SETVEC_SIZE, setvec))) {\n\t\tunsigned idx;\n\n\t\tnid = setvec[found - 1]->set + 1;\n\t\tfor (idx = 0; idx < found; idx++) {\n\t\t\t/* entry_cnt is not zero, when cp_error was occurred */\n\t\t\tf2fs_bug_on(sbi, !list_empty(&setvec[idx]->entry_list));\n\t\t\tradix_tree_delete(&nm_i->nat_set_root, setvec[idx]->set);\n\t\t\tkmem_cache_free(nat_entry_set_slab, setvec[idx]);\n\t\t}\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n\n\tkfree(nm_i->nat_bitmap);\n\tsbi->nm_info = NULL;\n\tkfree(nm_i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "sbi->meta_inode"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_discard_addrs",
          "args": [
            "sbi"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "release_discard_addrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "559-569",
          "snippet": "void release_discard_addrs(struct f2fs_sb_info *sbi)\n{\n\tstruct list_head *head = &(SM_I(sbi)->discard_list);\n\tstruct discard_entry *entry, *this;\n\n\t/* drop caches */\n\tlist_for_each_entry_safe(entry, this, head, list) {\n\t\tlist_del(&entry->list);\n\t\tkmem_cache_free(discard_entry_slab, entry);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *discard_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *discard_entry_slab;\n\nvoid release_discard_addrs(struct f2fs_sb_info *sbi)\n{\n\tstruct list_head *head = &(SM_I(sbi)->discard_list);\n\tstruct discard_entry *entry, *this;\n\n\t/* drop caches */\n\tlist_for_each_entry_safe(entry, this, head, list) {\n\t\tlist_del(&entry->list);\n\t\tkmem_cache_free(discard_entry_slab, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_dirty_inode",
          "args": [
            "sbi"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "release_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "399-416",
          "snippet": "void release_dirty_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct ino_entry *e, *tmp;\n\tint i;\n\n\tfor (i = APPEND_INO; i <= UPDATE_INO; i++) {\n\t\tstruct inode_management *im = &sbi->im[i];\n\n\t\tspin_lock(&im->ino_lock);\n\t\tlist_for_each_entry_safe(e, tmp, &im->ino_list, list) {\n\t\t\tlist_del(&e->list);\n\t\t\tradix_tree_delete(&im->ino_root, e->ino);\n\t\t\tkmem_cache_free(ino_entry_slab, e);\n\t\t\tim->ino_num--;\n\t\t}\n\t\tspin_unlock(&im->ino_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ino_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *ino_entry_slab;\n\nvoid release_dirty_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct ino_entry *e, *tmp;\n\tint i;\n\n\tfor (i = APPEND_INO; i <= UPDATE_INO; i++) {\n\t\tstruct inode_management *im = &sbi->im[i];\n\n\t\tspin_lock(&im->ino_lock);\n\t\tlist_for_each_entry_safe(e, tmp, &im->ino_list, list) {\n\t\t\tlist_del(&e->list);\n\t\t\tradix_tree_delete(&im->ino_root, e->ino);\n\t\t\tkmem_cache_free(ino_entry_slab, e);\n\t\t\tim->ino_num--;\n\t\t}\n\t\tspin_unlock(&im->ino_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_checkpoint",
          "args": [
            "sbi",
            "&cpc"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "write_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "1046-1091",
          "snippet": "void write_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_ver;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"start block_ops\");\n\n\tmutex_lock(&sbi->cp_mutex);\n\n\tif (!is_sbi_flag_set(sbi, SBI_IS_DIRTY) &&\n\t\t\tcpc->reason != CP_DISCARD && cpc->reason != CP_UMOUNT)\n\t\tgoto out;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto out;\n\tif (f2fs_readonly(sbi->sb))\n\t\tgoto out;\n\tif (block_operations(sbi))\n\t\tgoto out;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish block_ops\");\n\n\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\tf2fs_submit_merged_bio(sbi, META, WRITE);\n\n\t/*\n\t * update checkpoint pack index\n\t * Increase the version number so that\n\t * SIT entries and seg summaries are written at correct place\n\t */\n\tckpt_ver = cur_cp_version(ckpt);\n\tckpt->checkpoint_ver = cpu_to_le64(++ckpt_ver);\n\n\t/* write cached NAT/SIT entries to NAT/SIT area */\n\tflush_nat_entries(sbi);\n\tflush_sit_entries(sbi, cpc);\n\n\t/* unlock all the fs_lock[] in do_checkpoint() */\n\tdo_checkpoint(sbi, cpc);\n\n\tunblock_operations(sbi);\n\tstat_inc_cp_count(sbi->stat_info);\nout:\n\tmutex_unlock(&sbi->cp_mutex);\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish checkpoint\");\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid write_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_ver;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"start block_ops\");\n\n\tmutex_lock(&sbi->cp_mutex);\n\n\tif (!is_sbi_flag_set(sbi, SBI_IS_DIRTY) &&\n\t\t\tcpc->reason != CP_DISCARD && cpc->reason != CP_UMOUNT)\n\t\tgoto out;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto out;\n\tif (f2fs_readonly(sbi->sb))\n\t\tgoto out;\n\tif (block_operations(sbi))\n\t\tgoto out;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish block_ops\");\n\n\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\tf2fs_submit_merged_bio(sbi, META, WRITE);\n\n\t/*\n\t * update checkpoint pack index\n\t * Increase the version number so that\n\t * SIT entries and seg summaries are written at correct place\n\t */\n\tckpt_ver = cur_cp_version(ckpt);\n\tckpt->checkpoint_ver = cpu_to_le64(++ckpt_ver);\n\n\t/* write cached NAT/SIT entries to NAT/SIT area */\n\tflush_nat_entries(sbi);\n\tflush_sit_entries(sbi, cpc);\n\n\t/* unlock all the fs_lock[] in do_checkpoint() */\n\tdo_checkpoint(sbi, cpc);\n\n\tunblock_operations(sbi);\n\tstat_inc_cp_count(sbi->stat_info);\nout:\n\tmutex_unlock(&sbi->cp_mutex);\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish checkpoint\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_set_ckpt_flags",
          "args": [
            "F2FS_CKPT(sbi)",
            "CP_UMOUNT_FLAG"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "is_set_ckpt_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "735-739",
          "snippet": "static inline bool is_set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\treturn ckpt_flags & f;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool is_set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\treturn ckpt_flags & f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_CKPT",
          "args": [
            "sbi"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_CKPT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "665-668",
          "snippet": "static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_sbi_flag_set",
          "args": [
            "sbi",
            "SBI_IS_DIRTY"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "is_sbi_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "715-718",
          "snippet": "static inline bool is_sbi_flag_set(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\treturn sbi->s_flag & (0x01 << type);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool is_sbi_flag_set(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\treturn sbi->s_flag & (0x01 << type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_gc_thread",
          "args": [
            "sbi"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "stop_gc_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "122-130",
          "snippet": "void stop_gc_thread(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_gc_kthread *gc_th = sbi->gc_thread;\n\tif (!gc_th)\n\t\treturn;\n\tkthread_stop(gc_th->f2fs_gc_task);\n\tkfree(gc_th);\n\tsbi->gc_thread = NULL;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid stop_gc_thread(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_gc_kthread *gc_th = sbi->gc_thread;\n\tif (!gc_th)\n\t\treturn;\n\tkthread_stop(gc_th->f2fs_gc_task);\n\tkfree(gc_th);\n\tsbi->gc_thread = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_destroy_stats",
          "args": [
            "sbi"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_destroy_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1670-1670",
          "snippet": "static inline void f2fs_destroy_stats(struct f2fs_sb_info *sbi) { }",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_destroy_stats(struct f2fs_sb_info *sbi) { }"
        }
      },
      {
        "call_info": {
          "callee": "kobject_del",
          "args": [
            "&sbi->s_kobj"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "sb->s_id",
            "f2fs_proc_root"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "523-554",
          "snippet": "void remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_SB",
          "args": [
            "sb"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "640-643",
          "snippet": "static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct proc_dir_entry *f2fs_proc_root;\n\nstatic void f2fs_put_super(struct super_block *sb)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\tif (sbi->s_proc) {\n\t\tremove_proc_entry(\"segment_info\", sbi->s_proc);\n\t\tremove_proc_entry(sb->s_id, f2fs_proc_root);\n\t}\n\tkobject_del(&sbi->s_kobj);\n\n\tf2fs_destroy_stats(sbi);\n\tstop_gc_thread(sbi);\n\n\t/*\n\t * We don't need to do checkpoint when superblock is clean.\n\t * But, the previous checkpoint was not done by umount, it needs to do\n\t * clean checkpoint again.\n\t */\n\tif (is_sbi_flag_set(sbi, SBI_IS_DIRTY) ||\n\t\t\t!is_set_ckpt_flags(F2FS_CKPT(sbi), CP_UMOUNT_FLAG)) {\n\t\tstruct cp_control cpc = {\n\t\t\t.reason = CP_UMOUNT,\n\t\t};\n\t\twrite_checkpoint(sbi, &cpc);\n\t}\n\n\t/*\n\t * normally superblock is clean, so we need to release this.\n\t * In addition, EIO will skip do checkpoint, we need this as well.\n\t */\n\trelease_dirty_inode(sbi);\n\trelease_discard_addrs(sbi);\n\n\tiput(sbi->node_inode);\n\tiput(sbi->meta_inode);\n\n\t/* destroy f2fs internal modules */\n\tdestroy_node_manager(sbi);\n\tdestroy_segment_manager(sbi);\n\n\tkfree(sbi->ckpt);\n\tkobject_put(&sbi->s_kobj);\n\twait_for_completion(&sbi->s_kobj_unregister);\n\n\tsb->s_fs_info = NULL;\n\tbrelse(sbi->raw_super_buf);\n\tkfree(sbi);\n}"
  },
  {
    "function_name": "f2fs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "442-445",
    "snippet": "static void f2fs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, f2fs_i_callback);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "f2fs_i_callback"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void f2fs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, f2fs_i_callback);\n}"
  },
  {
    "function_name": "f2fs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "436-440",
    "snippet": "static void f2fs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(f2fs_inode_cachep, F2FS_I(inode));\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *f2fs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "f2fs_inode_cachep",
            "F2FS_I(inode)"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *f2fs_inode_cachep;\n\nstatic void f2fs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(f2fs_inode_cachep, F2FS_I(inode));\n}"
  },
  {
    "function_name": "f2fs_dirty_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "431-434",
    "snippet": "static void f2fs_dirty_inode(struct inode *inode, int flags)\n{\n\tset_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_DIRTY_INODE"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void f2fs_dirty_inode(struct inode *inode, int flags)\n{\n\tset_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}"
  },
  {
    "function_name": "f2fs_drop_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "412-424",
    "snippet": "static int f2fs_drop_inode(struct inode *inode)\n{\n\t/*\n\t * This is to avoid a deadlock condition like below.\n\t * writeback_single_inode(inode)\n\t *  - f2fs_write_data_page\n\t *    - f2fs_gc -> iput -> evict\n\t *       - inode_wait_for_writeback(inode)\n\t */\n\tif (!inode_unhashed(inode) && inode->i_state & I_SYNC)\n\t\treturn 0;\n\treturn generic_drop_inode(inode);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_drop_inode",
          "args": [
            "inode"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unhashed",
          "args": [
            "inode"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int f2fs_drop_inode(struct inode *inode)\n{\n\t/*\n\t * This is to avoid a deadlock condition like below.\n\t * writeback_single_inode(inode)\n\t *  - f2fs_write_data_page\n\t *    - f2fs_gc -> iput -> evict\n\t *       - inode_wait_for_writeback(inode)\n\t */\n\tif (!inode_unhashed(inode) && inode->i_state & I_SYNC)\n\t\treturn 0;\n\treturn generic_drop_inode(inode);\n}"
  },
  {
    "function_name": "f2fs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "380-410",
    "snippet": "static struct inode *f2fs_alloc_inode(struct super_block *sb)\n{\n\tstruct f2fs_inode_info *fi;\n\n\tfi = kmem_cache_alloc(f2fs_inode_cachep, GFP_F2FS_ZERO);\n\tif (!fi)\n\t\treturn NULL;\n\n\tinit_once((void *) fi);\n\n\t/* Initialize f2fs-specific inode info */\n\tfi->vfs_inode.i_version = 1;\n\tatomic_set(&fi->dirty_pages, 0);\n\tfi->i_current_depth = 1;\n\tfi->i_advise = 0;\n\trwlock_init(&fi->ext.ext_lock);\n\tinit_rwsem(&fi->i_sem);\n\tINIT_RADIX_TREE(&fi->inmem_root, GFP_NOFS);\n\tINIT_LIST_HEAD(&fi->inmem_pages);\n\tmutex_init(&fi->inmem_lock);\n\n\tset_inode_flag(fi, FI_NEW_INODE);\n\n\tif (test_opt(F2FS_SB(sb), INLINE_XATTR))\n\t\tset_inode_flag(fi, FI_INLINE_XATTR);\n\n\t/* Will be used by directory only */\n\tfi->i_dir_level = F2FS_SB(sb)->dir_level;\n\n\treturn &fi->vfs_inode;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *f2fs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "F2FS_SB",
          "args": [
            "sb"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "640-643",
          "snippet": "static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "fi",
            "FI_INLINE_XATTR"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "F2FS_SB(sb)",
            "INLINE_XATTR"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fi->inmem_lock"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fi->inmem_pages"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&fi->inmem_root",
            "GFP_NOFS"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&fi->i_sem"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwlock_init",
          "args": [
            "&fi->ext.ext_lock"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fi->dirty_pages",
            "0"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_once",
          "args": [
            "(void *) fi"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "247-252",
          "snippet": "static void init_once(void *foo)\n{\n\tstruct f2fs_inode_info *fi = (struct f2fs_inode_info *) foo;\n\n\tinode_init_once(&fi->vfs_inode);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct f2fs_inode_info *fi = (struct f2fs_inode_info *) foo;\n\n\tinode_init_once(&fi->vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "f2fs_inode_cachep",
            "GFP_F2FS_ZERO"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *f2fs_inode_cachep;\n\nstatic struct inode *f2fs_alloc_inode(struct super_block *sb)\n{\n\tstruct f2fs_inode_info *fi;\n\n\tfi = kmem_cache_alloc(f2fs_inode_cachep, GFP_F2FS_ZERO);\n\tif (!fi)\n\t\treturn NULL;\n\n\tinit_once((void *) fi);\n\n\t/* Initialize f2fs-specific inode info */\n\tfi->vfs_inode.i_version = 1;\n\tatomic_set(&fi->dirty_pages, 0);\n\tfi->i_current_depth = 1;\n\tfi->i_advise = 0;\n\trwlock_init(&fi->ext.ext_lock);\n\tinit_rwsem(&fi->i_sem);\n\tINIT_RADIX_TREE(&fi->inmem_root, GFP_NOFS);\n\tINIT_LIST_HEAD(&fi->inmem_pages);\n\tmutex_init(&fi->inmem_lock);\n\n\tset_inode_flag(fi, FI_NEW_INODE);\n\n\tif (test_opt(F2FS_SB(sb), INLINE_XATTR))\n\t\tset_inode_flag(fi, FI_INLINE_XATTR);\n\n\t/* Will be used by directory only */\n\tfi->i_dir_level = F2FS_SB(sb)->dir_level;\n\n\treturn &fi->vfs_inode;\n}"
  },
  {
    "function_name": "parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "254-378",
    "snippet": "static int parse_options(struct super_block *sb, char *options)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p, *name;\n\tint arg = 0;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, f2fs_tokens, args);\n\n\t\tswitch (token) {\n\t\tcase Opt_gc_background:\n\t\t\tname = match_strdup(&args[0]);\n\n\t\t\tif (!name)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (strlen(name) == 2 && !strncmp(name, \"on\", 2))\n\t\t\t\tset_opt(sbi, BG_GC);\n\t\t\telse if (strlen(name) == 3 && !strncmp(name, \"off\", 3))\n\t\t\t\tclear_opt(sbi, BG_GC);\n\t\t\telse {\n\t\t\t\tkfree(name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tkfree(name);\n\t\t\tbreak;\n\t\tcase Opt_disable_roll_forward:\n\t\t\tset_opt(sbi, DISABLE_ROLL_FORWARD);\n\t\t\tbreak;\n\t\tcase Opt_norecovery:\n\t\t\t/* this option mounts f2fs with ro */\n\t\t\tset_opt(sbi, DISABLE_ROLL_FORWARD);\n\t\t\tif (!f2fs_readonly(sb))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tset_opt(sbi, DISCARD);\n\t\t\tbreak;\n\t\tcase Opt_noheap:\n\t\t\tset_opt(sbi, NOHEAP);\n\t\t\tbreak;\n#ifdef CONFIG_F2FS_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt(sbi, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt(sbi, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_inline_xattr:\n\t\t\tset_opt(sbi, INLINE_XATTR);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\t\"user_xattr options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\t\"nouser_xattr options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_inline_xattr:\n\t\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\t\"inline_xattr options not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_F2FS_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\t\tf2fs_msg(sb, KERN_INFO, \"acl options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tf2fs_msg(sb, KERN_INFO, \"noacl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_active_logs:\n\t\t\tif (args->from && match_int(args, &arg))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (arg != 2 && arg != 4 && arg != NR_CURSEG_TYPE)\n\t\t\t\treturn -EINVAL;\n\t\t\tsbi->active_logs = arg;\n\t\t\tbreak;\n\t\tcase Opt_disable_ext_identify:\n\t\t\tset_opt(sbi, DISABLE_EXT_IDENTIFY);\n\t\t\tbreak;\n\t\tcase Opt_inline_data:\n\t\t\tset_opt(sbi, INLINE_DATA);\n\t\t\tbreak;\n\t\tcase Opt_inline_dentry:\n\t\t\tset_opt(sbi, INLINE_DENTRY);\n\t\t\tbreak;\n\t\tcase Opt_flush_merge:\n\t\t\tset_opt(sbi, FLUSH_MERGE);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tset_opt(sbi, NOBARRIER);\n\t\t\tbreak;\n\t\tcase Opt_fastboot:\n\t\t\tset_opt(sbi, FASTBOOT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t\t\"Unrecognized mount option \\\"%s\\\" or missing value\",\n\t\t\t\tp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static match_table_t f2fs_tokens = {\n\t{Opt_gc_background, \"background_gc=%s\"},\n\t{Opt_disable_roll_forward, \"disable_roll_forward\"},\n\t{Opt_norecovery, \"norecovery\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_noheap, \"no_heap\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_active_logs, \"active_logs=%u\"},\n\t{Opt_disable_ext_identify, \"disable_ext_identify\"},\n\t{Opt_inline_xattr, \"inline_xattr\"},\n\t{Opt_inline_data, \"inline_data\"},\n\t{Opt_inline_dentry, \"inline_dentry\"},\n\t{Opt_flush_merge, \"flush_merge\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_fastboot, \"fastboot\"},\n\t{Opt_err, NULL},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"Unrecognized mount option \\\"%s\\\" or missing value\"",
            "p"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "235-245",
          "snippet": "void f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_opt",
          "args": [
            "sbi",
            "FASTBOOT"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_set_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1239-1271",
          "snippet": "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&arg"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi",
            "POSIX_ACL"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi",
            "XATTR_USER"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_readonly",
          "args": [
            "sb"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1305-1308",
          "snippet": "static inline int f2fs_readonly(struct super_block *sb)\n{\n\treturn sb->s_flags & MS_RDONLY;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_readonly(struct super_block *sb)\n{\n\treturn sb->s_flags & MS_RDONLY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi",
            "BG_GC"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "\"off\"",
            "3"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "\"on\"",
            "2"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "f2fs_tokens",
            "args"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_SB",
          "args": [
            "sb"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "640-643",
          "snippet": "static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic match_table_t f2fs_tokens = {\n\t{Opt_gc_background, \"background_gc=%s\"},\n\t{Opt_disable_roll_forward, \"disable_roll_forward\"},\n\t{Opt_norecovery, \"norecovery\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_noheap, \"no_heap\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_active_logs, \"active_logs=%u\"},\n\t{Opt_disable_ext_identify, \"disable_ext_identify\"},\n\t{Opt_inline_xattr, \"inline_xattr\"},\n\t{Opt_inline_data, \"inline_data\"},\n\t{Opt_inline_dentry, \"inline_dentry\"},\n\t{Opt_flush_merge, \"flush_merge\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_fastboot, \"fastboot\"},\n\t{Opt_err, NULL},\n};\n\nstatic int parse_options(struct super_block *sb, char *options)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p, *name;\n\tint arg = 0;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, f2fs_tokens, args);\n\n\t\tswitch (token) {\n\t\tcase Opt_gc_background:\n\t\t\tname = match_strdup(&args[0]);\n\n\t\t\tif (!name)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (strlen(name) == 2 && !strncmp(name, \"on\", 2))\n\t\t\t\tset_opt(sbi, BG_GC);\n\t\t\telse if (strlen(name) == 3 && !strncmp(name, \"off\", 3))\n\t\t\t\tclear_opt(sbi, BG_GC);\n\t\t\telse {\n\t\t\t\tkfree(name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tkfree(name);\n\t\t\tbreak;\n\t\tcase Opt_disable_roll_forward:\n\t\t\tset_opt(sbi, DISABLE_ROLL_FORWARD);\n\t\t\tbreak;\n\t\tcase Opt_norecovery:\n\t\t\t/* this option mounts f2fs with ro */\n\t\t\tset_opt(sbi, DISABLE_ROLL_FORWARD);\n\t\t\tif (!f2fs_readonly(sb))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tset_opt(sbi, DISCARD);\n\t\t\tbreak;\n\t\tcase Opt_noheap:\n\t\t\tset_opt(sbi, NOHEAP);\n\t\t\tbreak;\n#ifdef CONFIG_F2FS_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt(sbi, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt(sbi, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_inline_xattr:\n\t\t\tset_opt(sbi, INLINE_XATTR);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\t\"user_xattr options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\t\"nouser_xattr options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_inline_xattr:\n\t\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\t\"inline_xattr options not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_F2FS_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\t\tf2fs_msg(sb, KERN_INFO, \"acl options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tf2fs_msg(sb, KERN_INFO, \"noacl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_active_logs:\n\t\t\tif (args->from && match_int(args, &arg))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (arg != 2 && arg != 4 && arg != NR_CURSEG_TYPE)\n\t\t\t\treturn -EINVAL;\n\t\t\tsbi->active_logs = arg;\n\t\t\tbreak;\n\t\tcase Opt_disable_ext_identify:\n\t\t\tset_opt(sbi, DISABLE_EXT_IDENTIFY);\n\t\t\tbreak;\n\t\tcase Opt_inline_data:\n\t\t\tset_opt(sbi, INLINE_DATA);\n\t\t\tbreak;\n\t\tcase Opt_inline_dentry:\n\t\t\tset_opt(sbi, INLINE_DENTRY);\n\t\t\tbreak;\n\t\tcase Opt_flush_merge:\n\t\t\tset_opt(sbi, FLUSH_MERGE);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tset_opt(sbi, NOBARRIER);\n\t\t\tbreak;\n\t\tcase Opt_fastboot:\n\t\t\tset_opt(sbi, FASTBOOT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tf2fs_msg(sb, KERN_ERR,\n\t\t\t\t\"Unrecognized mount option \\\"%s\\\" or missing value\",\n\t\t\t\tp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "247-252",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct f2fs_inode_info *fi = (struct f2fs_inode_info *) foo;\n\n\tinode_init_once(&fi->vfs_inode);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&fi->vfs_inode"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1725-1755",
          "snippet": "static void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\n\nstatic void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct f2fs_inode_info *fi = (struct f2fs_inode_info *) foo;\n\n\tinode_init_once(&fi->vfs_inode);\n}"
  },
  {
    "function_name": "f2fs_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "235-245",
    "snippet": "void f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%sF2FS-fs (%s): %pV\\n\"",
            "level",
            "sb->s_id",
            "&vaf"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
  },
  {
    "function_name": "f2fs_sb_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "171-176",
    "snippet": "static void f2fs_sb_release(struct kobject *kobj)\n{\n\tstruct f2fs_sb_info *sbi = container_of(kobj, struct f2fs_sb_info,\n\t\t\t\t\t\t\t\ts_kobj);\n\tcomplete(&sbi->s_kobj_unregister);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&sbi->s_kobj_unregister"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_dir_is_complete_ordered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "486-494",
          "snippet": "static inline bool ceph_dir_is_complete_ordered(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tbool ret;\n\tspin_lock(&ci->i_ceph_lock);\n\tret = __ceph_dir_is_complete_ordered(ci);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline bool ceph_dir_is_complete_ordered(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tbool ret;\n\tspin_lock(&ci->i_ceph_lock);\n\tret = __ceph_dir_is_complete_ordered(ci);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kobj",
            "structf2fs_sb_info",
            "s_kobj"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void f2fs_sb_release(struct kobject *kobj)\n{\n\tstruct f2fs_sb_info *sbi = container_of(kobj, struct f2fs_sb_info,\n\t\t\t\t\t\t\t\ts_kobj);\n\tcomplete(&sbi->s_kobj_unregister);\n}"
  },
  {
    "function_name": "f2fs_attr_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "161-169",
    "snippet": "static ssize_t f2fs_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct f2fs_sb_info *sbi = container_of(kobj, struct f2fs_sb_info,\n\t\t\t\t\t\t\t\t\ts_kobj);\n\tstruct f2fs_attr *a = container_of(attr, struct f2fs_attr, attr);\n\n\treturn a->store ? a->store(a, sbi, buf, len) : 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "a->store",
          "args": [
            "a",
            "sbi",
            "buf",
            "len"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "attr",
            "structf2fs_attr",
            "attr"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kobj",
            "structf2fs_sb_info",
            "s_kobj"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic ssize_t f2fs_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct f2fs_sb_info *sbi = container_of(kobj, struct f2fs_sb_info,\n\t\t\t\t\t\t\t\t\ts_kobj);\n\tstruct f2fs_attr *a = container_of(attr, struct f2fs_attr, attr);\n\n\treturn a->store ? a->store(a, sbi, buf, len) : 0;\n}"
  },
  {
    "function_name": "f2fs_attr_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "151-159",
    "snippet": "static ssize_t f2fs_attr_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr, char *buf)\n{\n\tstruct f2fs_sb_info *sbi = container_of(kobj, struct f2fs_sb_info,\n\t\t\t\t\t\t\t\ts_kobj);\n\tstruct f2fs_attr *a = container_of(attr, struct f2fs_attr, attr);\n\n\treturn a->show ? a->show(a, sbi, buf) : 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "a->show",
          "args": [
            "a",
            "sbi",
            "buf"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "attr",
            "structf2fs_attr",
            "attr"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kobj",
            "structf2fs_sb_info",
            "s_kobj"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic ssize_t f2fs_attr_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr, char *buf)\n{\n\tstruct f2fs_sb_info *sbi = container_of(kobj, struct f2fs_sb_info,\n\t\t\t\t\t\t\t\ts_kobj);\n\tstruct f2fs_attr *a = container_of(attr, struct f2fs_attr, attr);\n\n\treturn a->show ? a->show(a, sbi, buf) : 0;\n}"
  },
  {
    "function_name": "f2fs_sbi_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "129-149",
    "snippet": "static ssize_t f2fs_sbi_store(struct f2fs_attr *a,\n\t\t\tstruct f2fs_sb_info *sbi,\n\t\t\tconst char *buf, size_t count)\n{\n\tunsigned char *ptr;\n\tunsigned long t;\n\tunsigned int *ui;\n\tssize_t ret;\n\n\tptr = __struct_ptr(sbi, a->struct_type);\n\tif (!ptr)\n\t\treturn -EINVAL;\n\n\tui = (unsigned int *)(ptr + a->offset);\n\n\tret = kstrtoul(skip_spaces(buf), 0, &t);\n\tif (ret < 0)\n\t\treturn ret;\n\t*ui = t;\n\treturn count;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "skip_spaces(buf)",
            "0",
            "&t"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skip_spaces",
          "args": [
            "buf"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__struct_ptr",
          "args": [
            "sbi",
            "a->struct_type"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "__struct_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "101-112",
          "snippet": "static unsigned char *__struct_ptr(struct f2fs_sb_info *sbi, int struct_type)\n{\n\tif (struct_type == GC_THREAD)\n\t\treturn (unsigned char *)sbi->gc_thread;\n\telse if (struct_type == SM_INFO)\n\t\treturn (unsigned char *)SM_I(sbi);\n\telse if (struct_type == NM_INFO)\n\t\treturn (unsigned char *)NM_I(sbi);\n\telse if (struct_type == F2FS_SBI)\n\t\treturn (unsigned char *)sbi;\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic unsigned char *__struct_ptr(struct f2fs_sb_info *sbi, int struct_type)\n{\n\tif (struct_type == GC_THREAD)\n\t\treturn (unsigned char *)sbi->gc_thread;\n\telse if (struct_type == SM_INFO)\n\t\treturn (unsigned char *)SM_I(sbi);\n\telse if (struct_type == NM_INFO)\n\t\treturn (unsigned char *)NM_I(sbi);\n\telse if (struct_type == F2FS_SBI)\n\t\treturn (unsigned char *)sbi;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic ssize_t f2fs_sbi_store(struct f2fs_attr *a,\n\t\t\tstruct f2fs_sb_info *sbi,\n\t\t\tconst char *buf, size_t count)\n{\n\tunsigned char *ptr;\n\tunsigned long t;\n\tunsigned int *ui;\n\tssize_t ret;\n\n\tptr = __struct_ptr(sbi, a->struct_type);\n\tif (!ptr)\n\t\treturn -EINVAL;\n\n\tui = (unsigned int *)(ptr + a->offset);\n\n\tret = kstrtoul(skip_spaces(buf), 0, &t);\n\tif (ret < 0)\n\t\treturn ret;\n\t*ui = t;\n\treturn count;\n}"
  },
  {
    "function_name": "f2fs_sbi_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "114-127",
    "snippet": "static ssize_t f2fs_sbi_show(struct f2fs_attr *a,\n\t\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\tunsigned char *ptr = NULL;\n\tunsigned int *ui;\n\n\tptr = __struct_ptr(sbi, a->struct_type);\n\tif (!ptr)\n\t\treturn -EINVAL;\n\n\tui = (unsigned int *)(ptr + a->offset);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", *ui);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%u\\n\"",
            "*ui"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__struct_ptr",
          "args": [
            "sbi",
            "a->struct_type"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "__struct_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "101-112",
          "snippet": "static unsigned char *__struct_ptr(struct f2fs_sb_info *sbi, int struct_type)\n{\n\tif (struct_type == GC_THREAD)\n\t\treturn (unsigned char *)sbi->gc_thread;\n\telse if (struct_type == SM_INFO)\n\t\treturn (unsigned char *)SM_I(sbi);\n\telse if (struct_type == NM_INFO)\n\t\treturn (unsigned char *)NM_I(sbi);\n\telse if (struct_type == F2FS_SBI)\n\t\treturn (unsigned char *)sbi;\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic unsigned char *__struct_ptr(struct f2fs_sb_info *sbi, int struct_type)\n{\n\tif (struct_type == GC_THREAD)\n\t\treturn (unsigned char *)sbi->gc_thread;\n\telse if (struct_type == SM_INFO)\n\t\treturn (unsigned char *)SM_I(sbi);\n\telse if (struct_type == NM_INFO)\n\t\treturn (unsigned char *)NM_I(sbi);\n\telse if (struct_type == F2FS_SBI)\n\t\treturn (unsigned char *)sbi;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic ssize_t f2fs_sbi_show(struct f2fs_attr *a,\n\t\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\tunsigned char *ptr = NULL;\n\tunsigned int *ui;\n\n\tptr = __struct_ptr(sbi, a->struct_type);\n\tif (!ptr)\n\t\treturn -EINVAL;\n\n\tui = (unsigned int *)(ptr + a->offset);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", *ui);\n}"
  },
  {
    "function_name": "__struct_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
    "lines": "101-112",
    "snippet": "static unsigned char *__struct_ptr(struct f2fs_sb_info *sbi, int struct_type)\n{\n\tif (struct_type == GC_THREAD)\n\t\treturn (unsigned char *)sbi->gc_thread;\n\telse if (struct_type == SM_INFO)\n\t\treturn (unsigned char *)SM_I(sbi);\n\telse if (struct_type == NM_INFO)\n\t\treturn (unsigned char *)NM_I(sbi);\n\telse if (struct_type == F2FS_SBI)\n\t\treturn (unsigned char *)sbi;\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"gc.h\"",
      "#include \"xattr.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/sysfs.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/random.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/kthread.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic unsigned char *__struct_ptr(struct f2fs_sb_info *sbi, int struct_type)\n{\n\tif (struct_type == GC_THREAD)\n\t\treturn (unsigned char *)sbi->gc_thread;\n\telse if (struct_type == SM_INFO)\n\t\treturn (unsigned char *)SM_I(sbi);\n\telse if (struct_type == NM_INFO)\n\t\treturn (unsigned char *)NM_I(sbi);\n\telse if (struct_type == F2FS_SBI)\n\t\treturn (unsigned char *)sbi;\n\treturn NULL;\n}"
  }
]