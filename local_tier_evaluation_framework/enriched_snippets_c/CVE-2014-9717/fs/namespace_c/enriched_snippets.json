[
  {
    "function_name": "mntns_install",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "3195-3226",
    "snippet": "static int mntns_install(struct nsproxy *nsproxy, struct ns_common *ns)\n{\n\tstruct fs_struct *fs = current->fs;\n\tstruct mnt_namespace *mnt_ns = to_mnt_ns(ns);\n\tstruct path root;\n\n\tif (!ns_capable(mnt_ns->user_ns, CAP_SYS_ADMIN) ||\n\t    !ns_capable(current_user_ns(), CAP_SYS_CHROOT) ||\n\t    !ns_capable(current_user_ns(), CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (fs->users != 1)\n\t\treturn -EINVAL;\n\n\tget_mnt_ns(mnt_ns);\n\tput_mnt_ns(nsproxy->mnt_ns);\n\tnsproxy->mnt_ns = mnt_ns;\n\n\t/* Find the root */\n\troot.mnt    = &mnt_ns->root->mnt;\n\troot.dentry = mnt_ns->root->mnt.mnt_root;\n\tpath_get(&root);\n\twhile(d_mountpoint(root.dentry) && follow_down_one(&root))\n\t\t;\n\n\t/* Update the pwd and root */\n\tset_fs_pwd(fs, &root);\n\tset_fs_root(fs, &root);\n\n\tpath_put(&root);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&root"
          ],
          "line": 3224
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs_root",
          "args": [
            "fs",
            "&root"
          ],
          "line": 3222
        },
        "resolved": true,
        "details": {
          "function_name": "set_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "13-26",
          "snippet": "void set_fs_root(struct fs_struct *fs, const struct path *path)\n{\n\tstruct path old_root;\n\n\tpath_get(path);\n\tspin_lock(&fs->lock);\n\twrite_seqcount_begin(&fs->seq);\n\told_root = fs->root;\n\tfs->root = *path;\n\twrite_seqcount_end(&fs->seq);\n\tspin_unlock(&fs->lock);\n\tif (old_root.dentry)\n\t\tpath_put(&old_root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nvoid set_fs_root(struct fs_struct *fs, const struct path *path)\n{\n\tstruct path old_root;\n\n\tpath_get(path);\n\tspin_lock(&fs->lock);\n\twrite_seqcount_begin(&fs->seq);\n\told_root = fs->root;\n\tfs->root = *path;\n\twrite_seqcount_end(&fs->seq);\n\tspin_unlock(&fs->lock);\n\tif (old_root.dentry)\n\t\tpath_put(&old_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs_pwd",
          "args": [
            "fs",
            "&root"
          ],
          "line": 3221
        },
        "resolved": true,
        "details": {
          "function_name": "set_fs_pwd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "32-46",
          "snippet": "void set_fs_pwd(struct fs_struct *fs, const struct path *path)\n{\n\tstruct path old_pwd;\n\n\tpath_get(path);\n\tspin_lock(&fs->lock);\n\twrite_seqcount_begin(&fs->seq);\n\told_pwd = fs->pwd;\n\tfs->pwd = *path;\n\twrite_seqcount_end(&fs->seq);\n\tspin_unlock(&fs->lock);\n\n\tif (old_pwd.dentry)\n\t\tpath_put(&old_pwd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nvoid set_fs_pwd(struct fs_struct *fs, const struct path *path)\n{\n\tstruct path old_pwd;\n\n\tpath_get(path);\n\tspin_lock(&fs->lock);\n\twrite_seqcount_begin(&fs->seq);\n\told_pwd = fs->pwd;\n\tfs->pwd = *path;\n\twrite_seqcount_end(&fs->seq);\n\tspin_unlock(&fs->lock);\n\n\tif (old_pwd.dentry)\n\t\tpath_put(&old_pwd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "follow_down_one",
          "args": [
            "&root"
          ],
          "line": 3217
        },
        "resolved": true,
        "details": {
          "function_name": "follow_down_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1110-1123",
          "snippet": "int follow_down_one(struct path *path)\n{\n\tstruct vfsmount *mounted;\n\n\tmounted = lookup_mnt(path);\n\tif (mounted) {\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint follow_down_one(struct path *path)\n{\n\tstruct vfsmount *mounted;\n\n\tmounted = lookup_mnt(path);\n\tif (mounted) {\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "root.dentry"
          ],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&root"
          ],
          "line": 3216
        },
        "resolved": true,
        "details": {
          "function_name": "path_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "476-480",
          "snippet": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_mnt_ns",
          "args": [
            "nsproxy->mnt_ns"
          ],
          "line": 3210
        },
        "resolved": true,
        "details": {
          "function_name": "put_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "3077-3083",
          "snippet": "void put_mnt_ns(struct mnt_namespace *ns)\n{\n\tif (!atomic_dec_and_test(&ns->count))\n\t\treturn;\n\tdrop_collected_mounts(&ns->root->mnt);\n\tfree_mnt_ns(ns);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid put_mnt_ns(struct mnt_namespace *ns)\n{\n\tif (!atomic_dec_and_test(&ns->count))\n\t\treturn;\n\tdrop_collected_mounts(&ns->root->mnt);\n\tfree_mnt_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mnt_ns",
          "args": [
            "mnt_ns"
          ],
          "line": 3209
        },
        "resolved": true,
        "details": {
          "function_name": "get_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "102-105",
          "snippet": "static inline void get_mnt_ns(struct mnt_namespace *ns)\n{\n\tatomic_inc(&ns->count);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nstatic inline void get_mnt_ns(struct mnt_namespace *ns)\n{\n\tatomic_inc(&ns->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "current_user_ns()",
            "CAP_SYS_ADMIN"
          ],
          "line": 3203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 3203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "current_user_ns()",
            "CAP_SYS_CHROOT"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "mnt_ns->user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 3201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_mnt_ns",
          "args": [
            "ns"
          ],
          "line": 3198
        },
        "resolved": true,
        "details": {
          "function_name": "to_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1592-1595",
          "snippet": "struct mnt_namespace *to_mnt_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct mnt_namespace, ns);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct mnt_namespace *to_mnt_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct mnt_namespace, ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int mntns_install(struct nsproxy *nsproxy, struct ns_common *ns)\n{\n\tstruct fs_struct *fs = current->fs;\n\tstruct mnt_namespace *mnt_ns = to_mnt_ns(ns);\n\tstruct path root;\n\n\tif (!ns_capable(mnt_ns->user_ns, CAP_SYS_ADMIN) ||\n\t    !ns_capable(current_user_ns(), CAP_SYS_CHROOT) ||\n\t    !ns_capable(current_user_ns(), CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (fs->users != 1)\n\t\treturn -EINVAL;\n\n\tget_mnt_ns(mnt_ns);\n\tput_mnt_ns(nsproxy->mnt_ns);\n\tnsproxy->mnt_ns = mnt_ns;\n\n\t/* Find the root */\n\troot.mnt    = &mnt_ns->root->mnt;\n\troot.dentry = mnt_ns->root->mnt.mnt_root;\n\tpath_get(&root);\n\twhile(d_mountpoint(root.dentry) && follow_down_one(&root))\n\t\t;\n\n\t/* Update the pwd and root */\n\tset_fs_pwd(fs, &root);\n\tset_fs_root(fs, &root);\n\n\tpath_put(&root);\n\treturn 0;\n}"
  },
  {
    "function_name": "mntns_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "3190-3193",
    "snippet": "static void mntns_put(struct ns_common *ns)\n{\n\tput_mnt_ns(to_mnt_ns(ns));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_mnt_ns",
          "args": [
            "to_mnt_ns(ns)"
          ],
          "line": 3192
        },
        "resolved": true,
        "details": {
          "function_name": "put_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "3077-3083",
          "snippet": "void put_mnt_ns(struct mnt_namespace *ns)\n{\n\tif (!atomic_dec_and_test(&ns->count))\n\t\treturn;\n\tdrop_collected_mounts(&ns->root->mnt);\n\tfree_mnt_ns(ns);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid put_mnt_ns(struct mnt_namespace *ns)\n{\n\tif (!atomic_dec_and_test(&ns->count))\n\t\treturn;\n\tdrop_collected_mounts(&ns->root->mnt);\n\tfree_mnt_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_mnt_ns",
          "args": [
            "ns"
          ],
          "line": 3192
        },
        "resolved": true,
        "details": {
          "function_name": "to_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1592-1595",
          "snippet": "struct mnt_namespace *to_mnt_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct mnt_namespace, ns);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct mnt_namespace *to_mnt_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct mnt_namespace, ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void mntns_put(struct ns_common *ns)\n{\n\tput_mnt_ns(to_mnt_ns(ns));\n}"
  },
  {
    "function_name": "mntns_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "3174-3188",
    "snippet": "static struct ns_common *mntns_get(struct task_struct *task)\n{\n\tstruct ns_common *ns = NULL;\n\tstruct nsproxy *nsproxy;\n\n\ttask_lock(task);\n\tnsproxy = task->nsproxy;\n\tif (nsproxy) {\n\t\tns = &nsproxy->mnt_ns->ns;\n\t\tget_mnt_ns(to_mnt_ns(ns));\n\t}\n\ttask_unlock(task);\n\n\treturn ns;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 3185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mnt_ns",
          "args": [
            "to_mnt_ns(ns)"
          ],
          "line": 3183
        },
        "resolved": true,
        "details": {
          "function_name": "get_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "102-105",
          "snippet": "static inline void get_mnt_ns(struct mnt_namespace *ns)\n{\n\tatomic_inc(&ns->count);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nstatic inline void get_mnt_ns(struct mnt_namespace *ns)\n{\n\tatomic_inc(&ns->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_mnt_ns",
          "args": [
            "ns"
          ],
          "line": 3183
        },
        "resolved": true,
        "details": {
          "function_name": "to_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1592-1595",
          "snippet": "struct mnt_namespace *to_mnt_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct mnt_namespace, ns);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct mnt_namespace *to_mnt_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct mnt_namespace, ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "task"
          ],
          "line": 3179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct ns_common *mntns_get(struct task_struct *task)\n{\n\tstruct ns_common *ns = NULL;\n\tstruct nsproxy *nsproxy;\n\n\ttask_lock(task);\n\tnsproxy = task->nsproxy;\n\tif (nsproxy) {\n\t\tns = &nsproxy->mnt_ns->ns;\n\t\tget_mnt_ns(to_mnt_ns(ns));\n\t}\n\ttask_unlock(task);\n\n\treturn ns;\n}"
  },
  {
    "function_name": "fs_fully_visible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "3140-3172",
    "snippet": "bool fs_fully_visible(struct file_system_type *type)\n{\n\tstruct mnt_namespace *ns = current->nsproxy->mnt_ns;\n\tstruct mount *mnt;\n\tbool visible = false;\n\n\tif (unlikely(!ns))\n\t\treturn false;\n\n\tdown_read(&namespace_sem);\n\tlist_for_each_entry(mnt, &ns->list, mnt_list) {\n\t\tstruct mount *child;\n\t\tif (mnt->mnt.mnt_sb->s_type != type)\n\t\t\tcontinue;\n\n\t\t/* This mount is not fully visible if there are any child mounts\n\t\t * that cover anything except for empty directories.\n\t\t */\n\t\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\t\tstruct inode *inode = child->mnt_mountpoint->d_inode;\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tgoto next;\n\t\t\tif (inode->i_nlink > 2)\n\t\t\t\tgoto next;\n\t\t}\n\t\tvisible = true;\n\t\tgoto found;\n\tnext:\t;\n\t}\nfound:\n\tup_read(&namespace_sem);\n\treturn visible;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(namespace_sem);",
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&namespace_sem"
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 3160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&mnt->mnt_mounts",
            "mnt_child"
          ],
          "line": 3158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "mnt",
            "&ns->list",
            "mnt_list"
          ],
          "line": 3150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&namespace_sem"
          ],
          "line": 3149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ns"
          ],
          "line": 3146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic void shrink_submounts(struct mount *mnt);\n\nbool fs_fully_visible(struct file_system_type *type)\n{\n\tstruct mnt_namespace *ns = current->nsproxy->mnt_ns;\n\tstruct mount *mnt;\n\tbool visible = false;\n\n\tif (unlikely(!ns))\n\t\treturn false;\n\n\tdown_read(&namespace_sem);\n\tlist_for_each_entry(mnt, &ns->list, mnt_list) {\n\t\tstruct mount *child;\n\t\tif (mnt->mnt.mnt_sb->s_type != type)\n\t\t\tcontinue;\n\n\t\t/* This mount is not fully visible if there are any child mounts\n\t\t * that cover anything except for empty directories.\n\t\t */\n\t\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\t\tstruct inode *inode = child->mnt_mountpoint->d_inode;\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tgoto next;\n\t\t\tif (inode->i_nlink > 2)\n\t\t\t\tgoto next;\n\t\t}\n\t\tvisible = true;\n\t\tgoto found;\n\tnext:\t;\n\t}\nfound:\n\tup_read(&namespace_sem);\n\treturn visible;\n}"
  },
  {
    "function_name": "current_chrooted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "3116-3138",
    "snippet": "bool current_chrooted(void)\n{\n\t/* Does the current process have a non-standard root */\n\tstruct path ns_root;\n\tstruct path fs_root;\n\tbool chrooted;\n\n\t/* Find the namespace root */\n\tns_root.mnt = &current->nsproxy->mnt_ns->root->mnt;\n\tns_root.dentry = ns_root.mnt->mnt_root;\n\tpath_get(&ns_root);\n\twhile (d_mountpoint(ns_root.dentry) && follow_down_one(&ns_root))\n\t\t;\n\n\tget_fs_root(current->fs, &fs_root);\n\n\tchrooted = !path_equal(&fs_root, &ns_root);\n\n\tpath_put(&fs_root);\n\tpath_put(&ns_root);\n\n\treturn chrooted;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&ns_root"
          ],
          "line": 3135
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_equal",
          "args": [
            "&fs_root",
            "&ns_root"
          ],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs_root",
          "args": [
            "current->fs",
            "&fs_root"
          ],
          "line": 3130
        },
        "resolved": true,
        "details": {
          "function_name": "get_fs_root_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3021-3029",
          "snippet": "static void get_fs_root_rcu(struct fs_struct *fs, struct path *root)\n{\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t*root = fs->root;\n\t} while (read_seqcount_retry(&fs->seq, seq));\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void get_fs_root_rcu(struct fs_struct *fs, struct path *root)\n{\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t*root = fs->root;\n\t} while (read_seqcount_retry(&fs->seq, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "follow_down_one",
          "args": [
            "&ns_root"
          ],
          "line": 3127
        },
        "resolved": true,
        "details": {
          "function_name": "follow_down_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1110-1123",
          "snippet": "int follow_down_one(struct path *path)\n{\n\tstruct vfsmount *mounted;\n\n\tmounted = lookup_mnt(path);\n\tif (mounted) {\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint follow_down_one(struct path *path)\n{\n\tstruct vfsmount *mounted;\n\n\tmounted = lookup_mnt(path);\n\tif (mounted) {\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "ns_root.dentry"
          ],
          "line": 3127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&ns_root"
          ],
          "line": 3126
        },
        "resolved": true,
        "details": {
          "function_name": "path_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "476-480",
          "snippet": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nbool current_chrooted(void)\n{\n\t/* Does the current process have a non-standard root */\n\tstruct path ns_root;\n\tstruct path fs_root;\n\tbool chrooted;\n\n\t/* Find the namespace root */\n\tns_root.mnt = &current->nsproxy->mnt_ns->root->mnt;\n\tns_root.dentry = ns_root.mnt->mnt_root;\n\tpath_get(&ns_root);\n\twhile (d_mountpoint(ns_root.dentry) && follow_down_one(&ns_root))\n\t\t;\n\n\tget_fs_root(current->fs, &fs_root);\n\n\tchrooted = !path_equal(&fs_root, &ns_root);\n\n\tpath_put(&fs_root);\n\tpath_put(&ns_root);\n\n\treturn chrooted;\n}"
  },
  {
    "function_name": "our_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "3111-3114",
    "snippet": "bool our_mnt(struct vfsmount *mnt)\n{\n\treturn check_mnt(real_mount(mnt));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_mnt",
          "args": [
            "real_mount(mnt)"
          ],
          "line": 3113
        },
        "resolved": true,
        "details": {
          "function_name": "check_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "771-774",
          "snippet": "static inline int check_mnt(struct mount *mnt)\n{\n\treturn mnt->mnt_ns == current->nsproxy->mnt_ns;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline int check_mnt(struct mount *mnt)\n{\n\treturn mnt->mnt_ns == current->nsproxy->mnt_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 3113
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nbool our_mnt(struct vfsmount *mnt)\n{\n\treturn check_mnt(real_mount(mnt));\n}"
  },
  {
    "function_name": "kern_unmount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "3100-3108",
    "snippet": "void kern_unmount(struct vfsmount *mnt)\n{\n\t/* release long term mount so mount point can be released */\n\tif (!IS_ERR_OR_NULL(mnt)) {\n\t\treal_mount(mnt)->mnt_ns = NULL;\n\t\tsynchronize_rcu();\t/* yecchhh... */\n\t\tmntput(mnt);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "mnt"
          ],
          "line": 3106
        },
        "resolved": true,
        "details": {
          "function_name": "mntput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1118-1127",
          "snippet": "void mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 3105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 3104
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "mnt"
          ],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid kern_unmount(struct vfsmount *mnt)\n{\n\t/* release long term mount so mount point can be released */\n\tif (!IS_ERR_OR_NULL(mnt)) {\n\t\treal_mount(mnt)->mnt_ns = NULL;\n\t\tsynchronize_rcu();\t/* yecchhh... */\n\t\tmntput(mnt);\n\t}\n}"
  },
  {
    "function_name": "kern_mount_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "3085-3097",
    "snippet": "struct vfsmount *kern_mount_data(struct file_system_type *type, void *data)\n{\n\tstruct vfsmount *mnt;\n\tmnt = vfs_kern_mount(type, MS_KERNMOUNT, type->name, data);\n\tif (!IS_ERR(mnt)) {\n\t\t/*\n\t\t * it is a longterm mount, don't release mnt until\n\t\t * we unmount before file sys is unregistered\n\t\t*/\n\t\treal_mount(mnt)->mnt_ns = MNT_NS_INTERNAL;\n\t}\n\treturn mnt;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 3094
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_kern_mount",
          "args": [
            "type",
            "MS_KERNMOUNT",
            "type->name",
            "data"
          ],
          "line": 3088
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_kern_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "921-952",
          "snippet": "struct vfsmount *\nvfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & MS_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tmnt_free_id(mnt);\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tunlock_mount_hash();\n\treturn &mnt->mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *\nvfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & MS_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tmnt_free_id(mnt);\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tunlock_mount_hash();\n\treturn &mnt->mnt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *kern_mount_data(struct file_system_type *type, void *data)\n{\n\tstruct vfsmount *mnt;\n\tmnt = vfs_kern_mount(type, MS_KERNMOUNT, type->name, data);\n\tif (!IS_ERR(mnt)) {\n\t\t/*\n\t\t * it is a longterm mount, don't release mnt until\n\t\t * we unmount before file sys is unregistered\n\t\t*/\n\t\treal_mount(mnt)->mnt_ns = MNT_NS_INTERNAL;\n\t}\n\treturn mnt;\n}"
  },
  {
    "function_name": "put_mnt_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "3077-3083",
    "snippet": "void put_mnt_ns(struct mnt_namespace *ns)\n{\n\tif (!atomic_dec_and_test(&ns->count))\n\t\treturn;\n\tdrop_collected_mounts(&ns->root->mnt);\n\tfree_mnt_ns(ns);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_mnt_ns",
          "args": [
            "ns"
          ],
          "line": 3082
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2664-2669",
          "snippet": "static void free_mnt_ns(struct mnt_namespace *ns)\n{\n\tns_free_inum(&ns->ns);\n\tput_user_ns(ns->user_ns);\n\tkfree(ns);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void free_mnt_ns(struct mnt_namespace *ns)\n{\n\tns_free_inum(&ns->ns);\n\tput_user_ns(ns->user_ns);\n\tkfree(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_collected_mounts",
          "args": [
            "&ns->root->mnt"
          ],
          "line": 3081
        },
        "resolved": true,
        "details": {
          "function_name": "drop_collected_mounts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1694-1701",
          "snippet": "void drop_collected_mounts(struct vfsmount *mnt)\n{\n\tnamespace_lock();\n\tlock_mount_hash();\n\tumount_tree(real_mount(mnt), UMOUNT_SYNC);\n\tunlock_mount_hash();\n\tnamespace_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid drop_collected_mounts(struct vfsmount *mnt)\n{\n\tnamespace_lock();\n\tlock_mount_hash();\n\tumount_tree(real_mount(mnt), UMOUNT_SYNC);\n\tunlock_mount_hash();\n\tnamespace_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&ns->count"
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid put_mnt_ns(struct mnt_namespace *ns)\n{\n\tif (!atomic_dec_and_test(&ns->count))\n\t\treturn;\n\tdrop_collected_mounts(&ns->root->mnt);\n\tfree_mnt_ns(ns);\n}"
  },
  {
    "function_name": "mnt_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "3037-3075",
    "snippet": "void __init mnt_init(void)\n{\n\tunsigned u;\n\tint err;\n\n\tmnt_cache = kmem_cache_create(\"mnt_cache\", sizeof(struct mount),\n\t\t\t0, SLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);\n\n\tmount_hashtable = alloc_large_system_hash(\"Mount-cache\",\n\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\tmhash_entries, 19,\n\t\t\t\t0,\n\t\t\t\t&m_hash_shift, &m_hash_mask, 0, 0);\n\tmountpoint_hashtable = alloc_large_system_hash(\"Mountpoint-cache\",\n\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\tmphash_entries, 19,\n\t\t\t\t0,\n\t\t\t\t&mp_hash_shift, &mp_hash_mask, 0, 0);\n\n\tif (!mount_hashtable || !mountpoint_hashtable)\n\t\tpanic(\"Failed to allocate mount hash table\\n\");\n\n\tfor (u = 0; u <= m_hash_mask; u++)\n\t\tINIT_HLIST_HEAD(&mount_hashtable[u]);\n\tfor (u = 0; u <= mp_hash_mask; u++)\n\t\tINIT_HLIST_HEAD(&mountpoint_hashtable[u]);\n\n\tkernfs_init();\n\n\terr = sysfs_init();\n\tif (err)\n\t\tprintk(KERN_WARNING \"%s: sysfs_init error: %d\\n\",\n\t\t\t__func__, err);\n\tfs_kobj = kobject_create_and_add(\"fs\", NULL);\n\tif (!fs_kobj)\n\t\tprintk(KERN_WARNING \"%s: kobj create error\\n\", __func__);\n\tinit_rootfs();\n\tinit_mount_tree();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int m_hash_mask",
      "static unsigned int m_hash_shift",
      "static unsigned int mp_hash_mask",
      "static unsigned int mp_hash_shift",
      "static __initdata unsigned long mhash_entries;",
      "static __initdata unsigned long mphash_entries;",
      "static struct hlist_head *mount_hashtable",
      "static struct hlist_head *mountpoint_hashtable",
      "struct kobject *fs_kobj;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_mount_tree",
          "args": [],
          "line": 3074
        },
        "resolved": true,
        "details": {
          "function_name": "init_mount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "3007-3035",
          "snippet": "static void __init init_mount_tree(void)\n{\n\tstruct vfsmount *mnt;\n\tstruct mnt_namespace *ns;\n\tstruct path root;\n\tstruct file_system_type *type;\n\n\ttype = get_fs_type(\"rootfs\");\n\tif (!type)\n\t\tpanic(\"Can't find rootfs type\");\n\tmnt = vfs_kern_mount(type, 0, \"rootfs\", NULL);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\tpanic(\"Can't create rootfs\");\n\n\tns = create_mnt_ns(mnt);\n\tif (IS_ERR(ns))\n\t\tpanic(\"Can't allocate initial namespace\");\n\n\tinit_task.nsproxy->mnt_ns = ns;\n\tget_mnt_ns(ns);\n\n\troot.mnt = mnt;\n\troot.dentry = mnt->mnt_root;\n\tmnt->mnt_flags |= MNT_LOCKED;\n\n\tset_fs_pwd(current->fs, &root);\n\tset_fs_root(current->fs, &root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void __init init_mount_tree(void)\n{\n\tstruct vfsmount *mnt;\n\tstruct mnt_namespace *ns;\n\tstruct path root;\n\tstruct file_system_type *type;\n\n\ttype = get_fs_type(\"rootfs\");\n\tif (!type)\n\t\tpanic(\"Can't find rootfs type\");\n\tmnt = vfs_kern_mount(type, 0, \"rootfs\", NULL);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\tpanic(\"Can't create rootfs\");\n\n\tns = create_mnt_ns(mnt);\n\tif (IS_ERR(ns))\n\t\tpanic(\"Can't allocate initial namespace\");\n\n\tinit_task.nsproxy->mnt_ns = ns;\n\tget_mnt_ns(ns);\n\n\troot.mnt = mnt;\n\troot.dentry = mnt->mnt_root;\n\tmnt->mnt_flags |= MNT_LOCKED;\n\n\tset_fs_pwd(current->fs, &root);\n\tset_fs_root(current->fs, &root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rootfs",
          "args": [],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%s: kobj create error\\n\"",
            "__func__"
          ],
          "line": 3072
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "\"fs\"",
            "NULL"
          ],
          "line": 3070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_init",
          "args": [],
          "line": 3066
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sysfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "639-656",
          "snippet": "static int ocfs2_sysfs_init(void)\n{\n\tint ret;\n\n\tocfs2_kset = kset_create_and_add(\"ocfs2\", NULL, fs_kobj);\n\tif (!ocfs2_kset)\n\t\treturn -ENOMEM;\n\n\tret = sysfs_create_group(&ocfs2_kset->kobj, &ocfs2_attr_group);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tkset_unregister(ocfs2_kset);\n\treturn ret;\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct attribute_group ocfs2_attr_group = {\n\t.attrs = ocfs2_attrs,\n};",
            "static struct kset *ocfs2_kset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct attribute_group ocfs2_attr_group = {\n\t.attrs = ocfs2_attrs,\n};\nstatic struct kset *ocfs2_kset;\n\nstatic int ocfs2_sysfs_init(void)\n{\n\tint ret;\n\n\tocfs2_kset = kset_create_and_add(\"ocfs2\", NULL, fs_kobj);\n\tif (!ocfs2_kset)\n\t\treturn -ENOMEM;\n\n\tret = sysfs_create_group(&ocfs2_kset->kobj, &ocfs2_attr_group);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tkset_unregister(ocfs2_kset);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_init",
          "args": [],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/mount.c",
          "lines": "244-249",
          "snippet": "void __init kernfs_init(void)\n{\n\tkernfs_node_cache = kmem_cache_create(\"kernfs_node_cache\",\n\t\t\t\t\t      sizeof(struct kernfs_node),\n\t\t\t\t\t      0, SLAB_PANIC, NULL);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kernfs_node_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct kmem_cache *kernfs_node_cache;\n\nvoid __init kernfs_init(void)\n{\n\tkernfs_node_cache = kmem_cache_create(\"kernfs_node_cache\",\n\t\t\t\t\t      sizeof(struct kernfs_node),\n\t\t\t\t\t      0, SLAB_PANIC, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&mountpoint_hashtable[u]"
          ],
          "line": 3062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&mount_hashtable[u]"
          ],
          "line": 3060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Failed to allocate mount hash table\\n\""
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_large_system_hash",
          "args": [
            "\"Mountpoint-cache\"",
            "sizeof(struct hlist_head)",
            "mphash_entries",
            "19",
            "0",
            "&mp_hash_shift",
            "&mp_hash_mask",
            "0",
            "0"
          ],
          "line": 3050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_large_system_hash",
          "args": [
            "\"Mount-cache\"",
            "sizeof(struct hlist_head)",
            "mhash_entries",
            "19",
            "0",
            "&m_hash_shift",
            "&m_hash_mask",
            "0",
            "0"
          ],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"mnt_cache\"",
            "sizeof(struct mount)",
            "0",
            "SLAB_HWCACHE_ALIGN | SLAB_PANIC",
            "NULL"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned int m_hash_mask;\nstatic unsigned int m_hash_shift;\nstatic unsigned int mp_hash_mask;\nstatic unsigned int mp_hash_shift;\nstatic __initdata unsigned long mhash_entries;\nstatic __initdata unsigned long mphash_entries;\nstatic struct hlist_head *mount_hashtable;\nstatic struct hlist_head *mountpoint_hashtable;\nstruct kobject *fs_kobj;\n\nvoid __init mnt_init(void)\n{\n\tunsigned u;\n\tint err;\n\n\tmnt_cache = kmem_cache_create(\"mnt_cache\", sizeof(struct mount),\n\t\t\t0, SLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);\n\n\tmount_hashtable = alloc_large_system_hash(\"Mount-cache\",\n\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\tmhash_entries, 19,\n\t\t\t\t0,\n\t\t\t\t&m_hash_shift, &m_hash_mask, 0, 0);\n\tmountpoint_hashtable = alloc_large_system_hash(\"Mountpoint-cache\",\n\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\tmphash_entries, 19,\n\t\t\t\t0,\n\t\t\t\t&mp_hash_shift, &mp_hash_mask, 0, 0);\n\n\tif (!mount_hashtable || !mountpoint_hashtable)\n\t\tpanic(\"Failed to allocate mount hash table\\n\");\n\n\tfor (u = 0; u <= m_hash_mask; u++)\n\t\tINIT_HLIST_HEAD(&mount_hashtable[u]);\n\tfor (u = 0; u <= mp_hash_mask; u++)\n\t\tINIT_HLIST_HEAD(&mountpoint_hashtable[u]);\n\n\tkernfs_init();\n\n\terr = sysfs_init();\n\tif (err)\n\t\tprintk(KERN_WARNING \"%s: sysfs_init error: %d\\n\",\n\t\t\t__func__, err);\n\tfs_kobj = kobject_create_and_add(\"fs\", NULL);\n\tif (!fs_kobj)\n\t\tprintk(KERN_WARNING \"%s: kobj create error\\n\", __func__);\n\tinit_rootfs();\n\tinit_mount_tree();\n}"
  },
  {
    "function_name": "init_mount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "3007-3035",
    "snippet": "static void __init init_mount_tree(void)\n{\n\tstruct vfsmount *mnt;\n\tstruct mnt_namespace *ns;\n\tstruct path root;\n\tstruct file_system_type *type;\n\n\ttype = get_fs_type(\"rootfs\");\n\tif (!type)\n\t\tpanic(\"Can't find rootfs type\");\n\tmnt = vfs_kern_mount(type, 0, \"rootfs\", NULL);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\tpanic(\"Can't create rootfs\");\n\n\tns = create_mnt_ns(mnt);\n\tif (IS_ERR(ns))\n\t\tpanic(\"Can't allocate initial namespace\");\n\n\tinit_task.nsproxy->mnt_ns = ns;\n\tget_mnt_ns(ns);\n\n\troot.mnt = mnt;\n\troot.dentry = mnt->mnt_root;\n\tmnt->mnt_flags |= MNT_LOCKED;\n\n\tset_fs_pwd(current->fs, &root);\n\tset_fs_root(current->fs, &root);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_fs_root",
          "args": [
            "current->fs",
            "&root"
          ],
          "line": 3034
        },
        "resolved": true,
        "details": {
          "function_name": "set_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "13-26",
          "snippet": "void set_fs_root(struct fs_struct *fs, const struct path *path)\n{\n\tstruct path old_root;\n\n\tpath_get(path);\n\tspin_lock(&fs->lock);\n\twrite_seqcount_begin(&fs->seq);\n\told_root = fs->root;\n\tfs->root = *path;\n\twrite_seqcount_end(&fs->seq);\n\tspin_unlock(&fs->lock);\n\tif (old_root.dentry)\n\t\tpath_put(&old_root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nvoid set_fs_root(struct fs_struct *fs, const struct path *path)\n{\n\tstruct path old_root;\n\n\tpath_get(path);\n\tspin_lock(&fs->lock);\n\twrite_seqcount_begin(&fs->seq);\n\told_root = fs->root;\n\tfs->root = *path;\n\twrite_seqcount_end(&fs->seq);\n\tspin_unlock(&fs->lock);\n\tif (old_root.dentry)\n\t\tpath_put(&old_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs_pwd",
          "args": [
            "current->fs",
            "&root"
          ],
          "line": 3033
        },
        "resolved": true,
        "details": {
          "function_name": "set_fs_pwd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "32-46",
          "snippet": "void set_fs_pwd(struct fs_struct *fs, const struct path *path)\n{\n\tstruct path old_pwd;\n\n\tpath_get(path);\n\tspin_lock(&fs->lock);\n\twrite_seqcount_begin(&fs->seq);\n\told_pwd = fs->pwd;\n\tfs->pwd = *path;\n\twrite_seqcount_end(&fs->seq);\n\tspin_unlock(&fs->lock);\n\n\tif (old_pwd.dentry)\n\t\tpath_put(&old_pwd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nvoid set_fs_pwd(struct fs_struct *fs, const struct path *path)\n{\n\tstruct path old_pwd;\n\n\tpath_get(path);\n\tspin_lock(&fs->lock);\n\twrite_seqcount_begin(&fs->seq);\n\told_pwd = fs->pwd;\n\tfs->pwd = *path;\n\twrite_seqcount_end(&fs->seq);\n\tspin_unlock(&fs->lock);\n\n\tif (old_pwd.dentry)\n\t\tpath_put(&old_pwd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mnt_ns",
          "args": [
            "ns"
          ],
          "line": 3027
        },
        "resolved": true,
        "details": {
          "function_name": "get_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "102-105",
          "snippet": "static inline void get_mnt_ns(struct mnt_namespace *ns)\n{\n\tatomic_inc(&ns->count);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nstatic inline void get_mnt_ns(struct mnt_namespace *ns)\n{\n\tatomic_inc(&ns->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Can't allocate initial namespace\""
          ],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ns"
          ],
          "line": 3023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_mnt_ns",
          "args": [
            "mnt"
          ],
          "line": 3022
        },
        "resolved": true,
        "details": {
          "function_name": "create_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2781-2793",
          "snippet": "static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n{\n\tstruct mnt_namespace *new_ns = alloc_mnt_ns(&init_user_ns);\n\tif (!IS_ERR(new_ns)) {\n\t\tstruct mount *mnt = real_mount(m);\n\t\tmnt->mnt_ns = new_ns;\n\t\tnew_ns->root = mnt;\n\t\tlist_add(&mnt->mnt_list, &new_ns->list);\n\t} else {\n\t\tmntput(m);\n\t}\n\treturn new_ns;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n{\n\tstruct mnt_namespace *new_ns = alloc_mnt_ns(&init_user_ns);\n\tif (!IS_ERR(new_ns)) {\n\t\tstruct mount *mnt = real_mount(m);\n\t\tmnt->mnt_ns = new_ns;\n\t\tnew_ns->root = mnt;\n\t\tlist_add(&mnt->mnt_list, &new_ns->list);\n\t} else {\n\t\tmntput(m);\n\t}\n\treturn new_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Can't create rootfs\""
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_filesystem",
          "args": [
            "type"
          ],
          "line": 3018
        },
        "resolved": true,
        "details": {
          "function_name": "put_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "41-44",
          "snippet": "void put_filesystem(struct file_system_type *fs)\n{\n\tmodule_put(fs->owner);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nvoid put_filesystem(struct file_system_type *fs)\n{\n\tmodule_put(fs->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_kern_mount",
          "args": [
            "type",
            "0",
            "\"rootfs\"",
            "NULL"
          ],
          "line": 3017
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_kern_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "921-952",
          "snippet": "struct vfsmount *\nvfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & MS_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tmnt_free_id(mnt);\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tunlock_mount_hash();\n\treturn &mnt->mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *\nvfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & MS_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tmnt_free_id(mnt);\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tunlock_mount_hash();\n\treturn &mnt->mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Can't find rootfs type\""
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs_type",
          "args": [
            "\"rootfs\""
          ],
          "line": 3014
        },
        "resolved": true,
        "details": {
          "function_name": "get_fs_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "271-286",
          "snippet": "struct file_system_type *get_fs_type(const char *name)\n{\n\tstruct file_system_type *fs;\n\tconst char *dot = strchr(name, '.');\n\tint len = dot ? dot - name : strlen(name);\n\n\tfs = __get_fs_type(name, len);\n\tif (!fs && (request_module(\"fs-%.*s\", len, name) == 0))\n\t\tfs = __get_fs_type(name, len);\n\n\tif (dot && fs && !(fs->fs_flags & FS_HAS_SUBTYPE)) {\n\t\tput_filesystem(fs);\n\t\tfs = NULL;\n\t}\n\treturn fs;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstruct file_system_type *get_fs_type(const char *name)\n{\n\tstruct file_system_type *fs;\n\tconst char *dot = strchr(name, '.');\n\tint len = dot ? dot - name : strlen(name);\n\n\tfs = __get_fs_type(name, len);\n\tif (!fs && (request_module(\"fs-%.*s\", len, name) == 0))\n\t\tfs = __get_fs_type(name, len);\n\n\tif (dot && fs && !(fs->fs_flags & FS_HAS_SUBTYPE)) {\n\t\tput_filesystem(fs);\n\t\tfs = NULL;\n\t}\n\treturn fs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void __init init_mount_tree(void)\n{\n\tstruct vfsmount *mnt;\n\tstruct mnt_namespace *ns;\n\tstruct path root;\n\tstruct file_system_type *type;\n\n\ttype = get_fs_type(\"rootfs\");\n\tif (!type)\n\t\tpanic(\"Can't find rootfs type\");\n\tmnt = vfs_kern_mount(type, 0, \"rootfs\", NULL);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\tpanic(\"Can't create rootfs\");\n\n\tns = create_mnt_ns(mnt);\n\tif (IS_ERR(ns))\n\t\tpanic(\"Can't allocate initial namespace\");\n\n\tinit_task.nsproxy->mnt_ns = ns;\n\tget_mnt_ns(ns);\n\n\troot.mnt = mnt;\n\troot.dentry = mnt->mnt_root;\n\tmnt->mnt_flags |= MNT_LOCKED;\n\n\tset_fs_pwd(current->fs, &root);\n\tset_fs_root(current->fs, &root);\n}"
  },
  {
    "function_name": "path_is_under",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2874-2881",
    "snippet": "int path_is_under(struct path *path1, struct path *path2)\n{\n\tint res;\n\tread_seqlock_excl(&mount_lock);\n\tres = is_path_reachable(real_mount(path1->mnt), path1->dentry, path2);\n\tread_sequnlock_excl(&mount_lock);\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__cacheline_aligned_in_smp DEFINE_SEQLOCK(mount_lock);",
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_sequnlock_excl",
          "args": [
            "&mount_lock"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_path_reachable",
          "args": [
            "real_mount(path1->mnt)",
            "path1->dentry",
            "path2"
          ],
          "line": 2878
        },
        "resolved": true,
        "details": {
          "function_name": "is_path_reachable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2864-2872",
          "snippet": "bool is_path_reachable(struct mount *mnt, struct dentry *dentry,\n\t\t\t const struct path *root)\n{\n\twhile (&mnt->mnt != root->mnt && mnt_has_parent(mnt)) {\n\t\tdentry = mnt->mnt_mountpoint;\n\t\tmnt = mnt->mnt_parent;\n\t}\n\treturn &mnt->mnt == root->mnt && is_subdir(dentry, root->dentry);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nbool is_path_reachable(struct mount *mnt, struct dentry *dentry,\n\t\t\t const struct path *root)\n{\n\twhile (&mnt->mnt != root->mnt && mnt_has_parent(mnt)) {\n\t\tdentry = mnt->mnt_mountpoint;\n\t\tmnt = mnt->mnt_parent;\n\t}\n\treturn &mnt->mnt == root->mnt && is_subdir(dentry, root->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "path1->mnt"
          ],
          "line": 2878
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqlock_excl",
          "args": [
            "&mount_lock"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(mount_lock);\nstatic void shrink_submounts(struct mount *mnt);\n\nint path_is_under(struct path *path1, struct path *path2)\n{\n\tint res;\n\tread_seqlock_excl(&mount_lock);\n\tres = is_path_reachable(real_mount(path1->mnt), path1->dentry, path2);\n\tread_sequnlock_excl(&mount_lock);\n\treturn res;\n}"
  },
  {
    "function_name": "is_path_reachable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2864-2872",
    "snippet": "bool is_path_reachable(struct mount *mnt, struct dentry *dentry,\n\t\t\t const struct path *root)\n{\n\twhile (&mnt->mnt != root->mnt && mnt_has_parent(mnt)) {\n\t\tdentry = mnt->mnt_mountpoint;\n\t\tmnt = mnt->mnt_parent;\n\t}\n\treturn &mnt->mnt == root->mnt && is_subdir(dentry, root->dentry);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_subdir",
          "args": [
            "dentry",
            "root->dentry"
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "is_subdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3279-3303",
          "snippet": "int is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)\n{\n\tint result;\n\tunsigned seq;\n\n\tif (new_dentry == old_dentry)\n\t\treturn 1;\n\n\tdo {\n\t\t/* for restarting inner loop in case of seq retry */\n\t\tseq = read_seqbegin(&rename_lock);\n\t\t/*\n\t\t * Need rcu_readlock to protect against the d_parent trashing\n\t\t * due to d_move\n\t\t */\n\t\trcu_read_lock();\n\t\tif (d_ancestor(old_dentry, new_dentry))\n\t\t\tresult = 1;\n\t\telse\n\t\t\tresult = 0;\n\t\trcu_read_unlock();\n\t} while (read_seqretry(&rename_lock, seq));\n\n\treturn result;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nint is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)\n{\n\tint result;\n\tunsigned seq;\n\n\tif (new_dentry == old_dentry)\n\t\treturn 1;\n\n\tdo {\n\t\t/* for restarting inner loop in case of seq retry */\n\t\tseq = read_seqbegin(&rename_lock);\n\t\t/*\n\t\t * Need rcu_readlock to protect against the d_parent trashing\n\t\t * due to d_move\n\t\t */\n\t\trcu_read_lock();\n\t\tif (d_ancestor(old_dentry, new_dentry))\n\t\t\tresult = 1;\n\t\telse\n\t\t\tresult = 0;\n\t\trcu_read_unlock();\n\t} while (read_seqretry(&rename_lock, seq));\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_has_parent",
          "args": [
            "mnt"
          ],
          "line": 2867
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_has_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "77-80",
          "snippet": "static inline int mnt_has_parent(struct mount *mnt)\n{\n\treturn mnt != mnt->mnt_parent;\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nstatic inline int mnt_has_parent(struct mount *mnt)\n{\n\treturn mnt != mnt->mnt_parent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nbool is_path_reachable(struct mount *mnt, struct dentry *dentry,\n\t\t\t const struct path *root)\n{\n\twhile (&mnt->mnt != root->mnt && mnt_has_parent(mnt)) {\n\t\tdentry = mnt->mnt_mountpoint;\n\t\tmnt = mnt->mnt_parent;\n\t}\n\treturn &mnt->mnt == root->mnt && is_subdir(dentry, root->dentry);\n}"
  },
  {
    "function_name": "mount_subtree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2795-2822",
    "snippet": "struct dentry *mount_subtree(struct vfsmount *mnt, const char *name)\n{\n\tstruct mnt_namespace *ns;\n\tstruct super_block *s;\n\tstruct path path;\n\tint err;\n\n\tns = create_mnt_ns(mnt);\n\tif (IS_ERR(ns))\n\t\treturn ERR_CAST(ns);\n\n\terr = vfs_path_lookup(mnt->mnt_root, mnt,\n\t\t\tname, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &path);\n\n\tput_mnt_ns(ns);\n\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\t/* trade a vfsmount reference for active sb one */\n\ts = path.mnt->mnt_sb;\n\tatomic_inc(&s->s_active);\n\tmntput(path.mnt);\n\t/* lock the sucker */\n\tdown_write(&s->s_umount);\n\t/* ... and return the root of (sub)tree on it */\n\treturn path.dentry;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&s->s_umount"
          ],
          "line": 2819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "path.mnt"
          ],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "mntput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1118-1127",
          "snippet": "void mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&s->s_active"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_mnt_ns",
          "args": [
            "ns"
          ],
          "line": 2809
        },
        "resolved": true,
        "details": {
          "function_name": "put_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "3077-3083",
          "snippet": "void put_mnt_ns(struct mnt_namespace *ns)\n{\n\tif (!atomic_dec_and_test(&ns->count))\n\t\treturn;\n\tdrop_collected_mounts(&ns->root->mnt);\n\tfree_mnt_ns(ns);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid put_mnt_ns(struct mnt_namespace *ns)\n{\n\tif (!atomic_dec_and_test(&ns->count))\n\t\treturn;\n\tdrop_collected_mounts(&ns->root->mnt);\n\tfree_mnt_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_path_lookup",
          "args": [
            "mnt->mnt_root",
            "mnt",
            "name",
            "LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT",
            "&path"
          ],
          "line": 2806
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_path_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2107-2121",
          "snippet": "int vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt,\n\t\t    const char *name, unsigned int flags,\n\t\t    struct path *path)\n{\n\tstruct nameidata nd;\n\tint err;\n\tnd.root.dentry = dentry;\n\tnd.root.mnt = mnt;\n\tBUG_ON(flags & LOOKUP_PARENT);\n\t/* the first argument of do_path_lookup() is ignored with LOOKUP_ROOT */\n\terr = do_path_lookup(AT_FDCWD, name, flags | LOOKUP_ROOT, &nd);\n\tif (!err)\n\t\t*path = nd.path;\n\treturn err;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nint vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt,\n\t\t    const char *name, unsigned int flags,\n\t\t    struct path *path)\n{\n\tstruct nameidata nd;\n\tint err;\n\tnd.root.dentry = dentry;\n\tnd.root.mnt = mnt;\n\tBUG_ON(flags & LOOKUP_PARENT);\n\t/* the first argument of do_path_lookup() is ignored with LOOKUP_ROOT */\n\terr = do_path_lookup(AT_FDCWD, name, flags | LOOKUP_ROOT, &nd);\n\tif (!err)\n\t\t*path = nd.path;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "ns"
          ],
          "line": 2804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ns"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_mnt_ns",
          "args": [
            "mnt"
          ],
          "line": 2802
        },
        "resolved": true,
        "details": {
          "function_name": "create_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2781-2793",
          "snippet": "static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n{\n\tstruct mnt_namespace *new_ns = alloc_mnt_ns(&init_user_ns);\n\tif (!IS_ERR(new_ns)) {\n\t\tstruct mount *mnt = real_mount(m);\n\t\tmnt->mnt_ns = new_ns;\n\t\tnew_ns->root = mnt;\n\t\tlist_add(&mnt->mnt_list, &new_ns->list);\n\t} else {\n\t\tmntput(m);\n\t}\n\treturn new_ns;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n{\n\tstruct mnt_namespace *new_ns = alloc_mnt_ns(&init_user_ns);\n\tif (!IS_ERR(new_ns)) {\n\t\tstruct mount *mnt = real_mount(m);\n\t\tmnt->mnt_ns = new_ns;\n\t\tnew_ns->root = mnt;\n\t\tlist_add(&mnt->mnt_list, &new_ns->list);\n\t} else {\n\t\tmntput(m);\n\t}\n\treturn new_ns;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct dentry *mount_subtree(struct vfsmount *mnt, const char *name)\n{\n\tstruct mnt_namespace *ns;\n\tstruct super_block *s;\n\tstruct path path;\n\tint err;\n\n\tns = create_mnt_ns(mnt);\n\tif (IS_ERR(ns))\n\t\treturn ERR_CAST(ns);\n\n\terr = vfs_path_lookup(mnt->mnt_root, mnt,\n\t\t\tname, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &path);\n\n\tput_mnt_ns(ns);\n\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\t/* trade a vfsmount reference for active sb one */\n\ts = path.mnt->mnt_sb;\n\tatomic_inc(&s->s_active);\n\tmntput(path.mnt);\n\t/* lock the sucker */\n\tdown_write(&s->s_umount);\n\t/* ... and return the root of (sub)tree on it */\n\treturn path.dentry;\n}"
  },
  {
    "function_name": "create_mnt_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2781-2793",
    "snippet": "static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n{\n\tstruct mnt_namespace *new_ns = alloc_mnt_ns(&init_user_ns);\n\tif (!IS_ERR(new_ns)) {\n\t\tstruct mount *mnt = real_mount(m);\n\t\tmnt->mnt_ns = new_ns;\n\t\tnew_ns->root = mnt;\n\t\tlist_add(&mnt->mnt_list, &new_ns->list);\n\t} else {\n\t\tmntput(m);\n\t}\n\treturn new_ns;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "m"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "mntput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1118-1127",
          "snippet": "void mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&mnt->mnt_list",
            "&new_ns->list"
          ],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "m"
          ],
          "line": 2785
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_ns"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_mnt_ns",
          "args": [
            "&init_user_ns"
          ],
          "line": 2783
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2680-2702",
          "snippet": "static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n{\n\tstruct mnt_namespace *new_ns;\n\tint ret;\n\n\tnew_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL);\n\tif (!new_ns)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\treturn ERR_PTR(ret);\n\t}\n\tnew_ns->ns.ops = &mntns_operations;\n\tnew_ns->seq = atomic64_add_return(1, &mnt_ns_seq);\n\tatomic_set(&new_ns->count, 1);\n\tnew_ns->root = NULL;\n\tINIT_LIST_HEAD(&new_ns->list);\n\tinit_waitqueue_head(&new_ns->poll);\n\tnew_ns->event = 0;\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\treturn new_ns;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 event;",
            "static atomic64_t mnt_ns_seq = ATOMIC64_INIT(1);",
            "const struct proc_ns_operations mntns_operations = {\n\t.name\t\t= \"mnt\",\n\t.type\t\t= CLONE_NEWNS,\n\t.get\t\t= mntns_get,\n\t.put\t\t= mntns_put,\n\t.install\t= mntns_install,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic u64 event;\nstatic atomic64_t mnt_ns_seq = ATOMIC64_INIT(1);\nconst struct proc_ns_operations mntns_operations = {\n\t.name\t\t= \"mnt\",\n\t.type\t\t= CLONE_NEWNS,\n\t.get\t\t= mntns_get,\n\t.put\t\t= mntns_put,\n\t.install\t= mntns_install,\n};\n\nstatic struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n{\n\tstruct mnt_namespace *new_ns;\n\tint ret;\n\n\tnew_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL);\n\tif (!new_ns)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\treturn ERR_PTR(ret);\n\t}\n\tnew_ns->ns.ops = &mntns_operations;\n\tnew_ns->seq = atomic64_add_return(1, &mnt_ns_seq);\n\tatomic_set(&new_ns->count, 1);\n\tnew_ns->root = NULL;\n\tINIT_LIST_HEAD(&new_ns->list);\n\tinit_waitqueue_head(&new_ns->poll);\n\tnew_ns->event = 0;\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\treturn new_ns;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n{\n\tstruct mnt_namespace *new_ns = alloc_mnt_ns(&init_user_ns);\n\tif (!IS_ERR(new_ns)) {\n\t\tstruct mount *mnt = real_mount(m);\n\t\tmnt->mnt_ns = new_ns;\n\t\tnew_ns->root = mnt;\n\t\tlist_add(&mnt->mnt_list, &new_ns->list);\n\t} else {\n\t\tmntput(m);\n\t}\n\treturn new_ns;\n}"
  },
  {
    "function_name": "copy_mnt_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2704-2775",
    "snippet": "struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,\n\t\tstruct user_namespace *user_ns, struct fs_struct *new_fs)\n{\n\tstruct mnt_namespace *new_ns;\n\tstruct vfsmount *rootmnt = NULL, *pwdmnt = NULL;\n\tstruct mount *p, *q;\n\tstruct mount *old;\n\tstruct mount *new;\n\tint copy_flags;\n\n\tBUG_ON(!ns);\n\n\tif (likely(!(flags & CLONE_NEWNS))) {\n\t\tget_mnt_ns(ns);\n\t\treturn ns;\n\t}\n\n\told = ns->root;\n\n\tnew_ns = alloc_mnt_ns(user_ns);\n\tif (IS_ERR(new_ns))\n\t\treturn new_ns;\n\n\tnamespace_lock();\n\t/* First pass: copy the tree topology */\n\tcopy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE;\n\tif (user_ns != ns->user_ns)\n\t\tcopy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;\n\tnew = copy_tree(old, old->mnt.mnt_root, copy_flags);\n\tif (IS_ERR(new)) {\n\t\tnamespace_unlock();\n\t\tfree_mnt_ns(new_ns);\n\t\treturn ERR_CAST(new);\n\t}\n\tnew_ns->root = new;\n\tlist_add_tail(&new_ns->list, &new->mnt_list);\n\n\t/*\n\t * Second pass: switch the tsk->fs->* elements and mark new vfsmounts\n\t * as belonging to new namespace.  We have already acquired a private\n\t * fs_struct, so tsk->fs->lock is not needed.\n\t */\n\tp = old;\n\tq = new;\n\twhile (p) {\n\t\tq->mnt_ns = new_ns;\n\t\tif (new_fs) {\n\t\t\tif (&p->mnt == new_fs->root.mnt) {\n\t\t\t\tnew_fs->root.mnt = mntget(&q->mnt);\n\t\t\t\trootmnt = &p->mnt;\n\t\t\t}\n\t\t\tif (&p->mnt == new_fs->pwd.mnt) {\n\t\t\t\tnew_fs->pwd.mnt = mntget(&q->mnt);\n\t\t\t\tpwdmnt = &p->mnt;\n\t\t\t}\n\t\t}\n\t\tp = next_mnt(p, old);\n\t\tq = next_mnt(q, new);\n\t\tif (!q)\n\t\t\tbreak;\n\t\twhile (p->mnt.mnt_root != q->mnt.mnt_root)\n\t\t\tp = next_mnt(p, old);\n\t}\n\tnamespace_unlock();\n\n\tif (rootmnt)\n\t\tmntput(rootmnt);\n\tif (pwdmnt)\n\t\tmntput(pwdmnt);\n\n\treturn new_ns;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "pwdmnt"
          ],
          "line": 2772
        },
        "resolved": true,
        "details": {
          "function_name": "mntput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1118-1127",
          "snippet": "void mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "namespace_unlock",
          "args": [],
          "line": 2767
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1320-1334",
          "snippet": "static void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);",
            "static HLIST_HEAD(unmounted);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic HLIST_HEAD(unmounted);\n\nstatic void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_mnt",
          "args": [
            "p",
            "old"
          ],
          "line": 2765
        },
        "resolved": true,
        "details": {
          "function_name": "next_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "895-909",
          "snippet": "static struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mntget",
          "args": [
            "&q->mnt"
          ],
          "line": 2756
        },
        "resolved": true,
        "details": {
          "function_name": "mntget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1130-1135",
          "snippet": "struct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new_ns->list",
            "&new->mnt_list"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "new"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_mnt_ns",
          "args": [
            "new_ns"
          ],
          "line": 2735
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2664-2669",
          "snippet": "static void free_mnt_ns(struct mnt_namespace *ns)\n{\n\tns_free_inum(&ns->ns);\n\tput_user_ns(ns->user_ns);\n\tkfree(ns);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void free_mnt_ns(struct mnt_namespace *ns)\n{\n\tns_free_inum(&ns->ns);\n\tput_user_ns(ns->user_ns);\n\tkfree(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_tree",
          "args": [
            "old",
            "old->mnt.mnt_root",
            "copy_flags"
          ],
          "line": 2732
        },
        "resolved": true,
        "details": {
          "function_name": "copy_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1610-1675",
          "snippet": "struct mount *copy_tree(struct mount *mnt, struct dentry *dentry,\n\t\t\t\t\tint flag)\n{\n\tstruct mount *res, *p, *q, *r, *parent;\n\n\tif (!(flag & CL_COPY_UNBINDABLE) && IS_MNT_UNBINDABLE(mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!(flag & CL_COPY_MNT_NS_FILE) && is_mnt_ns_file(dentry))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tres = q = clone_mnt(mnt, dentry, flag);\n\tif (IS_ERR(q))\n\t\treturn q;\n\n\tq->mnt_mountpoint = mnt->mnt_mountpoint;\n\n\tp = mnt;\n\tlist_for_each_entry(r, &mnt->mnt_mounts, mnt_child) {\n\t\tstruct mount *s;\n\t\tif (!is_subdir(r->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tfor (s = r; s; s = next_mnt(s, r)) {\n\t\t\tstruct mount *t = NULL;\n\t\t\tif (!(flag & CL_COPY_UNBINDABLE) &&\n\t\t\t    IS_MNT_UNBINDABLE(s)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(flag & CL_COPY_MNT_NS_FILE) &&\n\t\t\t    is_mnt_ns_file(s->mnt.mnt_root)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (p != s->mnt_parent) {\n\t\t\t\tp = p->mnt_parent;\n\t\t\t\tq = q->mnt_parent;\n\t\t\t}\n\t\t\tp = s;\n\t\t\tparent = q;\n\t\t\tq = clone_mnt(p, p->mnt.mnt_root, flag);\n\t\t\tif (IS_ERR(q))\n\t\t\t\tgoto out;\n\t\t\tlock_mount_hash();\n\t\t\tlist_add_tail(&q->mnt_list, &res->mnt_list);\n\t\t\tmnt_set_mountpoint(parent, p->mnt_mp, q);\n\t\t\tif (!list_empty(&parent->mnt_mounts)) {\n\t\t\t\tt = list_last_entry(&parent->mnt_mounts,\n\t\t\t\t\tstruct mount, mnt_child);\n\t\t\t\tif (t->mnt_mp != p->mnt_mp)\n\t\t\t\t\tt = NULL;\n\t\t\t}\n\t\t\tattach_shadowed(q, parent, t);\n\t\t\tunlock_mount_hash();\n\t\t}\n\t}\n\treturn res;\nout:\n\tif (res) {\n\t\tlock_mount_hash();\n\t\tumount_tree(res, UMOUNT_SYNC);\n\t\tunlock_mount_hash();\n\t}\n\treturn q;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct mount *copy_tree(struct mount *mnt, struct dentry *dentry,\n\t\t\t\t\tint flag)\n{\n\tstruct mount *res, *p, *q, *r, *parent;\n\n\tif (!(flag & CL_COPY_UNBINDABLE) && IS_MNT_UNBINDABLE(mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!(flag & CL_COPY_MNT_NS_FILE) && is_mnt_ns_file(dentry))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tres = q = clone_mnt(mnt, dentry, flag);\n\tif (IS_ERR(q))\n\t\treturn q;\n\n\tq->mnt_mountpoint = mnt->mnt_mountpoint;\n\n\tp = mnt;\n\tlist_for_each_entry(r, &mnt->mnt_mounts, mnt_child) {\n\t\tstruct mount *s;\n\t\tif (!is_subdir(r->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tfor (s = r; s; s = next_mnt(s, r)) {\n\t\t\tstruct mount *t = NULL;\n\t\t\tif (!(flag & CL_COPY_UNBINDABLE) &&\n\t\t\t    IS_MNT_UNBINDABLE(s)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(flag & CL_COPY_MNT_NS_FILE) &&\n\t\t\t    is_mnt_ns_file(s->mnt.mnt_root)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (p != s->mnt_parent) {\n\t\t\t\tp = p->mnt_parent;\n\t\t\t\tq = q->mnt_parent;\n\t\t\t}\n\t\t\tp = s;\n\t\t\tparent = q;\n\t\t\tq = clone_mnt(p, p->mnt.mnt_root, flag);\n\t\t\tif (IS_ERR(q))\n\t\t\t\tgoto out;\n\t\t\tlock_mount_hash();\n\t\t\tlist_add_tail(&q->mnt_list, &res->mnt_list);\n\t\t\tmnt_set_mountpoint(parent, p->mnt_mp, q);\n\t\t\tif (!list_empty(&parent->mnt_mounts)) {\n\t\t\t\tt = list_last_entry(&parent->mnt_mounts,\n\t\t\t\t\tstruct mount, mnt_child);\n\t\t\t\tif (t->mnt_mp != p->mnt_mp)\n\t\t\t\t\tt = NULL;\n\t\t\t}\n\t\t\tattach_shadowed(q, parent, t);\n\t\t\tunlock_mount_hash();\n\t\t}\n\t}\n\treturn res;\nout:\n\tif (res) {\n\t\tlock_mount_hash();\n\t\tumount_tree(res, UMOUNT_SYNC);\n\t\tunlock_mount_hash();\n\t}\n\treturn q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "namespace_lock",
          "args": [],
          "line": 2727
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1336-1339",
          "snippet": "static inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\n\nstatic inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_ns"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_mnt_ns",
          "args": [
            "user_ns"
          ],
          "line": 2723
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2680-2702",
          "snippet": "static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n{\n\tstruct mnt_namespace *new_ns;\n\tint ret;\n\n\tnew_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL);\n\tif (!new_ns)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\treturn ERR_PTR(ret);\n\t}\n\tnew_ns->ns.ops = &mntns_operations;\n\tnew_ns->seq = atomic64_add_return(1, &mnt_ns_seq);\n\tatomic_set(&new_ns->count, 1);\n\tnew_ns->root = NULL;\n\tINIT_LIST_HEAD(&new_ns->list);\n\tinit_waitqueue_head(&new_ns->poll);\n\tnew_ns->event = 0;\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\treturn new_ns;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 event;",
            "static atomic64_t mnt_ns_seq = ATOMIC64_INIT(1);",
            "const struct proc_ns_operations mntns_operations = {\n\t.name\t\t= \"mnt\",\n\t.type\t\t= CLONE_NEWNS,\n\t.get\t\t= mntns_get,\n\t.put\t\t= mntns_put,\n\t.install\t= mntns_install,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic u64 event;\nstatic atomic64_t mnt_ns_seq = ATOMIC64_INIT(1);\nconst struct proc_ns_operations mntns_operations = {\n\t.name\t\t= \"mnt\",\n\t.type\t\t= CLONE_NEWNS,\n\t.get\t\t= mntns_get,\n\t.put\t\t= mntns_put,\n\t.install\t= mntns_install,\n};\n\nstatic struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n{\n\tstruct mnt_namespace *new_ns;\n\tint ret;\n\n\tnew_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL);\n\tif (!new_ns)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\treturn ERR_PTR(ret);\n\t}\n\tnew_ns->ns.ops = &mntns_operations;\n\tnew_ns->seq = atomic64_add_return(1, &mnt_ns_seq);\n\tatomic_set(&new_ns->count, 1);\n\tnew_ns->root = NULL;\n\tINIT_LIST_HEAD(&new_ns->list);\n\tinit_waitqueue_head(&new_ns->poll);\n\tnew_ns->event = 0;\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\treturn new_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mnt_ns",
          "args": [
            "ns"
          ],
          "line": 2717
        },
        "resolved": true,
        "details": {
          "function_name": "get_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "102-105",
          "snippet": "static inline void get_mnt_ns(struct mnt_namespace *ns)\n{\n\tatomic_inc(&ns->count);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nstatic inline void get_mnt_ns(struct mnt_namespace *ns)\n{\n\tatomic_inc(&ns->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(flags & CLONE_NEWNS)"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ns"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,\n\t\tstruct user_namespace *user_ns, struct fs_struct *new_fs)\n{\n\tstruct mnt_namespace *new_ns;\n\tstruct vfsmount *rootmnt = NULL, *pwdmnt = NULL;\n\tstruct mount *p, *q;\n\tstruct mount *old;\n\tstruct mount *new;\n\tint copy_flags;\n\n\tBUG_ON(!ns);\n\n\tif (likely(!(flags & CLONE_NEWNS))) {\n\t\tget_mnt_ns(ns);\n\t\treturn ns;\n\t}\n\n\told = ns->root;\n\n\tnew_ns = alloc_mnt_ns(user_ns);\n\tif (IS_ERR(new_ns))\n\t\treturn new_ns;\n\n\tnamespace_lock();\n\t/* First pass: copy the tree topology */\n\tcopy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE;\n\tif (user_ns != ns->user_ns)\n\t\tcopy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;\n\tnew = copy_tree(old, old->mnt.mnt_root, copy_flags);\n\tif (IS_ERR(new)) {\n\t\tnamespace_unlock();\n\t\tfree_mnt_ns(new_ns);\n\t\treturn ERR_CAST(new);\n\t}\n\tnew_ns->root = new;\n\tlist_add_tail(&new_ns->list, &new->mnt_list);\n\n\t/*\n\t * Second pass: switch the tsk->fs->* elements and mark new vfsmounts\n\t * as belonging to new namespace.  We have already acquired a private\n\t * fs_struct, so tsk->fs->lock is not needed.\n\t */\n\tp = old;\n\tq = new;\n\twhile (p) {\n\t\tq->mnt_ns = new_ns;\n\t\tif (new_fs) {\n\t\t\tif (&p->mnt == new_fs->root.mnt) {\n\t\t\t\tnew_fs->root.mnt = mntget(&q->mnt);\n\t\t\t\trootmnt = &p->mnt;\n\t\t\t}\n\t\t\tif (&p->mnt == new_fs->pwd.mnt) {\n\t\t\t\tnew_fs->pwd.mnt = mntget(&q->mnt);\n\t\t\t\tpwdmnt = &p->mnt;\n\t\t\t}\n\t\t}\n\t\tp = next_mnt(p, old);\n\t\tq = next_mnt(q, new);\n\t\tif (!q)\n\t\t\tbreak;\n\t\twhile (p->mnt.mnt_root != q->mnt.mnt_root)\n\t\t\tp = next_mnt(p, old);\n\t}\n\tnamespace_unlock();\n\n\tif (rootmnt)\n\t\tmntput(rootmnt);\n\tif (pwdmnt)\n\t\tmntput(pwdmnt);\n\n\treturn new_ns;\n}"
  },
  {
    "function_name": "alloc_mnt_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2680-2702",
    "snippet": "static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n{\n\tstruct mnt_namespace *new_ns;\n\tint ret;\n\n\tnew_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL);\n\tif (!new_ns)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\treturn ERR_PTR(ret);\n\t}\n\tnew_ns->ns.ops = &mntns_operations;\n\tnew_ns->seq = atomic64_add_return(1, &mnt_ns_seq);\n\tatomic_set(&new_ns->count, 1);\n\tnew_ns->root = NULL;\n\tINIT_LIST_HEAD(&new_ns->list);\n\tinit_waitqueue_head(&new_ns->poll);\n\tnew_ns->event = 0;\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\treturn new_ns;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 event;",
      "static atomic64_t mnt_ns_seq = ATOMIC64_INIT(1);",
      "const struct proc_ns_operations mntns_operations = {\n\t.name\t\t= \"mnt\",\n\t.type\t\t= CLONE_NEWNS,\n\t.get\t\t= mntns_get,\n\t.put\t\t= mntns_put,\n\t.install\t= mntns_install,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "user_ns"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&new_ns->poll"
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new_ns->list"
          ],
          "line": 2697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&new_ns->count",
            "1"
          ],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_add_return",
          "args": [
            "1",
            "&mnt_ns_seq"
          ],
          "line": 2694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_ns"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_alloc_inum",
          "args": [
            "&new_ns->ns"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct mnt_namespace)",
            "GFP_KERNEL"
          ],
          "line": 2685
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic u64 event;\nstatic atomic64_t mnt_ns_seq = ATOMIC64_INIT(1);\nconst struct proc_ns_operations mntns_operations = {\n\t.name\t\t= \"mnt\",\n\t.type\t\t= CLONE_NEWNS,\n\t.get\t\t= mntns_get,\n\t.put\t\t= mntns_put,\n\t.install\t= mntns_install,\n};\n\nstatic struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n{\n\tstruct mnt_namespace *new_ns;\n\tint ret;\n\n\tnew_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL);\n\tif (!new_ns)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\treturn ERR_PTR(ret);\n\t}\n\tnew_ns->ns.ops = &mntns_operations;\n\tnew_ns->seq = atomic64_add_return(1, &mnt_ns_seq);\n\tatomic_set(&new_ns->count, 1);\n\tnew_ns->root = NULL;\n\tINIT_LIST_HEAD(&new_ns->list);\n\tinit_waitqueue_head(&new_ns->poll);\n\tnew_ns->event = 0;\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\treturn new_ns;\n}"
  },
  {
    "function_name": "free_mnt_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2664-2669",
    "snippet": "static void free_mnt_ns(struct mnt_namespace *ns)\n{\n\tns_free_inum(&ns->ns);\n\tput_user_ns(ns->user_ns);\n\tkfree(ns);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ns"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user_ns",
          "args": [
            "ns->user_ns"
          ],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_free_inum",
          "args": [
            "&ns->ns"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void free_mnt_ns(struct mnt_namespace *ns)\n{\n\tns_free_inum(&ns->ns);\n\tput_user_ns(ns->user_ns);\n\tkfree(ns);\n}"
  },
  {
    "function_name": "do_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2588-2662",
    "snippet": "long do_mount(const char *dev_name, const char __user *dir_name,\n\t\tconst char *type_page, unsigned long flags, void *data_page)\n{\n\tstruct path path;\n\tint retval = 0;\n\tint mnt_flags = 0;\n\n\t/* Discard magic */\n\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)\n\t\tflags &= ~MS_MGC_MSK;\n\n\t/* Basic sanity checks */\n\tif (data_page)\n\t\t((char *)data_page)[PAGE_SIZE - 1] = 0;\n\n\t/* ... and get the mountpoint */\n\tretval = user_path(dir_name, &path);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = security_sb_mount(dev_name, &path,\n\t\t\t\t   type_page, flags, data_page);\n\tif (!retval && !may_mount())\n\t\tretval = -EPERM;\n\tif (retval)\n\t\tgoto dput_out;\n\n\t/* Default to relatime unless overriden */\n\tif (!(flags & MS_NOATIME))\n\t\tmnt_flags |= MNT_RELATIME;\n\n\t/* Separate the per-mountpoint flags */\n\tif (flags & MS_NOSUID)\n\t\tmnt_flags |= MNT_NOSUID;\n\tif (flags & MS_NODEV)\n\t\tmnt_flags |= MNT_NODEV;\n\tif (flags & MS_NOEXEC)\n\t\tmnt_flags |= MNT_NOEXEC;\n\tif (flags & MS_NOATIME)\n\t\tmnt_flags |= MNT_NOATIME;\n\tif (flags & MS_NODIRATIME)\n\t\tmnt_flags |= MNT_NODIRATIME;\n\tif (flags & MS_STRICTATIME)\n\t\tmnt_flags &= ~(MNT_RELATIME | MNT_NOATIME);\n\tif (flags & MS_RDONLY)\n\t\tmnt_flags |= MNT_READONLY;\n\n\t/* The default atime for remount is preservation */\n\tif ((flags & MS_REMOUNT) &&\n\t    ((flags & (MS_NOATIME | MS_NODIRATIME | MS_RELATIME |\n\t\t       MS_STRICTATIME)) == 0)) {\n\t\tmnt_flags &= ~MNT_ATIME_MASK;\n\t\tmnt_flags |= path.mnt->mnt_flags & MNT_ATIME_MASK;\n\t}\n\n\tflags &= ~(MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_ACTIVE | MS_BORN |\n\t\t   MS_NOATIME | MS_NODIRATIME | MS_RELATIME| MS_KERNMOUNT |\n\t\t   MS_STRICTATIME);\n\n\tif (flags & MS_REMOUNT)\n\t\tretval = do_remount(&path, flags & ~MS_REMOUNT, mnt_flags,\n\t\t\t\t    data_page);\n\telse if (flags & MS_BIND)\n\t\tretval = do_loopback(&path, dev_name, flags & MS_REC);\n\telse if (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))\n\t\tretval = do_change_type(&path, flags);\n\telse if (flags & MS_MOVE)\n\t\tretval = do_move_mount(&path, dev_name);\n\telse\n\t\tretval = do_new_mount(&path, type_page, flags, mnt_flags,\n\t\t\t\t      dev_name, data_page);\ndput_out:\n\tpath_put(&path);\n\treturn retval;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 2660
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_new_mount",
          "args": [
            "&path",
            "type_page",
            "flags",
            "mnt_flags",
            "dev_name",
            "data_page"
          ],
          "line": 2657
        },
        "resolved": true,
        "details": {
          "function_name": "do_new_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2312-2354",
          "snippet": "static int do_new_mount(struct path *path, const char *fstype, int flags,\n\t\t\tint mnt_flags, const char *name, void *data)\n{\n\tstruct file_system_type *type;\n\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n\tstruct vfsmount *mnt;\n\tint err;\n\n\tif (!fstype)\n\t\treturn -EINVAL;\n\n\ttype = get_fs_type(fstype);\n\tif (!type)\n\t\treturn -ENODEV;\n\n\tif (user_ns != &init_user_ns) {\n\t\tif (!(type->fs_flags & FS_USERNS_MOUNT)) {\n\t\t\tput_filesystem(type);\n\t\t\treturn -EPERM;\n\t\t}\n\t\t/* Only in special cases allow devices from mounts\n\t\t * created outside the initial user namespace.\n\t\t */\n\t\tif (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tflags |= MS_NODEV;\n\t\t\tmnt_flags |= MNT_NODEV | MNT_LOCK_NODEV;\n\t\t}\n\t}\n\n\tmnt = vfs_kern_mount(type, flags, name, data);\n\tif (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&\n\t    !mnt->mnt_sb->s_subtype)\n\t\tmnt = fs_set_subtype(mnt, fstype);\n\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\n\terr = do_add_mount(real_mount(mnt), path, mnt_flags);\n\tif (err)\n\t\tmntput(mnt);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int do_new_mount(struct path *path, const char *fstype, int flags,\n\t\t\tint mnt_flags, const char *name, void *data)\n{\n\tstruct file_system_type *type;\n\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n\tstruct vfsmount *mnt;\n\tint err;\n\n\tif (!fstype)\n\t\treturn -EINVAL;\n\n\ttype = get_fs_type(fstype);\n\tif (!type)\n\t\treturn -ENODEV;\n\n\tif (user_ns != &init_user_ns) {\n\t\tif (!(type->fs_flags & FS_USERNS_MOUNT)) {\n\t\t\tput_filesystem(type);\n\t\t\treturn -EPERM;\n\t\t}\n\t\t/* Only in special cases allow devices from mounts\n\t\t * created outside the initial user namespace.\n\t\t */\n\t\tif (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tflags |= MS_NODEV;\n\t\t\tmnt_flags |= MNT_NODEV | MNT_LOCK_NODEV;\n\t\t}\n\t}\n\n\tmnt = vfs_kern_mount(type, flags, name, data);\n\tif (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&\n\t    !mnt->mnt_sb->s_subtype)\n\t\tmnt = fs_set_subtype(mnt, fstype);\n\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\n\terr = do_add_mount(real_mount(mnt), path, mnt_flags);\n\tif (err)\n\t\tmntput(mnt);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_move_mount",
          "args": [
            "&path",
            "dev_name"
          ],
          "line": 2655
        },
        "resolved": true,
        "details": {
          "function_name": "do_move_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2171-2239",
          "snippet": "static int do_move_mount(struct path *path, const char *old_name)\n{\n\tstruct path old_path, parent_path;\n\tstruct mount *p;\n\tstruct mount *old;\n\tstruct mountpoint *mp;\n\tint err;\n\tif (!old_name || !*old_name)\n\t\treturn -EINVAL;\n\terr = kern_path(old_name, LOOKUP_FOLLOW, &old_path);\n\tif (err)\n\t\treturn err;\n\n\tmp = lock_mount(path);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto out;\n\n\told = real_mount(old_path.mnt);\n\tp = real_mount(path->mnt);\n\n\terr = -EINVAL;\n\tif (!check_mnt(p) || !check_mnt(old))\n\t\tgoto out1;\n\n\tif (old->mnt.mnt_flags & MNT_LOCKED)\n\t\tgoto out1;\n\n\terr = -EINVAL;\n\tif (old_path.dentry != old_path.mnt->mnt_root)\n\t\tgoto out1;\n\n\tif (!mnt_has_parent(old))\n\t\tgoto out1;\n\n\tif (d_is_dir(path->dentry) !=\n\t      d_is_dir(old_path.dentry))\n\t\tgoto out1;\n\t/*\n\t * Don't move a mount residing in a shared parent.\n\t */\n\tif (IS_MNT_SHARED(old->mnt_parent))\n\t\tgoto out1;\n\t/*\n\t * Don't move a mount tree containing unbindable mounts to a destination\n\t * mount which is shared.\n\t */\n\tif (IS_MNT_SHARED(p) && tree_contains_unbindable(old))\n\t\tgoto out1;\n\terr = -ELOOP;\n\tfor (; mnt_has_parent(p); p = p->mnt_parent)\n\t\tif (p == old)\n\t\t\tgoto out1;\n\n\terr = attach_recursive_mnt(old, real_mount(path->mnt), mp, &parent_path);\n\tif (err)\n\t\tgoto out1;\n\n\t/* if the mount is moved, it should no longer be expire\n\t * automatically */\n\tlist_del_init(&old->mnt_expire);\nout1:\n\tunlock_mount(mp);\nout:\n\tif (!err)\n\t\tpath_put(&parent_path);\n\tpath_put(&old_path);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int do_move_mount(struct path *path, const char *old_name)\n{\n\tstruct path old_path, parent_path;\n\tstruct mount *p;\n\tstruct mount *old;\n\tstruct mountpoint *mp;\n\tint err;\n\tif (!old_name || !*old_name)\n\t\treturn -EINVAL;\n\terr = kern_path(old_name, LOOKUP_FOLLOW, &old_path);\n\tif (err)\n\t\treturn err;\n\n\tmp = lock_mount(path);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto out;\n\n\told = real_mount(old_path.mnt);\n\tp = real_mount(path->mnt);\n\n\terr = -EINVAL;\n\tif (!check_mnt(p) || !check_mnt(old))\n\t\tgoto out1;\n\n\tif (old->mnt.mnt_flags & MNT_LOCKED)\n\t\tgoto out1;\n\n\terr = -EINVAL;\n\tif (old_path.dentry != old_path.mnt->mnt_root)\n\t\tgoto out1;\n\n\tif (!mnt_has_parent(old))\n\t\tgoto out1;\n\n\tif (d_is_dir(path->dentry) !=\n\t      d_is_dir(old_path.dentry))\n\t\tgoto out1;\n\t/*\n\t * Don't move a mount residing in a shared parent.\n\t */\n\tif (IS_MNT_SHARED(old->mnt_parent))\n\t\tgoto out1;\n\t/*\n\t * Don't move a mount tree containing unbindable mounts to a destination\n\t * mount which is shared.\n\t */\n\tif (IS_MNT_SHARED(p) && tree_contains_unbindable(old))\n\t\tgoto out1;\n\terr = -ELOOP;\n\tfor (; mnt_has_parent(p); p = p->mnt_parent)\n\t\tif (p == old)\n\t\t\tgoto out1;\n\n\terr = attach_recursive_mnt(old, real_mount(path->mnt), mp, &parent_path);\n\tif (err)\n\t\tgoto out1;\n\n\t/* if the mount is moved, it should no longer be expire\n\t * automatically */\n\tlist_del_init(&old->mnt_expire);\nout1:\n\tunlock_mount(mp);\nout:\n\tif (!err)\n\t\tpath_put(&parent_path);\n\tpath_put(&old_path);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_change_type",
          "args": [
            "&path",
            "flags"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "do_change_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1960-1990",
          "snippet": "static int do_change_type(struct path *path, int flag)\n{\n\tstruct mount *m;\n\tstruct mount *mnt = real_mount(path->mnt);\n\tint recurse = flag & MS_REC;\n\tint type;\n\tint err = 0;\n\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\ttype = flags_to_propagation_type(flag);\n\tif (!type)\n\t\treturn -EINVAL;\n\n\tnamespace_lock();\n\tif (type == MS_SHARED) {\n\t\terr = invent_group_ids(mnt, recurse);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tlock_mount_hash();\n\tfor (m = mnt; m; m = (recurse ? next_mnt(m, mnt) : NULL))\n\t\tchange_mnt_propagation(m, type);\n\tunlock_mount_hash();\n\n out_unlock:\n\tnamespace_unlock();\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int do_change_type(struct path *path, int flag)\n{\n\tstruct mount *m;\n\tstruct mount *mnt = real_mount(path->mnt);\n\tint recurse = flag & MS_REC;\n\tint type;\n\tint err = 0;\n\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\ttype = flags_to_propagation_type(flag);\n\tif (!type)\n\t\treturn -EINVAL;\n\n\tnamespace_lock();\n\tif (type == MS_SHARED) {\n\t\terr = invent_group_ids(mnt, recurse);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tlock_mount_hash();\n\tfor (m = mnt; m; m = (recurse ? next_mnt(m, mnt) : NULL))\n\t\tchange_mnt_propagation(m, type);\n\tunlock_mount_hash();\n\n out_unlock:\n\tnamespace_unlock();\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_loopback",
          "args": [
            "&path",
            "dev_name",
            "flags & MS_REC"
          ],
          "line": 2651
        },
        "resolved": true,
        "details": {
          "function_name": "do_loopback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2008-2069",
          "snippet": "static int do_loopback(struct path *path, const char *old_name,\n\t\t\t\tint recurse)\n{\n\tstruct path old_path;\n\tstruct mount *mnt = NULL, *old, *parent;\n\tstruct mountpoint *mp;\n\tint err;\n\tif (!old_name || !*old_name)\n\t\treturn -EINVAL;\n\terr = kern_path(old_name, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &old_path);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tif (mnt_ns_loop(old_path.dentry))\n\t\tgoto out; \n\n\tmp = lock_mount(path);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto out;\n\n\told = real_mount(old_path.mnt);\n\tparent = real_mount(path->mnt);\n\n\terr = -EINVAL;\n\tif (IS_MNT_UNBINDABLE(old))\n\t\tgoto out2;\n\n\tif (!check_mnt(parent))\n\t\tgoto out2;\n\n\tif (!check_mnt(old) && old_path.dentry->d_op != &ns_dentry_operations)\n\t\tgoto out2;\n\n\tif (!recurse && has_locked_children(old, old_path.dentry))\n\t\tgoto out2;\n\n\tif (recurse)\n\t\tmnt = copy_tree(old, old_path.dentry, CL_COPY_MNT_NS_FILE);\n\telse\n\t\tmnt = clone_mnt(old, old_path.dentry, 0);\n\n\tif (IS_ERR(mnt)) {\n\t\terr = PTR_ERR(mnt);\n\t\tgoto out2;\n\t}\n\n\tmnt->mnt.mnt_flags &= ~MNT_LOCKED;\n\n\terr = graft_tree(mnt, parent, mp);\n\tif (err) {\n\t\tlock_mount_hash();\n\t\tumount_tree(mnt, UMOUNT_SYNC);\n\t\tunlock_mount_hash();\n\t}\nout2:\n\tunlock_mount(mp);\nout:\n\tpath_put(&old_path);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int do_loopback(struct path *path, const char *old_name,\n\t\t\t\tint recurse)\n{\n\tstruct path old_path;\n\tstruct mount *mnt = NULL, *old, *parent;\n\tstruct mountpoint *mp;\n\tint err;\n\tif (!old_name || !*old_name)\n\t\treturn -EINVAL;\n\terr = kern_path(old_name, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &old_path);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tif (mnt_ns_loop(old_path.dentry))\n\t\tgoto out; \n\n\tmp = lock_mount(path);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto out;\n\n\told = real_mount(old_path.mnt);\n\tparent = real_mount(path->mnt);\n\n\terr = -EINVAL;\n\tif (IS_MNT_UNBINDABLE(old))\n\t\tgoto out2;\n\n\tif (!check_mnt(parent))\n\t\tgoto out2;\n\n\tif (!check_mnt(old) && old_path.dentry->d_op != &ns_dentry_operations)\n\t\tgoto out2;\n\n\tif (!recurse && has_locked_children(old, old_path.dentry))\n\t\tgoto out2;\n\n\tif (recurse)\n\t\tmnt = copy_tree(old, old_path.dentry, CL_COPY_MNT_NS_FILE);\n\telse\n\t\tmnt = clone_mnt(old, old_path.dentry, 0);\n\n\tif (IS_ERR(mnt)) {\n\t\terr = PTR_ERR(mnt);\n\t\tgoto out2;\n\t}\n\n\tmnt->mnt.mnt_flags &= ~MNT_LOCKED;\n\n\terr = graft_tree(mnt, parent, mp);\n\tif (err) {\n\t\tlock_mount_hash();\n\t\tumount_tree(mnt, UMOUNT_SYNC);\n\t\tunlock_mount_hash();\n\t}\nout2:\n\tunlock_mount(mp);\nout:\n\tpath_put(&old_path);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_remount",
          "args": [
            "&path",
            "flags & ~MS_REMOUNT",
            "mnt_flags",
            "data_page"
          ],
          "line": 2648
        },
        "resolved": true,
        "details": {
          "function_name": "do_remount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2093-2159",
          "snippet": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\t/* Don't allow changing of locked mnt flags.\n\t *\n\t * No locks need to be held here while testing the various\n\t * MNT_LOCK flags because those flags can never be cleared\n\t * once they are set.\n\t */\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_READONLY) &&\n\t    !(mnt_flags & MNT_READONLY)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NODEV) &&\n\t    !(mnt_flags & MNT_NODEV)) {\n\t\t/* Was the nodev implicitly added in mount? */\n\t\tif ((mnt->mnt_ns->user_ns != &init_user_ns) &&\n\t\t    !(sb->s_type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tmnt_flags |= MNT_NODEV;\n\t\t} else {\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOSUID) &&\n\t    !(mnt_flags & MNT_NOSUID)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOEXEC) &&\n\t    !(mnt_flags & MNT_NOEXEC)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_ATIME) &&\n\t    ((mnt->mnt.mnt_flags & MNT_ATIME_MASK) != (mnt_flags & MNT_ATIME_MASK))) {\n\t\treturn -EPERM;\n\t}\n\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\t/* Don't allow changing of locked mnt flags.\n\t *\n\t * No locks need to be held here while testing the various\n\t * MNT_LOCK flags because those flags can never be cleared\n\t * once they are set.\n\t */\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_READONLY) &&\n\t    !(mnt_flags & MNT_READONLY)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NODEV) &&\n\t    !(mnt_flags & MNT_NODEV)) {\n\t\t/* Was the nodev implicitly added in mount? */\n\t\tif ((mnt->mnt_ns->user_ns != &init_user_ns) &&\n\t\t    !(sb->s_type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tmnt_flags |= MNT_NODEV;\n\t\t} else {\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOSUID) &&\n\t    !(mnt_flags & MNT_NOSUID)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOEXEC) &&\n\t    !(mnt_flags & MNT_NOEXEC)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_ATIME) &&\n\t    ((mnt->mnt.mnt_flags & MNT_ATIME_MASK) != (mnt_flags & MNT_ATIME_MASK))) {\n\t\treturn -EPERM;\n\t}\n\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "may_mount",
          "args": [],
          "line": 2610
        },
        "resolved": true,
        "details": {
          "function_name": "may_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1520-1523",
          "snippet": "static inline bool may_mount(void)\n{\n\treturn ns_capable(current->nsproxy->mnt_ns->user_ns, CAP_SYS_ADMIN);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline bool may_mount(void)\n{\n\treturn ns_capable(current->nsproxy->mnt_ns->user_ns, CAP_SYS_ADMIN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_sb_mount",
          "args": [
            "dev_name",
            "&path",
            "type_page",
            "flags",
            "data_page"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_path",
          "args": [
            "dir_name",
            "&path"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nlong do_mount(const char *dev_name, const char __user *dir_name,\n\t\tconst char *type_page, unsigned long flags, void *data_page)\n{\n\tstruct path path;\n\tint retval = 0;\n\tint mnt_flags = 0;\n\n\t/* Discard magic */\n\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)\n\t\tflags &= ~MS_MGC_MSK;\n\n\t/* Basic sanity checks */\n\tif (data_page)\n\t\t((char *)data_page)[PAGE_SIZE - 1] = 0;\n\n\t/* ... and get the mountpoint */\n\tretval = user_path(dir_name, &path);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = security_sb_mount(dev_name, &path,\n\t\t\t\t   type_page, flags, data_page);\n\tif (!retval && !may_mount())\n\t\tretval = -EPERM;\n\tif (retval)\n\t\tgoto dput_out;\n\n\t/* Default to relatime unless overriden */\n\tif (!(flags & MS_NOATIME))\n\t\tmnt_flags |= MNT_RELATIME;\n\n\t/* Separate the per-mountpoint flags */\n\tif (flags & MS_NOSUID)\n\t\tmnt_flags |= MNT_NOSUID;\n\tif (flags & MS_NODEV)\n\t\tmnt_flags |= MNT_NODEV;\n\tif (flags & MS_NOEXEC)\n\t\tmnt_flags |= MNT_NOEXEC;\n\tif (flags & MS_NOATIME)\n\t\tmnt_flags |= MNT_NOATIME;\n\tif (flags & MS_NODIRATIME)\n\t\tmnt_flags |= MNT_NODIRATIME;\n\tif (flags & MS_STRICTATIME)\n\t\tmnt_flags &= ~(MNT_RELATIME | MNT_NOATIME);\n\tif (flags & MS_RDONLY)\n\t\tmnt_flags |= MNT_READONLY;\n\n\t/* The default atime for remount is preservation */\n\tif ((flags & MS_REMOUNT) &&\n\t    ((flags & (MS_NOATIME | MS_NODIRATIME | MS_RELATIME |\n\t\t       MS_STRICTATIME)) == 0)) {\n\t\tmnt_flags &= ~MNT_ATIME_MASK;\n\t\tmnt_flags |= path.mnt->mnt_flags & MNT_ATIME_MASK;\n\t}\n\n\tflags &= ~(MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_ACTIVE | MS_BORN |\n\t\t   MS_NOATIME | MS_NODIRATIME | MS_RELATIME| MS_KERNMOUNT |\n\t\t   MS_STRICTATIME);\n\n\tif (flags & MS_REMOUNT)\n\t\tretval = do_remount(&path, flags & ~MS_REMOUNT, mnt_flags,\n\t\t\t\t    data_page);\n\telse if (flags & MS_BIND)\n\t\tretval = do_loopback(&path, dev_name, flags & MS_REC);\n\telse if (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))\n\t\tretval = do_change_type(&path, flags);\n\telse if (flags & MS_MOVE)\n\t\tretval = do_move_mount(&path, dev_name);\n\telse\n\t\tretval = do_new_mount(&path, type_page, flags, mnt_flags,\n\t\t\t\t      dev_name, data_page);\ndput_out:\n\tpath_put(&path);\n\treturn retval;\n}"
  },
  {
    "function_name": "copy_mount_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2569-2572",
    "snippet": "char *copy_mount_string(const void __user *data)\n{\n\treturn data ? strndup_user(data, PAGE_SIZE) : NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strndup_user",
          "args": [
            "data",
            "PAGE_SIZE"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nchar *copy_mount_string(const void __user *data)\n{\n\treturn data ? strndup_user(data, PAGE_SIZE) : NULL;\n}"
  },
  {
    "function_name": "copy_mount_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2536-2567",
    "snippet": "int copy_mount_options(const void __user * data, unsigned long *where)\n{\n\tint i;\n\tunsigned long page;\n\tunsigned long size;\n\n\t*where = 0;\n\tif (!data)\n\t\treturn 0;\n\n\tif (!(page = __get_free_page(GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\t/* We only care that *some* data at the address the user\n\t * gave us is valid.  Just in case, we'll zero\n\t * the remainder of the page.\n\t */\n\t/* copy_from_user cannot cross TASK_SIZE ! */\n\tsize = TASK_SIZE - (unsigned long)data;\n\tif (size > PAGE_SIZE)\n\t\tsize = PAGE_SIZE;\n\n\ti = size - exact_copy_from_user((void *)page, data, size);\n\tif (!i) {\n\t\tfree_page(page);\n\t\treturn -EFAULT;\n\t}\n\tif (i != PAGE_SIZE)\n\t\tmemset((char *)page + i, 0, PAGE_SIZE - i);\n\t*where = page;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)page + i",
            "0",
            "PAGE_SIZE - i"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "page"
          ],
          "line": 2560
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exact_copy_from_user",
          "args": [
            "(void *)page",
            "data",
            "size"
          ],
          "line": 2558
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint copy_mount_options(const void __user * data, unsigned long *where)\n{\n\tint i;\n\tunsigned long page;\n\tunsigned long size;\n\n\t*where = 0;\n\tif (!data)\n\t\treturn 0;\n\n\tif (!(page = __get_free_page(GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\t/* We only care that *some* data at the address the user\n\t * gave us is valid.  Just in case, we'll zero\n\t * the remainder of the page.\n\t */\n\t/* copy_from_user cannot cross TASK_SIZE ! */\n\tsize = TASK_SIZE - (unsigned long)data;\n\tif (size > PAGE_SIZE)\n\t\tsize = PAGE_SIZE;\n\n\ti = size - exact_copy_from_user((void *)page, data, size);\n\tif (!i) {\n\t\tfree_page(page);\n\t\treturn -EFAULT;\n\t}\n\tif (i != PAGE_SIZE)\n\t\tmemset((char *)page + i, 0, PAGE_SIZE - i);\n\t*where = page;\n\treturn 0;\n}"
  },
  {
    "function_name": "exact_copy_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2514-2534",
    "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "t",
            "0",
            "n"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "c",
            "f"
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "from",
            "n"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
  },
  {
    "function_name": "shrink_submounts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2492-2506",
    "snippet": "static void shrink_submounts(struct mount *mnt)\n{\n\tLIST_HEAD(graveyard);\n\tstruct mount *m;\n\n\t/* extract submounts of 'mountpoint' from the expiration list */\n\twhile (select_submounts(mnt, &graveyard)) {\n\t\twhile (!list_empty(&graveyard)) {\n\t\t\tm = list_first_entry(&graveyard, struct mount,\n\t\t\t\t\t\tmnt_expire);\n\t\t\ttouch_mnt_namespace(m->mnt_ns);\n\t\t\tumount_tree(m, UMOUNT_PROPAGATE|UMOUNT_SYNC);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "umount_tree",
          "args": [
            "m",
            "UMOUNT_PROPAGATE|UMOUNT_SYNC"
          ],
          "line": 2503
        },
        "resolved": true,
        "details": {
          "function_name": "umount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1349-1388",
          "snippet": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static HLIST_HEAD(unmounted);",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic HLIST_HEAD(unmounted);\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_mnt_namespace",
          "args": [
            "m->mnt_ns"
          ],
          "line": 2502
        },
        "resolved": true,
        "details": {
          "function_name": "__touch_mnt_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "790-796",
          "snippet": "static void __touch_mnt_namespace(struct mnt_namespace *ns)\n{\n\tif (ns && ns->event != event) {\n\t\tns->event = event;\n\t\twake_up_interruptible(&ns->poll);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 event;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic u64 event;\n\nstatic void __touch_mnt_namespace(struct mnt_namespace *ns)\n{\n\tif (ns && ns->event != event) {\n\t\tns->event = event;\n\t\twake_up_interruptible(&ns->poll);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&graveyard",
            "structmount",
            "mnt_expire"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&graveyard"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_submounts",
          "args": [
            "mnt",
            "&graveyard"
          ],
          "line": 2498
        },
        "resolved": true,
        "details": {
          "function_name": "select_submounts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2446-2484",
          "snippet": "static int select_submounts(struct mount *parent, struct list_head *graveyard)\n{\n\tstruct mount *this_parent = parent;\n\tstruct list_head *next;\n\tint found = 0;\n\nrepeat:\n\tnext = this_parent->mnt_mounts.next;\nresume:\n\twhile (next != &this_parent->mnt_mounts) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct mount *mnt = list_entry(tmp, struct mount, mnt_child);\n\n\t\tnext = tmp->next;\n\t\tif (!(mnt->mnt.mnt_flags & MNT_SHRINKABLE))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Descend a level if the d_mounts list is non-empty.\n\t\t */\n\t\tif (!list_empty(&mnt->mnt_mounts)) {\n\t\t\tthis_parent = mnt;\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tif (!propagate_mount_busy(mnt, 1)) {\n\t\t\tlist_move_tail(&mnt->mnt_expire, graveyard);\n\t\t\tfound++;\n\t\t}\n\t}\n\t/*\n\t * All done at this level ... ascend and resume the search\n\t */\n\tif (this_parent != parent) {\n\t\tnext = this_parent->mnt_child.next;\n\t\tthis_parent = this_parent->mnt_parent;\n\t\tgoto resume;\n\t}\n\treturn found;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int select_submounts(struct mount *parent, struct list_head *graveyard)\n{\n\tstruct mount *this_parent = parent;\n\tstruct list_head *next;\n\tint found = 0;\n\nrepeat:\n\tnext = this_parent->mnt_mounts.next;\nresume:\n\twhile (next != &this_parent->mnt_mounts) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct mount *mnt = list_entry(tmp, struct mount, mnt_child);\n\n\t\tnext = tmp->next;\n\t\tif (!(mnt->mnt.mnt_flags & MNT_SHRINKABLE))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Descend a level if the d_mounts list is non-empty.\n\t\t */\n\t\tif (!list_empty(&mnt->mnt_mounts)) {\n\t\t\tthis_parent = mnt;\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tif (!propagate_mount_busy(mnt, 1)) {\n\t\t\tlist_move_tail(&mnt->mnt_expire, graveyard);\n\t\t\tfound++;\n\t\t}\n\t}\n\t/*\n\t * All done at this level ... ascend and resume the search\n\t */\n\tif (this_parent != parent) {\n\t\tnext = this_parent->mnt_child.next;\n\t\tthis_parent = this_parent->mnt_parent;\n\t\tgoto resume;\n\t}\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "graveyard"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void shrink_submounts(struct mount *mnt)\n{\n\tLIST_HEAD(graveyard);\n\tstruct mount *m;\n\n\t/* extract submounts of 'mountpoint' from the expiration list */\n\twhile (select_submounts(mnt, &graveyard)) {\n\t\twhile (!list_empty(&graveyard)) {\n\t\t\tm = list_first_entry(&graveyard, struct mount,\n\t\t\t\t\t\tmnt_expire);\n\t\t\ttouch_mnt_namespace(m->mnt_ns);\n\t\t\tumount_tree(m, UMOUNT_PROPAGATE|UMOUNT_SYNC);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "select_submounts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2446-2484",
    "snippet": "static int select_submounts(struct mount *parent, struct list_head *graveyard)\n{\n\tstruct mount *this_parent = parent;\n\tstruct list_head *next;\n\tint found = 0;\n\nrepeat:\n\tnext = this_parent->mnt_mounts.next;\nresume:\n\twhile (next != &this_parent->mnt_mounts) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct mount *mnt = list_entry(tmp, struct mount, mnt_child);\n\n\t\tnext = tmp->next;\n\t\tif (!(mnt->mnt.mnt_flags & MNT_SHRINKABLE))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Descend a level if the d_mounts list is non-empty.\n\t\t */\n\t\tif (!list_empty(&mnt->mnt_mounts)) {\n\t\t\tthis_parent = mnt;\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tif (!propagate_mount_busy(mnt, 1)) {\n\t\t\tlist_move_tail(&mnt->mnt_expire, graveyard);\n\t\t\tfound++;\n\t\t}\n\t}\n\t/*\n\t * All done at this level ... ascend and resume the search\n\t */\n\tif (this_parent != parent) {\n\t\tnext = this_parent->mnt_child.next;\n\t\tthis_parent = this_parent->mnt_parent;\n\t\tgoto resume;\n\t}\n\treturn found;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&mnt->mnt_expire",
            "graveyard"
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "propagate_mount_busy",
          "args": [
            "mnt",
            "1"
          ],
          "line": 2470
        },
        "resolved": true,
        "details": {
          "function_name": "propagate_mount_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "337-362",
          "snippet": "int propagate_mount_busy(struct mount *mnt, int refcnt)\n{\n\tstruct mount *m, *child;\n\tstruct mount *parent = mnt->mnt_parent;\n\tint ret = 0;\n\n\tif (mnt == parent)\n\t\treturn do_refcount_check(mnt, refcnt);\n\n\t/*\n\t * quickly check if the current mount can be unmounted.\n\t * If not, we don't have to go checking for all other\n\t * mounts\n\t */\n\tif (!list_empty(&mnt->mnt_mounts) || do_refcount_check(mnt, refcnt))\n\t\treturn 1;\n\n\tfor (m = propagation_next(parent, parent); m;\n\t     \t\tm = propagation_next(m, parent)) {\n\t\tchild = __lookup_mnt_last(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (child && list_empty(&child->mnt_mounts) &&\n\t\t    (ret = do_refcount_check(child, 1)))\n\t\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint propagate_mount_busy(struct mount *mnt, int refcnt)\n{\n\tstruct mount *m, *child;\n\tstruct mount *parent = mnt->mnt_parent;\n\tint ret = 0;\n\n\tif (mnt == parent)\n\t\treturn do_refcount_check(mnt, refcnt);\n\n\t/*\n\t * quickly check if the current mount can be unmounted.\n\t * If not, we don't have to go checking for all other\n\t * mounts\n\t */\n\tif (!list_empty(&mnt->mnt_mounts) || do_refcount_check(mnt, refcnt))\n\t\treturn 1;\n\n\tfor (m = propagation_next(parent, parent); m;\n\t     \t\tm = propagation_next(m, parent)) {\n\t\tchild = __lookup_mnt_last(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (child && list_empty(&child->mnt_mounts) &&\n\t\t    (ret = do_refcount_check(child, 1)))\n\t\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&mnt->mnt_mounts"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp",
            "structmount",
            "mnt_child"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int select_submounts(struct mount *parent, struct list_head *graveyard)\n{\n\tstruct mount *this_parent = parent;\n\tstruct list_head *next;\n\tint found = 0;\n\nrepeat:\n\tnext = this_parent->mnt_mounts.next;\nresume:\n\twhile (next != &this_parent->mnt_mounts) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct mount *mnt = list_entry(tmp, struct mount, mnt_child);\n\n\t\tnext = tmp->next;\n\t\tif (!(mnt->mnt.mnt_flags & MNT_SHRINKABLE))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Descend a level if the d_mounts list is non-empty.\n\t\t */\n\t\tif (!list_empty(&mnt->mnt_mounts)) {\n\t\t\tthis_parent = mnt;\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tif (!propagate_mount_busy(mnt, 1)) {\n\t\t\tlist_move_tail(&mnt->mnt_expire, graveyard);\n\t\t\tfound++;\n\t\t}\n\t}\n\t/*\n\t * All done at this level ... ascend and resume the search\n\t */\n\tif (this_parent != parent) {\n\t\tnext = this_parent->mnt_child.next;\n\t\tthis_parent = this_parent->mnt_parent;\n\t\tgoto resume;\n\t}\n\treturn found;\n}"
  },
  {
    "function_name": "mark_mounts_for_expiry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2406-2436",
    "snippet": "void mark_mounts_for_expiry(struct list_head *mounts)\n{\n\tstruct mount *mnt, *next;\n\tLIST_HEAD(graveyard);\n\n\tif (list_empty(mounts))\n\t\treturn;\n\n\tnamespace_lock();\n\tlock_mount_hash();\n\n\t/* extract from the expiration list every vfsmount that matches the\n\t * following criteria:\n\t * - only referenced by its parent vfsmount\n\t * - still marked for expiry (marked on the last call here; marks are\n\t *   cleared by mntput())\n\t */\n\tlist_for_each_entry_safe(mnt, next, mounts, mnt_expire) {\n\t\tif (!xchg(&mnt->mnt_expiry_mark, 1) ||\n\t\t\tpropagate_mount_busy(mnt, 1))\n\t\t\tcontinue;\n\t\tlist_move(&mnt->mnt_expire, &graveyard);\n\t}\n\twhile (!list_empty(&graveyard)) {\n\t\tmnt = list_first_entry(&graveyard, struct mount, mnt_expire);\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tumount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);\n\t}\n\tunlock_mount_hash();\n\tnamespace_unlock();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "namespace_unlock",
          "args": [],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1320-1334",
          "snippet": "static void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);",
            "static HLIST_HEAD(unmounted);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic HLIST_HEAD(unmounted);\n\nstatic void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_mount_hash",
          "args": [],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "114-117",
          "snippet": "static inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern seqlock_t mount_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern seqlock_t mount_lock;\n\nstatic inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umount_tree",
          "args": [
            "mnt",
            "UMOUNT_PROPAGATE|UMOUNT_SYNC"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "umount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1349-1388",
          "snippet": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static HLIST_HEAD(unmounted);",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic HLIST_HEAD(unmounted);\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_mnt_namespace",
          "args": [
            "mnt->mnt_ns"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "__touch_mnt_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "790-796",
          "snippet": "static void __touch_mnt_namespace(struct mnt_namespace *ns)\n{\n\tif (ns && ns->event != event) {\n\t\tns->event = event;\n\t\twake_up_interruptible(&ns->poll);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 event;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic u64 event;\n\nstatic void __touch_mnt_namespace(struct mnt_namespace *ns)\n{\n\tif (ns && ns->event != event) {\n\t\tns->event = event;\n\t\twake_up_interruptible(&ns->poll);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&graveyard",
            "structmount",
            "mnt_expire"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&graveyard"
          ],
          "line": 2429
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&mnt->mnt_expire",
            "&graveyard"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "propagate_mount_busy",
          "args": [
            "mnt",
            "1"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "propagate_mount_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "337-362",
          "snippet": "int propagate_mount_busy(struct mount *mnt, int refcnt)\n{\n\tstruct mount *m, *child;\n\tstruct mount *parent = mnt->mnt_parent;\n\tint ret = 0;\n\n\tif (mnt == parent)\n\t\treturn do_refcount_check(mnt, refcnt);\n\n\t/*\n\t * quickly check if the current mount can be unmounted.\n\t * If not, we don't have to go checking for all other\n\t * mounts\n\t */\n\tif (!list_empty(&mnt->mnt_mounts) || do_refcount_check(mnt, refcnt))\n\t\treturn 1;\n\n\tfor (m = propagation_next(parent, parent); m;\n\t     \t\tm = propagation_next(m, parent)) {\n\t\tchild = __lookup_mnt_last(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (child && list_empty(&child->mnt_mounts) &&\n\t\t    (ret = do_refcount_check(child, 1)))\n\t\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint propagate_mount_busy(struct mount *mnt, int refcnt)\n{\n\tstruct mount *m, *child;\n\tstruct mount *parent = mnt->mnt_parent;\n\tint ret = 0;\n\n\tif (mnt == parent)\n\t\treturn do_refcount_check(mnt, refcnt);\n\n\t/*\n\t * quickly check if the current mount can be unmounted.\n\t * If not, we don't have to go checking for all other\n\t * mounts\n\t */\n\tif (!list_empty(&mnt->mnt_mounts) || do_refcount_check(mnt, refcnt))\n\t\treturn 1;\n\n\tfor (m = propagation_next(parent, parent); m;\n\t     \t\tm = propagation_next(m, parent)) {\n\t\tchild = __lookup_mnt_last(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (child && list_empty(&child->mnt_mounts) &&\n\t\t    (ret = do_refcount_check(child, 1)))\n\t\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&mnt->mnt_expiry_mark",
            "1"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "mnt",
            "next",
            "mounts",
            "mnt_expire"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namespace_lock",
          "args": [],
          "line": 2414
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1336-1339",
          "snippet": "static inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\n\nstatic inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "graveyard"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mark_mounts_for_expiry(struct list_head *mounts)\n{\n\tstruct mount *mnt, *next;\n\tLIST_HEAD(graveyard);\n\n\tif (list_empty(mounts))\n\t\treturn;\n\n\tnamespace_lock();\n\tlock_mount_hash();\n\n\t/* extract from the expiration list every vfsmount that matches the\n\t * following criteria:\n\t * - only referenced by its parent vfsmount\n\t * - still marked for expiry (marked on the last call here; marks are\n\t *   cleared by mntput())\n\t */\n\tlist_for_each_entry_safe(mnt, next, mounts, mnt_expire) {\n\t\tif (!xchg(&mnt->mnt_expiry_mark, 1) ||\n\t\t\tpropagate_mount_busy(mnt, 1))\n\t\t\tcontinue;\n\t\tlist_move(&mnt->mnt_expire, &graveyard);\n\t}\n\twhile (!list_empty(&graveyard)) {\n\t\tmnt = list_first_entry(&graveyard, struct mount, mnt_expire);\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tumount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);\n\t}\n\tunlock_mount_hash();\n\tnamespace_unlock();\n}"
  },
  {
    "function_name": "mnt_set_expiry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2391-2398",
    "snippet": "void mnt_set_expiry(struct vfsmount *mnt, struct list_head *expiry_list)\n{\n\tnamespace_lock();\n\n\tlist_add_tail(&real_mount(mnt)->mnt_expire, expiry_list);\n\n\tnamespace_unlock();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "namespace_unlock",
          "args": [],
          "line": 2397
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1320-1334",
          "snippet": "static void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);",
            "static HLIST_HEAD(unmounted);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic HLIST_HEAD(unmounted);\n\nstatic void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&real_mount(mnt)->mnt_expire",
            "expiry_list"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "namespace_lock",
          "args": [],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1336-1339",
          "snippet": "static inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\n\nstatic inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_set_expiry(struct vfsmount *mnt, struct list_head *expiry_list)\n{\n\tnamespace_lock();\n\n\tlist_add_tail(&real_mount(mnt)->mnt_expire, expiry_list);\n\n\tnamespace_unlock();\n}"
  },
  {
    "function_name": "finish_automount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2356-2384",
    "snippet": "int finish_automount(struct vfsmount *m, struct path *path)\n{\n\tstruct mount *mnt = real_mount(m);\n\tint err;\n\t/* The new mount record should have at least 2 refs to prevent it being\n\t * expired before we get a chance to add it\n\t */\n\tBUG_ON(mnt_get_count(mnt) < 2);\n\n\tif (m->mnt_sb == path->mnt->mnt_sb &&\n\t    m->mnt_root == path->dentry) {\n\t\terr = -ELOOP;\n\t\tgoto fail;\n\t}\n\n\terr = do_add_mount(mnt, path, path->mnt->mnt_flags | MNT_SHRINKABLE);\n\tif (!err)\n\t\treturn 0;\nfail:\n\t/* remove m from any expiration list it may be on */\n\tif (!list_empty(&mnt->mnt_expire)) {\n\t\tnamespace_lock();\n\t\tlist_del_init(&mnt->mnt_expire);\n\t\tnamespace_unlock();\n\t}\n\tmntput(m);\n\tmntput(m);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "m"
          ],
          "line": 2382
        },
        "resolved": true,
        "details": {
          "function_name": "mntput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1118-1127",
          "snippet": "void mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "namespace_unlock",
          "args": [],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1320-1334",
          "snippet": "static void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);",
            "static HLIST_HEAD(unmounted);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic HLIST_HEAD(unmounted);\n\nstatic void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mnt->mnt_expire"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namespace_lock",
          "args": [],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1336-1339",
          "snippet": "static inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\n\nstatic inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&mnt->mnt_expire"
          ],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_add_mount",
          "args": [
            "mnt",
            "path",
            "path->mnt->mnt_flags | MNT_SHRINKABLE"
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "do_add_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2267-2306",
          "snippet": "static int do_add_mount(struct mount *newmnt, struct path *path, int mnt_flags)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *parent;\n\tint err;\n\n\tmnt_flags &= ~MNT_INTERNAL_FLAGS;\n\n\tmp = lock_mount(path);\n\tif (IS_ERR(mp))\n\t\treturn PTR_ERR(mp);\n\n\tparent = real_mount(path->mnt);\n\terr = -EINVAL;\n\tif (unlikely(!check_mnt(parent))) {\n\t\t/* that's acceptable only for automounts done in private ns */\n\t\tif (!(mnt_flags & MNT_SHRINKABLE))\n\t\t\tgoto unlock;\n\t\t/* ... and for those we'd better have mountpoint still alive */\n\t\tif (!parent->mnt_ns)\n\t\t\tgoto unlock;\n\t}\n\n\t/* Refuse the same filesystem on the same mount point */\n\terr = -EBUSY;\n\tif (path->mnt->mnt_sb == newmnt->mnt.mnt_sb &&\n\t    path->mnt->mnt_root == path->dentry)\n\t\tgoto unlock;\n\n\terr = -EINVAL;\n\tif (d_is_symlink(newmnt->mnt.mnt_root))\n\t\tgoto unlock;\n\n\tnewmnt->mnt.mnt_flags = mnt_flags;\n\terr = graft_tree(newmnt, parent, mp);\n\nunlock:\n\tunlock_mount(mp);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int do_add_mount(struct mount *newmnt, struct path *path, int mnt_flags)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *parent;\n\tint err;\n\n\tmnt_flags &= ~MNT_INTERNAL_FLAGS;\n\n\tmp = lock_mount(path);\n\tif (IS_ERR(mp))\n\t\treturn PTR_ERR(mp);\n\n\tparent = real_mount(path->mnt);\n\terr = -EINVAL;\n\tif (unlikely(!check_mnt(parent))) {\n\t\t/* that's acceptable only for automounts done in private ns */\n\t\tif (!(mnt_flags & MNT_SHRINKABLE))\n\t\t\tgoto unlock;\n\t\t/* ... and for those we'd better have mountpoint still alive */\n\t\tif (!parent->mnt_ns)\n\t\t\tgoto unlock;\n\t}\n\n\t/* Refuse the same filesystem on the same mount point */\n\terr = -EBUSY;\n\tif (path->mnt->mnt_sb == newmnt->mnt.mnt_sb &&\n\t    path->mnt->mnt_root == path->dentry)\n\t\tgoto unlock;\n\n\terr = -EINVAL;\n\tif (d_is_symlink(newmnt->mnt.mnt_root))\n\t\tgoto unlock;\n\n\tnewmnt->mnt.mnt_flags = mnt_flags;\n\terr = graft_tree(newmnt, parent, mp);\n\nunlock:\n\tunlock_mount(mp);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mnt_get_count(mnt) < 2"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_get_count",
          "args": [
            "mnt"
          ],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_get_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "177-191",
          "snippet": "unsigned int mnt_get_count(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_count;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_count;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nunsigned int mnt_get_count(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_count;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "m"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint finish_automount(struct vfsmount *m, struct path *path)\n{\n\tstruct mount *mnt = real_mount(m);\n\tint err;\n\t/* The new mount record should have at least 2 refs to prevent it being\n\t * expired before we get a chance to add it\n\t */\n\tBUG_ON(mnt_get_count(mnt) < 2);\n\n\tif (m->mnt_sb == path->mnt->mnt_sb &&\n\t    m->mnt_root == path->dentry) {\n\t\terr = -ELOOP;\n\t\tgoto fail;\n\t}\n\n\terr = do_add_mount(mnt, path, path->mnt->mnt_flags | MNT_SHRINKABLE);\n\tif (!err)\n\t\treturn 0;\nfail:\n\t/* remove m from any expiration list it may be on */\n\tif (!list_empty(&mnt->mnt_expire)) {\n\t\tnamespace_lock();\n\t\tlist_del_init(&mnt->mnt_expire);\n\t\tnamespace_unlock();\n\t}\n\tmntput(m);\n\tmntput(m);\n\treturn err;\n}"
  },
  {
    "function_name": "do_new_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2312-2354",
    "snippet": "static int do_new_mount(struct path *path, const char *fstype, int flags,\n\t\t\tint mnt_flags, const char *name, void *data)\n{\n\tstruct file_system_type *type;\n\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n\tstruct vfsmount *mnt;\n\tint err;\n\n\tif (!fstype)\n\t\treturn -EINVAL;\n\n\ttype = get_fs_type(fstype);\n\tif (!type)\n\t\treturn -ENODEV;\n\n\tif (user_ns != &init_user_ns) {\n\t\tif (!(type->fs_flags & FS_USERNS_MOUNT)) {\n\t\t\tput_filesystem(type);\n\t\t\treturn -EPERM;\n\t\t}\n\t\t/* Only in special cases allow devices from mounts\n\t\t * created outside the initial user namespace.\n\t\t */\n\t\tif (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tflags |= MS_NODEV;\n\t\t\tmnt_flags |= MNT_NODEV | MNT_LOCK_NODEV;\n\t\t}\n\t}\n\n\tmnt = vfs_kern_mount(type, flags, name, data);\n\tif (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&\n\t    !mnt->mnt_sb->s_subtype)\n\t\tmnt = fs_set_subtype(mnt, fstype);\n\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\n\terr = do_add_mount(real_mount(mnt), path, mnt_flags);\n\tif (err)\n\t\tmntput(mnt);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "mnt"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "mntput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1118-1127",
          "snippet": "void mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_add_mount",
          "args": [
            "real_mount(mnt)",
            "path",
            "mnt_flags"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "do_add_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2267-2306",
          "snippet": "static int do_add_mount(struct mount *newmnt, struct path *path, int mnt_flags)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *parent;\n\tint err;\n\n\tmnt_flags &= ~MNT_INTERNAL_FLAGS;\n\n\tmp = lock_mount(path);\n\tif (IS_ERR(mp))\n\t\treturn PTR_ERR(mp);\n\n\tparent = real_mount(path->mnt);\n\terr = -EINVAL;\n\tif (unlikely(!check_mnt(parent))) {\n\t\t/* that's acceptable only for automounts done in private ns */\n\t\tif (!(mnt_flags & MNT_SHRINKABLE))\n\t\t\tgoto unlock;\n\t\t/* ... and for those we'd better have mountpoint still alive */\n\t\tif (!parent->mnt_ns)\n\t\t\tgoto unlock;\n\t}\n\n\t/* Refuse the same filesystem on the same mount point */\n\terr = -EBUSY;\n\tif (path->mnt->mnt_sb == newmnt->mnt.mnt_sb &&\n\t    path->mnt->mnt_root == path->dentry)\n\t\tgoto unlock;\n\n\terr = -EINVAL;\n\tif (d_is_symlink(newmnt->mnt.mnt_root))\n\t\tgoto unlock;\n\n\tnewmnt->mnt.mnt_flags = mnt_flags;\n\terr = graft_tree(newmnt, parent, mp);\n\nunlock:\n\tunlock_mount(mp);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int do_add_mount(struct mount *newmnt, struct path *path, int mnt_flags)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *parent;\n\tint err;\n\n\tmnt_flags &= ~MNT_INTERNAL_FLAGS;\n\n\tmp = lock_mount(path);\n\tif (IS_ERR(mp))\n\t\treturn PTR_ERR(mp);\n\n\tparent = real_mount(path->mnt);\n\terr = -EINVAL;\n\tif (unlikely(!check_mnt(parent))) {\n\t\t/* that's acceptable only for automounts done in private ns */\n\t\tif (!(mnt_flags & MNT_SHRINKABLE))\n\t\t\tgoto unlock;\n\t\t/* ... and for those we'd better have mountpoint still alive */\n\t\tif (!parent->mnt_ns)\n\t\t\tgoto unlock;\n\t}\n\n\t/* Refuse the same filesystem on the same mount point */\n\terr = -EBUSY;\n\tif (path->mnt->mnt_sb == newmnt->mnt.mnt_sb &&\n\t    path->mnt->mnt_root == path->dentry)\n\t\tgoto unlock;\n\n\terr = -EINVAL;\n\tif (d_is_symlink(newmnt->mnt.mnt_root))\n\t\tgoto unlock;\n\n\tnewmnt->mnt.mnt_flags = mnt_flags;\n\terr = graft_tree(newmnt, parent, mp);\n\nunlock:\n\tunlock_mount(mp);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mnt"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_filesystem",
          "args": [
            "type"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "put_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "41-44",
          "snippet": "void put_filesystem(struct file_system_type *fs)\n{\n\tmodule_put(fs->owner);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nvoid put_filesystem(struct file_system_type *fs)\n{\n\tmodule_put(fs->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_set_subtype",
          "args": [
            "mnt",
            "fstype"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "fs_set_subtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2241-2262",
          "snippet": "static struct vfsmount *fs_set_subtype(struct vfsmount *mnt, const char *fstype)\n{\n\tint err;\n\tconst char *subtype = strchr(fstype, '.');\n\tif (subtype) {\n\t\tsubtype++;\n\t\terr = -EINVAL;\n\t\tif (!subtype[0])\n\t\t\tgoto err;\n\t} else\n\t\tsubtype = \"\";\n\n\tmnt->mnt_sb->s_subtype = kstrdup(subtype, GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!mnt->mnt_sb->s_subtype)\n\t\tgoto err;\n\treturn mnt;\n\n err:\n\tmntput(mnt);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic struct vfsmount *fs_set_subtype(struct vfsmount *mnt, const char *fstype)\n{\n\tint err;\n\tconst char *subtype = strchr(fstype, '.');\n\tif (subtype) {\n\t\tsubtype++;\n\t\terr = -EINVAL;\n\t\tif (!subtype[0])\n\t\t\tgoto err;\n\t} else\n\t\tsubtype = \"\";\n\n\tmnt->mnt_sb->s_subtype = kstrdup(subtype, GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!mnt->mnt_sb->s_subtype)\n\t\tgoto err;\n\treturn mnt;\n\n err:\n\tmntput(mnt);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_kern_mount",
          "args": [
            "type",
            "flags",
            "name",
            "data"
          ],
          "line": 2341
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_kern_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "921-952",
          "snippet": "struct vfsmount *\nvfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & MS_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tmnt_free_id(mnt);\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tunlock_mount_hash();\n\treturn &mnt->mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *\nvfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & MS_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tmnt_free_id(mnt);\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tunlock_mount_hash();\n\treturn &mnt->mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fs_type",
          "args": [
            "fstype"
          ],
          "line": 2323
        },
        "resolved": true,
        "details": {
          "function_name": "get_fs_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "271-286",
          "snippet": "struct file_system_type *get_fs_type(const char *name)\n{\n\tstruct file_system_type *fs;\n\tconst char *dot = strchr(name, '.');\n\tint len = dot ? dot - name : strlen(name);\n\n\tfs = __get_fs_type(name, len);\n\tif (!fs && (request_module(\"fs-%.*s\", len, name) == 0))\n\t\tfs = __get_fs_type(name, len);\n\n\tif (dot && fs && !(fs->fs_flags & FS_HAS_SUBTYPE)) {\n\t\tput_filesystem(fs);\n\t\tfs = NULL;\n\t}\n\treturn fs;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstruct file_system_type *get_fs_type(const char *name)\n{\n\tstruct file_system_type *fs;\n\tconst char *dot = strchr(name, '.');\n\tint len = dot ? dot - name : strlen(name);\n\n\tfs = __get_fs_type(name, len);\n\tif (!fs && (request_module(\"fs-%.*s\", len, name) == 0))\n\t\tfs = __get_fs_type(name, len);\n\n\tif (dot && fs && !(fs->fs_flags & FS_HAS_SUBTYPE)) {\n\t\tput_filesystem(fs);\n\t\tfs = NULL;\n\t}\n\treturn fs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int do_new_mount(struct path *path, const char *fstype, int flags,\n\t\t\tint mnt_flags, const char *name, void *data)\n{\n\tstruct file_system_type *type;\n\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n\tstruct vfsmount *mnt;\n\tint err;\n\n\tif (!fstype)\n\t\treturn -EINVAL;\n\n\ttype = get_fs_type(fstype);\n\tif (!type)\n\t\treturn -ENODEV;\n\n\tif (user_ns != &init_user_ns) {\n\t\tif (!(type->fs_flags & FS_USERNS_MOUNT)) {\n\t\t\tput_filesystem(type);\n\t\t\treturn -EPERM;\n\t\t}\n\t\t/* Only in special cases allow devices from mounts\n\t\t * created outside the initial user namespace.\n\t\t */\n\t\tif (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tflags |= MS_NODEV;\n\t\t\tmnt_flags |= MNT_NODEV | MNT_LOCK_NODEV;\n\t\t}\n\t}\n\n\tmnt = vfs_kern_mount(type, flags, name, data);\n\tif (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&\n\t    !mnt->mnt_sb->s_subtype)\n\t\tmnt = fs_set_subtype(mnt, fstype);\n\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\n\terr = do_add_mount(real_mount(mnt), path, mnt_flags);\n\tif (err)\n\t\tmntput(mnt);\n\treturn err;\n}"
  },
  {
    "function_name": "do_add_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2267-2306",
    "snippet": "static int do_add_mount(struct mount *newmnt, struct path *path, int mnt_flags)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *parent;\n\tint err;\n\n\tmnt_flags &= ~MNT_INTERNAL_FLAGS;\n\n\tmp = lock_mount(path);\n\tif (IS_ERR(mp))\n\t\treturn PTR_ERR(mp);\n\n\tparent = real_mount(path->mnt);\n\terr = -EINVAL;\n\tif (unlikely(!check_mnt(parent))) {\n\t\t/* that's acceptable only for automounts done in private ns */\n\t\tif (!(mnt_flags & MNT_SHRINKABLE))\n\t\t\tgoto unlock;\n\t\t/* ... and for those we'd better have mountpoint still alive */\n\t\tif (!parent->mnt_ns)\n\t\t\tgoto unlock;\n\t}\n\n\t/* Refuse the same filesystem on the same mount point */\n\terr = -EBUSY;\n\tif (path->mnt->mnt_sb == newmnt->mnt.mnt_sb &&\n\t    path->mnt->mnt_root == path->dentry)\n\t\tgoto unlock;\n\n\terr = -EINVAL;\n\tif (d_is_symlink(newmnt->mnt.mnt_root))\n\t\tgoto unlock;\n\n\tnewmnt->mnt.mnt_flags = mnt_flags;\n\terr = graft_tree(newmnt, parent, mp);\n\nunlock:\n\tunlock_mount(mp);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_mount",
          "args": [
            "mp"
          ],
          "line": 2304
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1920-1926",
          "snippet": "static void unlock_mount(struct mountpoint *where)\n{\n\tstruct dentry *dentry = where->m_dentry;\n\tput_mountpoint(where);\n\tnamespace_unlock();\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void unlock_mount(struct mountpoint *where)\n{\n\tstruct dentry *dentry = where->m_dentry;\n\tput_mountpoint(where);\n\tnamespace_unlock();\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "graft_tree",
          "args": [
            "newmnt",
            "parent",
            "mp"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "graft_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1928-1938",
          "snippet": "static int graft_tree(struct mount *mnt, struct mount *p, struct mountpoint *mp)\n{\n\tif (mnt->mnt.mnt_sb->s_flags & MS_NOUSER)\n\t\treturn -EINVAL;\n\n\tif (d_is_dir(mp->m_dentry) !=\n\t      d_is_dir(mnt->mnt.mnt_root))\n\t\treturn -ENOTDIR;\n\n\treturn attach_recursive_mnt(mnt, p, mp, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int graft_tree(struct mount *mnt, struct mount *p, struct mountpoint *mp)\n{\n\tif (mnt->mnt.mnt_sb->s_flags & MS_NOUSER)\n\t\treturn -EINVAL;\n\n\tif (d_is_dir(mp->m_dentry) !=\n\t      d_is_dir(mnt->mnt.mnt_root))\n\t\treturn -ENOTDIR;\n\n\treturn attach_recursive_mnt(mnt, p, mp, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_symlink",
          "args": [
            "newmnt->mnt.mnt_root"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!check_mnt(parent)"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_mnt",
          "args": [
            "parent"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "check_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "771-774",
          "snippet": "static inline int check_mnt(struct mount *mnt)\n{\n\treturn mnt->mnt_ns == current->nsproxy->mnt_ns;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline int check_mnt(struct mount *mnt)\n{\n\treturn mnt->mnt_ns == current->nsproxy->mnt_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "path->mnt"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mp"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mp"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int do_add_mount(struct mount *newmnt, struct path *path, int mnt_flags)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *parent;\n\tint err;\n\n\tmnt_flags &= ~MNT_INTERNAL_FLAGS;\n\n\tmp = lock_mount(path);\n\tif (IS_ERR(mp))\n\t\treturn PTR_ERR(mp);\n\n\tparent = real_mount(path->mnt);\n\terr = -EINVAL;\n\tif (unlikely(!check_mnt(parent))) {\n\t\t/* that's acceptable only for automounts done in private ns */\n\t\tif (!(mnt_flags & MNT_SHRINKABLE))\n\t\t\tgoto unlock;\n\t\t/* ... and for those we'd better have mountpoint still alive */\n\t\tif (!parent->mnt_ns)\n\t\t\tgoto unlock;\n\t}\n\n\t/* Refuse the same filesystem on the same mount point */\n\terr = -EBUSY;\n\tif (path->mnt->mnt_sb == newmnt->mnt.mnt_sb &&\n\t    path->mnt->mnt_root == path->dentry)\n\t\tgoto unlock;\n\n\terr = -EINVAL;\n\tif (d_is_symlink(newmnt->mnt.mnt_root))\n\t\tgoto unlock;\n\n\tnewmnt->mnt.mnt_flags = mnt_flags;\n\terr = graft_tree(newmnt, parent, mp);\n\nunlock:\n\tunlock_mount(mp);\n\treturn err;\n}"
  },
  {
    "function_name": "fs_set_subtype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2241-2262",
    "snippet": "static struct vfsmount *fs_set_subtype(struct vfsmount *mnt, const char *fstype)\n{\n\tint err;\n\tconst char *subtype = strchr(fstype, '.');\n\tif (subtype) {\n\t\tsubtype++;\n\t\terr = -EINVAL;\n\t\tif (!subtype[0])\n\t\t\tgoto err;\n\t} else\n\t\tsubtype = \"\";\n\n\tmnt->mnt_sb->s_subtype = kstrdup(subtype, GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!mnt->mnt_sb->s_subtype)\n\t\tgoto err;\n\treturn mnt;\n\n err:\n\tmntput(mnt);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "mnt"
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "mntput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1118-1127",
          "snippet": "void mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "subtype",
            "GFP_KERNEL"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fstype",
            "'.'"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic struct vfsmount *fs_set_subtype(struct vfsmount *mnt, const char *fstype)\n{\n\tint err;\n\tconst char *subtype = strchr(fstype, '.');\n\tif (subtype) {\n\t\tsubtype++;\n\t\terr = -EINVAL;\n\t\tif (!subtype[0])\n\t\t\tgoto err;\n\t} else\n\t\tsubtype = \"\";\n\n\tmnt->mnt_sb->s_subtype = kstrdup(subtype, GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!mnt->mnt_sb->s_subtype)\n\t\tgoto err;\n\treturn mnt;\n\n err:\n\tmntput(mnt);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "do_move_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2171-2239",
    "snippet": "static int do_move_mount(struct path *path, const char *old_name)\n{\n\tstruct path old_path, parent_path;\n\tstruct mount *p;\n\tstruct mount *old;\n\tstruct mountpoint *mp;\n\tint err;\n\tif (!old_name || !*old_name)\n\t\treturn -EINVAL;\n\terr = kern_path(old_name, LOOKUP_FOLLOW, &old_path);\n\tif (err)\n\t\treturn err;\n\n\tmp = lock_mount(path);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto out;\n\n\told = real_mount(old_path.mnt);\n\tp = real_mount(path->mnt);\n\n\terr = -EINVAL;\n\tif (!check_mnt(p) || !check_mnt(old))\n\t\tgoto out1;\n\n\tif (old->mnt.mnt_flags & MNT_LOCKED)\n\t\tgoto out1;\n\n\terr = -EINVAL;\n\tif (old_path.dentry != old_path.mnt->mnt_root)\n\t\tgoto out1;\n\n\tif (!mnt_has_parent(old))\n\t\tgoto out1;\n\n\tif (d_is_dir(path->dentry) !=\n\t      d_is_dir(old_path.dentry))\n\t\tgoto out1;\n\t/*\n\t * Don't move a mount residing in a shared parent.\n\t */\n\tif (IS_MNT_SHARED(old->mnt_parent))\n\t\tgoto out1;\n\t/*\n\t * Don't move a mount tree containing unbindable mounts to a destination\n\t * mount which is shared.\n\t */\n\tif (IS_MNT_SHARED(p) && tree_contains_unbindable(old))\n\t\tgoto out1;\n\terr = -ELOOP;\n\tfor (; mnt_has_parent(p); p = p->mnt_parent)\n\t\tif (p == old)\n\t\t\tgoto out1;\n\n\terr = attach_recursive_mnt(old, real_mount(path->mnt), mp, &parent_path);\n\tif (err)\n\t\tgoto out1;\n\n\t/* if the mount is moved, it should no longer be expire\n\t * automatically */\n\tlist_del_init(&old->mnt_expire);\nout1:\n\tunlock_mount(mp);\nout:\n\tif (!err)\n\t\tpath_put(&parent_path);\n\tpath_put(&old_path);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&old_path"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_mount",
          "args": [
            "mp"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1920-1926",
          "snippet": "static void unlock_mount(struct mountpoint *where)\n{\n\tstruct dentry *dentry = where->m_dentry;\n\tput_mountpoint(where);\n\tnamespace_unlock();\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void unlock_mount(struct mountpoint *where)\n{\n\tstruct dentry *dentry = where->m_dentry;\n\tput_mountpoint(where);\n\tnamespace_unlock();\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&old->mnt_expire"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attach_recursive_mnt",
          "args": [
            "old",
            "real_mount(path->mnt)",
            "mp",
            "&parent_path"
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "attach_recursive_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1835-1887",
          "snippet": "static int attach_recursive_mnt(struct mount *source_mnt,\n\t\t\tstruct mount *dest_mnt,\n\t\t\tstruct mountpoint *dest_mp,\n\t\t\tstruct path *parent_path)\n{\n\tHLIST_HEAD(tree_list);\n\tstruct mount *child, *p;\n\tstruct hlist_node *n;\n\tint err;\n\n\tif (IS_MNT_SHARED(dest_mnt)) {\n\t\terr = invent_group_ids(source_mnt, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = propagate_mnt(dest_mnt, dest_mp, source_mnt, &tree_list);\n\t\tlock_mount_hash();\n\t\tif (err)\n\t\t\tgoto out_cleanup_ids;\n\t\tfor (p = source_mnt; p; p = next_mnt(p, source_mnt))\n\t\t\tset_mnt_shared(p);\n\t} else {\n\t\tlock_mount_hash();\n\t}\n\tif (parent_path) {\n\t\tdetach_mnt(source_mnt, parent_path);\n\t\tattach_mnt(source_mnt, dest_mnt, dest_mp);\n\t\ttouch_mnt_namespace(source_mnt->mnt_ns);\n\t} else {\n\t\tmnt_set_mountpoint(dest_mnt, dest_mp, source_mnt);\n\t\tcommit_tree(source_mnt, NULL);\n\t}\n\n\thlist_for_each_entry_safe(child, n, &tree_list, mnt_hash) {\n\t\tstruct mount *q;\n\t\thlist_del_init(&child->mnt_hash);\n\t\tq = __lookup_mnt_last(&child->mnt_parent->mnt,\n\t\t\t\t      child->mnt_mountpoint);\n\t\tcommit_tree(child, q);\n\t}\n\tunlock_mount_hash();\n\n\treturn 0;\n\n out_cleanup_ids:\n\twhile (!hlist_empty(&tree_list)) {\n\t\tchild = hlist_entry(tree_list.first, struct mount, mnt_hash);\n\t\tumount_tree(child, UMOUNT_SYNC);\n\t}\n\tunlock_mount_hash();\n\tcleanup_group_ids(source_mnt, NULL);\n out:\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int attach_recursive_mnt(struct mount *source_mnt,\n\t\t\tstruct mount *dest_mnt,\n\t\t\tstruct mountpoint *dest_mp,\n\t\t\tstruct path *parent_path)\n{\n\tHLIST_HEAD(tree_list);\n\tstruct mount *child, *p;\n\tstruct hlist_node *n;\n\tint err;\n\n\tif (IS_MNT_SHARED(dest_mnt)) {\n\t\terr = invent_group_ids(source_mnt, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = propagate_mnt(dest_mnt, dest_mp, source_mnt, &tree_list);\n\t\tlock_mount_hash();\n\t\tif (err)\n\t\t\tgoto out_cleanup_ids;\n\t\tfor (p = source_mnt; p; p = next_mnt(p, source_mnt))\n\t\t\tset_mnt_shared(p);\n\t} else {\n\t\tlock_mount_hash();\n\t}\n\tif (parent_path) {\n\t\tdetach_mnt(source_mnt, parent_path);\n\t\tattach_mnt(source_mnt, dest_mnt, dest_mp);\n\t\ttouch_mnt_namespace(source_mnt->mnt_ns);\n\t} else {\n\t\tmnt_set_mountpoint(dest_mnt, dest_mp, source_mnt);\n\t\tcommit_tree(source_mnt, NULL);\n\t}\n\n\thlist_for_each_entry_safe(child, n, &tree_list, mnt_hash) {\n\t\tstruct mount *q;\n\t\thlist_del_init(&child->mnt_hash);\n\t\tq = __lookup_mnt_last(&child->mnt_parent->mnt,\n\t\t\t\t      child->mnt_mountpoint);\n\t\tcommit_tree(child, q);\n\t}\n\tunlock_mount_hash();\n\n\treturn 0;\n\n out_cleanup_ids:\n\twhile (!hlist_empty(&tree_list)) {\n\t\tchild = hlist_entry(tree_list.first, struct mount, mnt_hash);\n\t\tumount_tree(child, UMOUNT_SYNC);\n\t}\n\tunlock_mount_hash();\n\tcleanup_group_ids(source_mnt, NULL);\n out:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "path->mnt"
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_has_parent",
          "args": [
            "p"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_has_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "77-80",
          "snippet": "static inline int mnt_has_parent(struct mount *mnt)\n{\n\treturn mnt != mnt->mnt_parent;\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nstatic inline int mnt_has_parent(struct mount *mnt)\n{\n\treturn mnt != mnt->mnt_parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_contains_unbindable",
          "args": [
            "old"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "tree_contains_unbindable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2161-2169",
          "snippet": "static inline int tree_contains_unbindable(struct mount *mnt)\n{\n\tstruct mount *p;\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tif (IS_MNT_UNBINDABLE(p))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline int tree_contains_unbindable(struct mount *mnt)\n{\n\tstruct mount *p;\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tif (IS_MNT_UNBINDABLE(p))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_SHARED",
          "args": [
            "p"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MNT_SHARED",
          "args": [
            "old->mnt_parent"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "old_path.dentry"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "path->dentry"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_mnt",
          "args": [
            "old"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "check_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "771-774",
          "snippet": "static inline int check_mnt(struct mount *mnt)\n{\n\treturn mnt->mnt_ns == current->nsproxy->mnt_ns;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline int check_mnt(struct mount *mnt)\n{\n\treturn mnt->mnt_ns == current->nsproxy->mnt_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mp"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mp"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "old_name",
            "LOOKUP_FOLLOW",
            "&old_path"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "kern_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2089-2096",
          "snippet": "int kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int do_move_mount(struct path *path, const char *old_name)\n{\n\tstruct path old_path, parent_path;\n\tstruct mount *p;\n\tstruct mount *old;\n\tstruct mountpoint *mp;\n\tint err;\n\tif (!old_name || !*old_name)\n\t\treturn -EINVAL;\n\terr = kern_path(old_name, LOOKUP_FOLLOW, &old_path);\n\tif (err)\n\t\treturn err;\n\n\tmp = lock_mount(path);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto out;\n\n\told = real_mount(old_path.mnt);\n\tp = real_mount(path->mnt);\n\n\terr = -EINVAL;\n\tif (!check_mnt(p) || !check_mnt(old))\n\t\tgoto out1;\n\n\tif (old->mnt.mnt_flags & MNT_LOCKED)\n\t\tgoto out1;\n\n\terr = -EINVAL;\n\tif (old_path.dentry != old_path.mnt->mnt_root)\n\t\tgoto out1;\n\n\tif (!mnt_has_parent(old))\n\t\tgoto out1;\n\n\tif (d_is_dir(path->dentry) !=\n\t      d_is_dir(old_path.dentry))\n\t\tgoto out1;\n\t/*\n\t * Don't move a mount residing in a shared parent.\n\t */\n\tif (IS_MNT_SHARED(old->mnt_parent))\n\t\tgoto out1;\n\t/*\n\t * Don't move a mount tree containing unbindable mounts to a destination\n\t * mount which is shared.\n\t */\n\tif (IS_MNT_SHARED(p) && tree_contains_unbindable(old))\n\t\tgoto out1;\n\terr = -ELOOP;\n\tfor (; mnt_has_parent(p); p = p->mnt_parent)\n\t\tif (p == old)\n\t\t\tgoto out1;\n\n\terr = attach_recursive_mnt(old, real_mount(path->mnt), mp, &parent_path);\n\tif (err)\n\t\tgoto out1;\n\n\t/* if the mount is moved, it should no longer be expire\n\t * automatically */\n\tlist_del_init(&old->mnt_expire);\nout1:\n\tunlock_mount(mp);\nout:\n\tif (!err)\n\t\tpath_put(&parent_path);\n\tpath_put(&old_path);\n\treturn err;\n}"
  },
  {
    "function_name": "tree_contains_unbindable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2161-2169",
    "snippet": "static inline int tree_contains_unbindable(struct mount *mnt)\n{\n\tstruct mount *p;\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tif (IS_MNT_UNBINDABLE(p))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_MNT_UNBINDABLE",
          "args": [
            "p"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_mnt",
          "args": [
            "p",
            "mnt"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "next_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "895-909",
          "snippet": "static struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline int tree_contains_unbindable(struct mount *mnt)\n{\n\tstruct mount *p;\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tif (IS_MNT_UNBINDABLE(p))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "do_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2093-2159",
    "snippet": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\t/* Don't allow changing of locked mnt flags.\n\t *\n\t * No locks need to be held here while testing the various\n\t * MNT_LOCK flags because those flags can never be cleared\n\t * once they are set.\n\t */\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_READONLY) &&\n\t    !(mnt_flags & MNT_READONLY)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NODEV) &&\n\t    !(mnt_flags & MNT_NODEV)) {\n\t\t/* Was the nodev implicitly added in mount? */\n\t\tif ((mnt->mnt_ns->user_ns != &init_user_ns) &&\n\t\t    !(sb->s_type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tmnt_flags |= MNT_NODEV;\n\t\t} else {\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOSUID) &&\n\t    !(mnt_flags & MNT_NOSUID)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOEXEC) &&\n\t    !(mnt_flags & MNT_NOEXEC)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_ATIME) &&\n\t    ((mnt->mnt.mnt_flags & MNT_ATIME_MASK) != (mnt_flags & MNT_ATIME_MASK))) {\n\t\treturn -EPERM;\n\t}\n\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_mount_hash",
          "args": [],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "114-117",
          "snippet": "static inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern seqlock_t mount_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern seqlock_t mount_lock;\n\nstatic inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_mnt_namespace",
          "args": [
            "mnt->mnt_ns"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "__touch_mnt_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "790-796",
          "snippet": "static void __touch_mnt_namespace(struct mnt_namespace *ns)\n{\n\tif (ns && ns->event != event) {\n\t\tns->event = event;\n\t\twake_up_interruptible(&ns->poll);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 event;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic u64 event;\n\nstatic void __touch_mnt_namespace(struct mnt_namespace *ns)\n{\n\tif (ns && ns->event != event) {\n\t\tns->event = event;\n\t\twake_up_interruptible(&ns->poll);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_remount_sb",
          "args": [
            "sb",
            "flags",
            "data",
            "0"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "change_mount_flags",
          "args": [
            "path->mnt",
            "flags"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "change_mount_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2071-2086",
          "snippet": "static int change_mount_flags(struct vfsmount *mnt, int ms_flags)\n{\n\tint error = 0;\n\tint readonly_request = 0;\n\n\tif (ms_flags & MS_RDONLY)\n\t\treadonly_request = 1;\n\tif (readonly_request == __mnt_is_readonly(mnt))\n\t\treturn 0;\n\n\tif (readonly_request)\n\t\terror = mnt_make_readonly(real_mount(mnt));\n\telse\n\t\t__mnt_unmake_readonly(real_mount(mnt));\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int change_mount_flags(struct vfsmount *mnt, int ms_flags)\n{\n\tint error = 0;\n\tint readonly_request = 0;\n\n\tif (ms_flags & MS_RDONLY)\n\t\treadonly_request = 1;\n\tif (readonly_request == __mnt_is_readonly(mnt))\n\t\treturn 0;\n\n\tif (readonly_request)\n\t\terror = mnt_make_readonly(real_mount(mnt));\n\telse\n\t\t__mnt_unmake_readonly(real_mount(mnt));\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_sb_remount",
          "args": [
            "sb",
            "data"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_mnt",
          "args": [
            "mnt"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "check_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "771-774",
          "snippet": "static inline int check_mnt(struct mount *mnt)\n{\n\treturn mnt->mnt_ns == current->nsproxy->mnt_ns;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline int check_mnt(struct mount *mnt)\n{\n\treturn mnt->mnt_ns == current->nsproxy->mnt_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "path->mnt"
          ],
          "line": 2098
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\t/* Don't allow changing of locked mnt flags.\n\t *\n\t * No locks need to be held here while testing the various\n\t * MNT_LOCK flags because those flags can never be cleared\n\t * once they are set.\n\t */\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_READONLY) &&\n\t    !(mnt_flags & MNT_READONLY)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NODEV) &&\n\t    !(mnt_flags & MNT_NODEV)) {\n\t\t/* Was the nodev implicitly added in mount? */\n\t\tif ((mnt->mnt_ns->user_ns != &init_user_ns) &&\n\t\t    !(sb->s_type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tmnt_flags |= MNT_NODEV;\n\t\t} else {\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOSUID) &&\n\t    !(mnt_flags & MNT_NOSUID)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOEXEC) &&\n\t    !(mnt_flags & MNT_NOEXEC)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_ATIME) &&\n\t    ((mnt->mnt.mnt_flags & MNT_ATIME_MASK) != (mnt_flags & MNT_ATIME_MASK))) {\n\t\treturn -EPERM;\n\t}\n\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}"
  },
  {
    "function_name": "change_mount_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2071-2086",
    "snippet": "static int change_mount_flags(struct vfsmount *mnt, int ms_flags)\n{\n\tint error = 0;\n\tint readonly_request = 0;\n\n\tif (ms_flags & MS_RDONLY)\n\t\treadonly_request = 1;\n\tif (readonly_request == __mnt_is_readonly(mnt))\n\t\treturn 0;\n\n\tif (readonly_request)\n\t\terror = mnt_make_readonly(real_mount(mnt));\n\telse\n\t\t__mnt_unmake_readonly(real_mount(mnt));\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mnt_unmake_readonly",
          "args": [
            "real_mount(mnt)"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_unmake_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "535-540",
          "snippet": "static void __mnt_unmake_readonly(struct mount *mnt)\n{\n\tlock_mount_hash();\n\tmnt->mnt.mnt_flags &= ~MNT_READONLY;\n\tunlock_mount_hash();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void __mnt_unmake_readonly(struct mount *mnt)\n{\n\tlock_mount_hash();\n\tmnt->mnt.mnt_flags &= ~MNT_READONLY;\n\tunlock_mount_hash();\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_make_readonly",
          "args": [
            "real_mount(mnt)"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_make_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "493-533",
          "snippet": "static int mnt_make_readonly(struct mount *mnt)\n{\n\tint ret = 0;\n\n\tlock_mount_hash();\n\tmnt->mnt.mnt_flags |= MNT_WRITE_HOLD;\n\t/*\n\t * After storing MNT_WRITE_HOLD, we'll read the counters. This store\n\t * should be visible before we do.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * With writers on hold, if this value is zero, then there are\n\t * definitely no active writers (although held writers may subsequently\n\t * increment the count, they'll have to wait, and decrement it after\n\t * seeing MNT_READONLY).\n\t *\n\t * It is OK to have counter incremented on one CPU and decremented on\n\t * another: the sum will add up correctly. The danger would be when we\n\t * sum up each counter, if we read a counter before it is incremented,\n\t * but then read another CPU's count which it has been subsequently\n\t * decremented from -- we would see more decrements than we should.\n\t * MNT_WRITE_HOLD protects against this scenario, because\n\t * mnt_want_write first increments count, then smp_mb, then spins on\n\t * MNT_WRITE_HOLD, so it can't be decremented by another CPU while\n\t * we're counting up here.\n\t */\n\tif (mnt_get_writers(mnt) > 0)\n\t\tret = -EBUSY;\n\telse\n\t\tmnt->mnt.mnt_flags |= MNT_READONLY;\n\t/*\n\t * MNT_READONLY must become visible before ~MNT_WRITE_HOLD, so writers\n\t * that become unheld will see MNT_READONLY.\n\t */\n\tsmp_wmb();\n\tmnt->mnt.mnt_flags &= ~MNT_WRITE_HOLD;\n\tunlock_mount_hash();\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int mnt_make_readonly(struct mount *mnt)\n{\n\tint ret = 0;\n\n\tlock_mount_hash();\n\tmnt->mnt.mnt_flags |= MNT_WRITE_HOLD;\n\t/*\n\t * After storing MNT_WRITE_HOLD, we'll read the counters. This store\n\t * should be visible before we do.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * With writers on hold, if this value is zero, then there are\n\t * definitely no active writers (although held writers may subsequently\n\t * increment the count, they'll have to wait, and decrement it after\n\t * seeing MNT_READONLY).\n\t *\n\t * It is OK to have counter incremented on one CPU and decremented on\n\t * another: the sum will add up correctly. The danger would be when we\n\t * sum up each counter, if we read a counter before it is incremented,\n\t * but then read another CPU's count which it has been subsequently\n\t * decremented from -- we would see more decrements than we should.\n\t * MNT_WRITE_HOLD protects against this scenario, because\n\t * mnt_want_write first increments count, then smp_mb, then spins on\n\t * MNT_WRITE_HOLD, so it can't be decremented by another CPU while\n\t * we're counting up here.\n\t */\n\tif (mnt_get_writers(mnt) > 0)\n\t\tret = -EBUSY;\n\telse\n\t\tmnt->mnt.mnt_flags |= MNT_READONLY;\n\t/*\n\t * MNT_READONLY must become visible before ~MNT_WRITE_HOLD, so writers\n\t * that become unheld will see MNT_READONLY.\n\t */\n\tsmp_wmb();\n\tmnt->mnt.mnt_flags &= ~MNT_WRITE_HOLD;\n\tunlock_mount_hash();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mnt_is_readonly",
          "args": [
            "mnt"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_is_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "274-281",
          "snippet": "int __mnt_is_readonly(struct vfsmount *mnt)\n{\n\tif (mnt->mnt_flags & MNT_READONLY)\n\t\treturn 1;\n\tif (mnt->mnt_sb->s_flags & MS_RDONLY)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint __mnt_is_readonly(struct vfsmount *mnt)\n{\n\tif (mnt->mnt_flags & MNT_READONLY)\n\t\treturn 1;\n\tif (mnt->mnt_sb->s_flags & MS_RDONLY)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int change_mount_flags(struct vfsmount *mnt, int ms_flags)\n{\n\tint error = 0;\n\tint readonly_request = 0;\n\n\tif (ms_flags & MS_RDONLY)\n\t\treadonly_request = 1;\n\tif (readonly_request == __mnt_is_readonly(mnt))\n\t\treturn 0;\n\n\tif (readonly_request)\n\t\terror = mnt_make_readonly(real_mount(mnt));\n\telse\n\t\t__mnt_unmake_readonly(real_mount(mnt));\n\treturn error;\n}"
  },
  {
    "function_name": "do_loopback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "2008-2069",
    "snippet": "static int do_loopback(struct path *path, const char *old_name,\n\t\t\t\tint recurse)\n{\n\tstruct path old_path;\n\tstruct mount *mnt = NULL, *old, *parent;\n\tstruct mountpoint *mp;\n\tint err;\n\tif (!old_name || !*old_name)\n\t\treturn -EINVAL;\n\terr = kern_path(old_name, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &old_path);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tif (mnt_ns_loop(old_path.dentry))\n\t\tgoto out; \n\n\tmp = lock_mount(path);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto out;\n\n\told = real_mount(old_path.mnt);\n\tparent = real_mount(path->mnt);\n\n\terr = -EINVAL;\n\tif (IS_MNT_UNBINDABLE(old))\n\t\tgoto out2;\n\n\tif (!check_mnt(parent))\n\t\tgoto out2;\n\n\tif (!check_mnt(old) && old_path.dentry->d_op != &ns_dentry_operations)\n\t\tgoto out2;\n\n\tif (!recurse && has_locked_children(old, old_path.dentry))\n\t\tgoto out2;\n\n\tif (recurse)\n\t\tmnt = copy_tree(old, old_path.dentry, CL_COPY_MNT_NS_FILE);\n\telse\n\t\tmnt = clone_mnt(old, old_path.dentry, 0);\n\n\tif (IS_ERR(mnt)) {\n\t\terr = PTR_ERR(mnt);\n\t\tgoto out2;\n\t}\n\n\tmnt->mnt.mnt_flags &= ~MNT_LOCKED;\n\n\terr = graft_tree(mnt, parent, mp);\n\tif (err) {\n\t\tlock_mount_hash();\n\t\tumount_tree(mnt, UMOUNT_SYNC);\n\t\tunlock_mount_hash();\n\t}\nout2:\n\tunlock_mount(mp);\nout:\n\tpath_put(&old_path);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&old_path"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_mount",
          "args": [
            "mp"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1920-1926",
          "snippet": "static void unlock_mount(struct mountpoint *where)\n{\n\tstruct dentry *dentry = where->m_dentry;\n\tput_mountpoint(where);\n\tnamespace_unlock();\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void unlock_mount(struct mountpoint *where)\n{\n\tstruct dentry *dentry = where->m_dentry;\n\tput_mountpoint(where);\n\tnamespace_unlock();\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_mount_hash",
          "args": [],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "114-117",
          "snippet": "static inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern seqlock_t mount_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern seqlock_t mount_lock;\n\nstatic inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umount_tree",
          "args": [
            "mnt",
            "UMOUNT_SYNC"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "umount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1349-1388",
          "snippet": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static HLIST_HEAD(unmounted);",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic HLIST_HEAD(unmounted);\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "graft_tree",
          "args": [
            "mnt",
            "parent",
            "mp"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "graft_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1928-1938",
          "snippet": "static int graft_tree(struct mount *mnt, struct mount *p, struct mountpoint *mp)\n{\n\tif (mnt->mnt.mnt_sb->s_flags & MS_NOUSER)\n\t\treturn -EINVAL;\n\n\tif (d_is_dir(mp->m_dentry) !=\n\t      d_is_dir(mnt->mnt.mnt_root))\n\t\treturn -ENOTDIR;\n\n\treturn attach_recursive_mnt(mnt, p, mp, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int graft_tree(struct mount *mnt, struct mount *p, struct mountpoint *mp)\n{\n\tif (mnt->mnt.mnt_sb->s_flags & MS_NOUSER)\n\t\treturn -EINVAL;\n\n\tif (d_is_dir(mp->m_dentry) !=\n\t      d_is_dir(mnt->mnt.mnt_root))\n\t\treturn -ENOTDIR;\n\n\treturn attach_recursive_mnt(mnt, p, mp, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mnt"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone_mnt",
          "args": [
            "old",
            "old_path.dentry",
            "0"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "clone_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "955-1037",
          "snippet": "static struct mount *clone_mnt(struct mount *old, struct dentry *root,\n\t\t\t\t\tint flag)\n{\n\tstruct super_block *sb = old->mnt.mnt_sb;\n\tstruct mount *mnt;\n\tint err;\n\n\tmnt = alloc_vfsmnt(old->mnt_devname);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))\n\t\tmnt->mnt_group_id = 0; /* not a peer of original */\n\telse\n\t\tmnt->mnt_group_id = old->mnt_group_id;\n\n\tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {\n\t\terr = mnt_alloc_group_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n\t/* Don't allow unprivileged users to change mount flags */\n\tif (flag & CL_UNPRIVILEGED) {\n\t\tmnt->mnt.mnt_flags |= MNT_LOCK_ATIME;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_READONLY)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NODEV)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NODEV;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOSUID)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOSUID;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOEXEC)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOEXEC;\n\t}\n\n\t/* Don't allow unprivileged users to reveal what is under a mount */\n\tif ((flag & CL_UNPRIVILEGED) &&\n\t    (!(flag & CL_EXPIRE) || list_empty(&old->mnt_expire)))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCKED;\n\n\tatomic_inc(&sb->s_active);\n\tmnt->mnt.mnt_sb = sb;\n\tmnt->mnt.mnt_root = dget(root);\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &sb->s_mounts);\n\tunlock_mount_hash();\n\n\tif ((flag & CL_SLAVE) ||\n\t    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {\n\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave_list);\n\t\tmnt->mnt_master = old;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t} else if (!(flag & CL_PRIVATE)) {\n\t\tif ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))\n\t\t\tlist_add(&mnt->mnt_share, &old->mnt_share);\n\t\tif (IS_MNT_SLAVE(old))\n\t\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave);\n\t\tmnt->mnt_master = old->mnt_master;\n\t}\n\tif (flag & CL_MAKE_SHARED)\n\t\tset_mnt_shared(mnt);\n\n\t/* stick the duplicate mount on the same expiry list\n\t * as the original if that was on one */\n\tif (flag & CL_EXPIRE) {\n\t\tif (!list_empty(&old->mnt_expire))\n\t\t\tlist_add(&mnt->mnt_expire, &old->mnt_expire);\n\t}\n\n\treturn mnt;\n\n out_free:\n\tmnt_free_id(mnt);\n\tfree_vfsmnt(mnt);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic struct mount *clone_mnt(struct mount *old, struct dentry *root,\n\t\t\t\t\tint flag)\n{\n\tstruct super_block *sb = old->mnt.mnt_sb;\n\tstruct mount *mnt;\n\tint err;\n\n\tmnt = alloc_vfsmnt(old->mnt_devname);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))\n\t\tmnt->mnt_group_id = 0; /* not a peer of original */\n\telse\n\t\tmnt->mnt_group_id = old->mnt_group_id;\n\n\tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {\n\t\terr = mnt_alloc_group_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n\t/* Don't allow unprivileged users to change mount flags */\n\tif (flag & CL_UNPRIVILEGED) {\n\t\tmnt->mnt.mnt_flags |= MNT_LOCK_ATIME;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_READONLY)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NODEV)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NODEV;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOSUID)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOSUID;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOEXEC)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOEXEC;\n\t}\n\n\t/* Don't allow unprivileged users to reveal what is under a mount */\n\tif ((flag & CL_UNPRIVILEGED) &&\n\t    (!(flag & CL_EXPIRE) || list_empty(&old->mnt_expire)))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCKED;\n\n\tatomic_inc(&sb->s_active);\n\tmnt->mnt.mnt_sb = sb;\n\tmnt->mnt.mnt_root = dget(root);\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &sb->s_mounts);\n\tunlock_mount_hash();\n\n\tif ((flag & CL_SLAVE) ||\n\t    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {\n\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave_list);\n\t\tmnt->mnt_master = old;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t} else if (!(flag & CL_PRIVATE)) {\n\t\tif ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))\n\t\t\tlist_add(&mnt->mnt_share, &old->mnt_share);\n\t\tif (IS_MNT_SLAVE(old))\n\t\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave);\n\t\tmnt->mnt_master = old->mnt_master;\n\t}\n\tif (flag & CL_MAKE_SHARED)\n\t\tset_mnt_shared(mnt);\n\n\t/* stick the duplicate mount on the same expiry list\n\t * as the original if that was on one */\n\tif (flag & CL_EXPIRE) {\n\t\tif (!list_empty(&old->mnt_expire))\n\t\t\tlist_add(&mnt->mnt_expire, &old->mnt_expire);\n\t}\n\n\treturn mnt;\n\n out_free:\n\tmnt_free_id(mnt);\n\tfree_vfsmnt(mnt);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_tree",
          "args": [
            "old",
            "old_path.dentry",
            "CL_COPY_MNT_NS_FILE"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "copy_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1610-1675",
          "snippet": "struct mount *copy_tree(struct mount *mnt, struct dentry *dentry,\n\t\t\t\t\tint flag)\n{\n\tstruct mount *res, *p, *q, *r, *parent;\n\n\tif (!(flag & CL_COPY_UNBINDABLE) && IS_MNT_UNBINDABLE(mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!(flag & CL_COPY_MNT_NS_FILE) && is_mnt_ns_file(dentry))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tres = q = clone_mnt(mnt, dentry, flag);\n\tif (IS_ERR(q))\n\t\treturn q;\n\n\tq->mnt_mountpoint = mnt->mnt_mountpoint;\n\n\tp = mnt;\n\tlist_for_each_entry(r, &mnt->mnt_mounts, mnt_child) {\n\t\tstruct mount *s;\n\t\tif (!is_subdir(r->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tfor (s = r; s; s = next_mnt(s, r)) {\n\t\t\tstruct mount *t = NULL;\n\t\t\tif (!(flag & CL_COPY_UNBINDABLE) &&\n\t\t\t    IS_MNT_UNBINDABLE(s)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(flag & CL_COPY_MNT_NS_FILE) &&\n\t\t\t    is_mnt_ns_file(s->mnt.mnt_root)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (p != s->mnt_parent) {\n\t\t\t\tp = p->mnt_parent;\n\t\t\t\tq = q->mnt_parent;\n\t\t\t}\n\t\t\tp = s;\n\t\t\tparent = q;\n\t\t\tq = clone_mnt(p, p->mnt.mnt_root, flag);\n\t\t\tif (IS_ERR(q))\n\t\t\t\tgoto out;\n\t\t\tlock_mount_hash();\n\t\t\tlist_add_tail(&q->mnt_list, &res->mnt_list);\n\t\t\tmnt_set_mountpoint(parent, p->mnt_mp, q);\n\t\t\tif (!list_empty(&parent->mnt_mounts)) {\n\t\t\t\tt = list_last_entry(&parent->mnt_mounts,\n\t\t\t\t\tstruct mount, mnt_child);\n\t\t\t\tif (t->mnt_mp != p->mnt_mp)\n\t\t\t\t\tt = NULL;\n\t\t\t}\n\t\t\tattach_shadowed(q, parent, t);\n\t\t\tunlock_mount_hash();\n\t\t}\n\t}\n\treturn res;\nout:\n\tif (res) {\n\t\tlock_mount_hash();\n\t\tumount_tree(res, UMOUNT_SYNC);\n\t\tunlock_mount_hash();\n\t}\n\treturn q;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct mount *copy_tree(struct mount *mnt, struct dentry *dentry,\n\t\t\t\t\tint flag)\n{\n\tstruct mount *res, *p, *q, *r, *parent;\n\n\tif (!(flag & CL_COPY_UNBINDABLE) && IS_MNT_UNBINDABLE(mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!(flag & CL_COPY_MNT_NS_FILE) && is_mnt_ns_file(dentry))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tres = q = clone_mnt(mnt, dentry, flag);\n\tif (IS_ERR(q))\n\t\treturn q;\n\n\tq->mnt_mountpoint = mnt->mnt_mountpoint;\n\n\tp = mnt;\n\tlist_for_each_entry(r, &mnt->mnt_mounts, mnt_child) {\n\t\tstruct mount *s;\n\t\tif (!is_subdir(r->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tfor (s = r; s; s = next_mnt(s, r)) {\n\t\t\tstruct mount *t = NULL;\n\t\t\tif (!(flag & CL_COPY_UNBINDABLE) &&\n\t\t\t    IS_MNT_UNBINDABLE(s)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(flag & CL_COPY_MNT_NS_FILE) &&\n\t\t\t    is_mnt_ns_file(s->mnt.mnt_root)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (p != s->mnt_parent) {\n\t\t\t\tp = p->mnt_parent;\n\t\t\t\tq = q->mnt_parent;\n\t\t\t}\n\t\t\tp = s;\n\t\t\tparent = q;\n\t\t\tq = clone_mnt(p, p->mnt.mnt_root, flag);\n\t\t\tif (IS_ERR(q))\n\t\t\t\tgoto out;\n\t\t\tlock_mount_hash();\n\t\t\tlist_add_tail(&q->mnt_list, &res->mnt_list);\n\t\t\tmnt_set_mountpoint(parent, p->mnt_mp, q);\n\t\t\tif (!list_empty(&parent->mnt_mounts)) {\n\t\t\t\tt = list_last_entry(&parent->mnt_mounts,\n\t\t\t\t\tstruct mount, mnt_child);\n\t\t\t\tif (t->mnt_mp != p->mnt_mp)\n\t\t\t\t\tt = NULL;\n\t\t\t}\n\t\t\tattach_shadowed(q, parent, t);\n\t\t\tunlock_mount_hash();\n\t\t}\n\t}\n\treturn res;\nout:\n\tif (res) {\n\t\tlock_mount_hash();\n\t\tumount_tree(res, UMOUNT_SYNC);\n\t\tunlock_mount_hash();\n\t}\n\treturn q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_locked_children",
          "args": [
            "old",
            "old_path.dentry"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "has_locked_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1992-2003",
          "snippet": "static bool has_locked_children(struct mount *mnt, struct dentry *dentry)\n{\n\tstruct mount *child;\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic bool has_locked_children(struct mount *mnt, struct dentry *dentry)\n{\n\tstruct mount *child;\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_mnt",
          "args": [
            "old"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "check_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "771-774",
          "snippet": "static inline int check_mnt(struct mount *mnt)\n{\n\treturn mnt->mnt_ns == current->nsproxy->mnt_ns;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline int check_mnt(struct mount *mnt)\n{\n\treturn mnt->mnt_ns == current->nsproxy->mnt_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_UNBINDABLE",
          "args": [
            "old"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "path->mnt"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mp"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mp"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_ns_loop",
          "args": [
            "old_path.dentry"
          ],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_ns_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1597-1608",
          "snippet": "static bool mnt_ns_loop(struct dentry *dentry)\n{\n\t/* Could bind mounting the mount namespace inode cause a\n\t * mount namespace loop?\n\t */\n\tstruct mnt_namespace *mnt_ns;\n\tif (!is_mnt_ns_file(dentry))\n\t\treturn false;\n\n\tmnt_ns = to_mnt_ns(get_proc_ns(dentry->d_inode));\n\treturn current->nsproxy->mnt_ns->seq >= mnt_ns->seq;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic bool mnt_ns_loop(struct dentry *dentry)\n{\n\t/* Could bind mounting the mount namespace inode cause a\n\t * mount namespace loop?\n\t */\n\tstruct mnt_namespace *mnt_ns;\n\tif (!is_mnt_ns_file(dentry))\n\t\treturn false;\n\n\tmnt_ns = to_mnt_ns(get_proc_ns(dentry->d_inode));\n\treturn current->nsproxy->mnt_ns->seq >= mnt_ns->seq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "old_name",
            "LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT",
            "&old_path"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "kern_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2089-2096",
          "snippet": "int kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int do_loopback(struct path *path, const char *old_name,\n\t\t\t\tint recurse)\n{\n\tstruct path old_path;\n\tstruct mount *mnt = NULL, *old, *parent;\n\tstruct mountpoint *mp;\n\tint err;\n\tif (!old_name || !*old_name)\n\t\treturn -EINVAL;\n\terr = kern_path(old_name, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &old_path);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tif (mnt_ns_loop(old_path.dentry))\n\t\tgoto out; \n\n\tmp = lock_mount(path);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto out;\n\n\told = real_mount(old_path.mnt);\n\tparent = real_mount(path->mnt);\n\n\terr = -EINVAL;\n\tif (IS_MNT_UNBINDABLE(old))\n\t\tgoto out2;\n\n\tif (!check_mnt(parent))\n\t\tgoto out2;\n\n\tif (!check_mnt(old) && old_path.dentry->d_op != &ns_dentry_operations)\n\t\tgoto out2;\n\n\tif (!recurse && has_locked_children(old, old_path.dentry))\n\t\tgoto out2;\n\n\tif (recurse)\n\t\tmnt = copy_tree(old, old_path.dentry, CL_COPY_MNT_NS_FILE);\n\telse\n\t\tmnt = clone_mnt(old, old_path.dentry, 0);\n\n\tif (IS_ERR(mnt)) {\n\t\terr = PTR_ERR(mnt);\n\t\tgoto out2;\n\t}\n\n\tmnt->mnt.mnt_flags &= ~MNT_LOCKED;\n\n\terr = graft_tree(mnt, parent, mp);\n\tif (err) {\n\t\tlock_mount_hash();\n\t\tumount_tree(mnt, UMOUNT_SYNC);\n\t\tunlock_mount_hash();\n\t}\nout2:\n\tunlock_mount(mp);\nout:\n\tpath_put(&old_path);\n\treturn err;\n}"
  },
  {
    "function_name": "has_locked_children",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1992-2003",
    "snippet": "static bool has_locked_children(struct mount *mnt, struct dentry *dentry)\n{\n\tstruct mount *child;\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_subdir",
          "args": [
            "child->mnt_mountpoint",
            "dentry"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "is_subdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3279-3303",
          "snippet": "int is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)\n{\n\tint result;\n\tunsigned seq;\n\n\tif (new_dentry == old_dentry)\n\t\treturn 1;\n\n\tdo {\n\t\t/* for restarting inner loop in case of seq retry */\n\t\tseq = read_seqbegin(&rename_lock);\n\t\t/*\n\t\t * Need rcu_readlock to protect against the d_parent trashing\n\t\t * due to d_move\n\t\t */\n\t\trcu_read_lock();\n\t\tif (d_ancestor(old_dentry, new_dentry))\n\t\t\tresult = 1;\n\t\telse\n\t\t\tresult = 0;\n\t\trcu_read_unlock();\n\t} while (read_seqretry(&rename_lock, seq));\n\n\treturn result;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nint is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)\n{\n\tint result;\n\tunsigned seq;\n\n\tif (new_dentry == old_dentry)\n\t\treturn 1;\n\n\tdo {\n\t\t/* for restarting inner loop in case of seq retry */\n\t\tseq = read_seqbegin(&rename_lock);\n\t\t/*\n\t\t * Need rcu_readlock to protect against the d_parent trashing\n\t\t * due to d_move\n\t\t */\n\t\trcu_read_lock();\n\t\tif (d_ancestor(old_dentry, new_dentry))\n\t\t\tresult = 1;\n\t\telse\n\t\t\tresult = 0;\n\t\trcu_read_unlock();\n\t} while (read_seqretry(&rename_lock, seq));\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&mnt->mnt_mounts",
            "mnt_child"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic bool has_locked_children(struct mount *mnt, struct dentry *dentry)\n{\n\tstruct mount *child;\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "do_change_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1960-1990",
    "snippet": "static int do_change_type(struct path *path, int flag)\n{\n\tstruct mount *m;\n\tstruct mount *mnt = real_mount(path->mnt);\n\tint recurse = flag & MS_REC;\n\tint type;\n\tint err = 0;\n\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\ttype = flags_to_propagation_type(flag);\n\tif (!type)\n\t\treturn -EINVAL;\n\n\tnamespace_lock();\n\tif (type == MS_SHARED) {\n\t\terr = invent_group_ids(mnt, recurse);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tlock_mount_hash();\n\tfor (m = mnt; m; m = (recurse ? next_mnt(m, mnt) : NULL))\n\t\tchange_mnt_propagation(m, type);\n\tunlock_mount_hash();\n\n out_unlock:\n\tnamespace_unlock();\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "namespace_unlock",
          "args": [],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1320-1334",
          "snippet": "static void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);",
            "static HLIST_HEAD(unmounted);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic HLIST_HEAD(unmounted);\n\nstatic void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_mount_hash",
          "args": [],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "114-117",
          "snippet": "static inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern seqlock_t mount_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern seqlock_t mount_lock;\n\nstatic inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "change_mnt_propagation",
          "args": [
            "m",
            "type"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "change_mnt_propagation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "119-134",
          "snippet": "void change_mnt_propagation(struct mount *mnt, int type)\n{\n\tif (type == MS_SHARED) {\n\t\tset_mnt_shared(mnt);\n\t\treturn;\n\t}\n\tdo_make_slave(mnt);\n\tif (type != MS_SLAVE) {\n\t\tlist_del_init(&mnt->mnt_slave);\n\t\tmnt->mnt_master = NULL;\n\t\tif (type == MS_UNBINDABLE)\n\t\t\tmnt->mnt.mnt_flags |= MNT_UNBINDABLE;\n\t\telse\n\t\t\tmnt->mnt.mnt_flags &= ~MNT_UNBINDABLE;\n\t}\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nvoid change_mnt_propagation(struct mount *mnt, int type)\n{\n\tif (type == MS_SHARED) {\n\t\tset_mnt_shared(mnt);\n\t\treturn;\n\t}\n\tdo_make_slave(mnt);\n\tif (type != MS_SLAVE) {\n\t\tlist_del_init(&mnt->mnt_slave);\n\t\tmnt->mnt_master = NULL;\n\t\tif (type == MS_UNBINDABLE)\n\t\t\tmnt->mnt.mnt_flags |= MNT_UNBINDABLE;\n\t\telse\n\t\t\tmnt->mnt.mnt_flags &= ~MNT_UNBINDABLE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_mnt",
          "args": [
            "m",
            "mnt"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "next_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "895-909",
          "snippet": "static struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}"
        }
      },
      {
        "call_info": {
          "callee": "invent_group_ids",
          "args": [
            "mnt",
            "recurse"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "invent_group_ids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1755-1770",
          "snippet": "static int invent_group_ids(struct mount *mnt, bool recurse)\n{\n\tstruct mount *p;\n\n\tfor (p = mnt; p; p = recurse ? next_mnt(p, mnt) : NULL) {\n\t\tif (!p->mnt_group_id && !IS_MNT_SHARED(p)) {\n\t\t\tint err = mnt_alloc_group_id(p);\n\t\t\tif (err) {\n\t\t\t\tcleanup_group_ids(mnt, p);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int invent_group_ids(struct mount *mnt, bool recurse)\n{\n\tstruct mount *p;\n\n\tfor (p = mnt; p; p = recurse ? next_mnt(p, mnt) : NULL) {\n\t\tif (!p->mnt_group_id && !IS_MNT_SHARED(p)) {\n\t\t\tint err = mnt_alloc_group_id(p);\n\t\t\tif (err) {\n\t\t\t\tcleanup_group_ids(mnt, p);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "namespace_lock",
          "args": [],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1336-1339",
          "snippet": "static inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\n\nstatic inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flags_to_propagation_type",
          "args": [
            "flag"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "flags_to_propagation_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1944-1955",
          "snippet": "static int flags_to_propagation_type(int flags)\n{\n\tint type = flags & ~(MS_REC | MS_SILENT);\n\n\t/* Fail if any non-propagation flags are set */\n\tif (type & ~(MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))\n\t\treturn 0;\n\t/* Only one propagation flag should be set */\n\tif (!is_power_of_2(type))\n\t\treturn 0;\n\treturn type;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int flags_to_propagation_type(int flags)\n{\n\tint type = flags & ~(MS_REC | MS_SILENT);\n\n\t/* Fail if any non-propagation flags are set */\n\tif (type & ~(MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))\n\t\treturn 0;\n\t/* Only one propagation flag should be set */\n\tif (!is_power_of_2(type))\n\t\treturn 0;\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "path->mnt"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int do_change_type(struct path *path, int flag)\n{\n\tstruct mount *m;\n\tstruct mount *mnt = real_mount(path->mnt);\n\tint recurse = flag & MS_REC;\n\tint type;\n\tint err = 0;\n\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\ttype = flags_to_propagation_type(flag);\n\tif (!type)\n\t\treturn -EINVAL;\n\n\tnamespace_lock();\n\tif (type == MS_SHARED) {\n\t\terr = invent_group_ids(mnt, recurse);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tlock_mount_hash();\n\tfor (m = mnt; m; m = (recurse ? next_mnt(m, mnt) : NULL))\n\t\tchange_mnt_propagation(m, type);\n\tunlock_mount_hash();\n\n out_unlock:\n\tnamespace_unlock();\n\treturn err;\n}"
  },
  {
    "function_name": "flags_to_propagation_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1944-1955",
    "snippet": "static int flags_to_propagation_type(int flags)\n{\n\tint type = flags & ~(MS_REC | MS_SILENT);\n\n\t/* Fail if any non-propagation flags are set */\n\tif (type & ~(MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))\n\t\treturn 0;\n\t/* Only one propagation flag should be set */\n\tif (!is_power_of_2(type))\n\t\treturn 0;\n\treturn type;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "type"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int flags_to_propagation_type(int flags)\n{\n\tint type = flags & ~(MS_REC | MS_SILENT);\n\n\t/* Fail if any non-propagation flags are set */\n\tif (type & ~(MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))\n\t\treturn 0;\n\t/* Only one propagation flag should be set */\n\tif (!is_power_of_2(type))\n\t\treturn 0;\n\treturn type;\n}"
  },
  {
    "function_name": "graft_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1928-1938",
    "snippet": "static int graft_tree(struct mount *mnt, struct mount *p, struct mountpoint *mp)\n{\n\tif (mnt->mnt.mnt_sb->s_flags & MS_NOUSER)\n\t\treturn -EINVAL;\n\n\tif (d_is_dir(mp->m_dentry) !=\n\t      d_is_dir(mnt->mnt.mnt_root))\n\t\treturn -ENOTDIR;\n\n\treturn attach_recursive_mnt(mnt, p, mp, NULL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "attach_recursive_mnt",
          "args": [
            "mnt",
            "p",
            "mp",
            "NULL"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "attach_recursive_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1835-1887",
          "snippet": "static int attach_recursive_mnt(struct mount *source_mnt,\n\t\t\tstruct mount *dest_mnt,\n\t\t\tstruct mountpoint *dest_mp,\n\t\t\tstruct path *parent_path)\n{\n\tHLIST_HEAD(tree_list);\n\tstruct mount *child, *p;\n\tstruct hlist_node *n;\n\tint err;\n\n\tif (IS_MNT_SHARED(dest_mnt)) {\n\t\terr = invent_group_ids(source_mnt, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = propagate_mnt(dest_mnt, dest_mp, source_mnt, &tree_list);\n\t\tlock_mount_hash();\n\t\tif (err)\n\t\t\tgoto out_cleanup_ids;\n\t\tfor (p = source_mnt; p; p = next_mnt(p, source_mnt))\n\t\t\tset_mnt_shared(p);\n\t} else {\n\t\tlock_mount_hash();\n\t}\n\tif (parent_path) {\n\t\tdetach_mnt(source_mnt, parent_path);\n\t\tattach_mnt(source_mnt, dest_mnt, dest_mp);\n\t\ttouch_mnt_namespace(source_mnt->mnt_ns);\n\t} else {\n\t\tmnt_set_mountpoint(dest_mnt, dest_mp, source_mnt);\n\t\tcommit_tree(source_mnt, NULL);\n\t}\n\n\thlist_for_each_entry_safe(child, n, &tree_list, mnt_hash) {\n\t\tstruct mount *q;\n\t\thlist_del_init(&child->mnt_hash);\n\t\tq = __lookup_mnt_last(&child->mnt_parent->mnt,\n\t\t\t\t      child->mnt_mountpoint);\n\t\tcommit_tree(child, q);\n\t}\n\tunlock_mount_hash();\n\n\treturn 0;\n\n out_cleanup_ids:\n\twhile (!hlist_empty(&tree_list)) {\n\t\tchild = hlist_entry(tree_list.first, struct mount, mnt_hash);\n\t\tumount_tree(child, UMOUNT_SYNC);\n\t}\n\tunlock_mount_hash();\n\tcleanup_group_ids(source_mnt, NULL);\n out:\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int attach_recursive_mnt(struct mount *source_mnt,\n\t\t\tstruct mount *dest_mnt,\n\t\t\tstruct mountpoint *dest_mp,\n\t\t\tstruct path *parent_path)\n{\n\tHLIST_HEAD(tree_list);\n\tstruct mount *child, *p;\n\tstruct hlist_node *n;\n\tint err;\n\n\tif (IS_MNT_SHARED(dest_mnt)) {\n\t\terr = invent_group_ids(source_mnt, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = propagate_mnt(dest_mnt, dest_mp, source_mnt, &tree_list);\n\t\tlock_mount_hash();\n\t\tif (err)\n\t\t\tgoto out_cleanup_ids;\n\t\tfor (p = source_mnt; p; p = next_mnt(p, source_mnt))\n\t\t\tset_mnt_shared(p);\n\t} else {\n\t\tlock_mount_hash();\n\t}\n\tif (parent_path) {\n\t\tdetach_mnt(source_mnt, parent_path);\n\t\tattach_mnt(source_mnt, dest_mnt, dest_mp);\n\t\ttouch_mnt_namespace(source_mnt->mnt_ns);\n\t} else {\n\t\tmnt_set_mountpoint(dest_mnt, dest_mp, source_mnt);\n\t\tcommit_tree(source_mnt, NULL);\n\t}\n\n\thlist_for_each_entry_safe(child, n, &tree_list, mnt_hash) {\n\t\tstruct mount *q;\n\t\thlist_del_init(&child->mnt_hash);\n\t\tq = __lookup_mnt_last(&child->mnt_parent->mnt,\n\t\t\t\t      child->mnt_mountpoint);\n\t\tcommit_tree(child, q);\n\t}\n\tunlock_mount_hash();\n\n\treturn 0;\n\n out_cleanup_ids:\n\twhile (!hlist_empty(&tree_list)) {\n\t\tchild = hlist_entry(tree_list.first, struct mount, mnt_hash);\n\t\tumount_tree(child, UMOUNT_SYNC);\n\t}\n\tunlock_mount_hash();\n\tcleanup_group_ids(source_mnt, NULL);\n out:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "mnt->mnt.mnt_root"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "mp->m_dentry"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int graft_tree(struct mount *mnt, struct mount *p, struct mountpoint *mp)\n{\n\tif (mnt->mnt.mnt_sb->s_flags & MS_NOUSER)\n\t\treturn -EINVAL;\n\n\tif (d_is_dir(mp->m_dentry) !=\n\t      d_is_dir(mnt->mnt.mnt_root))\n\t\treturn -ENOTDIR;\n\n\treturn attach_recursive_mnt(mnt, p, mp, NULL);\n}"
  },
  {
    "function_name": "unlock_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1920-1926",
    "snippet": "static void unlock_mount(struct mountpoint *where)\n{\n\tstruct dentry *dentry = where->m_dentry;\n\tput_mountpoint(where);\n\tnamespace_unlock();\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namespace_unlock",
          "args": [],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1320-1334",
          "snippet": "static void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);",
            "static HLIST_HEAD(unmounted);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic HLIST_HEAD(unmounted);\n\nstatic void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_mountpoint",
          "args": [
            "where"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "put_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "758-769",
          "snippet": "static void put_mountpoint(struct mountpoint *mp)\n{\n\tif (!--mp->m_count) {\n\t\tstruct dentry *dentry = mp->m_dentry;\n\t\tBUG_ON(!hlist_empty(&mp->m_list));\n\t\tspin_lock(&dentry->d_lock);\n\t\tdentry->d_flags &= ~DCACHE_MOUNTED;\n\t\tspin_unlock(&dentry->d_lock);\n\t\thlist_del(&mp->m_hash);\n\t\tkfree(mp);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void put_mountpoint(struct mountpoint *mp)\n{\n\tif (!--mp->m_count) {\n\t\tstruct dentry *dentry = mp->m_dentry;\n\t\tBUG_ON(!hlist_empty(&mp->m_list));\n\t\tspin_lock(&dentry->d_lock);\n\t\tdentry->d_flags &= ~DCACHE_MOUNTED;\n\t\tspin_unlock(&dentry->d_lock);\n\t\thlist_del(&mp->m_hash);\n\t\tkfree(mp);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void unlock_mount(struct mountpoint *where)\n{\n\tstruct dentry *dentry = where->m_dentry;\n\tput_mountpoint(where);\n\tnamespace_unlock();\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n}"
  },
  {
    "function_name": "lock_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1889-1918",
    "snippet": "static struct mountpoint *lock_mount(struct path *path)\n{\n\tstruct vfsmount *mnt;\n\tstruct dentry *dentry = path->dentry;\nretry:\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tif (unlikely(cant_mount(dentry))) {\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tnamespace_lock();\n\tmnt = lookup_mnt(path);\n\tif (likely(!mnt)) {\n\t\tstruct mountpoint *mp = lookup_mountpoint(dentry);\n\t\tif (!mp)\n\t\t\tmp = new_mountpoint(dentry);\n\t\tif (IS_ERR(mp)) {\n\t\t\tnamespace_unlock();\n\t\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\t\treturn mp;\n\t\t}\n\t\treturn mp;\n\t}\n\tnamespace_unlock();\n\tmutex_unlock(&path->dentry->d_inode->i_mutex);\n\tpath_put(path);\n\tpath->mnt = mnt;\n\tdentry = path->dentry = dget(mnt->mnt_root);\n\tgoto retry;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "mnt->mnt_root"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "path"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&path->dentry->d_inode->i_mutex"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namespace_unlock",
          "args": [],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1320-1334",
          "snippet": "static void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);",
            "static HLIST_HEAD(unmounted);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic HLIST_HEAD(unmounted);\n\nstatic void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mp"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_mountpoint",
          "args": [
            "dentry"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "new_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "735-756",
          "snippet": "static struct mountpoint *new_mountpoint(struct dentry *dentry)\n{\n\tstruct hlist_head *chain = mp_hash(dentry);\n\tstruct mountpoint *mp;\n\tint ret;\n\n\tmp = kmalloc(sizeof(struct mountpoint), GFP_KERNEL);\n\tif (!mp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = d_set_mounted(dentry);\n\tif (ret) {\n\t\tkfree(mp);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tmp->m_dentry = dentry;\n\tmp->m_count = 1;\n\thlist_add_head(&mp->m_hash, chain);\n\tINIT_HLIST_HEAD(&mp->m_list);\n\treturn mp;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct mountpoint *new_mountpoint(struct dentry *dentry)\n{\n\tstruct hlist_head *chain = mp_hash(dentry);\n\tstruct mountpoint *mp;\n\tint ret;\n\n\tmp = kmalloc(sizeof(struct mountpoint), GFP_KERNEL);\n\tif (!mp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = d_set_mounted(dentry);\n\tif (ret) {\n\t\tkfree(mp);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tmp->m_dentry = dentry;\n\tmp->m_count = 1;\n\thlist_add_head(&mp->m_hash, chain);\n\tINIT_HLIST_HEAD(&mp->m_list);\n\treturn mp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_mountpoint",
          "args": [
            "dentry"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "718-733",
          "snippet": "static struct mountpoint *lookup_mountpoint(struct dentry *dentry)\n{\n\tstruct hlist_head *chain = mp_hash(dentry);\n\tstruct mountpoint *mp;\n\n\thlist_for_each_entry(mp, chain, m_hash) {\n\t\tif (mp->m_dentry == dentry) {\n\t\t\t/* might be worth a WARN_ON() */\n\t\t\tif (d_unlinked(dentry))\n\t\t\t\treturn ERR_PTR(-ENOENT);\n\t\t\tmp->m_count++;\n\t\t\treturn mp;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct mountpoint *lookup_mountpoint(struct dentry *dentry)\n{\n\tstruct hlist_head *chain = mp_hash(dentry);\n\tstruct mountpoint *mp;\n\n\thlist_for_each_entry(mp, chain, m_hash) {\n\t\tif (mp->m_dentry == dentry) {\n\t\t\t/* might be worth a WARN_ON() */\n\t\t\tif (d_unlinked(dentry))\n\t\t\t\treturn ERR_PTR(-ENOENT);\n\t\t\tmp->m_count++;\n\t\t\treturn mp;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!mnt"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_mnt",
          "args": [
            "path"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "667-681",
          "snippet": "struct vfsmount *lookup_mnt(struct path *path)\n{\n\tstruct mount *child_mnt;\n\tstruct vfsmount *m;\n\tunsigned seq;\n\n\trcu_read_lock();\n\tdo {\n\t\tseq = read_seqbegin(&mount_lock);\n\t\tchild_mnt = __lookup_mnt(path->mnt, path->dentry);\n\t\tm = child_mnt ? &child_mnt->mnt : NULL;\n\t} while (!legitimize_mnt(m, seq));\n\trcu_read_unlock();\n\treturn m;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(mount_lock);",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(mount_lock);\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *lookup_mnt(struct path *path)\n{\n\tstruct mount *child_mnt;\n\tstruct vfsmount *m;\n\tunsigned seq;\n\n\trcu_read_lock();\n\tdo {\n\t\tseq = read_seqbegin(&mount_lock);\n\t\tchild_mnt = __lookup_mnt(path->mnt, path->dentry);\n\t\tm = child_mnt ? &child_mnt->mnt : NULL;\n\t} while (!legitimize_mnt(m, seq));\n\trcu_read_unlock();\n\treturn m;\n}"
        }
      },
      {
        "call_info": {
          "callee": "namespace_lock",
          "args": [],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1336-1339",
          "snippet": "static inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\n\nstatic inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cant_mount(dentry)"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cant_mount",
          "args": [
            "dentry"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic struct mountpoint *lock_mount(struct path *path)\n{\n\tstruct vfsmount *mnt;\n\tstruct dentry *dentry = path->dentry;\nretry:\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tif (unlikely(cant_mount(dentry))) {\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tnamespace_lock();\n\tmnt = lookup_mnt(path);\n\tif (likely(!mnt)) {\n\t\tstruct mountpoint *mp = lookup_mountpoint(dentry);\n\t\tif (!mp)\n\t\t\tmp = new_mountpoint(dentry);\n\t\tif (IS_ERR(mp)) {\n\t\t\tnamespace_unlock();\n\t\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t\t\treturn mp;\n\t\t}\n\t\treturn mp;\n\t}\n\tnamespace_unlock();\n\tmutex_unlock(&path->dentry->d_inode->i_mutex);\n\tpath_put(path);\n\tpath->mnt = mnt;\n\tdentry = path->dentry = dget(mnt->mnt_root);\n\tgoto retry;\n}"
  },
  {
    "function_name": "attach_recursive_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1835-1887",
    "snippet": "static int attach_recursive_mnt(struct mount *source_mnt,\n\t\t\tstruct mount *dest_mnt,\n\t\t\tstruct mountpoint *dest_mp,\n\t\t\tstruct path *parent_path)\n{\n\tHLIST_HEAD(tree_list);\n\tstruct mount *child, *p;\n\tstruct hlist_node *n;\n\tint err;\n\n\tif (IS_MNT_SHARED(dest_mnt)) {\n\t\terr = invent_group_ids(source_mnt, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = propagate_mnt(dest_mnt, dest_mp, source_mnt, &tree_list);\n\t\tlock_mount_hash();\n\t\tif (err)\n\t\t\tgoto out_cleanup_ids;\n\t\tfor (p = source_mnt; p; p = next_mnt(p, source_mnt))\n\t\t\tset_mnt_shared(p);\n\t} else {\n\t\tlock_mount_hash();\n\t}\n\tif (parent_path) {\n\t\tdetach_mnt(source_mnt, parent_path);\n\t\tattach_mnt(source_mnt, dest_mnt, dest_mp);\n\t\ttouch_mnt_namespace(source_mnt->mnt_ns);\n\t} else {\n\t\tmnt_set_mountpoint(dest_mnt, dest_mp, source_mnt);\n\t\tcommit_tree(source_mnt, NULL);\n\t}\n\n\thlist_for_each_entry_safe(child, n, &tree_list, mnt_hash) {\n\t\tstruct mount *q;\n\t\thlist_del_init(&child->mnt_hash);\n\t\tq = __lookup_mnt_last(&child->mnt_parent->mnt,\n\t\t\t\t      child->mnt_mountpoint);\n\t\tcommit_tree(child, q);\n\t}\n\tunlock_mount_hash();\n\n\treturn 0;\n\n out_cleanup_ids:\n\twhile (!hlist_empty(&tree_list)) {\n\t\tchild = hlist_entry(tree_list.first, struct mount, mnt_hash);\n\t\tumount_tree(child, UMOUNT_SYNC);\n\t}\n\tunlock_mount_hash();\n\tcleanup_group_ids(source_mnt, NULL);\n out:\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_group_ids",
          "args": [
            "source_mnt",
            "NULL"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_group_ids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1745-1753",
          "snippet": "static void cleanup_group_ids(struct mount *mnt, struct mount *end)\n{\n\tstruct mount *p;\n\n\tfor (p = mnt; p != end; p = next_mnt(p, mnt)) {\n\t\tif (p->mnt_group_id && !IS_MNT_SHARED(p))\n\t\t\tmnt_release_group_id(p);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void cleanup_group_ids(struct mount *mnt, struct mount *end)\n{\n\tstruct mount *p;\n\n\tfor (p = mnt; p != end; p = next_mnt(p, mnt)) {\n\t\tif (p->mnt_group_id && !IS_MNT_SHARED(p))\n\t\t\tmnt_release_group_id(p);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_mount_hash",
          "args": [],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "114-117",
          "snippet": "static inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern seqlock_t mount_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern seqlock_t mount_lock;\n\nstatic inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umount_tree",
          "args": [
            "child",
            "UMOUNT_SYNC"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "umount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1349-1388",
          "snippet": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static HLIST_HEAD(unmounted);",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic HLIST_HEAD(unmounted);\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "tree_list.first",
            "structmount",
            "mnt_hash"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&tree_list"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit_tree",
          "args": [
            "child",
            "q"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "commit_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "876-893",
          "snippet": "static void commit_tree(struct mount *mnt, struct mount *shadows)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m;\n\tLIST_HEAD(head);\n\tstruct mnt_namespace *n = parent->mnt_ns;\n\n\tBUG_ON(parent == mnt);\n\n\tlist_add_tail(&head, &mnt->mnt_list);\n\tlist_for_each_entry(m, &head, mnt_list)\n\t\tm->mnt_ns = n;\n\n\tlist_splice(&head, n->list.prev);\n\n\tattach_shadowed(mnt, parent, shadows);\n\ttouch_mnt_namespace(n);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void commit_tree(struct mount *mnt, struct mount *shadows)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m;\n\tLIST_HEAD(head);\n\tstruct mnt_namespace *n = parent->mnt_ns;\n\n\tBUG_ON(parent == mnt);\n\n\tlist_add_tail(&head, &mnt->mnt_list);\n\tlist_for_each_entry(m, &head, mnt_list)\n\t\tm->mnt_ns = n;\n\n\tlist_splice(&head, n->list.prev);\n\n\tattach_shadowed(mnt, parent, shadows);\n\ttouch_mnt_namespace(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lookup_mnt_last",
          "args": [
            "&child->mnt_parent->mnt",
            "child->mnt_mountpoint"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_mnt_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "633-649",
          "snippet": "struct mount *__lookup_mnt_last(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct mount *p, *res = NULL;\n\tp = __lookup_mnt(mnt, dentry);\n\tif (!p)\n\t\tgoto out;\n\tif (!(p->mnt.mnt_flags & MNT_UMOUNT))\n\t\tres = p;\n\thlist_for_each_entry_continue(p, mnt_hash) {\n\t\tif (&p->mnt_parent->mnt != mnt || p->mnt_mountpoint != dentry)\n\t\t\tbreak;\n\t\tif (!(p->mnt.mnt_flags & MNT_UMOUNT))\n\t\t\tres = p;\n\t}\nout:\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct mount *__lookup_mnt_last(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct mount *p, *res = NULL;\n\tp = __lookup_mnt(mnt, dentry);\n\tif (!p)\n\t\tgoto out;\n\tif (!(p->mnt.mnt_flags & MNT_UMOUNT))\n\t\tres = p;\n\thlist_for_each_entry_continue(p, mnt_hash) {\n\t\tif (&p->mnt_parent->mnt != mnt || p->mnt_mountpoint != dentry)\n\t\t\tbreak;\n\t\tif (!(p->mnt.mnt_flags & MNT_UMOUNT))\n\t\t\tres = p;\n\t}\nout:\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&child->mnt_hash"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "child",
            "n",
            "&tree_list",
            "mnt_hash"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_set_mountpoint",
          "args": [
            "dest_mnt",
            "dest_mp",
            "source_mnt"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_set_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "835-845",
          "snippet": "void mnt_set_mountpoint(struct mount *mnt,\n\t\t\tstruct mountpoint *mp,\n\t\t\tstruct mount *child_mnt)\n{\n\tmp->m_count++;\n\tmnt_add_count(mnt, 1);\t/* essentially, that's mntget */\n\tchild_mnt->mnt_mountpoint = dget(mp->m_dentry);\n\tchild_mnt->mnt_parent = mnt;\n\tchild_mnt->mnt_mp = mp;\n\thlist_add_head(&child_mnt->mnt_mp_list, &mp->m_list);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_set_mountpoint(struct mount *mnt,\n\t\t\tstruct mountpoint *mp,\n\t\t\tstruct mount *child_mnt)\n{\n\tmp->m_count++;\n\tmnt_add_count(mnt, 1);\t/* essentially, that's mntget */\n\tchild_mnt->mnt_mountpoint = dget(mp->m_dentry);\n\tchild_mnt->mnt_parent = mnt;\n\tchild_mnt->mnt_mp = mp;\n\thlist_add_head(&child_mnt->mnt_mp_list, &mp->m_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_mnt_namespace",
          "args": [
            "source_mnt->mnt_ns"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "__touch_mnt_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "790-796",
          "snippet": "static void __touch_mnt_namespace(struct mnt_namespace *ns)\n{\n\tif (ns && ns->event != event) {\n\t\tns->event = event;\n\t\twake_up_interruptible(&ns->poll);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 event;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic u64 event;\n\nstatic void __touch_mnt_namespace(struct mnt_namespace *ns)\n{\n\tif (ns && ns->event != event) {\n\t\tns->event = event;\n\t\twake_up_interruptible(&ns->poll);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_mnt",
          "args": [
            "source_mnt",
            "dest_mnt",
            "dest_mp"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "attach_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "850-857",
          "snippet": "static void attach_mnt(struct mount *mnt,\n\t\t\tstruct mount *parent,\n\t\t\tstruct mountpoint *mp)\n{\n\tmnt_set_mountpoint(parent, mp, mnt);\n\thlist_add_head_rcu(&mnt->mnt_hash, m_hash(&parent->mnt, mp->m_dentry));\n\tlist_add_tail(&mnt->mnt_child, &parent->mnt_mounts);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void attach_mnt(struct mount *mnt,\n\t\t\tstruct mount *parent,\n\t\t\tstruct mountpoint *mp)\n{\n\tmnt_set_mountpoint(parent, mp, mnt);\n\thlist_add_head_rcu(&mnt->mnt_hash, m_hash(&parent->mnt, mp->m_dentry));\n\tlist_add_tail(&mnt->mnt_child, &parent->mnt_mounts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "detach_mnt",
          "args": [
            "source_mnt",
            "parent_path"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "detach_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "815-820",
          "snippet": "static void detach_mnt(struct mount *mnt, struct path *old_path)\n{\n\told_path->dentry = mnt->mnt_mountpoint;\n\told_path->mnt = &mnt->mnt_parent->mnt;\n\tunhash_mnt(mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void detach_mnt(struct mount *mnt, struct path *old_path)\n{\n\told_path->dentry = mnt->mnt_mountpoint;\n\told_path->mnt = &mnt->mnt_parent->mnt;\n\tunhash_mnt(mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_mnt_shared",
          "args": [
            "p"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "set_mnt_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.h",
          "lines": "35-39",
          "snippet": "static inline void set_mnt_shared(struct mount *mnt)\n{\n\tmnt->mnt.mnt_flags &= ~MNT_SHARED_MASK;\n\tmnt->mnt.mnt_flags |= MNT_SHARED;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/list.h>\n\nstatic inline void set_mnt_shared(struct mount *mnt)\n{\n\tmnt->mnt.mnt_flags &= ~MNT_SHARED_MASK;\n\tmnt->mnt.mnt_flags |= MNT_SHARED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_mnt",
          "args": [
            "p",
            "source_mnt"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "next_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "895-909",
          "snippet": "static struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}"
        }
      },
      {
        "call_info": {
          "callee": "propagate_mnt",
          "args": [
            "dest_mnt",
            "dest_mp",
            "source_mnt",
            "&tree_list"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "propagate_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "271-317",
          "snippet": "int propagate_mnt(struct mount *dest_mnt, struct mountpoint *dest_mp,\n\t\t    struct mount *source_mnt, struct hlist_head *tree_list)\n{\n\tstruct mount *m, *n;\n\tint ret = 0;\n\n\t/*\n\t * we don't want to bother passing tons of arguments to\n\t * propagate_one(); everything is serialized by namespace_sem,\n\t * so globals will do just fine.\n\t */\n\tuser_ns = current->nsproxy->mnt_ns->user_ns;\n\tlast_dest = dest_mnt;\n\tlast_source = source_mnt;\n\tmp = dest_mp;\n\tlist = tree_list;\n\tdest_master = dest_mnt->mnt_master;\n\n\t/* all peers of dest_mnt, except dest_mnt itself */\n\tfor (n = next_peer(dest_mnt); n != dest_mnt; n = next_peer(n)) {\n\t\tret = propagate_one(n);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/* all slave groups */\n\tfor (m = next_group(dest_mnt, dest_mnt); m;\n\t\t\tm = next_group(m, dest_mnt)) {\n\t\t/* everything in that slave group */\n\t\tn = m;\n\t\tdo {\n\t\t\tret = propagate_one(n);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tn = next_peer(n);\n\t\t} while (n != m);\n\t}\nout:\n\tread_seqlock_excl(&mount_lock);\n\thlist_for_each_entry(n, tree_list, mnt_hash) {\n\t\tm = n->mnt_parent;\n\t\tif (m->mnt_master != dest_mnt->mnt_master)\n\t\t\tCLEAR_MNT_MARK(m->mnt_master);\n\t}\n\tread_sequnlock_excl(&mount_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct user_namespace *user_ns;",
            "static struct mount *last_dest, *last_source, *dest_master;",
            "static struct mountpoint *mp;",
            "static struct hlist_head *list;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct user_namespace *user_ns;\nstatic struct mount *last_dest, *last_source, *dest_master;\nstatic struct mountpoint *mp;\nstatic struct hlist_head *list;\n\nint propagate_mnt(struct mount *dest_mnt, struct mountpoint *dest_mp,\n\t\t    struct mount *source_mnt, struct hlist_head *tree_list)\n{\n\tstruct mount *m, *n;\n\tint ret = 0;\n\n\t/*\n\t * we don't want to bother passing tons of arguments to\n\t * propagate_one(); everything is serialized by namespace_sem,\n\t * so globals will do just fine.\n\t */\n\tuser_ns = current->nsproxy->mnt_ns->user_ns;\n\tlast_dest = dest_mnt;\n\tlast_source = source_mnt;\n\tmp = dest_mp;\n\tlist = tree_list;\n\tdest_master = dest_mnt->mnt_master;\n\n\t/* all peers of dest_mnt, except dest_mnt itself */\n\tfor (n = next_peer(dest_mnt); n != dest_mnt; n = next_peer(n)) {\n\t\tret = propagate_one(n);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/* all slave groups */\n\tfor (m = next_group(dest_mnt, dest_mnt); m;\n\t\t\tm = next_group(m, dest_mnt)) {\n\t\t/* everything in that slave group */\n\t\tn = m;\n\t\tdo {\n\t\t\tret = propagate_one(n);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tn = next_peer(n);\n\t\t} while (n != m);\n\t}\nout:\n\tread_seqlock_excl(&mount_lock);\n\thlist_for_each_entry(n, tree_list, mnt_hash) {\n\t\tm = n->mnt_parent;\n\t\tif (m->mnt_master != dest_mnt->mnt_master)\n\t\t\tCLEAR_MNT_MARK(m->mnt_master);\n\t}\n\tread_sequnlock_excl(&mount_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invent_group_ids",
          "args": [
            "source_mnt",
            "true"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "invent_group_ids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1755-1770",
          "snippet": "static int invent_group_ids(struct mount *mnt, bool recurse)\n{\n\tstruct mount *p;\n\n\tfor (p = mnt; p; p = recurse ? next_mnt(p, mnt) : NULL) {\n\t\tif (!p->mnt_group_id && !IS_MNT_SHARED(p)) {\n\t\t\tint err = mnt_alloc_group_id(p);\n\t\t\tif (err) {\n\t\t\t\tcleanup_group_ids(mnt, p);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int invent_group_ids(struct mount *mnt, bool recurse)\n{\n\tstruct mount *p;\n\n\tfor (p = mnt; p; p = recurse ? next_mnt(p, mnt) : NULL) {\n\t\tif (!p->mnt_group_id && !IS_MNT_SHARED(p)) {\n\t\t\tint err = mnt_alloc_group_id(p);\n\t\t\tif (err) {\n\t\t\t\tcleanup_group_ids(mnt, p);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_SHARED",
          "args": [
            "dest_mnt"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HLIST_HEAD",
          "args": [
            "tree_list"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int attach_recursive_mnt(struct mount *source_mnt,\n\t\t\tstruct mount *dest_mnt,\n\t\t\tstruct mountpoint *dest_mp,\n\t\t\tstruct path *parent_path)\n{\n\tHLIST_HEAD(tree_list);\n\tstruct mount *child, *p;\n\tstruct hlist_node *n;\n\tint err;\n\n\tif (IS_MNT_SHARED(dest_mnt)) {\n\t\terr = invent_group_ids(source_mnt, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = propagate_mnt(dest_mnt, dest_mp, source_mnt, &tree_list);\n\t\tlock_mount_hash();\n\t\tif (err)\n\t\t\tgoto out_cleanup_ids;\n\t\tfor (p = source_mnt; p; p = next_mnt(p, source_mnt))\n\t\t\tset_mnt_shared(p);\n\t} else {\n\t\tlock_mount_hash();\n\t}\n\tif (parent_path) {\n\t\tdetach_mnt(source_mnt, parent_path);\n\t\tattach_mnt(source_mnt, dest_mnt, dest_mp);\n\t\ttouch_mnt_namespace(source_mnt->mnt_ns);\n\t} else {\n\t\tmnt_set_mountpoint(dest_mnt, dest_mp, source_mnt);\n\t\tcommit_tree(source_mnt, NULL);\n\t}\n\n\thlist_for_each_entry_safe(child, n, &tree_list, mnt_hash) {\n\t\tstruct mount *q;\n\t\thlist_del_init(&child->mnt_hash);\n\t\tq = __lookup_mnt_last(&child->mnt_parent->mnt,\n\t\t\t\t      child->mnt_mountpoint);\n\t\tcommit_tree(child, q);\n\t}\n\tunlock_mount_hash();\n\n\treturn 0;\n\n out_cleanup_ids:\n\twhile (!hlist_empty(&tree_list)) {\n\t\tchild = hlist_entry(tree_list.first, struct mount, mnt_hash);\n\t\tumount_tree(child, UMOUNT_SYNC);\n\t}\n\tunlock_mount_hash();\n\tcleanup_group_ids(source_mnt, NULL);\n out:\n\treturn err;\n}"
  },
  {
    "function_name": "invent_group_ids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1755-1770",
    "snippet": "static int invent_group_ids(struct mount *mnt, bool recurse)\n{\n\tstruct mount *p;\n\n\tfor (p = mnt; p; p = recurse ? next_mnt(p, mnt) : NULL) {\n\t\tif (!p->mnt_group_id && !IS_MNT_SHARED(p)) {\n\t\t\tint err = mnt_alloc_group_id(p);\n\t\t\tif (err) {\n\t\t\t\tcleanup_group_ids(mnt, p);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_group_ids",
          "args": [
            "mnt",
            "p"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_group_ids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1745-1753",
          "snippet": "static void cleanup_group_ids(struct mount *mnt, struct mount *end)\n{\n\tstruct mount *p;\n\n\tfor (p = mnt; p != end; p = next_mnt(p, mnt)) {\n\t\tif (p->mnt_group_id && !IS_MNT_SHARED(p))\n\t\t\tmnt_release_group_id(p);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void cleanup_group_ids(struct mount *mnt, struct mount *end)\n{\n\tstruct mount *p;\n\n\tfor (p = mnt; p != end; p = next_mnt(p, mnt)) {\n\t\tif (p->mnt_group_id && !IS_MNT_SHARED(p))\n\t\t\tmnt_release_group_id(p);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_alloc_group_id",
          "args": [
            "p"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_alloc_group_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "132-146",
          "snippet": "static int mnt_alloc_group_id(struct mount *mnt)\n{\n\tint res;\n\n\tif (!ida_pre_get(&mnt_group_ida, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tres = ida_get_new_above(&mnt_group_ida,\n\t\t\t\tmnt_group_start,\n\t\t\t\t&mnt->mnt_group_id);\n\tif (!res)\n\t\tmnt_group_start = mnt->mnt_group_id + 1;\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDA(mnt_group_ida);",
            "static int mnt_group_start = 1;",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_IDA(mnt_group_ida);\nstatic int mnt_group_start = 1;\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int mnt_alloc_group_id(struct mount *mnt)\n{\n\tint res;\n\n\tif (!ida_pre_get(&mnt_group_ida, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tres = ida_get_new_above(&mnt_group_ida,\n\t\t\t\tmnt_group_start,\n\t\t\t\t&mnt->mnt_group_id);\n\tif (!res)\n\t\tmnt_group_start = mnt->mnt_group_id + 1;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_SHARED",
          "args": [
            "p"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_mnt",
          "args": [
            "p",
            "mnt"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "next_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "895-909",
          "snippet": "static struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int invent_group_ids(struct mount *mnt, bool recurse)\n{\n\tstruct mount *p;\n\n\tfor (p = mnt; p; p = recurse ? next_mnt(p, mnt) : NULL) {\n\t\tif (!p->mnt_group_id && !IS_MNT_SHARED(p)) {\n\t\t\tint err = mnt_alloc_group_id(p);\n\t\t\tif (err) {\n\t\t\t\tcleanup_group_ids(mnt, p);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cleanup_group_ids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1745-1753",
    "snippet": "static void cleanup_group_ids(struct mount *mnt, struct mount *end)\n{\n\tstruct mount *p;\n\n\tfor (p = mnt; p != end; p = next_mnt(p, mnt)) {\n\t\tif (p->mnt_group_id && !IS_MNT_SHARED(p))\n\t\t\tmnt_release_group_id(p);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_release_group_id",
          "args": [
            "p"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_release_group_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "151-158",
          "snippet": "void mnt_release_group_id(struct mount *mnt)\n{\n\tint id = mnt->mnt_group_id;\n\tida_remove(&mnt_group_ida, id);\n\tif (mnt_group_start > id)\n\t\tmnt_group_start = id;\n\tmnt->mnt_group_id = 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDA(mnt_group_ida);",
            "static int mnt_group_start = 1;",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_IDA(mnt_group_ida);\nstatic int mnt_group_start = 1;\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_release_group_id(struct mount *mnt)\n{\n\tint id = mnt->mnt_group_id;\n\tida_remove(&mnt_group_ida, id);\n\tif (mnt_group_start > id)\n\t\tmnt_group_start = id;\n\tmnt->mnt_group_id = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_SHARED",
          "args": [
            "p"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_mnt",
          "args": [
            "p",
            "mnt"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "next_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "895-909",
          "snippet": "static struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void cleanup_group_ids(struct mount *mnt, struct mount *end)\n{\n\tstruct mount *p;\n\n\tfor (p = mnt; p != end; p = next_mnt(p, mnt)) {\n\t\tif (p->mnt_group_id && !IS_MNT_SHARED(p))\n\t\t\tmnt_release_group_id(p);\n\t}\n}"
  },
  {
    "function_name": "iterate_mounts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1730-1743",
    "snippet": "int iterate_mounts(int (*f)(struct vfsmount *, void *), void *arg,\n\t\t   struct vfsmount *root)\n{\n\tstruct mount *mnt;\n\tint res = f(root, arg);\n\tif (res)\n\t\treturn res;\n\tlist_for_each_entry(mnt, &real_mount(root)->mnt_list, mnt_list) {\n\t\tres = f(&mnt->mnt, arg);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "f",
          "args": [
            "&mnt->mnt",
            "arg"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "finish_automount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2356-2384",
          "snippet": "int finish_automount(struct vfsmount *m, struct path *path)\n{\n\tstruct mount *mnt = real_mount(m);\n\tint err;\n\t/* The new mount record should have at least 2 refs to prevent it being\n\t * expired before we get a chance to add it\n\t */\n\tBUG_ON(mnt_get_count(mnt) < 2);\n\n\tif (m->mnt_sb == path->mnt->mnt_sb &&\n\t    m->mnt_root == path->dentry) {\n\t\terr = -ELOOP;\n\t\tgoto fail;\n\t}\n\n\terr = do_add_mount(mnt, path, path->mnt->mnt_flags | MNT_SHRINKABLE);\n\tif (!err)\n\t\treturn 0;\nfail:\n\t/* remove m from any expiration list it may be on */\n\tif (!list_empty(&mnt->mnt_expire)) {\n\t\tnamespace_lock();\n\t\tlist_del_init(&mnt->mnt_expire);\n\t\tnamespace_unlock();\n\t}\n\tmntput(m);\n\tmntput(m);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint finish_automount(struct vfsmount *m, struct path *path)\n{\n\tstruct mount *mnt = real_mount(m);\n\tint err;\n\t/* The new mount record should have at least 2 refs to prevent it being\n\t * expired before we get a chance to add it\n\t */\n\tBUG_ON(mnt_get_count(mnt) < 2);\n\n\tif (m->mnt_sb == path->mnt->mnt_sb &&\n\t    m->mnt_root == path->dentry) {\n\t\terr = -ELOOP;\n\t\tgoto fail;\n\t}\n\n\terr = do_add_mount(mnt, path, path->mnt->mnt_flags | MNT_SHRINKABLE);\n\tif (!err)\n\t\treturn 0;\nfail:\n\t/* remove m from any expiration list it may be on */\n\tif (!list_empty(&mnt->mnt_expire)) {\n\t\tnamespace_lock();\n\t\tlist_del_init(&mnt->mnt_expire);\n\t\tnamespace_unlock();\n\t}\n\tmntput(m);\n\tmntput(m);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "mnt",
            "&real_mount(root)->mnt_list",
            "mnt_list"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "root"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint iterate_mounts(int (*f)(struct vfsmount *, void *), void *arg,\n\t\t   struct vfsmount *root)\n{\n\tstruct mount *mnt;\n\tint res = f(root, arg);\n\tif (res)\n\t\treturn res;\n\tlist_for_each_entry(mnt, &real_mount(root)->mnt_list, mnt_list) {\n\t\tres = f(&mnt->mnt, arg);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "clone_private_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1712-1727",
    "snippet": "struct vfsmount *clone_private_mount(struct path *path)\n{\n\tstruct mount *old_mnt = real_mount(path->mnt);\n\tstruct mount *new_mnt;\n\n\tif (IS_MNT_UNBINDABLE(old_mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdown_read(&namespace_sem);\n\tnew_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);\n\tup_read(&namespace_sem);\n\tif (IS_ERR(new_mnt))\n\t\treturn ERR_CAST(new_mnt);\n\n\treturn &new_mnt->mnt;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(namespace_sem);",
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "new_mnt"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_mnt"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&namespace_sem"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone_mnt",
          "args": [
            "old_mnt",
            "path->dentry",
            "CL_PRIVATE"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "clone_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "955-1037",
          "snippet": "static struct mount *clone_mnt(struct mount *old, struct dentry *root,\n\t\t\t\t\tint flag)\n{\n\tstruct super_block *sb = old->mnt.mnt_sb;\n\tstruct mount *mnt;\n\tint err;\n\n\tmnt = alloc_vfsmnt(old->mnt_devname);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))\n\t\tmnt->mnt_group_id = 0; /* not a peer of original */\n\telse\n\t\tmnt->mnt_group_id = old->mnt_group_id;\n\n\tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {\n\t\terr = mnt_alloc_group_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n\t/* Don't allow unprivileged users to change mount flags */\n\tif (flag & CL_UNPRIVILEGED) {\n\t\tmnt->mnt.mnt_flags |= MNT_LOCK_ATIME;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_READONLY)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NODEV)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NODEV;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOSUID)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOSUID;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOEXEC)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOEXEC;\n\t}\n\n\t/* Don't allow unprivileged users to reveal what is under a mount */\n\tif ((flag & CL_UNPRIVILEGED) &&\n\t    (!(flag & CL_EXPIRE) || list_empty(&old->mnt_expire)))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCKED;\n\n\tatomic_inc(&sb->s_active);\n\tmnt->mnt.mnt_sb = sb;\n\tmnt->mnt.mnt_root = dget(root);\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &sb->s_mounts);\n\tunlock_mount_hash();\n\n\tif ((flag & CL_SLAVE) ||\n\t    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {\n\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave_list);\n\t\tmnt->mnt_master = old;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t} else if (!(flag & CL_PRIVATE)) {\n\t\tif ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))\n\t\t\tlist_add(&mnt->mnt_share, &old->mnt_share);\n\t\tif (IS_MNT_SLAVE(old))\n\t\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave);\n\t\tmnt->mnt_master = old->mnt_master;\n\t}\n\tif (flag & CL_MAKE_SHARED)\n\t\tset_mnt_shared(mnt);\n\n\t/* stick the duplicate mount on the same expiry list\n\t * as the original if that was on one */\n\tif (flag & CL_EXPIRE) {\n\t\tif (!list_empty(&old->mnt_expire))\n\t\t\tlist_add(&mnt->mnt_expire, &old->mnt_expire);\n\t}\n\n\treturn mnt;\n\n out_free:\n\tmnt_free_id(mnt);\n\tfree_vfsmnt(mnt);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic struct mount *clone_mnt(struct mount *old, struct dentry *root,\n\t\t\t\t\tint flag)\n{\n\tstruct super_block *sb = old->mnt.mnt_sb;\n\tstruct mount *mnt;\n\tint err;\n\n\tmnt = alloc_vfsmnt(old->mnt_devname);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))\n\t\tmnt->mnt_group_id = 0; /* not a peer of original */\n\telse\n\t\tmnt->mnt_group_id = old->mnt_group_id;\n\n\tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {\n\t\terr = mnt_alloc_group_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n\t/* Don't allow unprivileged users to change mount flags */\n\tif (flag & CL_UNPRIVILEGED) {\n\t\tmnt->mnt.mnt_flags |= MNT_LOCK_ATIME;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_READONLY)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NODEV)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NODEV;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOSUID)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOSUID;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOEXEC)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOEXEC;\n\t}\n\n\t/* Don't allow unprivileged users to reveal what is under a mount */\n\tif ((flag & CL_UNPRIVILEGED) &&\n\t    (!(flag & CL_EXPIRE) || list_empty(&old->mnt_expire)))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCKED;\n\n\tatomic_inc(&sb->s_active);\n\tmnt->mnt.mnt_sb = sb;\n\tmnt->mnt.mnt_root = dget(root);\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &sb->s_mounts);\n\tunlock_mount_hash();\n\n\tif ((flag & CL_SLAVE) ||\n\t    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {\n\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave_list);\n\t\tmnt->mnt_master = old;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t} else if (!(flag & CL_PRIVATE)) {\n\t\tif ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))\n\t\t\tlist_add(&mnt->mnt_share, &old->mnt_share);\n\t\tif (IS_MNT_SLAVE(old))\n\t\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave);\n\t\tmnt->mnt_master = old->mnt_master;\n\t}\n\tif (flag & CL_MAKE_SHARED)\n\t\tset_mnt_shared(mnt);\n\n\t/* stick the duplicate mount on the same expiry list\n\t * as the original if that was on one */\n\tif (flag & CL_EXPIRE) {\n\t\tif (!list_empty(&old->mnt_expire))\n\t\t\tlist_add(&mnt->mnt_expire, &old->mnt_expire);\n\t}\n\n\treturn mnt;\n\n out_free:\n\tmnt_free_id(mnt);\n\tfree_vfsmnt(mnt);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&namespace_sem"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MNT_UNBINDABLE",
          "args": [
            "old_mnt"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "path->mnt"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *clone_private_mount(struct path *path)\n{\n\tstruct mount *old_mnt = real_mount(path->mnt);\n\tstruct mount *new_mnt;\n\n\tif (IS_MNT_UNBINDABLE(old_mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdown_read(&namespace_sem);\n\tnew_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);\n\tup_read(&namespace_sem);\n\tif (IS_ERR(new_mnt))\n\t\treturn ERR_CAST(new_mnt);\n\n\treturn &new_mnt->mnt;\n}"
  },
  {
    "function_name": "drop_collected_mounts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1694-1701",
    "snippet": "void drop_collected_mounts(struct vfsmount *mnt)\n{\n\tnamespace_lock();\n\tlock_mount_hash();\n\tumount_tree(real_mount(mnt), UMOUNT_SYNC);\n\tunlock_mount_hash();\n\tnamespace_unlock();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "namespace_unlock",
          "args": [],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1320-1334",
          "snippet": "static void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);",
            "static HLIST_HEAD(unmounted);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic HLIST_HEAD(unmounted);\n\nstatic void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_mount_hash",
          "args": [],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "114-117",
          "snippet": "static inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern seqlock_t mount_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern seqlock_t mount_lock;\n\nstatic inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umount_tree",
          "args": [
            "real_mount(mnt)",
            "UMOUNT_SYNC"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "umount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1349-1388",
          "snippet": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static HLIST_HEAD(unmounted);",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic HLIST_HEAD(unmounted);\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "namespace_lock",
          "args": [],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1336-1339",
          "snippet": "static inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\n\nstatic inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid drop_collected_mounts(struct vfsmount *mnt)\n{\n\tnamespace_lock();\n\tlock_mount_hash();\n\tumount_tree(real_mount(mnt), UMOUNT_SYNC);\n\tunlock_mount_hash();\n\tnamespace_unlock();\n}"
  },
  {
    "function_name": "collect_mounts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1679-1692",
    "snippet": "struct vfsmount *collect_mounts(struct path *path)\n{\n\tstruct mount *tree;\n\tnamespace_lock();\n\tif (!check_mnt(real_mount(path->mnt)))\n\t\ttree = ERR_PTR(-EINVAL);\n\telse\n\t\ttree = copy_tree(real_mount(path->mnt), path->dentry,\n\t\t\t\t CL_COPY_ALL | CL_PRIVATE);\n\tnamespace_unlock();\n\tif (IS_ERR(tree))\n\t\treturn ERR_CAST(tree);\n\treturn &tree->mnt;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "tree"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tree"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namespace_unlock",
          "args": [],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1320-1334",
          "snippet": "static void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);",
            "static HLIST_HEAD(unmounted);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic HLIST_HEAD(unmounted);\n\nstatic void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_tree",
          "args": [
            "real_mount(path->mnt)",
            "path->dentry",
            "CL_COPY_ALL | CL_PRIVATE"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "copy_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1610-1675",
          "snippet": "struct mount *copy_tree(struct mount *mnt, struct dentry *dentry,\n\t\t\t\t\tint flag)\n{\n\tstruct mount *res, *p, *q, *r, *parent;\n\n\tif (!(flag & CL_COPY_UNBINDABLE) && IS_MNT_UNBINDABLE(mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!(flag & CL_COPY_MNT_NS_FILE) && is_mnt_ns_file(dentry))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tres = q = clone_mnt(mnt, dentry, flag);\n\tif (IS_ERR(q))\n\t\treturn q;\n\n\tq->mnt_mountpoint = mnt->mnt_mountpoint;\n\n\tp = mnt;\n\tlist_for_each_entry(r, &mnt->mnt_mounts, mnt_child) {\n\t\tstruct mount *s;\n\t\tif (!is_subdir(r->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tfor (s = r; s; s = next_mnt(s, r)) {\n\t\t\tstruct mount *t = NULL;\n\t\t\tif (!(flag & CL_COPY_UNBINDABLE) &&\n\t\t\t    IS_MNT_UNBINDABLE(s)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(flag & CL_COPY_MNT_NS_FILE) &&\n\t\t\t    is_mnt_ns_file(s->mnt.mnt_root)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (p != s->mnt_parent) {\n\t\t\t\tp = p->mnt_parent;\n\t\t\t\tq = q->mnt_parent;\n\t\t\t}\n\t\t\tp = s;\n\t\t\tparent = q;\n\t\t\tq = clone_mnt(p, p->mnt.mnt_root, flag);\n\t\t\tif (IS_ERR(q))\n\t\t\t\tgoto out;\n\t\t\tlock_mount_hash();\n\t\t\tlist_add_tail(&q->mnt_list, &res->mnt_list);\n\t\t\tmnt_set_mountpoint(parent, p->mnt_mp, q);\n\t\t\tif (!list_empty(&parent->mnt_mounts)) {\n\t\t\t\tt = list_last_entry(&parent->mnt_mounts,\n\t\t\t\t\tstruct mount, mnt_child);\n\t\t\t\tif (t->mnt_mp != p->mnt_mp)\n\t\t\t\t\tt = NULL;\n\t\t\t}\n\t\t\tattach_shadowed(q, parent, t);\n\t\t\tunlock_mount_hash();\n\t\t}\n\t}\n\treturn res;\nout:\n\tif (res) {\n\t\tlock_mount_hash();\n\t\tumount_tree(res, UMOUNT_SYNC);\n\t\tunlock_mount_hash();\n\t}\n\treturn q;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct mount *copy_tree(struct mount *mnt, struct dentry *dentry,\n\t\t\t\t\tint flag)\n{\n\tstruct mount *res, *p, *q, *r, *parent;\n\n\tif (!(flag & CL_COPY_UNBINDABLE) && IS_MNT_UNBINDABLE(mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!(flag & CL_COPY_MNT_NS_FILE) && is_mnt_ns_file(dentry))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tres = q = clone_mnt(mnt, dentry, flag);\n\tif (IS_ERR(q))\n\t\treturn q;\n\n\tq->mnt_mountpoint = mnt->mnt_mountpoint;\n\n\tp = mnt;\n\tlist_for_each_entry(r, &mnt->mnt_mounts, mnt_child) {\n\t\tstruct mount *s;\n\t\tif (!is_subdir(r->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tfor (s = r; s; s = next_mnt(s, r)) {\n\t\t\tstruct mount *t = NULL;\n\t\t\tif (!(flag & CL_COPY_UNBINDABLE) &&\n\t\t\t    IS_MNT_UNBINDABLE(s)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(flag & CL_COPY_MNT_NS_FILE) &&\n\t\t\t    is_mnt_ns_file(s->mnt.mnt_root)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (p != s->mnt_parent) {\n\t\t\t\tp = p->mnt_parent;\n\t\t\t\tq = q->mnt_parent;\n\t\t\t}\n\t\t\tp = s;\n\t\t\tparent = q;\n\t\t\tq = clone_mnt(p, p->mnt.mnt_root, flag);\n\t\t\tif (IS_ERR(q))\n\t\t\t\tgoto out;\n\t\t\tlock_mount_hash();\n\t\t\tlist_add_tail(&q->mnt_list, &res->mnt_list);\n\t\t\tmnt_set_mountpoint(parent, p->mnt_mp, q);\n\t\t\tif (!list_empty(&parent->mnt_mounts)) {\n\t\t\t\tt = list_last_entry(&parent->mnt_mounts,\n\t\t\t\t\tstruct mount, mnt_child);\n\t\t\t\tif (t->mnt_mp != p->mnt_mp)\n\t\t\t\t\tt = NULL;\n\t\t\t}\n\t\t\tattach_shadowed(q, parent, t);\n\t\t\tunlock_mount_hash();\n\t\t}\n\t}\n\treturn res;\nout:\n\tif (res) {\n\t\tlock_mount_hash();\n\t\tumount_tree(res, UMOUNT_SYNC);\n\t\tunlock_mount_hash();\n\t}\n\treturn q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "path->mnt"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_mnt",
          "args": [
            "real_mount(path->mnt)"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "check_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "771-774",
          "snippet": "static inline int check_mnt(struct mount *mnt)\n{\n\treturn mnt->mnt_ns == current->nsproxy->mnt_ns;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline int check_mnt(struct mount *mnt)\n{\n\treturn mnt->mnt_ns == current->nsproxy->mnt_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "namespace_lock",
          "args": [],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1336-1339",
          "snippet": "static inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\n\nstatic inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *collect_mounts(struct path *path)\n{\n\tstruct mount *tree;\n\tnamespace_lock();\n\tif (!check_mnt(real_mount(path->mnt)))\n\t\ttree = ERR_PTR(-EINVAL);\n\telse\n\t\ttree = copy_tree(real_mount(path->mnt), path->dentry,\n\t\t\t\t CL_COPY_ALL | CL_PRIVATE);\n\tnamespace_unlock();\n\tif (IS_ERR(tree))\n\t\treturn ERR_CAST(tree);\n\treturn &tree->mnt;\n}"
  },
  {
    "function_name": "copy_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1610-1675",
    "snippet": "struct mount *copy_tree(struct mount *mnt, struct dentry *dentry,\n\t\t\t\t\tint flag)\n{\n\tstruct mount *res, *p, *q, *r, *parent;\n\n\tif (!(flag & CL_COPY_UNBINDABLE) && IS_MNT_UNBINDABLE(mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!(flag & CL_COPY_MNT_NS_FILE) && is_mnt_ns_file(dentry))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tres = q = clone_mnt(mnt, dentry, flag);\n\tif (IS_ERR(q))\n\t\treturn q;\n\n\tq->mnt_mountpoint = mnt->mnt_mountpoint;\n\n\tp = mnt;\n\tlist_for_each_entry(r, &mnt->mnt_mounts, mnt_child) {\n\t\tstruct mount *s;\n\t\tif (!is_subdir(r->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tfor (s = r; s; s = next_mnt(s, r)) {\n\t\t\tstruct mount *t = NULL;\n\t\t\tif (!(flag & CL_COPY_UNBINDABLE) &&\n\t\t\t    IS_MNT_UNBINDABLE(s)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(flag & CL_COPY_MNT_NS_FILE) &&\n\t\t\t    is_mnt_ns_file(s->mnt.mnt_root)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (p != s->mnt_parent) {\n\t\t\t\tp = p->mnt_parent;\n\t\t\t\tq = q->mnt_parent;\n\t\t\t}\n\t\t\tp = s;\n\t\t\tparent = q;\n\t\t\tq = clone_mnt(p, p->mnt.mnt_root, flag);\n\t\t\tif (IS_ERR(q))\n\t\t\t\tgoto out;\n\t\t\tlock_mount_hash();\n\t\t\tlist_add_tail(&q->mnt_list, &res->mnt_list);\n\t\t\tmnt_set_mountpoint(parent, p->mnt_mp, q);\n\t\t\tif (!list_empty(&parent->mnt_mounts)) {\n\t\t\t\tt = list_last_entry(&parent->mnt_mounts,\n\t\t\t\t\tstruct mount, mnt_child);\n\t\t\t\tif (t->mnt_mp != p->mnt_mp)\n\t\t\t\t\tt = NULL;\n\t\t\t}\n\t\t\tattach_shadowed(q, parent, t);\n\t\t\tunlock_mount_hash();\n\t\t}\n\t}\n\treturn res;\nout:\n\tif (res) {\n\t\tlock_mount_hash();\n\t\tumount_tree(res, UMOUNT_SYNC);\n\t\tunlock_mount_hash();\n\t}\n\treturn q;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_mount_hash",
          "args": [],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "114-117",
          "snippet": "static inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern seqlock_t mount_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern seqlock_t mount_lock;\n\nstatic inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umount_tree",
          "args": [
            "res",
            "UMOUNT_SYNC"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "umount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1349-1388",
          "snippet": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static HLIST_HEAD(unmounted);",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic HLIST_HEAD(unmounted);\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_shadowed",
          "args": [
            "q",
            "parent",
            "t"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "attach_shadowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "859-871",
          "snippet": "static void attach_shadowed(struct mount *mnt,\n\t\t\tstruct mount *parent,\n\t\t\tstruct mount *shadows)\n{\n\tif (shadows) {\n\t\thlist_add_behind_rcu(&mnt->mnt_hash, &shadows->mnt_hash);\n\t\tlist_add(&mnt->mnt_child, &shadows->mnt_child);\n\t} else {\n\t\thlist_add_head_rcu(&mnt->mnt_hash,\n\t\t\t\tm_hash(&parent->mnt, mnt->mnt_mountpoint));\n\t\tlist_add_tail(&mnt->mnt_child, &parent->mnt_mounts);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void attach_shadowed(struct mount *mnt,\n\t\t\tstruct mount *parent,\n\t\t\tstruct mount *shadows)\n{\n\tif (shadows) {\n\t\thlist_add_behind_rcu(&mnt->mnt_hash, &shadows->mnt_hash);\n\t\tlist_add(&mnt->mnt_child, &shadows->mnt_child);\n\t} else {\n\t\thlist_add_head_rcu(&mnt->mnt_hash,\n\t\t\t\tm_hash(&parent->mnt, mnt->mnt_mountpoint));\n\t\tlist_add_tail(&mnt->mnt_child, &parent->mnt_mounts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_last_entry",
          "args": [
            "&parent->mnt_mounts",
            "structmount",
            "mnt_child"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&parent->mnt_mounts"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_set_mountpoint",
          "args": [
            "parent",
            "p->mnt_mp",
            "q"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_set_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "835-845",
          "snippet": "void mnt_set_mountpoint(struct mount *mnt,\n\t\t\tstruct mountpoint *mp,\n\t\t\tstruct mount *child_mnt)\n{\n\tmp->m_count++;\n\tmnt_add_count(mnt, 1);\t/* essentially, that's mntget */\n\tchild_mnt->mnt_mountpoint = dget(mp->m_dentry);\n\tchild_mnt->mnt_parent = mnt;\n\tchild_mnt->mnt_mp = mp;\n\thlist_add_head(&child_mnt->mnt_mp_list, &mp->m_list);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_set_mountpoint(struct mount *mnt,\n\t\t\tstruct mountpoint *mp,\n\t\t\tstruct mount *child_mnt)\n{\n\tmp->m_count++;\n\tmnt_add_count(mnt, 1);\t/* essentially, that's mntget */\n\tchild_mnt->mnt_mountpoint = dget(mp->m_dentry);\n\tchild_mnt->mnt_parent = mnt;\n\tchild_mnt->mnt_mp = mp;\n\thlist_add_head(&child_mnt->mnt_mp_list, &mp->m_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&q->mnt_list",
            "&res->mnt_list"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "q"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone_mnt",
          "args": [
            "p",
            "p->mnt.mnt_root",
            "flag"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "clone_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "955-1037",
          "snippet": "static struct mount *clone_mnt(struct mount *old, struct dentry *root,\n\t\t\t\t\tint flag)\n{\n\tstruct super_block *sb = old->mnt.mnt_sb;\n\tstruct mount *mnt;\n\tint err;\n\n\tmnt = alloc_vfsmnt(old->mnt_devname);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))\n\t\tmnt->mnt_group_id = 0; /* not a peer of original */\n\telse\n\t\tmnt->mnt_group_id = old->mnt_group_id;\n\n\tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {\n\t\terr = mnt_alloc_group_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n\t/* Don't allow unprivileged users to change mount flags */\n\tif (flag & CL_UNPRIVILEGED) {\n\t\tmnt->mnt.mnt_flags |= MNT_LOCK_ATIME;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_READONLY)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NODEV)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NODEV;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOSUID)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOSUID;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOEXEC)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOEXEC;\n\t}\n\n\t/* Don't allow unprivileged users to reveal what is under a mount */\n\tif ((flag & CL_UNPRIVILEGED) &&\n\t    (!(flag & CL_EXPIRE) || list_empty(&old->mnt_expire)))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCKED;\n\n\tatomic_inc(&sb->s_active);\n\tmnt->mnt.mnt_sb = sb;\n\tmnt->mnt.mnt_root = dget(root);\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &sb->s_mounts);\n\tunlock_mount_hash();\n\n\tif ((flag & CL_SLAVE) ||\n\t    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {\n\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave_list);\n\t\tmnt->mnt_master = old;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t} else if (!(flag & CL_PRIVATE)) {\n\t\tif ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))\n\t\t\tlist_add(&mnt->mnt_share, &old->mnt_share);\n\t\tif (IS_MNT_SLAVE(old))\n\t\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave);\n\t\tmnt->mnt_master = old->mnt_master;\n\t}\n\tif (flag & CL_MAKE_SHARED)\n\t\tset_mnt_shared(mnt);\n\n\t/* stick the duplicate mount on the same expiry list\n\t * as the original if that was on one */\n\tif (flag & CL_EXPIRE) {\n\t\tif (!list_empty(&old->mnt_expire))\n\t\t\tlist_add(&mnt->mnt_expire, &old->mnt_expire);\n\t}\n\n\treturn mnt;\n\n out_free:\n\tmnt_free_id(mnt);\n\tfree_vfsmnt(mnt);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic struct mount *clone_mnt(struct mount *old, struct dentry *root,\n\t\t\t\t\tint flag)\n{\n\tstruct super_block *sb = old->mnt.mnt_sb;\n\tstruct mount *mnt;\n\tint err;\n\n\tmnt = alloc_vfsmnt(old->mnt_devname);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))\n\t\tmnt->mnt_group_id = 0; /* not a peer of original */\n\telse\n\t\tmnt->mnt_group_id = old->mnt_group_id;\n\n\tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {\n\t\terr = mnt_alloc_group_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n\t/* Don't allow unprivileged users to change mount flags */\n\tif (flag & CL_UNPRIVILEGED) {\n\t\tmnt->mnt.mnt_flags |= MNT_LOCK_ATIME;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_READONLY)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NODEV)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NODEV;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOSUID)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOSUID;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOEXEC)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOEXEC;\n\t}\n\n\t/* Don't allow unprivileged users to reveal what is under a mount */\n\tif ((flag & CL_UNPRIVILEGED) &&\n\t    (!(flag & CL_EXPIRE) || list_empty(&old->mnt_expire)))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCKED;\n\n\tatomic_inc(&sb->s_active);\n\tmnt->mnt.mnt_sb = sb;\n\tmnt->mnt.mnt_root = dget(root);\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &sb->s_mounts);\n\tunlock_mount_hash();\n\n\tif ((flag & CL_SLAVE) ||\n\t    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {\n\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave_list);\n\t\tmnt->mnt_master = old;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t} else if (!(flag & CL_PRIVATE)) {\n\t\tif ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))\n\t\t\tlist_add(&mnt->mnt_share, &old->mnt_share);\n\t\tif (IS_MNT_SLAVE(old))\n\t\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave);\n\t\tmnt->mnt_master = old->mnt_master;\n\t}\n\tif (flag & CL_MAKE_SHARED)\n\t\tset_mnt_shared(mnt);\n\n\t/* stick the duplicate mount on the same expiry list\n\t * as the original if that was on one */\n\tif (flag & CL_EXPIRE) {\n\t\tif (!list_empty(&old->mnt_expire))\n\t\t\tlist_add(&mnt->mnt_expire, &old->mnt_expire);\n\t}\n\n\treturn mnt;\n\n out_free:\n\tmnt_free_id(mnt);\n\tfree_vfsmnt(mnt);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_mnt_tree",
          "args": [
            "s"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "skip_mnt_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "911-919",
          "snippet": "static struct mount *skip_mnt_tree(struct mount *p)\n{\n\tstruct list_head *prev = p->mnt_mounts.prev;\n\twhile (prev != &p->mnt_mounts) {\n\t\tp = list_entry(prev, struct mount, mnt_child);\n\t\tprev = p->mnt_mounts.prev;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct mount *skip_mnt_tree(struct mount *p)\n{\n\tstruct list_head *prev = p->mnt_mounts.prev;\n\twhile (prev != &p->mnt_mounts) {\n\t\tp = list_entry(prev, struct mount, mnt_child);\n\t\tprev = p->mnt_mounts.prev;\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_mnt_ns_file",
          "args": [
            "s->mnt.mnt_root"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "is_mnt_ns_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1585-1590",
          "snippet": "static bool is_mnt_ns_file(struct dentry *dentry)\n{\n\t/* Is this a proxy for a mount namespace? */\n\treturn dentry->d_op == &ns_dentry_operations &&\n\t       dentry->d_fsdata == &mntns_operations;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct proc_ns_operations mntns_operations = {\n\t.name\t\t= \"mnt\",\n\t.type\t\t= CLONE_NEWNS,\n\t.get\t\t= mntns_get,\n\t.put\t\t= mntns_put,\n\t.install\t= mntns_install,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nconst struct proc_ns_operations mntns_operations = {\n\t.name\t\t= \"mnt\",\n\t.type\t\t= CLONE_NEWNS,\n\t.get\t\t= mntns_get,\n\t.put\t\t= mntns_put,\n\t.install\t= mntns_install,\n};\n\nstatic bool is_mnt_ns_file(struct dentry *dentry)\n{\n\t/* Is this a proxy for a mount namespace? */\n\treturn dentry->d_op == &ns_dentry_operations &&\n\t       dentry->d_fsdata == &mntns_operations;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_UNBINDABLE",
          "args": [
            "s"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_mnt",
          "args": [
            "s",
            "r"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "next_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "895-909",
          "snippet": "static struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_subdir",
          "args": [
            "r->mnt_mountpoint",
            "dentry"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "is_subdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3279-3303",
          "snippet": "int is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)\n{\n\tint result;\n\tunsigned seq;\n\n\tif (new_dentry == old_dentry)\n\t\treturn 1;\n\n\tdo {\n\t\t/* for restarting inner loop in case of seq retry */\n\t\tseq = read_seqbegin(&rename_lock);\n\t\t/*\n\t\t * Need rcu_readlock to protect against the d_parent trashing\n\t\t * due to d_move\n\t\t */\n\t\trcu_read_lock();\n\t\tif (d_ancestor(old_dentry, new_dentry))\n\t\t\tresult = 1;\n\t\telse\n\t\t\tresult = 0;\n\t\trcu_read_unlock();\n\t} while (read_seqretry(&rename_lock, seq));\n\n\treturn result;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nint is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)\n{\n\tint result;\n\tunsigned seq;\n\n\tif (new_dentry == old_dentry)\n\t\treturn 1;\n\n\tdo {\n\t\t/* for restarting inner loop in case of seq retry */\n\t\tseq = read_seqbegin(&rename_lock);\n\t\t/*\n\t\t * Need rcu_readlock to protect against the d_parent trashing\n\t\t * due to d_move\n\t\t */\n\t\trcu_read_lock();\n\t\tif (d_ancestor(old_dentry, new_dentry))\n\t\t\tresult = 1;\n\t\telse\n\t\t\tresult = 0;\n\t\trcu_read_unlock();\n\t} while (read_seqretry(&rename_lock, seq));\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "r",
            "&mnt->mnt_mounts",
            "mnt_child"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "q"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MNT_UNBINDABLE",
          "args": [
            "mnt"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct mount *copy_tree(struct mount *mnt, struct dentry *dentry,\n\t\t\t\t\tint flag)\n{\n\tstruct mount *res, *p, *q, *r, *parent;\n\n\tif (!(flag & CL_COPY_UNBINDABLE) && IS_MNT_UNBINDABLE(mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!(flag & CL_COPY_MNT_NS_FILE) && is_mnt_ns_file(dentry))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tres = q = clone_mnt(mnt, dentry, flag);\n\tif (IS_ERR(q))\n\t\treturn q;\n\n\tq->mnt_mountpoint = mnt->mnt_mountpoint;\n\n\tp = mnt;\n\tlist_for_each_entry(r, &mnt->mnt_mounts, mnt_child) {\n\t\tstruct mount *s;\n\t\tif (!is_subdir(r->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tfor (s = r; s; s = next_mnt(s, r)) {\n\t\t\tstruct mount *t = NULL;\n\t\t\tif (!(flag & CL_COPY_UNBINDABLE) &&\n\t\t\t    IS_MNT_UNBINDABLE(s)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(flag & CL_COPY_MNT_NS_FILE) &&\n\t\t\t    is_mnt_ns_file(s->mnt.mnt_root)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (p != s->mnt_parent) {\n\t\t\t\tp = p->mnt_parent;\n\t\t\t\tq = q->mnt_parent;\n\t\t\t}\n\t\t\tp = s;\n\t\t\tparent = q;\n\t\t\tq = clone_mnt(p, p->mnt.mnt_root, flag);\n\t\t\tif (IS_ERR(q))\n\t\t\t\tgoto out;\n\t\t\tlock_mount_hash();\n\t\t\tlist_add_tail(&q->mnt_list, &res->mnt_list);\n\t\t\tmnt_set_mountpoint(parent, p->mnt_mp, q);\n\t\t\tif (!list_empty(&parent->mnt_mounts)) {\n\t\t\t\tt = list_last_entry(&parent->mnt_mounts,\n\t\t\t\t\tstruct mount, mnt_child);\n\t\t\t\tif (t->mnt_mp != p->mnt_mp)\n\t\t\t\t\tt = NULL;\n\t\t\t}\n\t\t\tattach_shadowed(q, parent, t);\n\t\t\tunlock_mount_hash();\n\t\t}\n\t}\n\treturn res;\nout:\n\tif (res) {\n\t\tlock_mount_hash();\n\t\tumount_tree(res, UMOUNT_SYNC);\n\t\tunlock_mount_hash();\n\t}\n\treturn q;\n}"
  },
  {
    "function_name": "mnt_ns_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1597-1608",
    "snippet": "static bool mnt_ns_loop(struct dentry *dentry)\n{\n\t/* Could bind mounting the mount namespace inode cause a\n\t * mount namespace loop?\n\t */\n\tstruct mnt_namespace *mnt_ns;\n\tif (!is_mnt_ns_file(dentry))\n\t\treturn false;\n\n\tmnt_ns = to_mnt_ns(get_proc_ns(dentry->d_inode));\n\treturn current->nsproxy->mnt_ns->seq >= mnt_ns->seq;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_mnt_ns",
          "args": [
            "get_proc_ns(dentry->d_inode)"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "to_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1592-1595",
          "snippet": "struct mnt_namespace *to_mnt_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct mnt_namespace, ns);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct mnt_namespace *to_mnt_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct mnt_namespace, ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_proc_ns",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_mnt_ns_file",
          "args": [
            "dentry"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "is_mnt_ns_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1585-1590",
          "snippet": "static bool is_mnt_ns_file(struct dentry *dentry)\n{\n\t/* Is this a proxy for a mount namespace? */\n\treturn dentry->d_op == &ns_dentry_operations &&\n\t       dentry->d_fsdata == &mntns_operations;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct proc_ns_operations mntns_operations = {\n\t.name\t\t= \"mnt\",\n\t.type\t\t= CLONE_NEWNS,\n\t.get\t\t= mntns_get,\n\t.put\t\t= mntns_put,\n\t.install\t= mntns_install,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nconst struct proc_ns_operations mntns_operations = {\n\t.name\t\t= \"mnt\",\n\t.type\t\t= CLONE_NEWNS,\n\t.get\t\t= mntns_get,\n\t.put\t\t= mntns_put,\n\t.install\t= mntns_install,\n};\n\nstatic bool is_mnt_ns_file(struct dentry *dentry)\n{\n\t/* Is this a proxy for a mount namespace? */\n\treturn dentry->d_op == &ns_dentry_operations &&\n\t       dentry->d_fsdata == &mntns_operations;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic bool mnt_ns_loop(struct dentry *dentry)\n{\n\t/* Could bind mounting the mount namespace inode cause a\n\t * mount namespace loop?\n\t */\n\tstruct mnt_namespace *mnt_ns;\n\tif (!is_mnt_ns_file(dentry))\n\t\treturn false;\n\n\tmnt_ns = to_mnt_ns(get_proc_ns(dentry->d_inode));\n\treturn current->nsproxy->mnt_ns->seq >= mnt_ns->seq;\n}"
  },
  {
    "function_name": "to_mnt_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1592-1595",
    "snippet": "struct mnt_namespace *to_mnt_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct mnt_namespace, ns);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ns",
            "structmnt_namespace",
            "ns"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct mnt_namespace *to_mnt_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct mnt_namespace, ns);\n}"
  },
  {
    "function_name": "is_mnt_ns_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1585-1590",
    "snippet": "static bool is_mnt_ns_file(struct dentry *dentry)\n{\n\t/* Is this a proxy for a mount namespace? */\n\treturn dentry->d_op == &ns_dentry_operations &&\n\t       dentry->d_fsdata == &mntns_operations;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct proc_ns_operations mntns_operations = {\n\t.name\t\t= \"mnt\",\n\t.type\t\t= CLONE_NEWNS,\n\t.get\t\t= mntns_get,\n\t.put\t\t= mntns_put,\n\t.install\t= mntns_install,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nconst struct proc_ns_operations mntns_operations = {\n\t.name\t\t= \"mnt\",\n\t.type\t\t= CLONE_NEWNS,\n\t.get\t\t= mntns_get,\n\t.put\t\t= mntns_put,\n\t.install\t= mntns_install,\n};\n\nstatic bool is_mnt_ns_file(struct dentry *dentry)\n{\n\t/* Is this a proxy for a mount namespace? */\n\treturn dentry->d_op == &ns_dentry_operations &&\n\t       dentry->d_fsdata == &mntns_operations;\n}"
  },
  {
    "function_name": "may_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1520-1523",
    "snippet": "static inline bool may_mount(void)\n{\n\treturn ns_capable(current->nsproxy->mnt_ns->user_ns, CAP_SYS_ADMIN);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "current->nsproxy->mnt_ns->user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline bool may_mount(void)\n{\n\treturn ns_capable(current->nsproxy->mnt_ns->user_ns, CAP_SYS_ADMIN);\n}"
  },
  {
    "function_name": "__detach_mounts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1496-1515",
    "snippet": "void __detach_mounts(struct dentry *dentry)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *mnt;\n\n\tnamespace_lock();\n\tmp = lookup_mountpoint(dentry);\n\tif (!mp)\n\t\tgoto out_unlock;\n\n\tlock_mount_hash();\n\twhile (!hlist_empty(&mp->m_list)) {\n\t\tmnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);\n\t\tumount_tree(mnt, 0);\n\t}\n\tunlock_mount_hash();\n\tput_mountpoint(mp);\nout_unlock:\n\tnamespace_unlock();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "namespace_unlock",
          "args": [],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1320-1334",
          "snippet": "static void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);",
            "static HLIST_HEAD(unmounted);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic HLIST_HEAD(unmounted);\n\nstatic void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_mountpoint",
          "args": [
            "mp"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "put_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "758-769",
          "snippet": "static void put_mountpoint(struct mountpoint *mp)\n{\n\tif (!--mp->m_count) {\n\t\tstruct dentry *dentry = mp->m_dentry;\n\t\tBUG_ON(!hlist_empty(&mp->m_list));\n\t\tspin_lock(&dentry->d_lock);\n\t\tdentry->d_flags &= ~DCACHE_MOUNTED;\n\t\tspin_unlock(&dentry->d_lock);\n\t\thlist_del(&mp->m_hash);\n\t\tkfree(mp);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void put_mountpoint(struct mountpoint *mp)\n{\n\tif (!--mp->m_count) {\n\t\tstruct dentry *dentry = mp->m_dentry;\n\t\tBUG_ON(!hlist_empty(&mp->m_list));\n\t\tspin_lock(&dentry->d_lock);\n\t\tdentry->d_flags &= ~DCACHE_MOUNTED;\n\t\tspin_unlock(&dentry->d_lock);\n\t\thlist_del(&mp->m_hash);\n\t\tkfree(mp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_mount_hash",
          "args": [],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "114-117",
          "snippet": "static inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern seqlock_t mount_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern seqlock_t mount_lock;\n\nstatic inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umount_tree",
          "args": [
            "mnt",
            "0"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "umount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1349-1388",
          "snippet": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static HLIST_HEAD(unmounted);",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic HLIST_HEAD(unmounted);\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "mp->m_list.first",
            "structmount",
            "mnt_mp_list"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&mp->m_list"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_mountpoint",
          "args": [
            "dentry"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "718-733",
          "snippet": "static struct mountpoint *lookup_mountpoint(struct dentry *dentry)\n{\n\tstruct hlist_head *chain = mp_hash(dentry);\n\tstruct mountpoint *mp;\n\n\thlist_for_each_entry(mp, chain, m_hash) {\n\t\tif (mp->m_dentry == dentry) {\n\t\t\t/* might be worth a WARN_ON() */\n\t\t\tif (d_unlinked(dentry))\n\t\t\t\treturn ERR_PTR(-ENOENT);\n\t\t\tmp->m_count++;\n\t\t\treturn mp;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct mountpoint *lookup_mountpoint(struct dentry *dentry)\n{\n\tstruct hlist_head *chain = mp_hash(dentry);\n\tstruct mountpoint *mp;\n\n\thlist_for_each_entry(mp, chain, m_hash) {\n\t\tif (mp->m_dentry == dentry) {\n\t\t\t/* might be worth a WARN_ON() */\n\t\t\tif (d_unlinked(dentry))\n\t\t\t\treturn ERR_PTR(-ENOENT);\n\t\t\tmp->m_count++;\n\t\t\treturn mp;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "namespace_lock",
          "args": [],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1336-1339",
          "snippet": "static inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\n\nstatic inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid __detach_mounts(struct dentry *dentry)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *mnt;\n\n\tnamespace_lock();\n\tmp = lookup_mountpoint(dentry);\n\tif (!mp)\n\t\tgoto out_unlock;\n\n\tlock_mount_hash();\n\twhile (!hlist_empty(&mp->m_list)) {\n\t\tmnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);\n\t\tumount_tree(mnt, 0);\n\t}\n\tunlock_mount_hash();\n\tput_mountpoint(mp);\nout_unlock:\n\tnamespace_unlock();\n}"
  },
  {
    "function_name": "do_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1392-1484",
    "snippet": "static int do_umount(struct mount *mnt, int flags)\n{\n\tstruct super_block *sb = mnt->mnt.mnt_sb;\n\tint retval;\n\n\tretval = security_sb_umount(&mnt->mnt, flags);\n\tif (retval)\n\t\treturn retval;\n\n\t/*\n\t * Allow userspace to request a mountpoint be expired rather than\n\t * unmounting unconditionally. Unmount only happens if:\n\t *  (1) the mark is already set (the mark is cleared by mntput())\n\t *  (2) the usage count == 1 [parent vfsmount] + 1 [sys_umount]\n\t */\n\tif (flags & MNT_EXPIRE) {\n\t\tif (&mnt->mnt == current->fs->root.mnt ||\n\t\t    flags & (MNT_FORCE | MNT_DETACH))\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * probably don't strictly need the lock here if we examined\n\t\t * all race cases, but it's a slowpath.\n\t\t */\n\t\tlock_mount_hash();\n\t\tif (mnt_get_count(mnt) != 2) {\n\t\t\tunlock_mount_hash();\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tunlock_mount_hash();\n\n\t\tif (!xchg(&mnt->mnt_expiry_mark, 1))\n\t\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * If we may have to abort operations to get out of this\n\t * mount, and they will themselves hold resources we must\n\t * allow the fs to do things. In the Unix tradition of\n\t * 'Gee thats tricky lets do it in userspace' the umount_begin\n\t * might fail to complete on the first run through as other tasks\n\t * must return, and the like. Thats for the mount program to worry\n\t * about for the moment.\n\t */\n\n\tif (flags & MNT_FORCE && sb->s_op->umount_begin) {\n\t\tsb->s_op->umount_begin(sb);\n\t}\n\n\t/*\n\t * No sense to grab the lock for this test, but test itself looks\n\t * somewhat bogus. Suggestions for better replacement?\n\t * Ho-hum... In principle, we might treat that as umount + switch\n\t * to rootfs. GC would eventually take care of the old vfsmount.\n\t * Actually it makes sense, especially if rootfs would contain a\n\t * /reboot - static binary that would close all descriptors and\n\t * call reboot(9). Then init(8) could umount root and exec /reboot.\n\t */\n\tif (&mnt->mnt == current->fs->root.mnt && !(flags & MNT_DETACH)) {\n\t\t/*\n\t\t * Special case for \"unmounting\" root ...\n\t\t * we just try to remount it readonly.\n\t\t */\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tdown_write(&sb->s_umount);\n\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\tretval = do_remount_sb(sb, MS_RDONLY, NULL, 0);\n\t\tup_write(&sb->s_umount);\n\t\treturn retval;\n\t}\n\n\tnamespace_lock();\n\tlock_mount_hash();\n\tevent++;\n\n\tif (flags & MNT_DETACH) {\n\t\tif (!list_empty(&mnt->mnt_list))\n\t\t\tumount_tree(mnt, UMOUNT_PROPAGATE);\n\t\tretval = 0;\n\t} else {\n\t\tshrink_submounts(mnt);\n\t\tretval = -EBUSY;\n\t\tif (!propagate_mount_busy(mnt, 2)) {\n\t\t\tif (!list_empty(&mnt->mnt_list))\n\t\t\t\tumount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);\n\t\t\tretval = 0;\n\t\t}\n\t}\n\tunlock_mount_hash();\n\tnamespace_unlock();\n\treturn retval;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 event;",
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "namespace_unlock",
          "args": [],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1320-1334",
          "snippet": "static void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);",
            "static HLIST_HEAD(unmounted);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic HLIST_HEAD(unmounted);\n\nstatic void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_mount_hash",
          "args": [],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "114-117",
          "snippet": "static inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern seqlock_t mount_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern seqlock_t mount_lock;\n\nstatic inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umount_tree",
          "args": [
            "mnt",
            "UMOUNT_PROPAGATE|UMOUNT_SYNC"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "umount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1349-1388",
          "snippet": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static HLIST_HEAD(unmounted);",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic HLIST_HEAD(unmounted);\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&mnt->mnt_list"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "propagate_mount_busy",
          "args": [
            "mnt",
            "2"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "propagate_mount_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "337-362",
          "snippet": "int propagate_mount_busy(struct mount *mnt, int refcnt)\n{\n\tstruct mount *m, *child;\n\tstruct mount *parent = mnt->mnt_parent;\n\tint ret = 0;\n\n\tif (mnt == parent)\n\t\treturn do_refcount_check(mnt, refcnt);\n\n\t/*\n\t * quickly check if the current mount can be unmounted.\n\t * If not, we don't have to go checking for all other\n\t * mounts\n\t */\n\tif (!list_empty(&mnt->mnt_mounts) || do_refcount_check(mnt, refcnt))\n\t\treturn 1;\n\n\tfor (m = propagation_next(parent, parent); m;\n\t     \t\tm = propagation_next(m, parent)) {\n\t\tchild = __lookup_mnt_last(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (child && list_empty(&child->mnt_mounts) &&\n\t\t    (ret = do_refcount_check(child, 1)))\n\t\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint propagate_mount_busy(struct mount *mnt, int refcnt)\n{\n\tstruct mount *m, *child;\n\tstruct mount *parent = mnt->mnt_parent;\n\tint ret = 0;\n\n\tif (mnt == parent)\n\t\treturn do_refcount_check(mnt, refcnt);\n\n\t/*\n\t * quickly check if the current mount can be unmounted.\n\t * If not, we don't have to go checking for all other\n\t * mounts\n\t */\n\tif (!list_empty(&mnt->mnt_mounts) || do_refcount_check(mnt, refcnt))\n\t\treturn 1;\n\n\tfor (m = propagation_next(parent, parent); m;\n\t     \t\tm = propagation_next(m, parent)) {\n\t\tchild = __lookup_mnt_last(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (child && list_empty(&child->mnt_mounts) &&\n\t\t    (ret = do_refcount_check(child, 1)))\n\t\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_submounts",
          "args": [
            "mnt"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_submounts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2492-2506",
          "snippet": "static void shrink_submounts(struct mount *mnt)\n{\n\tLIST_HEAD(graveyard);\n\tstruct mount *m;\n\n\t/* extract submounts of 'mountpoint' from the expiration list */\n\twhile (select_submounts(mnt, &graveyard)) {\n\t\twhile (!list_empty(&graveyard)) {\n\t\t\tm = list_first_entry(&graveyard, struct mount,\n\t\t\t\t\t\tmnt_expire);\n\t\t\ttouch_mnt_namespace(m->mnt_ns);\n\t\t\tumount_tree(m, UMOUNT_PROPAGATE|UMOUNT_SYNC);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void shrink_submounts(struct mount *mnt)\n{\n\tLIST_HEAD(graveyard);\n\tstruct mount *m;\n\n\t/* extract submounts of 'mountpoint' from the expiration list */\n\twhile (select_submounts(mnt, &graveyard)) {\n\t\twhile (!list_empty(&graveyard)) {\n\t\t\tm = list_first_entry(&graveyard, struct mount,\n\t\t\t\t\t\tmnt_expire);\n\t\t\ttouch_mnt_namespace(m->mnt_ns);\n\t\t\tumount_tree(m, UMOUNT_PROPAGATE|UMOUNT_SYNC);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "namespace_lock",
          "args": [],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "namespace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1336-1339",
          "snippet": "static inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\n\nstatic inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_remount_sb",
          "args": [
            "sb",
            "MS_RDONLY",
            "NULL",
            "0"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->umount_begin",
          "args": [
            "sb"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&mnt->mnt_expiry_mark",
            "1"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_get_count",
          "args": [
            "mnt"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_get_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "177-191",
          "snippet": "unsigned int mnt_get_count(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_count;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_count;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nunsigned int mnt_get_count(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_count;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_sb_umount",
          "args": [
            "&mnt->mnt",
            "flags"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic u64 event;\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int do_umount(struct mount *mnt, int flags)\n{\n\tstruct super_block *sb = mnt->mnt.mnt_sb;\n\tint retval;\n\n\tretval = security_sb_umount(&mnt->mnt, flags);\n\tif (retval)\n\t\treturn retval;\n\n\t/*\n\t * Allow userspace to request a mountpoint be expired rather than\n\t * unmounting unconditionally. Unmount only happens if:\n\t *  (1) the mark is already set (the mark is cleared by mntput())\n\t *  (2) the usage count == 1 [parent vfsmount] + 1 [sys_umount]\n\t */\n\tif (flags & MNT_EXPIRE) {\n\t\tif (&mnt->mnt == current->fs->root.mnt ||\n\t\t    flags & (MNT_FORCE | MNT_DETACH))\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * probably don't strictly need the lock here if we examined\n\t\t * all race cases, but it's a slowpath.\n\t\t */\n\t\tlock_mount_hash();\n\t\tif (mnt_get_count(mnt) != 2) {\n\t\t\tunlock_mount_hash();\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tunlock_mount_hash();\n\n\t\tif (!xchg(&mnt->mnt_expiry_mark, 1))\n\t\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * If we may have to abort operations to get out of this\n\t * mount, and they will themselves hold resources we must\n\t * allow the fs to do things. In the Unix tradition of\n\t * 'Gee thats tricky lets do it in userspace' the umount_begin\n\t * might fail to complete on the first run through as other tasks\n\t * must return, and the like. Thats for the mount program to worry\n\t * about for the moment.\n\t */\n\n\tif (flags & MNT_FORCE && sb->s_op->umount_begin) {\n\t\tsb->s_op->umount_begin(sb);\n\t}\n\n\t/*\n\t * No sense to grab the lock for this test, but test itself looks\n\t * somewhat bogus. Suggestions for better replacement?\n\t * Ho-hum... In principle, we might treat that as umount + switch\n\t * to rootfs. GC would eventually take care of the old vfsmount.\n\t * Actually it makes sense, especially if rootfs would contain a\n\t * /reboot - static binary that would close all descriptors and\n\t * call reboot(9). Then init(8) could umount root and exec /reboot.\n\t */\n\tif (&mnt->mnt == current->fs->root.mnt && !(flags & MNT_DETACH)) {\n\t\t/*\n\t\t * Special case for \"unmounting\" root ...\n\t\t * we just try to remount it readonly.\n\t\t */\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tdown_write(&sb->s_umount);\n\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\tretval = do_remount_sb(sb, MS_RDONLY, NULL, 0);\n\t\tup_write(&sb->s_umount);\n\t\treturn retval;\n\t}\n\n\tnamespace_lock();\n\tlock_mount_hash();\n\tevent++;\n\n\tif (flags & MNT_DETACH) {\n\t\tif (!list_empty(&mnt->mnt_list))\n\t\t\tumount_tree(mnt, UMOUNT_PROPAGATE);\n\t\tretval = 0;\n\t} else {\n\t\tshrink_submounts(mnt);\n\t\tretval = -EBUSY;\n\t\tif (!propagate_mount_busy(mnt, 2)) {\n\t\t\tif (!list_empty(&mnt->mnt_list))\n\t\t\t\tumount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);\n\t\t\tretval = 0;\n\t\t}\n\t}\n\tunlock_mount_hash();\n\tnamespace_unlock();\n\treturn retval;\n}"
  },
  {
    "function_name": "umount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1349-1388",
    "snippet": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static HLIST_HEAD(unmounted);",
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "change_mnt_propagation",
          "args": [
            "p",
            "MS_PRIVATE"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "change_mnt_propagation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "119-134",
          "snippet": "void change_mnt_propagation(struct mount *mnt, int type)\n{\n\tif (type == MS_SHARED) {\n\t\tset_mnt_shared(mnt);\n\t\treturn;\n\t}\n\tdo_make_slave(mnt);\n\tif (type != MS_SLAVE) {\n\t\tlist_del_init(&mnt->mnt_slave);\n\t\tmnt->mnt_master = NULL;\n\t\tif (type == MS_UNBINDABLE)\n\t\t\tmnt->mnt.mnt_flags |= MNT_UNBINDABLE;\n\t\telse\n\t\t\tmnt->mnt.mnt_flags &= ~MNT_UNBINDABLE;\n\t}\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nvoid change_mnt_propagation(struct mount *mnt, int type)\n{\n\tif (type == MS_SHARED) {\n\t\tset_mnt_shared(mnt);\n\t\treturn;\n\t}\n\tdo_make_slave(mnt);\n\tif (type != MS_SLAVE) {\n\t\tlist_del_init(&mnt->mnt_slave);\n\t\tmnt->mnt_master = NULL;\n\t\tif (type == MS_UNBINDABLE)\n\t\t\tmnt->mnt.mnt_flags |= MNT_UNBINDABLE;\n\t\telse\n\t\t\tmnt->mnt.mnt_flags &= ~MNT_UNBINDABLE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "umount_mnt",
          "args": [
            "p"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "umount_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "825-830",
          "snippet": "static void umount_mnt(struct mount *mnt)\n{\n\t/* old mountpoint will be dropped when we can do that */\n\tmnt->mnt_ex_mountpoint = mnt->mnt_mountpoint;\n\tunhash_mnt(mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void umount_mnt(struct mount *mnt)\n{\n\t/* old mountpoint will be dropped when we can do that */\n\tmnt->mnt_ex_mountpoint = mnt->mnt_mountpoint;\n\tunhash_mnt(mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_add_count",
          "args": [
            "p->mnt_parent",
            "-1"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_add_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "163-172",
          "snippet": "static inline void mnt_add_count(struct mount *mnt, int n)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_add(mnt->mnt_pcp->mnt_count, n);\n#else\n\tpreempt_disable();\n\tmnt->mnt_count += n;\n\tpreempt_enable();\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline void mnt_add_count(struct mount *mnt, int n)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_add(mnt->mnt_pcp->mnt_count, n);\n#else\n\tpreempt_disable();\n\tmnt->mnt_count += n;\n\tpreempt_enable();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_has_parent",
          "args": [
            "p"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_has_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "77-80",
          "snippet": "static inline int mnt_has_parent(struct mount *mnt)\n{\n\treturn mnt != mnt->mnt_parent;\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nstatic inline int mnt_has_parent(struct mount *mnt)\n{\n\treturn mnt != mnt->mnt_parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_insert_group",
          "args": [
            "&p->mnt_umount",
            "&p->mnt_parent->mnt",
            "&unmounted"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "pin_insert_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_pin.c",
          "lines": "21-28",
          "snippet": "void pin_insert_group(struct fs_pin *pin, struct vfsmount *m, struct hlist_head *p)\n{\n\tspin_lock(&pin_lock);\n\tif (p)\n\t\thlist_add_head(&pin->s_list, p);\n\thlist_add_head(&pin->m_list, &real_mount(m)->mnt_pins);\n\tspin_unlock(&pin_lock);\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pin_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(pin_lock);\n\nvoid pin_insert_group(struct fs_pin *pin, struct vfsmount *m, struct hlist_head *p)\n{\n\tspin_lock(&pin_lock);\n\tif (p)\n\t\thlist_add_head(&pin->s_list, p);\n\thlist_add_head(&pin->m_list, &real_mount(m)->mnt_pins);\n\tspin_unlock(&pin_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__touch_mnt_namespace",
          "args": [
            "p->mnt_ns"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "__touch_mnt_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "790-796",
          "snippet": "static void __touch_mnt_namespace(struct mnt_namespace *ns)\n{\n\tif (ns && ns->event != event) {\n\t\tns->event = event;\n\t\twake_up_interruptible(&ns->poll);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 event;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic u64 event;\n\nstatic void __touch_mnt_namespace(struct mnt_namespace *ns)\n{\n\tif (ns && ns->event != event) {\n\t\tns->event = event;\n\t\twake_up_interruptible(&ns->poll);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&p->mnt_list"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&p->mnt_expire"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&tmp_list",
            "structmount",
            "mnt_list"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tmp_list"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "propagate_umount",
          "args": [
            "&tmp_list"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "propagate_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "442-452",
          "snippet": "int propagate_umount(struct list_head *list)\n{\n\tstruct mount *mnt;\n\n\tlist_for_each_entry_reverse(mnt, list, mnt_list)\n\t\tmark_umount_candidates(mnt);\n\n\tlist_for_each_entry(mnt, list, mnt_list)\n\t\t__propagate_umount(mnt);\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *list;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct hlist_head *list;\n\nint propagate_umount(struct list_head *list)\n{\n\tstruct mount *mnt;\n\n\tlist_for_each_entry_reverse(mnt, list, mnt_list)\n\t\tmark_umount_candidates(mnt);\n\n\tlist_for_each_entry(mnt, list, mnt_list)\n\t\t__propagate_umount(mnt);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&p->mnt_child"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&tmp_list",
            "mnt_list"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&p->mnt_list",
            "&tmp_list"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_mnt",
          "args": [
            "p",
            "mnt"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "next_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "895-909",
          "snippet": "static struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}"
        }
      },
      {
        "call_info": {
          "callee": "propagate_mount_unlock",
          "args": [
            "mnt"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "propagate_mount_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "369-382",
          "snippet": "void propagate_mount_unlock(struct mount *mnt)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m, *child;\n\n\tBUG_ON(parent == mnt);\n\n\tfor (m = propagation_next(parent, parent); m;\n\t\t\tm = propagation_next(m, parent)) {\n\t\tchild = __lookup_mnt_last(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (child)\n\t\t\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\t}\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nvoid propagate_mount_unlock(struct mount *mnt)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m, *child;\n\n\tBUG_ON(parent == mnt);\n\n\tfor (m = propagation_next(parent, parent); m;\n\t\t\tm = propagation_next(m, parent)) {\n\t\tchild = __lookup_mnt_last(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (child)\n\t\t\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tmp_list"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic HLIST_HEAD(unmounted);\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}"
  },
  {
    "function_name": "namespace_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1336-1339",
    "snippet": "static inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(namespace_sem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&namespace_sem"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\n\nstatic inline void namespace_lock(void)\n{\n\tdown_write(&namespace_sem);\n}"
  },
  {
    "function_name": "namespace_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1320-1334",
    "snippet": "static void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(namespace_sem);",
      "static HLIST_HEAD(unmounted);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "group_pin_kill",
          "args": [
            "&head"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "group_pin_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_pin.c",
          "lines": "90-102",
          "snippet": "void group_pin_kill(struct hlist_head *p)\n{\n\twhile (1) {\n\t\tstruct hlist_node *q;\n\t\trcu_read_lock();\n\t\tq = ACCESS_ONCE(p->first);\n\t\tif (!q) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tpin_kill(hlist_entry(q, struct fs_pin, s_list));\n\t}\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n\nvoid group_pin_kill(struct hlist_head *p)\n{\n\twhile (1) {\n\t\tstruct hlist_node *q;\n\t\trcu_read_lock();\n\t\tq = ACCESS_ONCE(p->first);\n\t\tif (!q) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tpin_kill(hlist_entry(q, struct fs_pin, s_list));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "hlist_empty(&head)"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&head"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&namespace_sem"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_move_list",
          "args": [
            "&unmounted",
            "&head"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic HLIST_HEAD(unmounted);\n\nstatic void namespace_unlock(void)\n{\n\tstruct hlist_head head;\n\n\thlist_move_list(&unmounted, &head);\n\n\tup_write(&namespace_sem);\n\n\tif (likely(hlist_empty(&head)))\n\t\treturn;\n\n\tsynchronize_rcu();\n\n\tgroup_pin_kill(&head);\n}"
  },
  {
    "function_name": "may_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1304-1314",
    "snippet": "int may_umount(struct vfsmount *mnt)\n{\n\tint ret = 1;\n\tdown_read(&namespace_sem);\n\tlock_mount_hash();\n\tif (propagate_mount_busy(real_mount(mnt), 2))\n\t\tret = 0;\n\tunlock_mount_hash();\n\tup_read(&namespace_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(namespace_sem);",
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&namespace_sem"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_mount_hash",
          "args": [],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "114-117",
          "snippet": "static inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern seqlock_t mount_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern seqlock_t mount_lock;\n\nstatic inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "propagate_mount_busy",
          "args": [
            "real_mount(mnt)",
            "2"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "propagate_mount_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "337-362",
          "snippet": "int propagate_mount_busy(struct mount *mnt, int refcnt)\n{\n\tstruct mount *m, *child;\n\tstruct mount *parent = mnt->mnt_parent;\n\tint ret = 0;\n\n\tif (mnt == parent)\n\t\treturn do_refcount_check(mnt, refcnt);\n\n\t/*\n\t * quickly check if the current mount can be unmounted.\n\t * If not, we don't have to go checking for all other\n\t * mounts\n\t */\n\tif (!list_empty(&mnt->mnt_mounts) || do_refcount_check(mnt, refcnt))\n\t\treturn 1;\n\n\tfor (m = propagation_next(parent, parent); m;\n\t     \t\tm = propagation_next(m, parent)) {\n\t\tchild = __lookup_mnt_last(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (child && list_empty(&child->mnt_mounts) &&\n\t\t    (ret = do_refcount_check(child, 1)))\n\t\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint propagate_mount_busy(struct mount *mnt, int refcnt)\n{\n\tstruct mount *m, *child;\n\tstruct mount *parent = mnt->mnt_parent;\n\tint ret = 0;\n\n\tif (mnt == parent)\n\t\treturn do_refcount_check(mnt, refcnt);\n\n\t/*\n\t * quickly check if the current mount can be unmounted.\n\t * If not, we don't have to go checking for all other\n\t * mounts\n\t */\n\tif (!list_empty(&mnt->mnt_mounts) || do_refcount_check(mnt, refcnt))\n\t\treturn 1;\n\n\tfor (m = propagation_next(parent, parent); m;\n\t     \t\tm = propagation_next(m, parent)) {\n\t\tchild = __lookup_mnt_last(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (child && list_empty(&child->mnt_mounts) &&\n\t\t    (ret = do_refcount_check(child, 1)))\n\t\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&namespace_sem"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic void shrink_submounts(struct mount *mnt);\n\nint may_umount(struct vfsmount *mnt)\n{\n\tint ret = 1;\n\tdown_read(&namespace_sem);\n\tlock_mount_hash();\n\tif (propagate_mount_busy(real_mount(mnt), 2))\n\t\tret = 0;\n\tunlock_mount_hash();\n\tup_read(&namespace_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "may_umount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1267-1287",
    "snippet": "int may_umount_tree(struct vfsmount *m)\n{\n\tstruct mount *mnt = real_mount(m);\n\tint actual_refs = 0;\n\tint minimum_refs = 0;\n\tstruct mount *p;\n\tBUG_ON(!m);\n\n\t/* write lock needed for mnt_get_count */\n\tlock_mount_hash();\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tactual_refs += mnt_get_count(p);\n\t\tminimum_refs += 2;\n\t}\n\tunlock_mount_hash();\n\n\tif (actual_refs > minimum_refs)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_mount_hash",
          "args": [],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "114-117",
          "snippet": "static inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern seqlock_t mount_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern seqlock_t mount_lock;\n\nstatic inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_get_count",
          "args": [
            "p"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_get_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "177-191",
          "snippet": "unsigned int mnt_get_count(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_count;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_count;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nunsigned int mnt_get_count(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_count;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_mnt",
          "args": [
            "p",
            "mnt"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "next_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "895-909",
          "snippet": "static struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!m"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "m"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint may_umount_tree(struct vfsmount *m)\n{\n\tstruct mount *mnt = real_mount(m);\n\tint actual_refs = 0;\n\tint minimum_refs = 0;\n\tstruct mount *p;\n\tBUG_ON(!m);\n\n\t/* write lock needed for mnt_get_count */\n\tlock_mount_hash();\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tactual_refs += mnt_get_count(p);\n\t\tminimum_refs += 2;\n\t}\n\tunlock_mount_hash();\n\n\tif (actual_refs > minimum_refs)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "m_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1244-1249",
    "snippet": "static int m_show(struct seq_file *m, void *v)\n{\n\tstruct proc_mounts *p = proc_mounts(m);\n\tstruct mount *r = list_entry(v, struct mount, mnt_list);\n\treturn p->show(m, &r->mnt);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "p->show",
          "args": [
            "m",
            "&r->mnt"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "v",
            "structmount",
            "mnt_list"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_mounts",
          "args": [
            "m"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int m_show(struct seq_file *m, void *v)\n{\n\tstruct proc_mounts *p = proc_mounts(m);\n\tstruct mount *r = list_entry(v, struct mount, mnt_list);\n\treturn p->show(m, &r->mnt);\n}"
  },
  {
    "function_name": "m_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1239-1242",
    "snippet": "static void m_stop(struct seq_file *m, void *v)\n{\n\tup_read(&namespace_sem);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(namespace_sem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&namespace_sem"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\n\nstatic void m_stop(struct seq_file *m, void *v)\n{\n\tup_read(&namespace_sem);\n}"
  },
  {
    "function_name": "m_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1230-1237",
    "snippet": "static void *m_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct proc_mounts *p = proc_mounts(m);\n\n\tp->cached_mount = seq_list_next(v, &p->ns->list, pos);\n\tp->cached_index = *pos;\n\treturn p->cached_mount;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "v",
            "&p->ns->list",
            "pos"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "seq_list_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "779-786",
          "snippet": "struct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mounts",
          "args": [
            "m"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void *m_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct proc_mounts *p = proc_mounts(m);\n\n\tp->cached_mount = seq_list_next(v, &p->ns->list, pos);\n\tp->cached_index = *pos;\n\treturn p->cached_mount;\n}"
  },
  {
    "function_name": "m_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1209-1228",
    "snippet": "static void *m_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct proc_mounts *p = proc_mounts(m);\n\n\tdown_read(&namespace_sem);\n\tif (p->cached_event == p->ns->event) {\n\t\tvoid *v = p->cached_mount;\n\t\tif (*pos == p->cached_index)\n\t\t\treturn v;\n\t\tif (*pos == p->cached_index + 1) {\n\t\t\tv = seq_list_next(v, &p->ns->list, &p->cached_index);\n\t\t\treturn p->cached_mount = v;\n\t\t}\n\t}\n\n\tp->cached_event = p->ns->event;\n\tp->cached_mount = seq_list_start(&p->ns->list, *pos);\n\tp->cached_index = *pos;\n\treturn p->cached_mount;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 event;",
      "static DECLARE_RWSEM(namespace_sem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start",
          "args": [
            "&p->ns->list",
            "*pos"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "seq_list_start_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "770-776",
          "snippet": "struct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start(head, pos - 1);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start(head, pos - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "v",
            "&p->ns->list",
            "&p->cached_index"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "seq_list_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "779-786",
          "snippet": "struct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&namespace_sem"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_mounts",
          "args": [
            "m"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic u64 event;\nstatic DECLARE_RWSEM(namespace_sem);\n\nstatic void *m_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct proc_mounts *p = proc_mounts(m);\n\n\tdown_read(&namespace_sem);\n\tif (p->cached_event == p->ns->event) {\n\t\tvoid *v = p->cached_mount;\n\t\tif (*pos == p->cached_index)\n\t\t\treturn v;\n\t\tif (*pos == p->cached_index + 1) {\n\t\t\tv = seq_list_next(v, &p->ns->list, &p->cached_index);\n\t\t\treturn p->cached_mount = v;\n\t\t}\n\t}\n\n\tp->cached_event = p->ns->event;\n\tp->cached_mount = seq_list_start(&p->ns->list, *pos);\n\tp->cached_index = *pos;\n\treturn p->cached_mount;\n}"
  },
  {
    "function_name": "replace_mount_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1196-1204",
    "snippet": "void replace_mount_options(struct super_block *sb, char *options)\n{\n\tchar *old = sb->s_options;\n\trcu_assign_pointer(sb->s_options, options);\n\tif (old) {\n\t\tsynchronize_rcu();\n\t\tkfree(old);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "old"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "sb->s_options",
            "options"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid replace_mount_options(struct super_block *sb, char *options)\n{\n\tchar *old = sb->s_options;\n\trcu_assign_pointer(sb->s_options, options);\n\tif (old) {\n\t\tsynchronize_rcu();\n\t\tkfree(old);\n\t}\n}"
  },
  {
    "function_name": "save_mount_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1189-1193",
    "snippet": "void save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "sb->s_options",
            "kstrdup(options, GFP_KERNEL)"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "options",
            "GFP_KERNEL"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sb->s_options"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}"
  },
  {
    "function_name": "generic_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1159-1173",
    "snippet": "int generic_show_options(struct seq_file *m, struct dentry *root)\n{\n\tconst char *options;\n\n\trcu_read_lock();\n\toptions = rcu_dereference(root->d_sb->s_options);\n\n\tif (options != NULL && options[0]) {\n\t\tseq_putc(m, ',');\n\t\tmangle(m, options);\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mangle",
          "args": [
            "m",
            "options"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "mangle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1148-1151",
          "snippet": "static inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "','"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "root->d_sb->s_options"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint generic_show_options(struct seq_file *m, struct dentry *root)\n{\n\tconst char *options;\n\n\trcu_read_lock();\n\toptions = rcu_dereference(root->d_sb->s_options);\n\n\tif (options != NULL && options[0]) {\n\t\tseq_putc(m, ',');\n\t\tmangle(m, options);\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mangle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1148-1151",
    "snippet": "static inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_escape",
          "args": [
            "m",
            "s",
            "\" \\t\\n\\\\\""
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "seq_escape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "374-397",
          "snippet": "int seq_escape(struct seq_file *m, const char *s, const char *esc)\n{\n\tchar *end = m->buf + m->size;\n        char *p;\n\tchar c;\n\n        for (p = m->buf + m->count; (c = *s) != '\\0' && p < end; s++) {\n\t\tif (!strchr(esc, c)) {\n\t\t\t*p++ = c;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p + 3 < end) {\n\t\t\t*p++ = '\\\\';\n\t\t\t*p++ = '0' + ((c & 0300) >> 6);\n\t\t\t*p++ = '0' + ((c & 070) >> 3);\n\t\t\t*p++ = '0' + (c & 07);\n\t\t\tcontinue;\n\t\t}\n\t\tseq_set_overflow(m);\n\t\treturn -1;\n        }\n\tm->count = p - m->buf;\n        return 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_escape(struct seq_file *m, const char *s, const char *esc)\n{\n\tchar *end = m->buf + m->size;\n        char *p;\n\tchar c;\n\n        for (p = m->buf + m->count; (c = *s) != '\\0' && p < end; s++) {\n\t\tif (!strchr(esc, c)) {\n\t\t\t*p++ = c;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p + 3 < end) {\n\t\t\t*p++ = '\\\\';\n\t\t\t*p++ = '0' + ((c & 0300) >> 6);\n\t\t\t*p++ = '0' + ((c & 070) >> 3);\n\t\t\t*p++ = '0' + (c & 07);\n\t\t\tcontinue;\n\t\t}\n\t\tseq_set_overflow(m);\n\t\treturn -1;\n        }\n\tm->count = p - m->buf;\n        return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}"
  },
  {
    "function_name": "mnt_clone_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1138-1146",
    "snippet": "struct vfsmount *mnt_clone_internal(struct path *path)\n{\n\tstruct mount *p;\n\tp = clone_mnt(real_mount(path->mnt), path->dentry, CL_PRIVATE);\n\tif (IS_ERR(p))\n\t\treturn ERR_CAST(p);\n\tp->mnt.mnt_flags |= MNT_INTERNAL;\n\treturn &p->mnt;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "p"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone_mnt",
          "args": [
            "real_mount(path->mnt)",
            "path->dentry",
            "CL_PRIVATE"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "clone_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "955-1037",
          "snippet": "static struct mount *clone_mnt(struct mount *old, struct dentry *root,\n\t\t\t\t\tint flag)\n{\n\tstruct super_block *sb = old->mnt.mnt_sb;\n\tstruct mount *mnt;\n\tint err;\n\n\tmnt = alloc_vfsmnt(old->mnt_devname);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))\n\t\tmnt->mnt_group_id = 0; /* not a peer of original */\n\telse\n\t\tmnt->mnt_group_id = old->mnt_group_id;\n\n\tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {\n\t\terr = mnt_alloc_group_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n\t/* Don't allow unprivileged users to change mount flags */\n\tif (flag & CL_UNPRIVILEGED) {\n\t\tmnt->mnt.mnt_flags |= MNT_LOCK_ATIME;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_READONLY)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NODEV)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NODEV;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOSUID)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOSUID;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOEXEC)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOEXEC;\n\t}\n\n\t/* Don't allow unprivileged users to reveal what is under a mount */\n\tif ((flag & CL_UNPRIVILEGED) &&\n\t    (!(flag & CL_EXPIRE) || list_empty(&old->mnt_expire)))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCKED;\n\n\tatomic_inc(&sb->s_active);\n\tmnt->mnt.mnt_sb = sb;\n\tmnt->mnt.mnt_root = dget(root);\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &sb->s_mounts);\n\tunlock_mount_hash();\n\n\tif ((flag & CL_SLAVE) ||\n\t    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {\n\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave_list);\n\t\tmnt->mnt_master = old;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t} else if (!(flag & CL_PRIVATE)) {\n\t\tif ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))\n\t\t\tlist_add(&mnt->mnt_share, &old->mnt_share);\n\t\tif (IS_MNT_SLAVE(old))\n\t\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave);\n\t\tmnt->mnt_master = old->mnt_master;\n\t}\n\tif (flag & CL_MAKE_SHARED)\n\t\tset_mnt_shared(mnt);\n\n\t/* stick the duplicate mount on the same expiry list\n\t * as the original if that was on one */\n\tif (flag & CL_EXPIRE) {\n\t\tif (!list_empty(&old->mnt_expire))\n\t\t\tlist_add(&mnt->mnt_expire, &old->mnt_expire);\n\t}\n\n\treturn mnt;\n\n out_free:\n\tmnt_free_id(mnt);\n\tfree_vfsmnt(mnt);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic struct mount *clone_mnt(struct mount *old, struct dentry *root,\n\t\t\t\t\tint flag)\n{\n\tstruct super_block *sb = old->mnt.mnt_sb;\n\tstruct mount *mnt;\n\tint err;\n\n\tmnt = alloc_vfsmnt(old->mnt_devname);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))\n\t\tmnt->mnt_group_id = 0; /* not a peer of original */\n\telse\n\t\tmnt->mnt_group_id = old->mnt_group_id;\n\n\tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {\n\t\terr = mnt_alloc_group_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n\t/* Don't allow unprivileged users to change mount flags */\n\tif (flag & CL_UNPRIVILEGED) {\n\t\tmnt->mnt.mnt_flags |= MNT_LOCK_ATIME;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_READONLY)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NODEV)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NODEV;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOSUID)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOSUID;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOEXEC)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOEXEC;\n\t}\n\n\t/* Don't allow unprivileged users to reveal what is under a mount */\n\tif ((flag & CL_UNPRIVILEGED) &&\n\t    (!(flag & CL_EXPIRE) || list_empty(&old->mnt_expire)))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCKED;\n\n\tatomic_inc(&sb->s_active);\n\tmnt->mnt.mnt_sb = sb;\n\tmnt->mnt.mnt_root = dget(root);\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &sb->s_mounts);\n\tunlock_mount_hash();\n\n\tif ((flag & CL_SLAVE) ||\n\t    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {\n\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave_list);\n\t\tmnt->mnt_master = old;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t} else if (!(flag & CL_PRIVATE)) {\n\t\tif ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))\n\t\t\tlist_add(&mnt->mnt_share, &old->mnt_share);\n\t\tif (IS_MNT_SLAVE(old))\n\t\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave);\n\t\tmnt->mnt_master = old->mnt_master;\n\t}\n\tif (flag & CL_MAKE_SHARED)\n\t\tset_mnt_shared(mnt);\n\n\t/* stick the duplicate mount on the same expiry list\n\t * as the original if that was on one */\n\tif (flag & CL_EXPIRE) {\n\t\tif (!list_empty(&old->mnt_expire))\n\t\t\tlist_add(&mnt->mnt_expire, &old->mnt_expire);\n\t}\n\n\treturn mnt;\n\n out_free:\n\tmnt_free_id(mnt);\n\tfree_vfsmnt(mnt);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "path->mnt"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *mnt_clone_internal(struct path *path)\n{\n\tstruct mount *p;\n\tp = clone_mnt(real_mount(path->mnt), path->dentry, CL_PRIVATE);\n\tif (IS_ERR(p))\n\t\treturn ERR_CAST(p);\n\tp->mnt.mnt_flags |= MNT_INTERNAL;\n\treturn &p->mnt;\n}"
  },
  {
    "function_name": "mntget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1130-1135",
    "snippet": "struct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_add_count",
          "args": [
            "real_mount(mnt)",
            "1"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_add_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "163-172",
          "snippet": "static inline void mnt_add_count(struct mount *mnt, int n)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_add(mnt->mnt_pcp->mnt_count, n);\n#else\n\tpreempt_disable();\n\tmnt->mnt_count += n;\n\tpreempt_enable();\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline void mnt_add_count(struct mount *mnt, int n)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_add(mnt->mnt_pcp->mnt_count, n);\n#else\n\tpreempt_disable();\n\tmnt->mnt_count += n;\n\tpreempt_enable();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}"
  },
  {
    "function_name": "mntput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1118-1127",
    "snippet": "void mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mntput_no_expire",
          "args": [
            "m"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "mntput_no_expire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1079-1116",
          "snippet": "static void mntput_no_expire(struct mount *mnt)\n{\n\trcu_read_lock();\n\tmnt_add_count(mnt, -1);\n\tif (likely(mnt->mnt_ns)) { /* shouldn't be the last one */\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tlock_mount_hash();\n\tif (mnt_get_count(mnt)) {\n\t\trcu_read_unlock();\n\t\tunlock_mount_hash();\n\t\treturn;\n\t}\n\tif (unlikely(mnt->mnt.mnt_flags & MNT_DOOMED)) {\n\t\trcu_read_unlock();\n\t\tunlock_mount_hash();\n\t\treturn;\n\t}\n\tmnt->mnt.mnt_flags |= MNT_DOOMED;\n\trcu_read_unlock();\n\n\tlist_del(&mnt->mnt_instance);\n\tunlock_mount_hash();\n\n\tif (likely(!(mnt->mnt.mnt_flags & MNT_INTERNAL))) {\n\t\tstruct task_struct *task = current;\n\t\tif (likely(!(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&mnt->mnt_rcu, __cleanup_mnt);\n\t\t\tif (!task_work_add(task, &mnt->mnt_rcu, true))\n\t\t\t\treturn;\n\t\t}\n\t\tif (llist_add(&mnt->mnt_llist, &delayed_mntput_list))\n\t\t\tschedule_delayed_work(&delayed_mntput_work, 1);\n\t\treturn;\n\t}\n\tcleanup_mnt(mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LLIST_HEAD(delayed_mntput_list);",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic LLIST_HEAD(delayed_mntput_list);\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void mntput_no_expire(struct mount *mnt)\n{\n\trcu_read_lock();\n\tmnt_add_count(mnt, -1);\n\tif (likely(mnt->mnt_ns)) { /* shouldn't be the last one */\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tlock_mount_hash();\n\tif (mnt_get_count(mnt)) {\n\t\trcu_read_unlock();\n\t\tunlock_mount_hash();\n\t\treturn;\n\t}\n\tif (unlikely(mnt->mnt.mnt_flags & MNT_DOOMED)) {\n\t\trcu_read_unlock();\n\t\tunlock_mount_hash();\n\t\treturn;\n\t}\n\tmnt->mnt.mnt_flags |= MNT_DOOMED;\n\trcu_read_unlock();\n\n\tlist_del(&mnt->mnt_instance);\n\tunlock_mount_hash();\n\n\tif (likely(!(mnt->mnt.mnt_flags & MNT_INTERNAL))) {\n\t\tstruct task_struct *task = current;\n\t\tif (likely(!(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&mnt->mnt_rcu, __cleanup_mnt);\n\t\t\tif (!task_work_add(task, &mnt->mnt_rcu, true))\n\t\t\t\treturn;\n\t\t}\n\t\tif (llist_add(&mnt->mnt_llist, &delayed_mntput_list))\n\t\t\tschedule_delayed_work(&delayed_mntput_work, 1);\n\t\treturn;\n\t}\n\tcleanup_mnt(mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "m->mnt_expiry_mark"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}"
  },
  {
    "function_name": "mntput_no_expire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1079-1116",
    "snippet": "static void mntput_no_expire(struct mount *mnt)\n{\n\trcu_read_lock();\n\tmnt_add_count(mnt, -1);\n\tif (likely(mnt->mnt_ns)) { /* shouldn't be the last one */\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tlock_mount_hash();\n\tif (mnt_get_count(mnt)) {\n\t\trcu_read_unlock();\n\t\tunlock_mount_hash();\n\t\treturn;\n\t}\n\tif (unlikely(mnt->mnt.mnt_flags & MNT_DOOMED)) {\n\t\trcu_read_unlock();\n\t\tunlock_mount_hash();\n\t\treturn;\n\t}\n\tmnt->mnt.mnt_flags |= MNT_DOOMED;\n\trcu_read_unlock();\n\n\tlist_del(&mnt->mnt_instance);\n\tunlock_mount_hash();\n\n\tif (likely(!(mnt->mnt.mnt_flags & MNT_INTERNAL))) {\n\t\tstruct task_struct *task = current;\n\t\tif (likely(!(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&mnt->mnt_rcu, __cleanup_mnt);\n\t\t\tif (!task_work_add(task, &mnt->mnt_rcu, true))\n\t\t\t\treturn;\n\t\t}\n\t\tif (llist_add(&mnt->mnt_llist, &delayed_mntput_list))\n\t\t\tschedule_delayed_work(&delayed_mntput_work, 1);\n\t\treturn;\n\t}\n\tcleanup_mnt(mnt);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LLIST_HEAD(delayed_mntput_list);",
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_mnt",
          "args": [
            "mnt"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "__cleanup_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1061-1064",
          "snippet": "static void __cleanup_mnt(struct rcu_head *head)\n{\n\tcleanup_mnt(container_of(head, struct mount, mnt_rcu));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void __cleanup_mnt(struct rcu_head *head)\n{\n\tcleanup_mnt(container_of(head, struct mount, mnt_rcu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&delayed_mntput_work",
            "1"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_add",
          "args": [
            "&mnt->mnt_llist",
            "&delayed_mntput_list"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_work_add",
          "args": [
            "task",
            "&mnt->mnt_rcu",
            "true"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_task_work",
          "args": [
            "&mnt->mnt_rcu",
            "__cleanup_mnt"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(task->flags & PF_KTHREAD)"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(mnt->mnt.mnt_flags & MNT_INTERNAL)"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_mount_hash",
          "args": [],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "114-117",
          "snippet": "static inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern seqlock_t mount_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern seqlock_t mount_lock;\n\nstatic inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&mnt->mnt_instance"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mnt->mnt.mnt_flags & MNT_DOOMED"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_get_count",
          "args": [
            "mnt"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_get_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "177-191",
          "snippet": "unsigned int mnt_get_count(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_count;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_count;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nunsigned int mnt_get_count(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_count;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "mnt->mnt_ns"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_add_count",
          "args": [
            "mnt",
            "-1"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_add_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "163-172",
          "snippet": "static inline void mnt_add_count(struct mount *mnt, int n)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_add(mnt->mnt_pcp->mnt_count, n);\n#else\n\tpreempt_disable();\n\tmnt->mnt_count += n;\n\tpreempt_enable();\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline void mnt_add_count(struct mount *mnt, int n)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_add(mnt->mnt_pcp->mnt_count, n);\n#else\n\tpreempt_disable();\n\tmnt->mnt_count += n;\n\tpreempt_enable();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic LLIST_HEAD(delayed_mntput_list);\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void mntput_no_expire(struct mount *mnt)\n{\n\trcu_read_lock();\n\tmnt_add_count(mnt, -1);\n\tif (likely(mnt->mnt_ns)) { /* shouldn't be the last one */\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tlock_mount_hash();\n\tif (mnt_get_count(mnt)) {\n\t\trcu_read_unlock();\n\t\tunlock_mount_hash();\n\t\treturn;\n\t}\n\tif (unlikely(mnt->mnt.mnt_flags & MNT_DOOMED)) {\n\t\trcu_read_unlock();\n\t\tunlock_mount_hash();\n\t\treturn;\n\t}\n\tmnt->mnt.mnt_flags |= MNT_DOOMED;\n\trcu_read_unlock();\n\n\tlist_del(&mnt->mnt_instance);\n\tunlock_mount_hash();\n\n\tif (likely(!(mnt->mnt.mnt_flags & MNT_INTERNAL))) {\n\t\tstruct task_struct *task = current;\n\t\tif (likely(!(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&mnt->mnt_rcu, __cleanup_mnt);\n\t\t\tif (!task_work_add(task, &mnt->mnt_rcu, true))\n\t\t\t\treturn;\n\t\t}\n\t\tif (llist_add(&mnt->mnt_llist, &delayed_mntput_list))\n\t\t\tschedule_delayed_work(&delayed_mntput_work, 1);\n\t\treturn;\n\t}\n\tcleanup_mnt(mnt);\n}"
  },
  {
    "function_name": "delayed_mntput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1067-1076",
    "snippet": "static void delayed_mntput(struct work_struct *unused)\n{\n\tstruct llist_node *node = llist_del_all(&delayed_mntput_list);\n\tstruct llist_node *next;\n\n\tfor (; node; node = next) {\n\t\tnext = llist_next(node);\n\t\tcleanup_mnt(llist_entry(node, struct mount, mnt_llist));\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LLIST_HEAD(delayed_mntput_list);",
      "static DECLARE_DELAYED_WORK(delayed_mntput_work, delayed_mntput);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "llist_next",
          "args": [
            "node"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_del_all",
          "args": [
            "&delayed_mntput_list"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic LLIST_HEAD(delayed_mntput_list);\nstatic DECLARE_DELAYED_WORK(delayed_mntput_work, delayed_mntput);\n\nstatic void delayed_mntput(struct work_struct *unused)\n{\n\tstruct llist_node *node = llist_del_all(&delayed_mntput_list);\n\tstruct llist_node *next;\n\n\tfor (; node; node = next) {\n\t\tnext = llist_next(node);\n\t\tcleanup_mnt(llist_entry(node, struct mount, mnt_llist));\n\t}\n}"
  },
  {
    "function_name": "__cleanup_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1061-1064",
    "snippet": "static void __cleanup_mnt(struct rcu_head *head)\n{\n\tcleanup_mnt(container_of(head, struct mount, mnt_rcu));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void __cleanup_mnt(struct rcu_head *head)\n{\n\tcleanup_mnt(container_of(head, struct mount, mnt_rcu));\n}"
  },
  {
    "function_name": "cleanup_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "1039-1059",
    "snippet": "static void cleanup_mnt(struct mount *mnt)\n{\n\t/*\n\t * This probably indicates that somebody messed\n\t * up a mnt_want/drop_write() pair.  If this\n\t * happens, the filesystem was probably unable\n\t * to make r/w->r/o transitions.\n\t */\n\t/*\n\t * The locking used to deal with mnt_count decrement provides barriers,\n\t * so mnt_get_writers() below is safe.\n\t */\n\tWARN_ON(mnt_get_writers(mnt));\n\tif (unlikely(mnt->mnt_pins.first))\n\t\tmnt_pin_kill(mnt);\n\tfsnotify_vfsmount_delete(&mnt->mnt);\n\tdput(mnt->mnt.mnt_root);\n\tdeactivate_super(mnt->mnt.mnt_sb);\n\tmnt_free_id(mnt);\n\tcall_rcu(&mnt->mnt_rcu, delayed_free_vfsmnt);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&mnt->mnt_rcu",
            "delayed_free_vfsmnt"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_free_id",
          "args": [
            "mnt"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_free_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "117-125",
          "snippet": "static void mnt_free_id(struct mount *mnt)\n{\n\tint id = mnt->mnt_id;\n\tspin_lock(&mnt_id_lock);\n\tida_remove(&mnt_id_ida, id);\n\tif (mnt_id_start > id)\n\t\tmnt_id_start = id;\n\tspin_unlock(&mnt_id_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDA(mnt_id_ida);",
            "static DEFINE_SPINLOCK(mnt_id_lock);",
            "static int mnt_id_start = 0;",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_IDA(mnt_id_ida);\nstatic DEFINE_SPINLOCK(mnt_id_lock);\nstatic int mnt_id_start = 0;\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void mnt_free_id(struct mount *mnt)\n{\n\tint id = mnt->mnt_id;\n\tspin_lock(&mnt_id_lock);\n\tida_remove(&mnt_id_ida, id);\n\tif (mnt_id_start > id)\n\t\tmnt_id_start = id;\n\tspin_unlock(&mnt_id_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deactivate_super",
          "args": [
            "mnt->mnt.mnt_sb"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "mnt->mnt.mnt_root"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_vfsmount_delete",
          "args": [
            "&mnt->mnt"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "__fsnotify_vfsmount_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
          "lines": "40-43",
          "snippet": "void __fsnotify_vfsmount_delete(struct vfsmount *mnt)\n{\n\tfsnotify_clear_marks_by_mount(mnt);\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/srcu.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nvoid __fsnotify_vfsmount_delete(struct vfsmount *mnt)\n{\n\tfsnotify_clear_marks_by_mount(mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_pin_kill",
          "args": [
            "mnt"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_pin_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_pin.c",
          "lines": "76-88",
          "snippet": "void mnt_pin_kill(struct mount *m)\n{\n\twhile (1) {\n\t\tstruct hlist_node *p;\n\t\trcu_read_lock();\n\t\tp = ACCESS_ONCE(m->mnt_pins.first);\n\t\tif (!p) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tpin_kill(hlist_entry(p, struct fs_pin, m_list));\n\t}\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n\nvoid mnt_pin_kill(struct mount *m)\n{\n\twhile (1) {\n\t\tstruct hlist_node *p;\n\t\trcu_read_lock();\n\t\tp = ACCESS_ONCE(m->mnt_pins.first);\n\t\tif (!p) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tpin_kill(hlist_entry(p, struct fs_pin, m_list));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mnt->mnt_pins.first"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "mnt_get_writers(mnt)"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_get_writers",
          "args": [
            "mnt"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_get_writers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "302-316",
          "snippet": "static unsigned int mnt_get_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_writers;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_writers;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic unsigned int mnt_get_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_writers;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_writers;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void cleanup_mnt(struct mount *mnt)\n{\n\t/*\n\t * This probably indicates that somebody messed\n\t * up a mnt_want/drop_write() pair.  If this\n\t * happens, the filesystem was probably unable\n\t * to make r/w->r/o transitions.\n\t */\n\t/*\n\t * The locking used to deal with mnt_count decrement provides barriers,\n\t * so mnt_get_writers() below is safe.\n\t */\n\tWARN_ON(mnt_get_writers(mnt));\n\tif (unlikely(mnt->mnt_pins.first))\n\t\tmnt_pin_kill(mnt);\n\tfsnotify_vfsmount_delete(&mnt->mnt);\n\tdput(mnt->mnt.mnt_root);\n\tdeactivate_super(mnt->mnt.mnt_sb);\n\tmnt_free_id(mnt);\n\tcall_rcu(&mnt->mnt_rcu, delayed_free_vfsmnt);\n}"
  },
  {
    "function_name": "clone_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "955-1037",
    "snippet": "static struct mount *clone_mnt(struct mount *old, struct dentry *root,\n\t\t\t\t\tint flag)\n{\n\tstruct super_block *sb = old->mnt.mnt_sb;\n\tstruct mount *mnt;\n\tint err;\n\n\tmnt = alloc_vfsmnt(old->mnt_devname);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))\n\t\tmnt->mnt_group_id = 0; /* not a peer of original */\n\telse\n\t\tmnt->mnt_group_id = old->mnt_group_id;\n\n\tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {\n\t\terr = mnt_alloc_group_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n\t/* Don't allow unprivileged users to change mount flags */\n\tif (flag & CL_UNPRIVILEGED) {\n\t\tmnt->mnt.mnt_flags |= MNT_LOCK_ATIME;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_READONLY)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NODEV)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NODEV;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOSUID)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOSUID;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOEXEC)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOEXEC;\n\t}\n\n\t/* Don't allow unprivileged users to reveal what is under a mount */\n\tif ((flag & CL_UNPRIVILEGED) &&\n\t    (!(flag & CL_EXPIRE) || list_empty(&old->mnt_expire)))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCKED;\n\n\tatomic_inc(&sb->s_active);\n\tmnt->mnt.mnt_sb = sb;\n\tmnt->mnt.mnt_root = dget(root);\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &sb->s_mounts);\n\tunlock_mount_hash();\n\n\tif ((flag & CL_SLAVE) ||\n\t    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {\n\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave_list);\n\t\tmnt->mnt_master = old;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t} else if (!(flag & CL_PRIVATE)) {\n\t\tif ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))\n\t\t\tlist_add(&mnt->mnt_share, &old->mnt_share);\n\t\tif (IS_MNT_SLAVE(old))\n\t\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave);\n\t\tmnt->mnt_master = old->mnt_master;\n\t}\n\tif (flag & CL_MAKE_SHARED)\n\t\tset_mnt_shared(mnt);\n\n\t/* stick the duplicate mount on the same expiry list\n\t * as the original if that was on one */\n\tif (flag & CL_EXPIRE) {\n\t\tif (!list_empty(&old->mnt_expire))\n\t\t\tlist_add(&mnt->mnt_expire, &old->mnt_expire);\n\t}\n\n\treturn mnt;\n\n out_free:\n\tmnt_free_id(mnt);\n\tfree_vfsmnt(mnt);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_vfsmnt",
          "args": [
            "mnt"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_free_vfsmnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "587-590",
          "snippet": "static void delayed_free_vfsmnt(struct rcu_head *head)\n{\n\tfree_vfsmnt(container_of(head, struct mount, mnt_rcu));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void delayed_free_vfsmnt(struct rcu_head *head)\n{\n\tfree_vfsmnt(container_of(head, struct mount, mnt_rcu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_free_id",
          "args": [
            "mnt"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_free_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "117-125",
          "snippet": "static void mnt_free_id(struct mount *mnt)\n{\n\tint id = mnt->mnt_id;\n\tspin_lock(&mnt_id_lock);\n\tida_remove(&mnt_id_ida, id);\n\tif (mnt_id_start > id)\n\t\tmnt_id_start = id;\n\tspin_unlock(&mnt_id_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDA(mnt_id_ida);",
            "static DEFINE_SPINLOCK(mnt_id_lock);",
            "static int mnt_id_start = 0;",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_IDA(mnt_id_ida);\nstatic DEFINE_SPINLOCK(mnt_id_lock);\nstatic int mnt_id_start = 0;\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void mnt_free_id(struct mount *mnt)\n{\n\tint id = mnt->mnt_id;\n\tspin_lock(&mnt_id_lock);\n\tida_remove(&mnt_id_ida, id);\n\tif (mnt_id_start > id)\n\t\tmnt_id_start = id;\n\tspin_unlock(&mnt_id_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&mnt->mnt_expire",
            "&old->mnt_expire"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&old->mnt_expire"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_mnt_shared",
          "args": [
            "mnt"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "set_mnt_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.h",
          "lines": "35-39",
          "snippet": "static inline void set_mnt_shared(struct mount *mnt)\n{\n\tmnt->mnt.mnt_flags &= ~MNT_SHARED_MASK;\n\tmnt->mnt.mnt_flags |= MNT_SHARED;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/list.h>\n\nstatic inline void set_mnt_shared(struct mount *mnt)\n{\n\tmnt->mnt.mnt_flags &= ~MNT_SHARED_MASK;\n\tmnt->mnt.mnt_flags |= MNT_SHARED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_SLAVE",
          "args": [
            "old"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MNT_SHARED",
          "args": [
            "old"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_MNT_SHARED",
          "args": [
            "mnt"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MNT_SHARED",
          "args": [
            "old"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_mount_hash",
          "args": [],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "114-117",
          "snippet": "static inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern seqlock_t mount_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern seqlock_t mount_lock;\n\nstatic inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&mnt->mnt_instance",
            "&sb->s_mounts"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "root"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sb->s_active"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_alloc_group_id",
          "args": [
            "mnt"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_alloc_group_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "132-146",
          "snippet": "static int mnt_alloc_group_id(struct mount *mnt)\n{\n\tint res;\n\n\tif (!ida_pre_get(&mnt_group_ida, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tres = ida_get_new_above(&mnt_group_ida,\n\t\t\t\tmnt_group_start,\n\t\t\t\t&mnt->mnt_group_id);\n\tif (!res)\n\t\tmnt_group_start = mnt->mnt_group_id + 1;\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDA(mnt_group_ida);",
            "static int mnt_group_start = 1;",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_IDA(mnt_group_ida);\nstatic int mnt_group_start = 1;\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int mnt_alloc_group_id(struct mount *mnt)\n{\n\tint res;\n\n\tif (!ida_pre_get(&mnt_group_ida, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tres = ida_get_new_above(&mnt_group_ida,\n\t\t\t\tmnt_group_start,\n\t\t\t\t&mnt->mnt_group_id);\n\tif (!res)\n\t\tmnt_group_start = mnt->mnt_group_id + 1;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_vfsmnt",
          "args": [
            "old->mnt_devname"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_vfsmnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "201-253",
          "snippet": "static struct mount *alloc_vfsmnt(const char *name)\n{\n\tstruct mount *mnt = kmem_cache_zalloc(mnt_cache, GFP_KERNEL);\n\tif (mnt) {\n\t\tint err;\n\n\t\terr = mnt_alloc_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free_cache;\n\n\t\tif (name) {\n\t\t\tmnt->mnt_devname = kstrdup_const(name, GFP_KERNEL);\n\t\t\tif (!mnt->mnt_devname)\n\t\t\t\tgoto out_free_id;\n\t\t}\n\n#ifdef CONFIG_SMP\n\t\tmnt->mnt_pcp = alloc_percpu(struct mnt_pcp);\n\t\tif (!mnt->mnt_pcp)\n\t\t\tgoto out_free_devname;\n\n\t\tthis_cpu_add(mnt->mnt_pcp->mnt_count, 1);\n#else\n\t\tmnt->mnt_count = 1;\n\t\tmnt->mnt_writers = 0;\n#endif\n\n\t\tINIT_HLIST_NODE(&mnt->mnt_hash);\n\t\tINIT_LIST_HEAD(&mnt->mnt_child);\n\t\tINIT_LIST_HEAD(&mnt->mnt_mounts);\n\t\tINIT_LIST_HEAD(&mnt->mnt_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_expire);\n\t\tINIT_LIST_HEAD(&mnt->mnt_share);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave);\n\t\tINIT_HLIST_NODE(&mnt->mnt_mp_list);\n#ifdef CONFIG_FSNOTIFY\n\t\tINIT_HLIST_HEAD(&mnt->mnt_fsnotify_marks);\n#endif\n\t\tinit_fs_pin(&mnt->mnt_umount, drop_mountpoint);\n\t}\n\treturn mnt;\n\n#ifdef CONFIG_SMP\nout_free_devname:\n\tkfree_const(mnt->mnt_devname);\n#endif\nout_free_id:\n\tmnt_free_id(mnt);\nout_free_cache:\n\tkmem_cache_free(mnt_cache, mnt);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic struct mount *alloc_vfsmnt(const char *name)\n{\n\tstruct mount *mnt = kmem_cache_zalloc(mnt_cache, GFP_KERNEL);\n\tif (mnt) {\n\t\tint err;\n\n\t\terr = mnt_alloc_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free_cache;\n\n\t\tif (name) {\n\t\t\tmnt->mnt_devname = kstrdup_const(name, GFP_KERNEL);\n\t\t\tif (!mnt->mnt_devname)\n\t\t\t\tgoto out_free_id;\n\t\t}\n\n#ifdef CONFIG_SMP\n\t\tmnt->mnt_pcp = alloc_percpu(struct mnt_pcp);\n\t\tif (!mnt->mnt_pcp)\n\t\t\tgoto out_free_devname;\n\n\t\tthis_cpu_add(mnt->mnt_pcp->mnt_count, 1);\n#else\n\t\tmnt->mnt_count = 1;\n\t\tmnt->mnt_writers = 0;\n#endif\n\n\t\tINIT_HLIST_NODE(&mnt->mnt_hash);\n\t\tINIT_LIST_HEAD(&mnt->mnt_child);\n\t\tINIT_LIST_HEAD(&mnt->mnt_mounts);\n\t\tINIT_LIST_HEAD(&mnt->mnt_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_expire);\n\t\tINIT_LIST_HEAD(&mnt->mnt_share);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave);\n\t\tINIT_HLIST_NODE(&mnt->mnt_mp_list);\n#ifdef CONFIG_FSNOTIFY\n\t\tINIT_HLIST_HEAD(&mnt->mnt_fsnotify_marks);\n#endif\n\t\tinit_fs_pin(&mnt->mnt_umount, drop_mountpoint);\n\t}\n\treturn mnt;\n\n#ifdef CONFIG_SMP\nout_free_devname:\n\tkfree_const(mnt->mnt_devname);\n#endif\nout_free_id:\n\tmnt_free_id(mnt);\nout_free_cache:\n\tkmem_cache_free(mnt_cache, mnt);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic struct mount *clone_mnt(struct mount *old, struct dentry *root,\n\t\t\t\t\tint flag)\n{\n\tstruct super_block *sb = old->mnt.mnt_sb;\n\tstruct mount *mnt;\n\tint err;\n\n\tmnt = alloc_vfsmnt(old->mnt_devname);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))\n\t\tmnt->mnt_group_id = 0; /* not a peer of original */\n\telse\n\t\tmnt->mnt_group_id = old->mnt_group_id;\n\n\tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {\n\t\terr = mnt_alloc_group_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n\t/* Don't allow unprivileged users to change mount flags */\n\tif (flag & CL_UNPRIVILEGED) {\n\t\tmnt->mnt.mnt_flags |= MNT_LOCK_ATIME;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_READONLY)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NODEV)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NODEV;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOSUID)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOSUID;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOEXEC)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOEXEC;\n\t}\n\n\t/* Don't allow unprivileged users to reveal what is under a mount */\n\tif ((flag & CL_UNPRIVILEGED) &&\n\t    (!(flag & CL_EXPIRE) || list_empty(&old->mnt_expire)))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCKED;\n\n\tatomic_inc(&sb->s_active);\n\tmnt->mnt.mnt_sb = sb;\n\tmnt->mnt.mnt_root = dget(root);\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &sb->s_mounts);\n\tunlock_mount_hash();\n\n\tif ((flag & CL_SLAVE) ||\n\t    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {\n\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave_list);\n\t\tmnt->mnt_master = old;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t} else if (!(flag & CL_PRIVATE)) {\n\t\tif ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))\n\t\t\tlist_add(&mnt->mnt_share, &old->mnt_share);\n\t\tif (IS_MNT_SLAVE(old))\n\t\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave);\n\t\tmnt->mnt_master = old->mnt_master;\n\t}\n\tif (flag & CL_MAKE_SHARED)\n\t\tset_mnt_shared(mnt);\n\n\t/* stick the duplicate mount on the same expiry list\n\t * as the original if that was on one */\n\tif (flag & CL_EXPIRE) {\n\t\tif (!list_empty(&old->mnt_expire))\n\t\t\tlist_add(&mnt->mnt_expire, &old->mnt_expire);\n\t}\n\n\treturn mnt;\n\n out_free:\n\tmnt_free_id(mnt);\n\tfree_vfsmnt(mnt);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "vfs_kern_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "921-952",
    "snippet": "struct vfsmount *\nvfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & MS_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tmnt_free_id(mnt);\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tunlock_mount_hash();\n\treturn &mnt->mnt;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_mount_hash",
          "args": [],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "114-117",
          "snippet": "static inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern seqlock_t mount_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern seqlock_t mount_lock;\n\nstatic inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&mnt->mnt_instance",
            "&root->d_sb->s_mounts"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "root"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_vfsmnt",
          "args": [
            "mnt"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_free_vfsmnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "587-590",
          "snippet": "static void delayed_free_vfsmnt(struct rcu_head *head)\n{\n\tfree_vfsmnt(container_of(head, struct mount, mnt_rcu));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void delayed_free_vfsmnt(struct rcu_head *head)\n{\n\tfree_vfsmnt(container_of(head, struct mount, mnt_rcu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_free_id",
          "args": [
            "mnt"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_free_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "117-125",
          "snippet": "static void mnt_free_id(struct mount *mnt)\n{\n\tint id = mnt->mnt_id;\n\tspin_lock(&mnt_id_lock);\n\tida_remove(&mnt_id_ida, id);\n\tif (mnt_id_start > id)\n\t\tmnt_id_start = id;\n\tspin_unlock(&mnt_id_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDA(mnt_id_ida);",
            "static DEFINE_SPINLOCK(mnt_id_lock);",
            "static int mnt_id_start = 0;",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_IDA(mnt_id_ida);\nstatic DEFINE_SPINLOCK(mnt_id_lock);\nstatic int mnt_id_start = 0;\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void mnt_free_id(struct mount *mnt)\n{\n\tint id = mnt->mnt_id;\n\tspin_lock(&mnt_id_lock);\n\tida_remove(&mnt_id_ida, id);\n\tif (mnt_id_start > id)\n\t\tmnt_id_start = id;\n\tspin_unlock(&mnt_id_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount_fs",
          "args": [
            "type",
            "flags",
            "name",
            "data"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_vfsmnt",
          "args": [
            "name"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_vfsmnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "201-253",
          "snippet": "static struct mount *alloc_vfsmnt(const char *name)\n{\n\tstruct mount *mnt = kmem_cache_zalloc(mnt_cache, GFP_KERNEL);\n\tif (mnt) {\n\t\tint err;\n\n\t\terr = mnt_alloc_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free_cache;\n\n\t\tif (name) {\n\t\t\tmnt->mnt_devname = kstrdup_const(name, GFP_KERNEL);\n\t\t\tif (!mnt->mnt_devname)\n\t\t\t\tgoto out_free_id;\n\t\t}\n\n#ifdef CONFIG_SMP\n\t\tmnt->mnt_pcp = alloc_percpu(struct mnt_pcp);\n\t\tif (!mnt->mnt_pcp)\n\t\t\tgoto out_free_devname;\n\n\t\tthis_cpu_add(mnt->mnt_pcp->mnt_count, 1);\n#else\n\t\tmnt->mnt_count = 1;\n\t\tmnt->mnt_writers = 0;\n#endif\n\n\t\tINIT_HLIST_NODE(&mnt->mnt_hash);\n\t\tINIT_LIST_HEAD(&mnt->mnt_child);\n\t\tINIT_LIST_HEAD(&mnt->mnt_mounts);\n\t\tINIT_LIST_HEAD(&mnt->mnt_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_expire);\n\t\tINIT_LIST_HEAD(&mnt->mnt_share);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave);\n\t\tINIT_HLIST_NODE(&mnt->mnt_mp_list);\n#ifdef CONFIG_FSNOTIFY\n\t\tINIT_HLIST_HEAD(&mnt->mnt_fsnotify_marks);\n#endif\n\t\tinit_fs_pin(&mnt->mnt_umount, drop_mountpoint);\n\t}\n\treturn mnt;\n\n#ifdef CONFIG_SMP\nout_free_devname:\n\tkfree_const(mnt->mnt_devname);\n#endif\nout_free_id:\n\tmnt_free_id(mnt);\nout_free_cache:\n\tkmem_cache_free(mnt_cache, mnt);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic struct mount *alloc_vfsmnt(const char *name)\n{\n\tstruct mount *mnt = kmem_cache_zalloc(mnt_cache, GFP_KERNEL);\n\tif (mnt) {\n\t\tint err;\n\n\t\terr = mnt_alloc_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free_cache;\n\n\t\tif (name) {\n\t\t\tmnt->mnt_devname = kstrdup_const(name, GFP_KERNEL);\n\t\t\tif (!mnt->mnt_devname)\n\t\t\t\tgoto out_free_id;\n\t\t}\n\n#ifdef CONFIG_SMP\n\t\tmnt->mnt_pcp = alloc_percpu(struct mnt_pcp);\n\t\tif (!mnt->mnt_pcp)\n\t\t\tgoto out_free_devname;\n\n\t\tthis_cpu_add(mnt->mnt_pcp->mnt_count, 1);\n#else\n\t\tmnt->mnt_count = 1;\n\t\tmnt->mnt_writers = 0;\n#endif\n\n\t\tINIT_HLIST_NODE(&mnt->mnt_hash);\n\t\tINIT_LIST_HEAD(&mnt->mnt_child);\n\t\tINIT_LIST_HEAD(&mnt->mnt_mounts);\n\t\tINIT_LIST_HEAD(&mnt->mnt_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_expire);\n\t\tINIT_LIST_HEAD(&mnt->mnt_share);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave);\n\t\tINIT_HLIST_NODE(&mnt->mnt_mp_list);\n#ifdef CONFIG_FSNOTIFY\n\t\tINIT_HLIST_HEAD(&mnt->mnt_fsnotify_marks);\n#endif\n\t\tinit_fs_pin(&mnt->mnt_umount, drop_mountpoint);\n\t}\n\treturn mnt;\n\n#ifdef CONFIG_SMP\nout_free_devname:\n\tkfree_const(mnt->mnt_devname);\n#endif\nout_free_id:\n\tmnt_free_id(mnt);\nout_free_cache:\n\tkmem_cache_free(mnt_cache, mnt);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENODEV"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *\nvfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & MS_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tmnt_free_id(mnt);\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tunlock_mount_hash();\n\treturn &mnt->mnt;\n}"
  },
  {
    "function_name": "skip_mnt_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "911-919",
    "snippet": "static struct mount *skip_mnt_tree(struct mount *p)\n{\n\tstruct list_head *prev = p->mnt_mounts.prev;\n\twhile (prev != &p->mnt_mounts) {\n\t\tp = list_entry(prev, struct mount, mnt_child);\n\t\tprev = p->mnt_mounts.prev;\n\t}\n\treturn p;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "prev",
            "structmount",
            "mnt_child"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct mount *skip_mnt_tree(struct mount *p)\n{\n\tstruct list_head *prev = p->mnt_mounts.prev;\n\twhile (prev != &p->mnt_mounts) {\n\t\tp = list_entry(prev, struct mount, mnt_child);\n\t\tprev = p->mnt_mounts.prev;\n\t}\n\treturn p;\n}"
  },
  {
    "function_name": "next_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "895-909",
    "snippet": "static struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structmount",
            "mnt_child"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}"
  },
  {
    "function_name": "commit_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "876-893",
    "snippet": "static void commit_tree(struct mount *mnt, struct mount *shadows)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m;\n\tLIST_HEAD(head);\n\tstruct mnt_namespace *n = parent->mnt_ns;\n\n\tBUG_ON(parent == mnt);\n\n\tlist_add_tail(&head, &mnt->mnt_list);\n\tlist_for_each_entry(m, &head, mnt_list)\n\t\tm->mnt_ns = n;\n\n\tlist_splice(&head, n->list.prev);\n\n\tattach_shadowed(mnt, parent, shadows);\n\ttouch_mnt_namespace(n);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "touch_mnt_namespace",
          "args": [
            "n"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "__touch_mnt_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "790-796",
          "snippet": "static void __touch_mnt_namespace(struct mnt_namespace *ns)\n{\n\tif (ns && ns->event != event) {\n\t\tns->event = event;\n\t\twake_up_interruptible(&ns->poll);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 event;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic u64 event;\n\nstatic void __touch_mnt_namespace(struct mnt_namespace *ns)\n{\n\tif (ns && ns->event != event) {\n\t\tns->event = event;\n\t\twake_up_interruptible(&ns->poll);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_shadowed",
          "args": [
            "mnt",
            "parent",
            "shadows"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "attach_shadowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "859-871",
          "snippet": "static void attach_shadowed(struct mount *mnt,\n\t\t\tstruct mount *parent,\n\t\t\tstruct mount *shadows)\n{\n\tif (shadows) {\n\t\thlist_add_behind_rcu(&mnt->mnt_hash, &shadows->mnt_hash);\n\t\tlist_add(&mnt->mnt_child, &shadows->mnt_child);\n\t} else {\n\t\thlist_add_head_rcu(&mnt->mnt_hash,\n\t\t\t\tm_hash(&parent->mnt, mnt->mnt_mountpoint));\n\t\tlist_add_tail(&mnt->mnt_child, &parent->mnt_mounts);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void attach_shadowed(struct mount *mnt,\n\t\t\tstruct mount *parent,\n\t\t\tstruct mount *shadows)\n{\n\tif (shadows) {\n\t\thlist_add_behind_rcu(&mnt->mnt_hash, &shadows->mnt_hash);\n\t\tlist_add(&mnt->mnt_child, &shadows->mnt_child);\n\t} else {\n\t\thlist_add_head_rcu(&mnt->mnt_hash,\n\t\t\t\tm_hash(&parent->mnt, mnt->mnt_mountpoint));\n\t\tlist_add_tail(&mnt->mnt_child, &parent->mnt_mounts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&head",
            "n->list.prev"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "m",
            "&head",
            "mnt_list"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&head",
            "&mnt->mnt_list"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "parent == mnt"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "head"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void commit_tree(struct mount *mnt, struct mount *shadows)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m;\n\tLIST_HEAD(head);\n\tstruct mnt_namespace *n = parent->mnt_ns;\n\n\tBUG_ON(parent == mnt);\n\n\tlist_add_tail(&head, &mnt->mnt_list);\n\tlist_for_each_entry(m, &head, mnt_list)\n\t\tm->mnt_ns = n;\n\n\tlist_splice(&head, n->list.prev);\n\n\tattach_shadowed(mnt, parent, shadows);\n\ttouch_mnt_namespace(n);\n}"
  },
  {
    "function_name": "attach_shadowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "859-871",
    "snippet": "static void attach_shadowed(struct mount *mnt,\n\t\t\tstruct mount *parent,\n\t\t\tstruct mount *shadows)\n{\n\tif (shadows) {\n\t\thlist_add_behind_rcu(&mnt->mnt_hash, &shadows->mnt_hash);\n\t\tlist_add(&mnt->mnt_child, &shadows->mnt_child);\n\t} else {\n\t\thlist_add_head_rcu(&mnt->mnt_hash,\n\t\t\t\tm_hash(&parent->mnt, mnt->mnt_mountpoint));\n\t\tlist_add_tail(&mnt->mnt_child, &parent->mnt_mounts);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&mnt->mnt_child",
            "&parent->mnt_mounts"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&mnt->mnt_hash",
            "m_hash(&parent->mnt, mnt->mnt_mountpoint)"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_hash",
          "args": [
            "&parent->mnt",
            "mnt->mnt_mountpoint"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "m_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "81-87",
          "snippet": "static inline struct hlist_head *m_hash(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tunsigned long tmp = ((unsigned long)mnt / L1_CACHE_BYTES);\n\ttmp += ((unsigned long)dentry / L1_CACHE_BYTES);\n\ttmp = tmp + (tmp >> m_hash_shift);\n\treturn &mount_hashtable[tmp & m_hash_mask];\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int m_hash_mask",
            "static unsigned int m_hash_shift",
            "static struct hlist_head *mount_hashtable",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned int m_hash_mask;\nstatic unsigned int m_hash_shift;\nstatic struct hlist_head *mount_hashtable;\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline struct hlist_head *m_hash(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tunsigned long tmp = ((unsigned long)mnt / L1_CACHE_BYTES);\n\ttmp += ((unsigned long)dentry / L1_CACHE_BYTES);\n\ttmp = tmp + (tmp >> m_hash_shift);\n\treturn &mount_hashtable[tmp & m_hash_mask];\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&mnt->mnt_child",
            "&shadows->mnt_child"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_behind_rcu",
          "args": [
            "&mnt->mnt_hash",
            "&shadows->mnt_hash"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void attach_shadowed(struct mount *mnt,\n\t\t\tstruct mount *parent,\n\t\t\tstruct mount *shadows)\n{\n\tif (shadows) {\n\t\thlist_add_behind_rcu(&mnt->mnt_hash, &shadows->mnt_hash);\n\t\tlist_add(&mnt->mnt_child, &shadows->mnt_child);\n\t} else {\n\t\thlist_add_head_rcu(&mnt->mnt_hash,\n\t\t\t\tm_hash(&parent->mnt, mnt->mnt_mountpoint));\n\t\tlist_add_tail(&mnt->mnt_child, &parent->mnt_mounts);\n\t}\n}"
  },
  {
    "function_name": "attach_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "850-857",
    "snippet": "static void attach_mnt(struct mount *mnt,\n\t\t\tstruct mount *parent,\n\t\t\tstruct mountpoint *mp)\n{\n\tmnt_set_mountpoint(parent, mp, mnt);\n\thlist_add_head_rcu(&mnt->mnt_hash, m_hash(&parent->mnt, mp->m_dentry));\n\tlist_add_tail(&mnt->mnt_child, &parent->mnt_mounts);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&mnt->mnt_child",
            "&parent->mnt_mounts"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&mnt->mnt_hash",
            "m_hash(&parent->mnt, mp->m_dentry)"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_hash",
          "args": [
            "&parent->mnt",
            "mp->m_dentry"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "m_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "81-87",
          "snippet": "static inline struct hlist_head *m_hash(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tunsigned long tmp = ((unsigned long)mnt / L1_CACHE_BYTES);\n\ttmp += ((unsigned long)dentry / L1_CACHE_BYTES);\n\ttmp = tmp + (tmp >> m_hash_shift);\n\treturn &mount_hashtable[tmp & m_hash_mask];\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int m_hash_mask",
            "static unsigned int m_hash_shift",
            "static struct hlist_head *mount_hashtable",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned int m_hash_mask;\nstatic unsigned int m_hash_shift;\nstatic struct hlist_head *mount_hashtable;\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline struct hlist_head *m_hash(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tunsigned long tmp = ((unsigned long)mnt / L1_CACHE_BYTES);\n\ttmp += ((unsigned long)dentry / L1_CACHE_BYTES);\n\ttmp = tmp + (tmp >> m_hash_shift);\n\treturn &mount_hashtable[tmp & m_hash_mask];\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_set_mountpoint",
          "args": [
            "parent",
            "mp",
            "mnt"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_set_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "835-845",
          "snippet": "void mnt_set_mountpoint(struct mount *mnt,\n\t\t\tstruct mountpoint *mp,\n\t\t\tstruct mount *child_mnt)\n{\n\tmp->m_count++;\n\tmnt_add_count(mnt, 1);\t/* essentially, that's mntget */\n\tchild_mnt->mnt_mountpoint = dget(mp->m_dentry);\n\tchild_mnt->mnt_parent = mnt;\n\tchild_mnt->mnt_mp = mp;\n\thlist_add_head(&child_mnt->mnt_mp_list, &mp->m_list);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_set_mountpoint(struct mount *mnt,\n\t\t\tstruct mountpoint *mp,\n\t\t\tstruct mount *child_mnt)\n{\n\tmp->m_count++;\n\tmnt_add_count(mnt, 1);\t/* essentially, that's mntget */\n\tchild_mnt->mnt_mountpoint = dget(mp->m_dentry);\n\tchild_mnt->mnt_parent = mnt;\n\tchild_mnt->mnt_mp = mp;\n\thlist_add_head(&child_mnt->mnt_mp_list, &mp->m_list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void attach_mnt(struct mount *mnt,\n\t\t\tstruct mount *parent,\n\t\t\tstruct mountpoint *mp)\n{\n\tmnt_set_mountpoint(parent, mp, mnt);\n\thlist_add_head_rcu(&mnt->mnt_hash, m_hash(&parent->mnt, mp->m_dentry));\n\tlist_add_tail(&mnt->mnt_child, &parent->mnt_mounts);\n}"
  },
  {
    "function_name": "mnt_set_mountpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "835-845",
    "snippet": "void mnt_set_mountpoint(struct mount *mnt,\n\t\t\tstruct mountpoint *mp,\n\t\t\tstruct mount *child_mnt)\n{\n\tmp->m_count++;\n\tmnt_add_count(mnt, 1);\t/* essentially, that's mntget */\n\tchild_mnt->mnt_mountpoint = dget(mp->m_dentry);\n\tchild_mnt->mnt_parent = mnt;\n\tchild_mnt->mnt_mp = mp;\n\thlist_add_head(&child_mnt->mnt_mp_list, &mp->m_list);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&child_mnt->mnt_mp_list",
            "&mp->m_list"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "mp->m_dentry"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_add_count",
          "args": [
            "mnt",
            "1"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_add_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "163-172",
          "snippet": "static inline void mnt_add_count(struct mount *mnt, int n)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_add(mnt->mnt_pcp->mnt_count, n);\n#else\n\tpreempt_disable();\n\tmnt->mnt_count += n;\n\tpreempt_enable();\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline void mnt_add_count(struct mount *mnt, int n)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_add(mnt->mnt_pcp->mnt_count, n);\n#else\n\tpreempt_disable();\n\tmnt->mnt_count += n;\n\tpreempt_enable();\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_set_mountpoint(struct mount *mnt,\n\t\t\tstruct mountpoint *mp,\n\t\t\tstruct mount *child_mnt)\n{\n\tmp->m_count++;\n\tmnt_add_count(mnt, 1);\t/* essentially, that's mntget */\n\tchild_mnt->mnt_mountpoint = dget(mp->m_dentry);\n\tchild_mnt->mnt_parent = mnt;\n\tchild_mnt->mnt_mp = mp;\n\thlist_add_head(&child_mnt->mnt_mp_list, &mp->m_list);\n}"
  },
  {
    "function_name": "umount_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "825-830",
    "snippet": "static void umount_mnt(struct mount *mnt)\n{\n\t/* old mountpoint will be dropped when we can do that */\n\tmnt->mnt_ex_mountpoint = mnt->mnt_mountpoint;\n\tunhash_mnt(mnt);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unhash_mnt",
          "args": [
            "mnt"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "801-810",
          "snippet": "static void unhash_mnt(struct mount *mnt)\n{\n\tmnt->mnt_parent = mnt;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tlist_del_init(&mnt->mnt_child);\n\thlist_del_init_rcu(&mnt->mnt_hash);\n\thlist_del_init(&mnt->mnt_mp_list);\n\tput_mountpoint(mnt->mnt_mp);\n\tmnt->mnt_mp = NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void unhash_mnt(struct mount *mnt)\n{\n\tmnt->mnt_parent = mnt;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tlist_del_init(&mnt->mnt_child);\n\thlist_del_init_rcu(&mnt->mnt_hash);\n\thlist_del_init(&mnt->mnt_mp_list);\n\tput_mountpoint(mnt->mnt_mp);\n\tmnt->mnt_mp = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void umount_mnt(struct mount *mnt)\n{\n\t/* old mountpoint will be dropped when we can do that */\n\tmnt->mnt_ex_mountpoint = mnt->mnt_mountpoint;\n\tunhash_mnt(mnt);\n}"
  },
  {
    "function_name": "detach_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "815-820",
    "snippet": "static void detach_mnt(struct mount *mnt, struct path *old_path)\n{\n\told_path->dentry = mnt->mnt_mountpoint;\n\told_path->mnt = &mnt->mnt_parent->mnt;\n\tunhash_mnt(mnt);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unhash_mnt",
          "args": [
            "mnt"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "801-810",
          "snippet": "static void unhash_mnt(struct mount *mnt)\n{\n\tmnt->mnt_parent = mnt;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tlist_del_init(&mnt->mnt_child);\n\thlist_del_init_rcu(&mnt->mnt_hash);\n\thlist_del_init(&mnt->mnt_mp_list);\n\tput_mountpoint(mnt->mnt_mp);\n\tmnt->mnt_mp = NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void unhash_mnt(struct mount *mnt)\n{\n\tmnt->mnt_parent = mnt;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tlist_del_init(&mnt->mnt_child);\n\thlist_del_init_rcu(&mnt->mnt_hash);\n\thlist_del_init(&mnt->mnt_mp_list);\n\tput_mountpoint(mnt->mnt_mp);\n\tmnt->mnt_mp = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void detach_mnt(struct mount *mnt, struct path *old_path)\n{\n\told_path->dentry = mnt->mnt_mountpoint;\n\told_path->mnt = &mnt->mnt_parent->mnt;\n\tunhash_mnt(mnt);\n}"
  },
  {
    "function_name": "unhash_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "801-810",
    "snippet": "static void unhash_mnt(struct mount *mnt)\n{\n\tmnt->mnt_parent = mnt;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tlist_del_init(&mnt->mnt_child);\n\thlist_del_init_rcu(&mnt->mnt_hash);\n\thlist_del_init(&mnt->mnt_mp_list);\n\tput_mountpoint(mnt->mnt_mp);\n\tmnt->mnt_mp = NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_mountpoint",
          "args": [
            "mnt->mnt_mp"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "put_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "758-769",
          "snippet": "static void put_mountpoint(struct mountpoint *mp)\n{\n\tif (!--mp->m_count) {\n\t\tstruct dentry *dentry = mp->m_dentry;\n\t\tBUG_ON(!hlist_empty(&mp->m_list));\n\t\tspin_lock(&dentry->d_lock);\n\t\tdentry->d_flags &= ~DCACHE_MOUNTED;\n\t\tspin_unlock(&dentry->d_lock);\n\t\thlist_del(&mp->m_hash);\n\t\tkfree(mp);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void put_mountpoint(struct mountpoint *mp)\n{\n\tif (!--mp->m_count) {\n\t\tstruct dentry *dentry = mp->m_dentry;\n\t\tBUG_ON(!hlist_empty(&mp->m_list));\n\t\tspin_lock(&dentry->d_lock);\n\t\tdentry->d_flags &= ~DCACHE_MOUNTED;\n\t\tspin_unlock(&dentry->d_lock);\n\t\thlist_del(&mp->m_hash);\n\t\tkfree(mp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&mnt->mnt_mp_list"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_init_rcu",
          "args": [
            "&mnt->mnt_hash"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mnt->mnt_child"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void unhash_mnt(struct mount *mnt)\n{\n\tmnt->mnt_parent = mnt;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tlist_del_init(&mnt->mnt_child);\n\thlist_del_init_rcu(&mnt->mnt_hash);\n\thlist_del_init(&mnt->mnt_mp_list);\n\tput_mountpoint(mnt->mnt_mp);\n\tmnt->mnt_mp = NULL;\n}"
  },
  {
    "function_name": "__touch_mnt_namespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "790-796",
    "snippet": "static void __touch_mnt_namespace(struct mnt_namespace *ns)\n{\n\tif (ns && ns->event != event) {\n\t\tns->event = event;\n\t\twake_up_interruptible(&ns->poll);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 event;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&ns->poll"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic u64 event;\n\nstatic void __touch_mnt_namespace(struct mnt_namespace *ns)\n{\n\tif (ns && ns->event != event) {\n\t\tns->event = event;\n\t\twake_up_interruptible(&ns->poll);\n\t}\n}"
  },
  {
    "function_name": "touch_mnt_namespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "779-785",
    "snippet": "static void touch_mnt_namespace(struct mnt_namespace *ns)\n{\n\tif (ns) {\n\t\tns->event = ++event;\n\t\twake_up_interruptible(&ns->poll);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 event;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&ns->poll"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic u64 event;\n\nstatic void touch_mnt_namespace(struct mnt_namespace *ns)\n{\n\tif (ns) {\n\t\tns->event = ++event;\n\t\twake_up_interruptible(&ns->poll);\n\t}\n}"
  },
  {
    "function_name": "check_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "771-774",
    "snippet": "static inline int check_mnt(struct mount *mnt)\n{\n\treturn mnt->mnt_ns == current->nsproxy->mnt_ns;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline int check_mnt(struct mount *mnt)\n{\n\treturn mnt->mnt_ns == current->nsproxy->mnt_ns;\n}"
  },
  {
    "function_name": "put_mountpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "758-769",
    "snippet": "static void put_mountpoint(struct mountpoint *mp)\n{\n\tif (!--mp->m_count) {\n\t\tstruct dentry *dentry = mp->m_dentry;\n\t\tBUG_ON(!hlist_empty(&mp->m_list));\n\t\tspin_lock(&dentry->d_lock);\n\t\tdentry->d_flags &= ~DCACHE_MOUNTED;\n\t\tspin_unlock(&dentry->d_lock);\n\t\thlist_del(&mp->m_hash);\n\t\tkfree(mp);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mp"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&mp->m_hash"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!hlist_empty(&mp->m_list)"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&mp->m_list"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void put_mountpoint(struct mountpoint *mp)\n{\n\tif (!--mp->m_count) {\n\t\tstruct dentry *dentry = mp->m_dentry;\n\t\tBUG_ON(!hlist_empty(&mp->m_list));\n\t\tspin_lock(&dentry->d_lock);\n\t\tdentry->d_flags &= ~DCACHE_MOUNTED;\n\t\tspin_unlock(&dentry->d_lock);\n\t\thlist_del(&mp->m_hash);\n\t\tkfree(mp);\n\t}\n}"
  },
  {
    "function_name": "new_mountpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "735-756",
    "snippet": "static struct mountpoint *new_mountpoint(struct dentry *dentry)\n{\n\tstruct hlist_head *chain = mp_hash(dentry);\n\tstruct mountpoint *mp;\n\tint ret;\n\n\tmp = kmalloc(sizeof(struct mountpoint), GFP_KERNEL);\n\tif (!mp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = d_set_mounted(dentry);\n\tif (ret) {\n\t\tkfree(mp);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tmp->m_dentry = dentry;\n\tmp->m_count = 1;\n\thlist_add_head(&mp->m_hash, chain);\n\tINIT_HLIST_HEAD(&mp->m_list);\n\treturn mp;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&mp->m_list"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&mp->m_hash",
            "chain"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mp"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_set_mounted",
          "args": [
            "dentry"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "d_set_mounted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1280-1303",
          "snippet": "int d_set_mounted(struct dentry *dentry)\n{\n\tstruct dentry *p;\n\tint ret = -ENOENT;\n\twrite_seqlock(&rename_lock);\n\tfor (p = dentry->d_parent; !IS_ROOT(p); p = p->d_parent) {\n\t\t/* Need exclusion wrt. d_invalidate() */\n\t\tspin_lock(&p->d_lock);\n\t\tif (unlikely(d_unhashed(p))) {\n\t\t\tspin_unlock(&p->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&p->d_lock);\n\t}\n\tspin_lock(&dentry->d_lock);\n\tif (!d_unlinked(dentry)) {\n\t\tdentry->d_flags |= DCACHE_MOUNTED;\n\t\tret = 0;\n\t}\n \tspin_unlock(&dentry->d_lock);\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nint d_set_mounted(struct dentry *dentry)\n{\n\tstruct dentry *p;\n\tint ret = -ENOENT;\n\twrite_seqlock(&rename_lock);\n\tfor (p = dentry->d_parent; !IS_ROOT(p); p = p->d_parent) {\n\t\t/* Need exclusion wrt. d_invalidate() */\n\t\tspin_lock(&p->d_lock);\n\t\tif (unlikely(d_unhashed(p))) {\n\t\t\tspin_unlock(&p->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&p->d_lock);\n\t}\n\tspin_lock(&dentry->d_lock);\n\tif (!d_unlinked(dentry)) {\n\t\tdentry->d_flags |= DCACHE_MOUNTED;\n\t\tret = 0;\n\t}\n \tspin_unlock(&dentry->d_lock);\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct mountpoint)",
            "GFP_KERNEL"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mp_hash",
          "args": [
            "dentry"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "mp_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "89-94",
          "snippet": "static inline struct hlist_head *mp_hash(struct dentry *dentry)\n{\n\tunsigned long tmp = ((unsigned long)dentry / L1_CACHE_BYTES);\n\ttmp = tmp + (tmp >> mp_hash_shift);\n\treturn &mountpoint_hashtable[tmp & mp_hash_mask];\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mp_hash_mask",
            "static unsigned int mp_hash_shift",
            "static struct hlist_head *mountpoint_hashtable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned int mp_hash_mask;\nstatic unsigned int mp_hash_shift;\nstatic struct hlist_head *mountpoint_hashtable;\n\nstatic inline struct hlist_head *mp_hash(struct dentry *dentry)\n{\n\tunsigned long tmp = ((unsigned long)dentry / L1_CACHE_BYTES);\n\ttmp = tmp + (tmp >> mp_hash_shift);\n\treturn &mountpoint_hashtable[tmp & mp_hash_mask];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct mountpoint *new_mountpoint(struct dentry *dentry)\n{\n\tstruct hlist_head *chain = mp_hash(dentry);\n\tstruct mountpoint *mp;\n\tint ret;\n\n\tmp = kmalloc(sizeof(struct mountpoint), GFP_KERNEL);\n\tif (!mp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = d_set_mounted(dentry);\n\tif (ret) {\n\t\tkfree(mp);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tmp->m_dentry = dentry;\n\tmp->m_count = 1;\n\thlist_add_head(&mp->m_hash, chain);\n\tINIT_HLIST_HEAD(&mp->m_list);\n\treturn mp;\n}"
  },
  {
    "function_name": "lookup_mountpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "718-733",
    "snippet": "static struct mountpoint *lookup_mountpoint(struct dentry *dentry)\n{\n\tstruct hlist_head *chain = mp_hash(dentry);\n\tstruct mountpoint *mp;\n\n\thlist_for_each_entry(mp, chain, m_hash) {\n\t\tif (mp->m_dentry == dentry) {\n\t\t\t/* might be worth a WARN_ON() */\n\t\t\tif (d_unlinked(dentry))\n\t\t\t\treturn ERR_PTR(-ENOENT);\n\t\t\tmp->m_count++;\n\t\t\treturn mp;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unlinked",
          "args": [
            "dentry"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "mp",
            "chain",
            "m_hash"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp_hash",
          "args": [
            "dentry"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "mp_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "89-94",
          "snippet": "static inline struct hlist_head *mp_hash(struct dentry *dentry)\n{\n\tunsigned long tmp = ((unsigned long)dentry / L1_CACHE_BYTES);\n\ttmp = tmp + (tmp >> mp_hash_shift);\n\treturn &mountpoint_hashtable[tmp & mp_hash_mask];\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mp_hash_mask",
            "static unsigned int mp_hash_shift",
            "static struct hlist_head *mountpoint_hashtable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned int mp_hash_mask;\nstatic unsigned int mp_hash_shift;\nstatic struct hlist_head *mountpoint_hashtable;\n\nstatic inline struct hlist_head *mp_hash(struct dentry *dentry)\n{\n\tunsigned long tmp = ((unsigned long)dentry / L1_CACHE_BYTES);\n\ttmp = tmp + (tmp >> mp_hash_shift);\n\treturn &mountpoint_hashtable[tmp & mp_hash_mask];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct mountpoint *lookup_mountpoint(struct dentry *dentry)\n{\n\tstruct hlist_head *chain = mp_hash(dentry);\n\tstruct mountpoint *mp;\n\n\thlist_for_each_entry(mp, chain, m_hash) {\n\t\tif (mp->m_dentry == dentry) {\n\t\t\t/* might be worth a WARN_ON() */\n\t\t\tif (d_unlinked(dentry))\n\t\t\t\treturn ERR_PTR(-ENOENT);\n\t\t\tmp->m_count++;\n\t\t\treturn mp;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "__is_local_mountpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "698-716",
    "snippet": "bool __is_local_mountpoint(struct dentry *dentry)\n{\n\tstruct mnt_namespace *ns = current->nsproxy->mnt_ns;\n\tstruct mount *mnt;\n\tbool is_covered = false;\n\n\tif (!d_mountpoint(dentry))\n\t\tgoto out;\n\n\tdown_read(&namespace_sem);\n\tlist_for_each_entry(mnt, &ns->list, mnt_list) {\n\t\tis_covered = (mnt->mnt_mountpoint == dentry);\n\t\tif (is_covered)\n\t\t\tbreak;\n\t}\n\tup_read(&namespace_sem);\nout:\n\treturn is_covered;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(namespace_sem);",
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&namespace_sem"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "mnt",
            "&ns->list",
            "mnt_list"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&namespace_sem"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "dentry"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic void shrink_submounts(struct mount *mnt);\n\nbool __is_local_mountpoint(struct dentry *dentry)\n{\n\tstruct mnt_namespace *ns = current->nsproxy->mnt_ns;\n\tstruct mount *mnt;\n\tbool is_covered = false;\n\n\tif (!d_mountpoint(dentry))\n\t\tgoto out;\n\n\tdown_read(&namespace_sem);\n\tlist_for_each_entry(mnt, &ns->list, mnt_list) {\n\t\tis_covered = (mnt->mnt_mountpoint == dentry);\n\t\tif (is_covered)\n\t\t\tbreak;\n\t}\n\tup_read(&namespace_sem);\nout:\n\treturn is_covered;\n}"
  },
  {
    "function_name": "lookup_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "667-681",
    "snippet": "struct vfsmount *lookup_mnt(struct path *path)\n{\n\tstruct mount *child_mnt;\n\tstruct vfsmount *m;\n\tunsigned seq;\n\n\trcu_read_lock();\n\tdo {\n\t\tseq = read_seqbegin(&mount_lock);\n\t\tchild_mnt = __lookup_mnt(path->mnt, path->dentry);\n\t\tm = child_mnt ? &child_mnt->mnt : NULL;\n\t} while (!legitimize_mnt(m, seq));\n\trcu_read_unlock();\n\treturn m;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__cacheline_aligned_in_smp DEFINE_SEQLOCK(mount_lock);",
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "legitimize_mnt",
          "args": [
            "m",
            "seq"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "legitimize_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "593-612",
          "snippet": "bool legitimize_mnt(struct vfsmount *bastard, unsigned seq)\n{\n\tstruct mount *mnt;\n\tif (read_seqretry(&mount_lock, seq))\n\t\treturn false;\n\tif (bastard == NULL)\n\t\treturn true;\n\tmnt = real_mount(bastard);\n\tmnt_add_count(mnt, 1);\n\tif (likely(!read_seqretry(&mount_lock, seq)))\n\t\treturn true;\n\tif (bastard->mnt_flags & MNT_SYNC_UMOUNT) {\n\t\tmnt_add_count(mnt, -1);\n\t\treturn false;\n\t}\n\trcu_read_unlock();\n\tmntput(bastard);\n\trcu_read_lock();\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(mount_lock);",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(mount_lock);\nstatic void shrink_submounts(struct mount *mnt);\n\nbool legitimize_mnt(struct vfsmount *bastard, unsigned seq)\n{\n\tstruct mount *mnt;\n\tif (read_seqretry(&mount_lock, seq))\n\t\treturn false;\n\tif (bastard == NULL)\n\t\treturn true;\n\tmnt = real_mount(bastard);\n\tmnt_add_count(mnt, 1);\n\tif (likely(!read_seqretry(&mount_lock, seq)))\n\t\treturn true;\n\tif (bastard->mnt_flags & MNT_SYNC_UMOUNT) {\n\t\tmnt_add_count(mnt, -1);\n\t\treturn false;\n\t}\n\trcu_read_unlock();\n\tmntput(bastard);\n\trcu_read_lock();\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lookup_mnt",
          "args": [
            "path->mnt",
            "path->dentry"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_mnt_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "633-649",
          "snippet": "struct mount *__lookup_mnt_last(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct mount *p, *res = NULL;\n\tp = __lookup_mnt(mnt, dentry);\n\tif (!p)\n\t\tgoto out;\n\tif (!(p->mnt.mnt_flags & MNT_UMOUNT))\n\t\tres = p;\n\thlist_for_each_entry_continue(p, mnt_hash) {\n\t\tif (&p->mnt_parent->mnt != mnt || p->mnt_mountpoint != dentry)\n\t\t\tbreak;\n\t\tif (!(p->mnt.mnt_flags & MNT_UMOUNT))\n\t\t\tres = p;\n\t}\nout:\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct mount *__lookup_mnt_last(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct mount *p, *res = NULL;\n\tp = __lookup_mnt(mnt, dentry);\n\tif (!p)\n\t\tgoto out;\n\tif (!(p->mnt.mnt_flags & MNT_UMOUNT))\n\t\tres = p;\n\thlist_for_each_entry_continue(p, mnt_hash) {\n\t\tif (&p->mnt_parent->mnt != mnt || p->mnt_mountpoint != dentry)\n\t\t\tbreak;\n\t\tif (!(p->mnt.mnt_flags & MNT_UMOUNT))\n\t\t\tres = p;\n\t}\nout:\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqbegin",
          "args": [
            "&mount_lock"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(mount_lock);\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *lookup_mnt(struct path *path)\n{\n\tstruct mount *child_mnt;\n\tstruct vfsmount *m;\n\tunsigned seq;\n\n\trcu_read_lock();\n\tdo {\n\t\tseq = read_seqbegin(&mount_lock);\n\t\tchild_mnt = __lookup_mnt(path->mnt, path->dentry);\n\t\tm = child_mnt ? &child_mnt->mnt : NULL;\n\t} while (!legitimize_mnt(m, seq));\n\trcu_read_unlock();\n\treturn m;\n}"
  },
  {
    "function_name": "__lookup_mnt_last",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "633-649",
    "snippet": "struct mount *__lookup_mnt_last(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct mount *p, *res = NULL;\n\tp = __lookup_mnt(mnt, dentry);\n\tif (!p)\n\t\tgoto out;\n\tif (!(p->mnt.mnt_flags & MNT_UMOUNT))\n\t\tres = p;\n\thlist_for_each_entry_continue(p, mnt_hash) {\n\t\tif (&p->mnt_parent->mnt != mnt || p->mnt_mountpoint != dentry)\n\t\t\tbreak;\n\t\tif (!(p->mnt.mnt_flags & MNT_UMOUNT))\n\t\t\tres = p;\n\t}\nout:\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry_continue",
          "args": [
            "p",
            "mnt_hash"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lookup_mnt",
          "args": [
            "mnt",
            "dentry"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_mnt_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "633-649",
          "snippet": "struct mount *__lookup_mnt_last(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct mount *p, *res = NULL;\n\tp = __lookup_mnt(mnt, dentry);\n\tif (!p)\n\t\tgoto out;\n\tif (!(p->mnt.mnt_flags & MNT_UMOUNT))\n\t\tres = p;\n\thlist_for_each_entry_continue(p, mnt_hash) {\n\t\tif (&p->mnt_parent->mnt != mnt || p->mnt_mountpoint != dentry)\n\t\t\tbreak;\n\t\tif (!(p->mnt.mnt_flags & MNT_UMOUNT))\n\t\t\tres = p;\n\t}\nout:\n\treturn res;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct mount *__lookup_mnt_last(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct mount *p, *res = NULL;\n\tp = __lookup_mnt(mnt, dentry);\n\tif (!p)\n\t\tgoto out;\n\tif (!(p->mnt.mnt_flags & MNT_UMOUNT))\n\t\tres = p;\n\thlist_for_each_entry_continue(p, mnt_hash) {\n\t\tif (&p->mnt_parent->mnt != mnt || p->mnt_mountpoint != dentry)\n\t\t\tbreak;\n\t\tif (!(p->mnt.mnt_flags & MNT_UMOUNT))\n\t\t\tres = p;\n\t}\nout:\n\treturn res;\n}"
  },
  {
    "function_name": "__lookup_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "618-627",
    "snippet": "struct mount *__lookup_mnt(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct hlist_head *head = m_hash(mnt, dentry);\n\tstruct mount *p;\n\n\thlist_for_each_entry_rcu(p, head, mnt_hash)\n\t\tif (&p->mnt_parent->mnt == mnt && p->mnt_mountpoint == dentry)\n\t\t\treturn p;\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "p",
            "head",
            "mnt_hash"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_hash",
          "args": [
            "mnt",
            "dentry"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "m_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "81-87",
          "snippet": "static inline struct hlist_head *m_hash(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tunsigned long tmp = ((unsigned long)mnt / L1_CACHE_BYTES);\n\ttmp += ((unsigned long)dentry / L1_CACHE_BYTES);\n\ttmp = tmp + (tmp >> m_hash_shift);\n\treturn &mount_hashtable[tmp & m_hash_mask];\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int m_hash_mask",
            "static unsigned int m_hash_shift",
            "static struct hlist_head *mount_hashtable",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned int m_hash_mask;\nstatic unsigned int m_hash_shift;\nstatic struct hlist_head *mount_hashtable;\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline struct hlist_head *m_hash(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tunsigned long tmp = ((unsigned long)mnt / L1_CACHE_BYTES);\n\ttmp += ((unsigned long)dentry / L1_CACHE_BYTES);\n\ttmp = tmp + (tmp >> m_hash_shift);\n\treturn &mount_hashtable[tmp & m_hash_mask];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct mount *__lookup_mnt(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct hlist_head *head = m_hash(mnt, dentry);\n\tstruct mount *p;\n\n\thlist_for_each_entry_rcu(p, head, mnt_hash)\n\t\tif (&p->mnt_parent->mnt == mnt && p->mnt_mountpoint == dentry)\n\t\t\treturn p;\n\treturn NULL;\n}"
  },
  {
    "function_name": "legitimize_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "593-612",
    "snippet": "bool legitimize_mnt(struct vfsmount *bastard, unsigned seq)\n{\n\tstruct mount *mnt;\n\tif (read_seqretry(&mount_lock, seq))\n\t\treturn false;\n\tif (bastard == NULL)\n\t\treturn true;\n\tmnt = real_mount(bastard);\n\tmnt_add_count(mnt, 1);\n\tif (likely(!read_seqretry(&mount_lock, seq)))\n\t\treturn true;\n\tif (bastard->mnt_flags & MNT_SYNC_UMOUNT) {\n\t\tmnt_add_count(mnt, -1);\n\t\treturn false;\n\t}\n\trcu_read_unlock();\n\tmntput(bastard);\n\trcu_read_lock();\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__cacheline_aligned_in_smp DEFINE_SEQLOCK(mount_lock);",
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "bastard"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "mntput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1118-1127",
          "snippet": "void mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_add_count",
          "args": [
            "mnt",
            "-1"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_add_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "163-172",
          "snippet": "static inline void mnt_add_count(struct mount *mnt, int n)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_add(mnt->mnt_pcp->mnt_count, n);\n#else\n\tpreempt_disable();\n\tmnt->mnt_count += n;\n\tpreempt_enable();\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline void mnt_add_count(struct mount *mnt, int n)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_add(mnt->mnt_pcp->mnt_count, n);\n#else\n\tpreempt_disable();\n\tmnt->mnt_count += n;\n\tpreempt_enable();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!read_seqretry(&mount_lock, seq)"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&mount_lock",
            "seq"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "bastard"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&mount_lock",
            "seq"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(mount_lock);\nstatic void shrink_submounts(struct mount *mnt);\n\nbool legitimize_mnt(struct vfsmount *bastard, unsigned seq)\n{\n\tstruct mount *mnt;\n\tif (read_seqretry(&mount_lock, seq))\n\t\treturn false;\n\tif (bastard == NULL)\n\t\treturn true;\n\tmnt = real_mount(bastard);\n\tmnt_add_count(mnt, 1);\n\tif (likely(!read_seqretry(&mount_lock, seq)))\n\t\treturn true;\n\tif (bastard->mnt_flags & MNT_SYNC_UMOUNT) {\n\t\tmnt_add_count(mnt, -1);\n\t\treturn false;\n\t}\n\trcu_read_unlock();\n\tmntput(bastard);\n\trcu_read_lock();\n\treturn false;\n}"
  },
  {
    "function_name": "delayed_free_vfsmnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "587-590",
    "snippet": "static void delayed_free_vfsmnt(struct rcu_head *head)\n{\n\tfree_vfsmnt(container_of(head, struct mount, mnt_rcu));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void delayed_free_vfsmnt(struct rcu_head *head)\n{\n\tfree_vfsmnt(container_of(head, struct mount, mnt_rcu));\n}"
  },
  {
    "function_name": "free_vfsmnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "578-585",
    "snippet": "static void free_vfsmnt(struct mount *mnt)\n{\n\tkfree_const(mnt->mnt_devname);\n#ifdef CONFIG_SMP\n\tfree_percpu(mnt->mnt_pcp);\n#endif\n\tkmem_cache_free(mnt_cache, mnt);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "mnt_cache",
            "mnt"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "mnt->mnt_pcp"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_const",
          "args": [
            "mnt->mnt_devname"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void free_vfsmnt(struct mount *mnt)\n{\n\tkfree_const(mnt->mnt_devname);\n#ifdef CONFIG_SMP\n\tfree_percpu(mnt->mnt_pcp);\n#endif\n\tkmem_cache_free(mnt_cache, mnt);\n}"
  },
  {
    "function_name": "sb_prepare_remount_readonly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "542-576",
    "snippet": "int sb_prepare_remount_readonly(struct super_block *sb)\n{\n\tstruct mount *mnt;\n\tint err = 0;\n\n\t/* Racy optimization.  Recheck the counter under MNT_WRITE_HOLD */\n\tif (atomic_long_read(&sb->s_remove_count))\n\t\treturn -EBUSY;\n\n\tlock_mount_hash();\n\tlist_for_each_entry(mnt, &sb->s_mounts, mnt_instance) {\n\t\tif (!(mnt->mnt.mnt_flags & MNT_READONLY)) {\n\t\t\tmnt->mnt.mnt_flags |= MNT_WRITE_HOLD;\n\t\t\tsmp_mb();\n\t\t\tif (mnt_get_writers(mnt) > 0) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!err && atomic_long_read(&sb->s_remove_count))\n\t\terr = -EBUSY;\n\n\tif (!err) {\n\t\tsb->s_readonly_remount = 1;\n\t\tsmp_wmb();\n\t}\n\tlist_for_each_entry(mnt, &sb->s_mounts, mnt_instance) {\n\t\tif (mnt->mnt.mnt_flags & MNT_WRITE_HOLD)\n\t\t\tmnt->mnt.mnt_flags &= ~MNT_WRITE_HOLD;\n\t}\n\tunlock_mount_hash();\n\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_mount_hash",
          "args": [],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "114-117",
          "snippet": "static inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern seqlock_t mount_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern seqlock_t mount_lock;\n\nstatic inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "mnt",
            "&sb->s_mounts",
            "mnt_instance"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&sb->s_remove_count"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_get_writers",
          "args": [
            "mnt"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_get_writers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "302-316",
          "snippet": "static unsigned int mnt_get_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_writers;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_writers;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic unsigned int mnt_get_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_writers;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_writers;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "mnt",
            "&sb->s_mounts",
            "mnt_instance"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&sb->s_remove_count"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint sb_prepare_remount_readonly(struct super_block *sb)\n{\n\tstruct mount *mnt;\n\tint err = 0;\n\n\t/* Racy optimization.  Recheck the counter under MNT_WRITE_HOLD */\n\tif (atomic_long_read(&sb->s_remove_count))\n\t\treturn -EBUSY;\n\n\tlock_mount_hash();\n\tlist_for_each_entry(mnt, &sb->s_mounts, mnt_instance) {\n\t\tif (!(mnt->mnt.mnt_flags & MNT_READONLY)) {\n\t\t\tmnt->mnt.mnt_flags |= MNT_WRITE_HOLD;\n\t\t\tsmp_mb();\n\t\t\tif (mnt_get_writers(mnt) > 0) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!err && atomic_long_read(&sb->s_remove_count))\n\t\terr = -EBUSY;\n\n\tif (!err) {\n\t\tsb->s_readonly_remount = 1;\n\t\tsmp_wmb();\n\t}\n\tlist_for_each_entry(mnt, &sb->s_mounts, mnt_instance) {\n\t\tif (mnt->mnt.mnt_flags & MNT_WRITE_HOLD)\n\t\t\tmnt->mnt.mnt_flags &= ~MNT_WRITE_HOLD;\n\t}\n\tunlock_mount_hash();\n\n\treturn err;\n}"
  },
  {
    "function_name": "__mnt_unmake_readonly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "535-540",
    "snippet": "static void __mnt_unmake_readonly(struct mount *mnt)\n{\n\tlock_mount_hash();\n\tmnt->mnt.mnt_flags &= ~MNT_READONLY;\n\tunlock_mount_hash();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_mount_hash",
          "args": [],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "114-117",
          "snippet": "static inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern seqlock_t mount_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern seqlock_t mount_lock;\n\nstatic inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void __mnt_unmake_readonly(struct mount *mnt)\n{\n\tlock_mount_hash();\n\tmnt->mnt.mnt_flags &= ~MNT_READONLY;\n\tunlock_mount_hash();\n}"
  },
  {
    "function_name": "mnt_make_readonly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "493-533",
    "snippet": "static int mnt_make_readonly(struct mount *mnt)\n{\n\tint ret = 0;\n\n\tlock_mount_hash();\n\tmnt->mnt.mnt_flags |= MNT_WRITE_HOLD;\n\t/*\n\t * After storing MNT_WRITE_HOLD, we'll read the counters. This store\n\t * should be visible before we do.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * With writers on hold, if this value is zero, then there are\n\t * definitely no active writers (although held writers may subsequently\n\t * increment the count, they'll have to wait, and decrement it after\n\t * seeing MNT_READONLY).\n\t *\n\t * It is OK to have counter incremented on one CPU and decremented on\n\t * another: the sum will add up correctly. The danger would be when we\n\t * sum up each counter, if we read a counter before it is incremented,\n\t * but then read another CPU's count which it has been subsequently\n\t * decremented from -- we would see more decrements than we should.\n\t * MNT_WRITE_HOLD protects against this scenario, because\n\t * mnt_want_write first increments count, then smp_mb, then spins on\n\t * MNT_WRITE_HOLD, so it can't be decremented by another CPU while\n\t * we're counting up here.\n\t */\n\tif (mnt_get_writers(mnt) > 0)\n\t\tret = -EBUSY;\n\telse\n\t\tmnt->mnt.mnt_flags |= MNT_READONLY;\n\t/*\n\t * MNT_READONLY must become visible before ~MNT_WRITE_HOLD, so writers\n\t * that become unheld will see MNT_READONLY.\n\t */\n\tsmp_wmb();\n\tmnt->mnt.mnt_flags &= ~MNT_WRITE_HOLD;\n\tunlock_mount_hash();\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_mount_hash",
          "args": [],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_mount_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "114-117",
          "snippet": "static inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern seqlock_t mount_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern seqlock_t mount_lock;\n\nstatic inline void unlock_mount_hash(void)\n{\n\twrite_sequnlock(&mount_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_get_writers",
          "args": [
            "mnt"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_get_writers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "302-316",
          "snippet": "static unsigned int mnt_get_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_writers;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_writers;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic unsigned int mnt_get_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_writers;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_writers;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int mnt_make_readonly(struct mount *mnt)\n{\n\tint ret = 0;\n\n\tlock_mount_hash();\n\tmnt->mnt.mnt_flags |= MNT_WRITE_HOLD;\n\t/*\n\t * After storing MNT_WRITE_HOLD, we'll read the counters. This store\n\t * should be visible before we do.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * With writers on hold, if this value is zero, then there are\n\t * definitely no active writers (although held writers may subsequently\n\t * increment the count, they'll have to wait, and decrement it after\n\t * seeing MNT_READONLY).\n\t *\n\t * It is OK to have counter incremented on one CPU and decremented on\n\t * another: the sum will add up correctly. The danger would be when we\n\t * sum up each counter, if we read a counter before it is incremented,\n\t * but then read another CPU's count which it has been subsequently\n\t * decremented from -- we would see more decrements than we should.\n\t * MNT_WRITE_HOLD protects against this scenario, because\n\t * mnt_want_write first increments count, then smp_mb, then spins on\n\t * MNT_WRITE_HOLD, so it can't be decremented by another CPU while\n\t * we're counting up here.\n\t */\n\tif (mnt_get_writers(mnt) > 0)\n\t\tret = -EBUSY;\n\telse\n\t\tmnt->mnt.mnt_flags |= MNT_READONLY;\n\t/*\n\t * MNT_READONLY must become visible before ~MNT_WRITE_HOLD, so writers\n\t * that become unheld will see MNT_READONLY.\n\t */\n\tsmp_wmb();\n\tmnt->mnt.mnt_flags &= ~MNT_WRITE_HOLD;\n\tunlock_mount_hash();\n\treturn ret;\n}"
  },
  {
    "function_name": "mnt_drop_write_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "487-490",
    "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write",
          "args": [
            "file->f_path.mnt"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
  },
  {
    "function_name": "__mnt_drop_write_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "482-485",
    "snippet": "void __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mnt_drop_write",
          "args": [
            "file->f_path.mnt"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "482-485",
          "snippet": "void __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}"
  },
  {
    "function_name": "mnt_drop_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "475-479",
    "snippet": "void mnt_drop_write(struct vfsmount *mnt)\n{\n\t__mnt_drop_write(mnt);\n\tsb_end_write(mnt->mnt_sb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_write",
          "args": [
            "mnt->mnt_sb"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mnt_drop_write",
          "args": [
            "mnt"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "482-485",
          "snippet": "void __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write(struct vfsmount *mnt)\n{\n\t__mnt_drop_write(mnt);\n\tsb_end_write(mnt->mnt_sb);\n}"
  },
  {
    "function_name": "__mnt_drop_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "460-465",
    "snippet": "void __mnt_drop_write(struct vfsmount *mnt)\n{\n\tpreempt_disable();\n\tmnt_dec_writers(real_mount(mnt));\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_dec_writers",
          "args": [
            "real_mount(mnt)"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_dec_writers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "293-300",
          "snippet": "static inline void mnt_dec_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_dec(mnt->mnt_pcp->mnt_writers);\n#else\n\tmnt->mnt_writers--;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline void mnt_dec_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_dec(mnt->mnt_pcp->mnt_writers);\n#else\n\tmnt->mnt_writers--;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid __mnt_drop_write(struct vfsmount *mnt)\n{\n\tpreempt_disable();\n\tmnt_dec_writers(real_mount(mnt));\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "mnt_want_write_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "440-449",
    "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_write",
          "args": [
            "file->f_path.mnt->mnt_sb"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "425-431",
          "snippet": "int __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_write",
          "args": [
            "file->f_path.mnt->mnt_sb"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
  },
  {
    "function_name": "__mnt_want_write_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "425-431",
    "snippet": "int __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_clone_write",
          "args": [
            "file->f_path.mnt"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_clone_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "406-415",
          "snippet": "int mnt_clone_write(struct vfsmount *mnt)\n{\n\t/* superblock may be r/o */\n\tif (__mnt_is_readonly(mnt))\n\t\treturn -EROFS;\n\tpreempt_disable();\n\tmnt_inc_writers(real_mount(mnt));\n\tpreempt_enable();\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_clone_write(struct vfsmount *mnt)\n{\n\t/* superblock may be r/o */\n\tif (__mnt_is_readonly(mnt))\n\t\treturn -EROFS;\n\tpreempt_disable();\n\tmnt_inc_writers(real_mount(mnt));\n\tpreempt_enable();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mnt_want_write",
          "args": [
            "file->f_path.mnt"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "425-431",
          "snippet": "int __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}"
  },
  {
    "function_name": "mnt_clone_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "406-415",
    "snippet": "int mnt_clone_write(struct vfsmount *mnt)\n{\n\t/* superblock may be r/o */\n\tif (__mnt_is_readonly(mnt))\n\t\treturn -EROFS;\n\tpreempt_disable();\n\tmnt_inc_writers(real_mount(mnt));\n\tpreempt_enable();\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_inc_writers",
          "args": [
            "real_mount(mnt)"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_inc_writers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "284-291",
          "snippet": "static inline void mnt_inc_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_inc(mnt->mnt_pcp->mnt_writers);\n#else\n\tmnt->mnt_writers++;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline void mnt_inc_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_inc(mnt->mnt_pcp->mnt_writers);\n#else\n\tmnt->mnt_writers++;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mnt_is_readonly",
          "args": [
            "mnt"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_is_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "274-281",
          "snippet": "int __mnt_is_readonly(struct vfsmount *mnt)\n{\n\tif (mnt->mnt_flags & MNT_READONLY)\n\t\treturn 1;\n\tif (mnt->mnt_sb->s_flags & MS_RDONLY)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint __mnt_is_readonly(struct vfsmount *mnt)\n{\n\tif (mnt->mnt_flags & MNT_READONLY)\n\t\treturn 1;\n\tif (mnt->mnt_sb->s_flags & MS_RDONLY)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_clone_write(struct vfsmount *mnt)\n{\n\t/* superblock may be r/o */\n\tif (__mnt_is_readonly(mnt))\n\t\treturn -EROFS;\n\tpreempt_disable();\n\tmnt_inc_writers(real_mount(mnt));\n\tpreempt_enable();\n\treturn 0;\n}"
  },
  {
    "function_name": "mnt_want_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "382-391",
    "snippet": "int mnt_want_write(struct vfsmount *m)\n{\n\tint ret;\n\n\tsb_start_write(m->mnt_sb);\n\tret = __mnt_want_write(m);\n\tif (ret)\n\t\tsb_end_write(m->mnt_sb);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_write",
          "args": [
            "m->mnt_sb"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mnt_want_write",
          "args": [
            "m"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "425-431",
          "snippet": "int __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_write",
          "args": [
            "m->mnt_sb"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint mnt_want_write(struct vfsmount *m)\n{\n\tint ret;\n\n\tsb_start_write(m->mnt_sb);\n\tret = __mnt_want_write(m);\n\tif (ret)\n\t\tsb_end_write(m->mnt_sb);\n\treturn ret;\n}"
  },
  {
    "function_name": "__mnt_want_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "343-371",
    "snippet": "int __mnt_want_write(struct vfsmount *m)\n{\n\tstruct mount *mnt = real_mount(m);\n\tint ret = 0;\n\n\tpreempt_disable();\n\tmnt_inc_writers(mnt);\n\t/*\n\t * The store to mnt_inc_writers must be visible before we pass\n\t * MNT_WRITE_HOLD loop below, so that the slowpath can see our\n\t * incremented count after it has set MNT_WRITE_HOLD.\n\t */\n\tsmp_mb();\n\twhile (ACCESS_ONCE(mnt->mnt.mnt_flags) & MNT_WRITE_HOLD)\n\t\tcpu_relax();\n\t/*\n\t * After the slowpath clears MNT_WRITE_HOLD, mnt_is_readonly will\n\t * be set to match its requirements. So we must not load that until\n\t * MNT_WRITE_HOLD is cleared.\n\t */\n\tsmp_rmb();\n\tif (mnt_is_readonly(m)) {\n\t\tmnt_dec_writers(mnt);\n\t\tret = -EROFS;\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_dec_writers",
          "args": [
            "mnt"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_dec_writers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "293-300",
          "snippet": "static inline void mnt_dec_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_dec(mnt->mnt_pcp->mnt_writers);\n#else\n\tmnt->mnt_writers--;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline void mnt_dec_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_dec(mnt->mnt_pcp->mnt_writers);\n#else\n\tmnt->mnt_writers--;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_is_readonly",
          "args": [
            "m"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_is_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "318-325",
          "snippet": "static int mnt_is_readonly(struct vfsmount *mnt)\n{\n\tif (mnt->mnt_sb->s_readonly_remount)\n\t\treturn 1;\n\t/* Order wrt setting s_flags/s_readonly_remount in do_remount() */\n\tsmp_rmb();\n\treturn __mnt_is_readonly(mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int mnt_is_readonly(struct vfsmount *mnt)\n{\n\tif (mnt->mnt_sb->s_readonly_remount)\n\t\treturn 1;\n\t/* Order wrt setting s_flags/s_readonly_remount in do_remount() */\n\tsmp_rmb();\n\treturn __mnt_is_readonly(mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "mnt->mnt.mnt_flags"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_inc_writers",
          "args": [
            "mnt"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_inc_writers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "284-291",
          "snippet": "static inline void mnt_inc_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_inc(mnt->mnt_pcp->mnt_writers);\n#else\n\tmnt->mnt_writers++;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline void mnt_inc_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_inc(mnt->mnt_pcp->mnt_writers);\n#else\n\tmnt->mnt_writers++;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "m"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint __mnt_want_write(struct vfsmount *m)\n{\n\tstruct mount *mnt = real_mount(m);\n\tint ret = 0;\n\n\tpreempt_disable();\n\tmnt_inc_writers(mnt);\n\t/*\n\t * The store to mnt_inc_writers must be visible before we pass\n\t * MNT_WRITE_HOLD loop below, so that the slowpath can see our\n\t * incremented count after it has set MNT_WRITE_HOLD.\n\t */\n\tsmp_mb();\n\twhile (ACCESS_ONCE(mnt->mnt.mnt_flags) & MNT_WRITE_HOLD)\n\t\tcpu_relax();\n\t/*\n\t * After the slowpath clears MNT_WRITE_HOLD, mnt_is_readonly will\n\t * be set to match its requirements. So we must not load that until\n\t * MNT_WRITE_HOLD is cleared.\n\t */\n\tsmp_rmb();\n\tif (mnt_is_readonly(m)) {\n\t\tmnt_dec_writers(mnt);\n\t\tret = -EROFS;\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "mnt_is_readonly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "318-325",
    "snippet": "static int mnt_is_readonly(struct vfsmount *mnt)\n{\n\tif (mnt->mnt_sb->s_readonly_remount)\n\t\treturn 1;\n\t/* Order wrt setting s_flags/s_readonly_remount in do_remount() */\n\tsmp_rmb();\n\treturn __mnt_is_readonly(mnt);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mnt_is_readonly",
          "args": [
            "mnt"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_is_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "274-281",
          "snippet": "int __mnt_is_readonly(struct vfsmount *mnt)\n{\n\tif (mnt->mnt_flags & MNT_READONLY)\n\t\treturn 1;\n\tif (mnt->mnt_sb->s_flags & MS_RDONLY)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint __mnt_is_readonly(struct vfsmount *mnt)\n{\n\tif (mnt->mnt_flags & MNT_READONLY)\n\t\treturn 1;\n\tif (mnt->mnt_sb->s_flags & MS_RDONLY)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int mnt_is_readonly(struct vfsmount *mnt)\n{\n\tif (mnt->mnt_sb->s_readonly_remount)\n\t\treturn 1;\n\t/* Order wrt setting s_flags/s_readonly_remount in do_remount() */\n\tsmp_rmb();\n\treturn __mnt_is_readonly(mnt);\n}"
  },
  {
    "function_name": "mnt_get_writers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "302-316",
    "snippet": "static unsigned int mnt_get_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_writers;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_writers;\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "mnt->mnt_pcp",
            "cpu"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic unsigned int mnt_get_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_writers;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_writers;\n#endif\n}"
  },
  {
    "function_name": "mnt_dec_writers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "293-300",
    "snippet": "static inline void mnt_dec_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_dec(mnt->mnt_pcp->mnt_writers);\n#else\n\tmnt->mnt_writers--;\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_dec",
          "args": [
            "mnt->mnt_pcp->mnt_writers"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline void mnt_dec_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_dec(mnt->mnt_pcp->mnt_writers);\n#else\n\tmnt->mnt_writers--;\n#endif\n}"
  },
  {
    "function_name": "mnt_inc_writers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "284-291",
    "snippet": "static inline void mnt_inc_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_inc(mnt->mnt_pcp->mnt_writers);\n#else\n\tmnt->mnt_writers++;\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "mnt->mnt_pcp->mnt_writers"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline void mnt_inc_writers(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_inc(mnt->mnt_pcp->mnt_writers);\n#else\n\tmnt->mnt_writers++;\n#endif\n}"
  },
  {
    "function_name": "__mnt_is_readonly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "274-281",
    "snippet": "int __mnt_is_readonly(struct vfsmount *mnt)\n{\n\tif (mnt->mnt_flags & MNT_READONLY)\n\t\treturn 1;\n\tif (mnt->mnt_sb->s_flags & MS_RDONLY)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint __mnt_is_readonly(struct vfsmount *mnt)\n{\n\tif (mnt->mnt_flags & MNT_READONLY)\n\t\treturn 1;\n\tif (mnt->mnt_sb->s_flags & MS_RDONLY)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "alloc_vfsmnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "201-253",
    "snippet": "static struct mount *alloc_vfsmnt(const char *name)\n{\n\tstruct mount *mnt = kmem_cache_zalloc(mnt_cache, GFP_KERNEL);\n\tif (mnt) {\n\t\tint err;\n\n\t\terr = mnt_alloc_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free_cache;\n\n\t\tif (name) {\n\t\t\tmnt->mnt_devname = kstrdup_const(name, GFP_KERNEL);\n\t\t\tif (!mnt->mnt_devname)\n\t\t\t\tgoto out_free_id;\n\t\t}\n\n#ifdef CONFIG_SMP\n\t\tmnt->mnt_pcp = alloc_percpu(struct mnt_pcp);\n\t\tif (!mnt->mnt_pcp)\n\t\t\tgoto out_free_devname;\n\n\t\tthis_cpu_add(mnt->mnt_pcp->mnt_count, 1);\n#else\n\t\tmnt->mnt_count = 1;\n\t\tmnt->mnt_writers = 0;\n#endif\n\n\t\tINIT_HLIST_NODE(&mnt->mnt_hash);\n\t\tINIT_LIST_HEAD(&mnt->mnt_child);\n\t\tINIT_LIST_HEAD(&mnt->mnt_mounts);\n\t\tINIT_LIST_HEAD(&mnt->mnt_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_expire);\n\t\tINIT_LIST_HEAD(&mnt->mnt_share);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave);\n\t\tINIT_HLIST_NODE(&mnt->mnt_mp_list);\n#ifdef CONFIG_FSNOTIFY\n\t\tINIT_HLIST_HEAD(&mnt->mnt_fsnotify_marks);\n#endif\n\t\tinit_fs_pin(&mnt->mnt_umount, drop_mountpoint);\n\t}\n\treturn mnt;\n\n#ifdef CONFIG_SMP\nout_free_devname:\n\tkfree_const(mnt->mnt_devname);\n#endif\nout_free_id:\n\tmnt_free_id(mnt);\nout_free_cache:\n\tkmem_cache_free(mnt_cache, mnt);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "mnt_cache",
            "mnt"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_free_id",
          "args": [
            "mnt"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_free_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "117-125",
          "snippet": "static void mnt_free_id(struct mount *mnt)\n{\n\tint id = mnt->mnt_id;\n\tspin_lock(&mnt_id_lock);\n\tida_remove(&mnt_id_ida, id);\n\tif (mnt_id_start > id)\n\t\tmnt_id_start = id;\n\tspin_unlock(&mnt_id_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDA(mnt_id_ida);",
            "static DEFINE_SPINLOCK(mnt_id_lock);",
            "static int mnt_id_start = 0;",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_IDA(mnt_id_ida);\nstatic DEFINE_SPINLOCK(mnt_id_lock);\nstatic int mnt_id_start = 0;\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void mnt_free_id(struct mount *mnt)\n{\n\tint id = mnt->mnt_id;\n\tspin_lock(&mnt_id_lock);\n\tida_remove(&mnt_id_ida, id);\n\tif (mnt_id_start > id)\n\t\tmnt_id_start = id;\n\tspin_unlock(&mnt_id_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_const",
          "args": [
            "mnt->mnt_devname"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_fs_pin",
          "args": [
            "&mnt->mnt_umount",
            "drop_mountpoint"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&mnt->mnt_fsnotify_marks"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&mnt->mnt_mp_list"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mnt->mnt_slave"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mnt->mnt_slave_list"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mnt->mnt_share"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mnt->mnt_expire"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mnt->mnt_list"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mnt->mnt_mounts"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mnt->mnt_child"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&mnt->mnt_hash"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_add",
          "args": [
            "mnt->mnt_pcp->mnt_count",
            "1"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structmnt_pcp"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup_const",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_alloc_id",
          "args": [
            "mnt"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_alloc_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "100-115",
          "snippet": "static int mnt_alloc_id(struct mount *mnt)\n{\n\tint res;\n\nretry:\n\tida_pre_get(&mnt_id_ida, GFP_KERNEL);\n\tspin_lock(&mnt_id_lock);\n\tres = ida_get_new_above(&mnt_id_ida, mnt_id_start, &mnt->mnt_id);\n\tif (!res)\n\t\tmnt_id_start = mnt->mnt_id + 1;\n\tspin_unlock(&mnt_id_lock);\n\tif (res == -EAGAIN)\n\t\tgoto retry;\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDA(mnt_id_ida);",
            "static DEFINE_SPINLOCK(mnt_id_lock);",
            "static int mnt_id_start = 0;",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_IDA(mnt_id_ida);\nstatic DEFINE_SPINLOCK(mnt_id_lock);\nstatic int mnt_id_start = 0;\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int mnt_alloc_id(struct mount *mnt)\n{\n\tint res;\n\nretry:\n\tida_pre_get(&mnt_id_ida, GFP_KERNEL);\n\tspin_lock(&mnt_id_lock);\n\tres = ida_get_new_above(&mnt_id_ida, mnt_id_start, &mnt->mnt_id);\n\tif (!res)\n\t\tmnt_id_start = mnt->mnt_id + 1;\n\tspin_unlock(&mnt_id_lock);\n\tif (res == -EAGAIN)\n\t\tgoto retry;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "mnt_cache",
            "GFP_KERNEL"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic struct mount *alloc_vfsmnt(const char *name)\n{\n\tstruct mount *mnt = kmem_cache_zalloc(mnt_cache, GFP_KERNEL);\n\tif (mnt) {\n\t\tint err;\n\n\t\terr = mnt_alloc_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free_cache;\n\n\t\tif (name) {\n\t\t\tmnt->mnt_devname = kstrdup_const(name, GFP_KERNEL);\n\t\t\tif (!mnt->mnt_devname)\n\t\t\t\tgoto out_free_id;\n\t\t}\n\n#ifdef CONFIG_SMP\n\t\tmnt->mnt_pcp = alloc_percpu(struct mnt_pcp);\n\t\tif (!mnt->mnt_pcp)\n\t\t\tgoto out_free_devname;\n\n\t\tthis_cpu_add(mnt->mnt_pcp->mnt_count, 1);\n#else\n\t\tmnt->mnt_count = 1;\n\t\tmnt->mnt_writers = 0;\n#endif\n\n\t\tINIT_HLIST_NODE(&mnt->mnt_hash);\n\t\tINIT_LIST_HEAD(&mnt->mnt_child);\n\t\tINIT_LIST_HEAD(&mnt->mnt_mounts);\n\t\tINIT_LIST_HEAD(&mnt->mnt_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_expire);\n\t\tINIT_LIST_HEAD(&mnt->mnt_share);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave);\n\t\tINIT_HLIST_NODE(&mnt->mnt_mp_list);\n#ifdef CONFIG_FSNOTIFY\n\t\tINIT_HLIST_HEAD(&mnt->mnt_fsnotify_marks);\n#endif\n\t\tinit_fs_pin(&mnt->mnt_umount, drop_mountpoint);\n\t}\n\treturn mnt;\n\n#ifdef CONFIG_SMP\nout_free_devname:\n\tkfree_const(mnt->mnt_devname);\n#endif\nout_free_id:\n\tmnt_free_id(mnt);\nout_free_cache:\n\tkmem_cache_free(mnt_cache, mnt);\n\treturn NULL;\n}"
  },
  {
    "function_name": "drop_mountpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "193-199",
    "snippet": "static void drop_mountpoint(struct fs_pin *p)\n{\n\tstruct mount *m = container_of(p, struct mount, mnt_umount);\n\tdput(m->mnt_ex_mountpoint);\n\tpin_remove(p);\n\tmntput(&m->mnt);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "&m->mnt"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "mntput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1118-1127",
          "snippet": "void mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_remove",
          "args": [
            "p"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "pin_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_pin.c",
          "lines": "9-19",
          "snippet": "void pin_remove(struct fs_pin *pin)\n{\n\tspin_lock(&pin_lock);\n\thlist_del_init(&pin->m_list);\n\thlist_del_init(&pin->s_list);\n\tspin_unlock(&pin_lock);\n\tspin_lock_irq(&pin->wait.lock);\n\tpin->done = 1;\n\twake_up_locked(&pin->wait);\n\tspin_unlock_irq(&pin->wait.lock);\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pin_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(pin_lock);\n\nvoid pin_remove(struct fs_pin *pin)\n{\n\tspin_lock(&pin_lock);\n\thlist_del_init(&pin->m_list);\n\thlist_del_init(&pin->s_list);\n\tspin_unlock(&pin_lock);\n\tspin_lock_irq(&pin->wait.lock);\n\tpin->done = 1;\n\twake_up_locked(&pin->wait);\n\tspin_unlock_irq(&pin->wait.lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "m->mnt_ex_mountpoint"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structmount",
            "mnt_umount"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void drop_mountpoint(struct fs_pin *p)\n{\n\tstruct mount *m = container_of(p, struct mount, mnt_umount);\n\tdput(m->mnt_ex_mountpoint);\n\tpin_remove(p);\n\tmntput(&m->mnt);\n}"
  },
  {
    "function_name": "mnt_get_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "177-191",
    "snippet": "unsigned int mnt_get_count(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_count;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_count;\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "mnt->mnt_pcp",
            "cpu"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nunsigned int mnt_get_count(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_count;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_count;\n#endif\n}"
  },
  {
    "function_name": "mnt_add_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "163-172",
    "snippet": "static inline void mnt_add_count(struct mount *mnt, int n)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_add(mnt->mnt_pcp->mnt_count, n);\n#else\n\tpreempt_disable();\n\tmnt->mnt_count += n;\n\tpreempt_enable();\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_add",
          "args": [
            "mnt->mnt_pcp->mnt_count",
            "n"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline void mnt_add_count(struct mount *mnt, int n)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_add(mnt->mnt_pcp->mnt_count, n);\n#else\n\tpreempt_disable();\n\tmnt->mnt_count += n;\n\tpreempt_enable();\n#endif\n}"
  },
  {
    "function_name": "mnt_release_group_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "151-158",
    "snippet": "void mnt_release_group_id(struct mount *mnt)\n{\n\tint id = mnt->mnt_group_id;\n\tida_remove(&mnt_group_ida, id);\n\tif (mnt_group_start > id)\n\t\tmnt_group_start = id;\n\tmnt->mnt_group_id = 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDA(mnt_group_ida);",
      "static int mnt_group_start = 1;",
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ida_remove",
          "args": [
            "&mnt_group_ida",
            "id"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_IDA(mnt_group_ida);\nstatic int mnt_group_start = 1;\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_release_group_id(struct mount *mnt)\n{\n\tint id = mnt->mnt_group_id;\n\tida_remove(&mnt_group_ida, id);\n\tif (mnt_group_start > id)\n\t\tmnt_group_start = id;\n\tmnt->mnt_group_id = 0;\n}"
  },
  {
    "function_name": "mnt_alloc_group_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "132-146",
    "snippet": "static int mnt_alloc_group_id(struct mount *mnt)\n{\n\tint res;\n\n\tif (!ida_pre_get(&mnt_group_ida, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tres = ida_get_new_above(&mnt_group_ida,\n\t\t\t\tmnt_group_start,\n\t\t\t\t&mnt->mnt_group_id);\n\tif (!res)\n\t\tmnt_group_start = mnt->mnt_group_id + 1;\n\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDA(mnt_group_ida);",
      "static int mnt_group_start = 1;",
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ida_get_new_above",
          "args": [
            "&mnt_group_ida",
            "mnt_group_start",
            "&mnt->mnt_group_id"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ida_pre_get",
          "args": [
            "&mnt_group_ida",
            "GFP_KERNEL"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_IDA(mnt_group_ida);\nstatic int mnt_group_start = 1;\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int mnt_alloc_group_id(struct mount *mnt)\n{\n\tint res;\n\n\tif (!ida_pre_get(&mnt_group_ida, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tres = ida_get_new_above(&mnt_group_ida,\n\t\t\t\tmnt_group_start,\n\t\t\t\t&mnt->mnt_group_id);\n\tif (!res)\n\t\tmnt_group_start = mnt->mnt_group_id + 1;\n\n\treturn res;\n}"
  },
  {
    "function_name": "mnt_free_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "117-125",
    "snippet": "static void mnt_free_id(struct mount *mnt)\n{\n\tint id = mnt->mnt_id;\n\tspin_lock(&mnt_id_lock);\n\tida_remove(&mnt_id_ida, id);\n\tif (mnt_id_start > id)\n\t\tmnt_id_start = id;\n\tspin_unlock(&mnt_id_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDA(mnt_id_ida);",
      "static DEFINE_SPINLOCK(mnt_id_lock);",
      "static int mnt_id_start = 0;",
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mnt_id_lock"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ida_remove",
          "args": [
            "&mnt_id_ida",
            "id"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mnt_id_lock"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_IDA(mnt_id_ida);\nstatic DEFINE_SPINLOCK(mnt_id_lock);\nstatic int mnt_id_start = 0;\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void mnt_free_id(struct mount *mnt)\n{\n\tint id = mnt->mnt_id;\n\tspin_lock(&mnt_id_lock);\n\tida_remove(&mnt_id_ida, id);\n\tif (mnt_id_start > id)\n\t\tmnt_id_start = id;\n\tspin_unlock(&mnt_id_lock);\n}"
  },
  {
    "function_name": "mnt_alloc_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "100-115",
    "snippet": "static int mnt_alloc_id(struct mount *mnt)\n{\n\tint res;\n\nretry:\n\tida_pre_get(&mnt_id_ida, GFP_KERNEL);\n\tspin_lock(&mnt_id_lock);\n\tres = ida_get_new_above(&mnt_id_ida, mnt_id_start, &mnt->mnt_id);\n\tif (!res)\n\t\tmnt_id_start = mnt->mnt_id + 1;\n\tspin_unlock(&mnt_id_lock);\n\tif (res == -EAGAIN)\n\t\tgoto retry;\n\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDA(mnt_id_ida);",
      "static DEFINE_SPINLOCK(mnt_id_lock);",
      "static int mnt_id_start = 0;",
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mnt_id_lock"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ida_get_new_above",
          "args": [
            "&mnt_id_ida",
            "mnt_id_start",
            "&mnt->mnt_id"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mnt_id_lock"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ida_pre_get",
          "args": [
            "&mnt_id_ida",
            "GFP_KERNEL"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_IDA(mnt_id_ida);\nstatic DEFINE_SPINLOCK(mnt_id_lock);\nstatic int mnt_id_start = 0;\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic int mnt_alloc_id(struct mount *mnt)\n{\n\tint res;\n\nretry:\n\tida_pre_get(&mnt_id_ida, GFP_KERNEL);\n\tspin_lock(&mnt_id_lock);\n\tres = ida_get_new_above(&mnt_id_ida, mnt_id_start, &mnt->mnt_id);\n\tif (!res)\n\t\tmnt_id_start = mnt->mnt_id + 1;\n\tspin_unlock(&mnt_id_lock);\n\tif (res == -EAGAIN)\n\t\tgoto retry;\n\n\treturn res;\n}"
  },
  {
    "function_name": "mp_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "89-94",
    "snippet": "static inline struct hlist_head *mp_hash(struct dentry *dentry)\n{\n\tunsigned long tmp = ((unsigned long)dentry / L1_CACHE_BYTES);\n\ttmp = tmp + (tmp >> mp_hash_shift);\n\treturn &mountpoint_hashtable[tmp & mp_hash_mask];\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int mp_hash_mask",
      "static unsigned int mp_hash_shift",
      "static struct hlist_head *mountpoint_hashtable"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned int mp_hash_mask;\nstatic unsigned int mp_hash_shift;\nstatic struct hlist_head *mountpoint_hashtable;\n\nstatic inline struct hlist_head *mp_hash(struct dentry *dentry)\n{\n\tunsigned long tmp = ((unsigned long)dentry / L1_CACHE_BYTES);\n\ttmp = tmp + (tmp >> mp_hash_shift);\n\treturn &mountpoint_hashtable[tmp & mp_hash_mask];\n}"
  },
  {
    "function_name": "m_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "81-87",
    "snippet": "static inline struct hlist_head *m_hash(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tunsigned long tmp = ((unsigned long)mnt / L1_CACHE_BYTES);\n\ttmp += ((unsigned long)dentry / L1_CACHE_BYTES);\n\ttmp = tmp + (tmp >> m_hash_shift);\n\treturn &mount_hashtable[tmp & m_hash_mask];\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int m_hash_mask",
      "static unsigned int m_hash_shift",
      "static struct hlist_head *mount_hashtable",
      "static void shrink_submounts(struct mount *mnt);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned int m_hash_mask;\nstatic unsigned int m_hash_shift;\nstatic struct hlist_head *mount_hashtable;\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic inline struct hlist_head *m_hash(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tunsigned long tmp = ((unsigned long)mnt / L1_CACHE_BYTES);\n\ttmp += ((unsigned long)dentry / L1_CACHE_BYTES);\n\ttmp = tmp + (tmp >> m_hash_shift);\n\treturn &mount_hashtable[tmp & m_hash_mask];\n}"
  },
  {
    "function_name": "set_mphash_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "46-52",
    "snippet": "static int __init set_mphash_entries(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tmphash_entries = simple_strtoul(str, &str, 0);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __initdata unsigned long mphash_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "str",
            "&str",
            "0"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic __initdata unsigned long mphash_entries;\n\nstatic int __init set_mphash_entries(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tmphash_entries = simple_strtoul(str, &str, 0);\n\treturn 1;\n}"
  },
  {
    "function_name": "set_mhash_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
    "lines": "36-42",
    "snippet": "static int __init set_mhash_entries(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tmhash_entries = simple_strtoul(str, &str, 0);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
      "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
      "#include <linux/init.h>\t\t/* init_rootfs */",
      "#include <linux/idr.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/capability.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __initdata unsigned long mhash_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "str",
            "&str",
            "0"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic __initdata unsigned long mhash_entries;\n\nstatic int __init set_mhash_entries(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tmhash_entries = simple_strtoul(str, &str, 0);\n\treturn 1;\n}"
  }
]