[
  {
    "function_name": "squashfs_read_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/block.c",
    "lines": "90-214",
    "snippet": "int squashfs_read_data(struct super_block *sb, u64 index, int length,\n\t\tu64 *next_index, struct squashfs_page_actor *output)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tstruct buffer_head **bh;\n\tint offset = index & ((1 << msblk->devblksize_log2) - 1);\n\tu64 cur_index = index >> msblk->devblksize_log2;\n\tint bytes, compressed, b = 0, k = 0, avail, i;\n\n\tbh = kcalloc(((output->length + msblk->devblksize - 1)\n\t\t>> msblk->devblksize_log2) + 1, sizeof(*bh), GFP_KERNEL);\n\tif (bh == NULL)\n\t\treturn -ENOMEM;\n\n\tif (length) {\n\t\t/*\n\t\t * Datablock.\n\t\t */\n\t\tbytes = -offset;\n\t\tcompressed = SQUASHFS_COMPRESSED_BLOCK(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE_BLOCK(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d, src size %d\\n\",\n\t\t\tindex, compressed ? \"\" : \"un\", length, output->length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tfor (b = 0; bytes < length; b++, cur_index++) {\n\t\t\tbh[b] = sb_getblk(sb, cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b, bh);\n\t} else {\n\t\t/*\n\t\t * Metadata block.\n\t\t */\n\t\tif ((index + 2) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tbh[0] = get_block_length(sb, &cur_index, &offset, &length);\n\t\tif (bh[0] == NULL)\n\t\t\tgoto read_failure;\n\t\tb = 1;\n\n\t\tbytes = msblk->devblksize - offset;\n\t\tcompressed = SQUASHFS_COMPRESSED(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length + 2;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d\\n\", index,\n\t\t\t\tcompressed ? \"\" : \"un\", length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto block_release;\n\n\t\tfor (; bytes < length; b++) {\n\t\t\tbh[b] = sb_getblk(sb, ++cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b - 1, bh + 1);\n\t}\n\n\tfor (i = 0; i < b; i++) {\n\t\twait_on_buffer(bh[i]);\n\t\tif (!buffer_uptodate(bh[i]))\n\t\t\tgoto block_release;\n\t}\n\n\tif (compressed) {\n\t\tlength = squashfs_decompress(msblk, bh, b, offset, length,\n\t\t\toutput);\n\t\tif (length < 0)\n\t\t\tgoto read_failure;\n\t} else {\n\t\t/*\n\t\t * Block is uncompressed.\n\t\t */\n\t\tint in, pg_offset = 0;\n\t\tvoid *data = squashfs_first_page(output);\n\n\t\tfor (bytes = length; k < b; k++) {\n\t\t\tin = min(bytes, msblk->devblksize - offset);\n\t\t\tbytes -= in;\n\t\t\twhile (in) {\n\t\t\t\tif (pg_offset == PAGE_CACHE_SIZE) {\n\t\t\t\t\tdata = squashfs_next_page(output);\n\t\t\t\t\tpg_offset = 0;\n\t\t\t\t}\n\t\t\t\tavail = min_t(int, in, PAGE_CACHE_SIZE -\n\t\t\t\t\t\tpg_offset);\n\t\t\t\tmemcpy(data + pg_offset, bh[k]->b_data + offset,\n\t\t\t\t\t\tavail);\n\t\t\t\tin -= avail;\n\t\t\t\tpg_offset += avail;\n\t\t\t\toffset += avail;\n\t\t\t}\n\t\t\toffset = 0;\n\t\t\tput_bh(bh[k]);\n\t\t}\n\t\tsquashfs_finish_page(output);\n\t}\n\n\tkfree(bh);\n\treturn length;\n\nblock_release:\n\tfor (; k < b; k++)\n\t\tput_bh(bh[k]);\n\nread_failure:\n\tERROR(\"squashfs_read_data failed to read block 0x%llx\\n\",\n\t\t\t\t\t(unsigned long long) index);\n\tkfree(bh);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"page_actor.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bh"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"squashfs_read_data failed to read block 0x%llx\\n\"",
            "(unsigned long long) index"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh[k]"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bh"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_finish_page",
          "args": [
            "output"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_finish_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/page_actor.h",
          "lines": "76-79",
          "snippet": "static inline void squashfs_finish_page(struct squashfs_page_actor *actor)\n{\n\tactor->squashfs_finish_page(actor);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void squashfs_finish_page(struct squashfs_page_actor *actor)\n{\n\tactor->squashfs_finish_page(actor);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh[k]"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + pg_offset",
            "bh[k]->b_data + offset",
            "avail"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "in",
            "PAGE_CACHE_SIZE -\n\t\t\t\t\t\tpg_offset"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_next_page",
          "args": [
            "output"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_next_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/page_actor.h",
          "lines": "72-75",
          "snippet": "static inline void *squashfs_next_page(struct squashfs_page_actor *actor)\n{\n\treturn actor->squashfs_next_page(actor);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void *squashfs_next_page(struct squashfs_page_actor *actor)\n{\n\treturn actor->squashfs_next_page(actor);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bytes",
            "msblk->devblksize - offset"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_first_page",
          "args": [
            "output"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_first_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/page_actor.h",
          "lines": "68-71",
          "snippet": "static inline void *squashfs_first_page(struct squashfs_page_actor *actor)\n{\n\treturn actor->squashfs_first_page(actor);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void *squashfs_first_page(struct squashfs_page_actor *actor)\n{\n\treturn actor->squashfs_first_page(actor);\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_decompress",
          "args": [
            "msblk",
            "bh",
            "b",
            "offset",
            "length",
            "output"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_decompress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor_multi_percpu.c",
          "lines": "77-92",
          "snippet": "int squashfs_decompress(struct squashfs_sb_info *msblk, struct buffer_head **bh,\n\tint b, int offset, int length, struct squashfs_page_actor *output)\n{\n\tstruct squashfs_stream __percpu *percpu =\n\t\t\t(struct squashfs_stream __percpu *) msblk->stream;\n\tstruct squashfs_stream *stream = get_cpu_ptr(percpu);\n\tint res = msblk->decompressor->decompress(msblk, stream->stream, bh, b,\n\t\toffset, length, output);\n\tput_cpu_ptr(stream);\n\n\tif (res < 0)\n\t\tERROR(\"%s decompression failed, data probably corrupt\\n\",\n\t\t\tmsblk->decompressor->name);\n\n\treturn res;\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/percpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/percpu.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint squashfs_decompress(struct squashfs_sb_info *msblk, struct buffer_head **bh,\n\tint b, int offset, int length, struct squashfs_page_actor *output)\n{\n\tstruct squashfs_stream __percpu *percpu =\n\t\t\t(struct squashfs_stream __percpu *) msblk->stream;\n\tstruct squashfs_stream *stream = get_cpu_ptr(percpu);\n\tint res = msblk->decompressor->decompress(msblk, stream->stream, bh, b,\n\t\toffset, length, output);\n\tput_cpu_ptr(stream);\n\n\tif (res < 0)\n\t\tERROR(\"%s decompression failed, data probably corrupt\\n\",\n\t\t\tmsblk->decompressor->name);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh[i]"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh[i]"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ",
            "b - 1",
            "bh + 1"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "++cur_index"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Block @ 0x%llx, %scompressed size %d\\n\"",
            "index",
            "compressed ? \"\" : \"un\"",
            "length"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_COMPRESSED_SIZE",
          "args": [
            "length"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_COMPRESSED",
          "args": [
            "length"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_block_length",
          "args": [
            "sb",
            "&cur_index",
            "&offset",
            "&length"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "get_block_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/block.c",
          "lines": "45-78",
          "snippet": "static struct buffer_head *get_block_length(struct super_block *sb,\n\t\t\tu64 *cur_index, int *offset, int *length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tstruct buffer_head *bh;\n\n\tbh = sb_bread(sb, *cur_index);\n\tif (bh == NULL)\n\t\treturn NULL;\n\n\tif (msblk->devblksize - *offset == 1) {\n\t\t*length = (unsigned char) bh->b_data[*offset];\n\t\tput_bh(bh);\n\t\tbh = sb_bread(sb, ++(*cur_index));\n\t\tif (bh == NULL)\n\t\t\treturn NULL;\n\t\t*length |= (unsigned char) bh->b_data[0] << 8;\n\t\t*offset = 1;\n\t} else {\n\t\t*length = (unsigned char) bh->b_data[*offset] |\n\t\t\t(unsigned char) bh->b_data[*offset + 1] << 8;\n\t\t*offset += 2;\n\n\t\tif (*offset == msblk->devblksize) {\n\t\t\tput_bh(bh);\n\t\t\tbh = sb_bread(sb, ++(*cur_index));\n\t\t\tif (bh == NULL)\n\t\t\t\treturn NULL;\n\t\t\t*offset = 0;\n\t\t}\n\t}\n\n\treturn bh;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head *get_block_length(struct super_block *sb,\n\t\t\tu64 *cur_index, int *offset, int *length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tstruct buffer_head *bh;\n\n\tbh = sb_bread(sb, *cur_index);\n\tif (bh == NULL)\n\t\treturn NULL;\n\n\tif (msblk->devblksize - *offset == 1) {\n\t\t*length = (unsigned char) bh->b_data[*offset];\n\t\tput_bh(bh);\n\t\tbh = sb_bread(sb, ++(*cur_index));\n\t\tif (bh == NULL)\n\t\t\treturn NULL;\n\t\t*length |= (unsigned char) bh->b_data[0] << 8;\n\t\t*offset = 1;\n\t} else {\n\t\t*length = (unsigned char) bh->b_data[*offset] |\n\t\t\t(unsigned char) bh->b_data[*offset + 1] << 8;\n\t\t*offset += 2;\n\n\t\tif (*offset == msblk->devblksize) {\n\t\t\tput_bh(bh);\n\t\t\tbh = sb_bread(sb, ++(*cur_index));\n\t\t\tif (bh == NULL)\n\t\t\t\treturn NULL;\n\t\t\t*offset = 0;\n\t\t}\n\t}\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "cur_index"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Block @ 0x%llx, %scompressed size %d, src size %d\\n\"",
            "index",
            "compressed ? \"\" : \"un\"",
            "length",
            "output->length"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_COMPRESSED_SIZE_BLOCK",
          "args": [
            "length"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_COMPRESSED_BLOCK",
          "args": [
            "length"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "((output->length + msblk->devblksize - 1)\n\t\t>> msblk->devblksize_log2) + 1",
            "sizeof(*bh)",
            "GFP_KERNEL"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"page_actor.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_read_data(struct super_block *sb, u64 index, int length,\n\t\tu64 *next_index, struct squashfs_page_actor *output)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tstruct buffer_head **bh;\n\tint offset = index & ((1 << msblk->devblksize_log2) - 1);\n\tu64 cur_index = index >> msblk->devblksize_log2;\n\tint bytes, compressed, b = 0, k = 0, avail, i;\n\n\tbh = kcalloc(((output->length + msblk->devblksize - 1)\n\t\t>> msblk->devblksize_log2) + 1, sizeof(*bh), GFP_KERNEL);\n\tif (bh == NULL)\n\t\treturn -ENOMEM;\n\n\tif (length) {\n\t\t/*\n\t\t * Datablock.\n\t\t */\n\t\tbytes = -offset;\n\t\tcompressed = SQUASHFS_COMPRESSED_BLOCK(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE_BLOCK(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d, src size %d\\n\",\n\t\t\tindex, compressed ? \"\" : \"un\", length, output->length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tfor (b = 0; bytes < length; b++, cur_index++) {\n\t\t\tbh[b] = sb_getblk(sb, cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b, bh);\n\t} else {\n\t\t/*\n\t\t * Metadata block.\n\t\t */\n\t\tif ((index + 2) > msblk->bytes_used)\n\t\t\tgoto read_failure;\n\n\t\tbh[0] = get_block_length(sb, &cur_index, &offset, &length);\n\t\tif (bh[0] == NULL)\n\t\t\tgoto read_failure;\n\t\tb = 1;\n\n\t\tbytes = msblk->devblksize - offset;\n\t\tcompressed = SQUASHFS_COMPRESSED(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE(length);\n\t\tif (next_index)\n\t\t\t*next_index = index + length + 2;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d\\n\", index,\n\t\t\t\tcompressed ? \"\" : \"un\", length);\n\n\t\tif (length < 0 || length > output->length ||\n\t\t\t\t\t(index + length) > msblk->bytes_used)\n\t\t\tgoto block_release;\n\n\t\tfor (; bytes < length; b++) {\n\t\t\tbh[b] = sb_getblk(sb, ++cur_index);\n\t\t\tif (bh[b] == NULL)\n\t\t\t\tgoto block_release;\n\t\t\tbytes += msblk->devblksize;\n\t\t}\n\t\tll_rw_block(READ, b - 1, bh + 1);\n\t}\n\n\tfor (i = 0; i < b; i++) {\n\t\twait_on_buffer(bh[i]);\n\t\tif (!buffer_uptodate(bh[i]))\n\t\t\tgoto block_release;\n\t}\n\n\tif (compressed) {\n\t\tlength = squashfs_decompress(msblk, bh, b, offset, length,\n\t\t\toutput);\n\t\tif (length < 0)\n\t\t\tgoto read_failure;\n\t} else {\n\t\t/*\n\t\t * Block is uncompressed.\n\t\t */\n\t\tint in, pg_offset = 0;\n\t\tvoid *data = squashfs_first_page(output);\n\n\t\tfor (bytes = length; k < b; k++) {\n\t\t\tin = min(bytes, msblk->devblksize - offset);\n\t\t\tbytes -= in;\n\t\t\twhile (in) {\n\t\t\t\tif (pg_offset == PAGE_CACHE_SIZE) {\n\t\t\t\t\tdata = squashfs_next_page(output);\n\t\t\t\t\tpg_offset = 0;\n\t\t\t\t}\n\t\t\t\tavail = min_t(int, in, PAGE_CACHE_SIZE -\n\t\t\t\t\t\tpg_offset);\n\t\t\t\tmemcpy(data + pg_offset, bh[k]->b_data + offset,\n\t\t\t\t\t\tavail);\n\t\t\t\tin -= avail;\n\t\t\t\tpg_offset += avail;\n\t\t\t\toffset += avail;\n\t\t\t}\n\t\t\toffset = 0;\n\t\t\tput_bh(bh[k]);\n\t\t}\n\t\tsquashfs_finish_page(output);\n\t}\n\n\tkfree(bh);\n\treturn length;\n\nblock_release:\n\tfor (; k < b; k++)\n\t\tput_bh(bh[k]);\n\nread_failure:\n\tERROR(\"squashfs_read_data failed to read block 0x%llx\\n\",\n\t\t\t\t\t(unsigned long long) index);\n\tkfree(bh);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "get_block_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/block.c",
    "lines": "45-78",
    "snippet": "static struct buffer_head *get_block_length(struct super_block *sb,\n\t\t\tu64 *cur_index, int *offset, int *length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tstruct buffer_head *bh;\n\n\tbh = sb_bread(sb, *cur_index);\n\tif (bh == NULL)\n\t\treturn NULL;\n\n\tif (msblk->devblksize - *offset == 1) {\n\t\t*length = (unsigned char) bh->b_data[*offset];\n\t\tput_bh(bh);\n\t\tbh = sb_bread(sb, ++(*cur_index));\n\t\tif (bh == NULL)\n\t\t\treturn NULL;\n\t\t*length |= (unsigned char) bh->b_data[0] << 8;\n\t\t*offset = 1;\n\t} else {\n\t\t*length = (unsigned char) bh->b_data[*offset] |\n\t\t\t(unsigned char) bh->b_data[*offset + 1] << 8;\n\t\t*offset += 2;\n\n\t\tif (*offset == msblk->devblksize) {\n\t\t\tput_bh(bh);\n\t\t\tbh = sb_bread(sb, ++(*cur_index));\n\t\t\tif (bh == NULL)\n\t\t\t\treturn NULL;\n\t\t\t*offset = 0;\n\t\t}\n\t}\n\n\treturn bh;\n}",
    "includes": [
      "#include \"page_actor.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "++(*cur_index)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "++(*cur_index)"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "*cur_index"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"page_actor.h\"\n#include \"decompressor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head *get_block_length(struct super_block *sb,\n\t\t\tu64 *cur_index, int *offset, int *length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tstruct buffer_head *bh;\n\n\tbh = sb_bread(sb, *cur_index);\n\tif (bh == NULL)\n\t\treturn NULL;\n\n\tif (msblk->devblksize - *offset == 1) {\n\t\t*length = (unsigned char) bh->b_data[*offset];\n\t\tput_bh(bh);\n\t\tbh = sb_bread(sb, ++(*cur_index));\n\t\tif (bh == NULL)\n\t\t\treturn NULL;\n\t\t*length |= (unsigned char) bh->b_data[0] << 8;\n\t\t*offset = 1;\n\t} else {\n\t\t*length = (unsigned char) bh->b_data[*offset] |\n\t\t\t(unsigned char) bh->b_data[*offset + 1] << 8;\n\t\t*offset += 2;\n\n\t\tif (*offset == msblk->devblksize) {\n\t\t\tput_bh(bh);\n\t\t\tbh = sb_bread(sb, ++(*cur_index));\n\t\t\tif (bh == NULL)\n\t\t\t\treturn NULL;\n\t\t\t*offset = 0;\n\t\t}\n\t}\n\n\treturn bh;\n}"
  }
]