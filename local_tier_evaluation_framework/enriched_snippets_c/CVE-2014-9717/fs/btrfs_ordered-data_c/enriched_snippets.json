[
  {
    "function_name": "ordered_data_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "1041-1045",
    "snippet": "void ordered_data_exit(void)\n{\n\tif (btrfs_ordered_extent_cache)\n\t\tkmem_cache_destroy(btrfs_ordered_extent_cache);\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *btrfs_ordered_extent_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "btrfs_ordered_extent_cache"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid ordered_data_exit(void)\n{\n\tif (btrfs_ordered_extent_cache)\n\t\tkmem_cache_destroy(btrfs_ordered_extent_cache);\n}"
  },
  {
    "function_name": "ordered_data_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "1029-1039",
    "snippet": "int __init ordered_data_init(void)\n{\n\tbtrfs_ordered_extent_cache = kmem_cache_create(\"btrfs_ordered_extent\",\n\t\t\t\t     sizeof(struct btrfs_ordered_extent), 0,\n\t\t\t\t     SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t     NULL);\n\tif (!btrfs_ordered_extent_cache)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *btrfs_ordered_extent_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"btrfs_ordered_extent\"",
            "sizeof(struct btrfs_ordered_extent)",
            "0",
            "SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD",
            "NULL"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nint __init ordered_data_init(void)\n{\n\tbtrfs_ordered_extent_cache = kmem_cache_create(\"btrfs_ordered_extent\",\n\t\t\t\t     sizeof(struct btrfs_ordered_extent), 0,\n\t\t\t\t     SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t     NULL);\n\tif (!btrfs_ordered_extent_cache)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_find_ordered_sum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "990-1027",
    "snippet": "int btrfs_find_ordered_sum(struct inode *inode, u64 offset, u64 disk_bytenr,\n\t\t\t   u32 *sum, int len)\n{\n\tstruct btrfs_ordered_sum *ordered_sum;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct btrfs_ordered_inode_tree *tree = &BTRFS_I(inode)->ordered_tree;\n\tunsigned long num_sectors;\n\tunsigned long i;\n\tu32 sectorsize = BTRFS_I(inode)->root->sectorsize;\n\tint index = 0;\n\n\tordered = btrfs_lookup_ordered_extent(inode, offset);\n\tif (!ordered)\n\t\treturn 0;\n\n\tspin_lock_irq(&tree->lock);\n\tlist_for_each_entry_reverse(ordered_sum, &ordered->list, list) {\n\t\tif (disk_bytenr >= ordered_sum->bytenr &&\n\t\t    disk_bytenr < ordered_sum->bytenr + ordered_sum->len) {\n\t\t\ti = (disk_bytenr - ordered_sum->bytenr) >>\n\t\t\t    inode->i_sb->s_blocksize_bits;\n\t\t\tnum_sectors = ordered_sum->len >>\n\t\t\t\t      inode->i_sb->s_blocksize_bits;\n\t\t\tnum_sectors = min_t(int, len - index, num_sectors - i);\n\t\t\tmemcpy(sum + index, ordered_sum->sums + i,\n\t\t\t       num_sectors);\n\n\t\t\tindex += (int)num_sectors;\n\t\t\tif (index == len)\n\t\t\t\tgoto out;\n\t\t\tdisk_bytenr += num_sectors * sectorsize;\n\t\t}\n\t}\nout:\n\tspin_unlock_irq(&tree->lock);\n\tbtrfs_put_ordered_extent(ordered);\n\treturn index;\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_put_ordered_extent",
          "args": [
            "ordered"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "540-558",
          "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tree->lock"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sum + index",
            "ordered_sum->sums + i",
            "num_sectors"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "len - index",
            "num_sectors - i"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "ordered_sum",
            "&ordered->list",
            "list"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tree->lock"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_ordered_extent",
          "args": [
            "inode",
            "offset"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "777-798",
          "snippet": "struct btrfs_ordered_extent *btrfs_lookup_ordered_extent(struct inode *inode,\n\t\t\t\t\t\t\t u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tif (!offset_in_entry(entry, file_offset))\n\t\tentry = NULL;\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstruct btrfs_ordered_extent *btrfs_lookup_ordered_extent(struct inode *inode,\n\t\t\t\t\t\t\t u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tif (!offset_in_entry(entry, file_offset))\n\t\tentry = NULL;\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_find_ordered_sum(struct inode *inode, u64 offset, u64 disk_bytenr,\n\t\t\t   u32 *sum, int len)\n{\n\tstruct btrfs_ordered_sum *ordered_sum;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct btrfs_ordered_inode_tree *tree = &BTRFS_I(inode)->ordered_tree;\n\tunsigned long num_sectors;\n\tunsigned long i;\n\tu32 sectorsize = BTRFS_I(inode)->root->sectorsize;\n\tint index = 0;\n\n\tordered = btrfs_lookup_ordered_extent(inode, offset);\n\tif (!ordered)\n\t\treturn 0;\n\n\tspin_lock_irq(&tree->lock);\n\tlist_for_each_entry_reverse(ordered_sum, &ordered->list, list) {\n\t\tif (disk_bytenr >= ordered_sum->bytenr &&\n\t\t    disk_bytenr < ordered_sum->bytenr + ordered_sum->len) {\n\t\t\ti = (disk_bytenr - ordered_sum->bytenr) >>\n\t\t\t    inode->i_sb->s_blocksize_bits;\n\t\t\tnum_sectors = ordered_sum->len >>\n\t\t\t\t      inode->i_sb->s_blocksize_bits;\n\t\t\tnum_sectors = min_t(int, len - index, num_sectors - i);\n\t\t\tmemcpy(sum + index, ordered_sum->sums + i,\n\t\t\t       num_sectors);\n\n\t\t\tindex += (int)num_sectors;\n\t\t\tif (index == len)\n\t\t\t\tgoto out;\n\t\t\tdisk_bytenr += num_sectors * sectorsize;\n\t\t}\n\t}\nout:\n\tspin_unlock_irq(&tree->lock);\n\tbtrfs_put_ordered_extent(ordered);\n\treturn index;\n}"
  },
  {
    "function_name": "btrfs_ordered_update_i_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "869-983",
    "snippet": "int btrfs_ordered_update_i_size(struct inode *inode, u64 offset,\n\t\t\t\tstruct btrfs_ordered_extent *ordered)\n{\n\tstruct btrfs_ordered_inode_tree *tree = &BTRFS_I(inode)->ordered_tree;\n\tu64 disk_i_size;\n\tu64 new_i_size;\n\tu64 i_size = i_size_read(inode);\n\tstruct rb_node *node;\n\tstruct rb_node *prev = NULL;\n\tstruct btrfs_ordered_extent *test;\n\tint ret = 1;\n\n\tspin_lock_irq(&tree->lock);\n\tif (ordered) {\n\t\toffset = entry_end(ordered);\n\t\tif (test_bit(BTRFS_ORDERED_TRUNCATED, &ordered->flags))\n\t\t\toffset = min(offset,\n\t\t\t\t     ordered->file_offset +\n\t\t\t\t     ordered->truncated_len);\n\t} else {\n\t\toffset = ALIGN(offset, BTRFS_I(inode)->root->sectorsize);\n\t}\n\tdisk_i_size = BTRFS_I(inode)->disk_i_size;\n\n\t/* truncate file */\n\tif (disk_i_size > i_size) {\n\t\tBTRFS_I(inode)->disk_i_size = i_size;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * if the disk i_size is already at the inode->i_size, or\n\t * this ordered extent is inside the disk i_size, we're done\n\t */\n\tif (disk_i_size == i_size)\n\t\tgoto out;\n\n\t/*\n\t * We still need to update disk_i_size if outstanding_isize is greater\n\t * than disk_i_size.\n\t */\n\tif (offset <= disk_i_size &&\n\t    (!ordered || ordered->outstanding_isize <= disk_i_size))\n\t\tgoto out;\n\n\t/*\n\t * walk backward from this ordered extent to disk_i_size.\n\t * if we find an ordered extent then we can't update disk i_size\n\t * yet\n\t */\n\tif (ordered) {\n\t\tnode = rb_prev(&ordered->rb_node);\n\t} else {\n\t\tprev = tree_search(tree, offset);\n\t\t/*\n\t\t * we insert file extents without involving ordered struct,\n\t\t * so there should be no ordered struct cover this offset\n\t\t */\n\t\tif (prev) {\n\t\t\ttest = rb_entry(prev, struct btrfs_ordered_extent,\n\t\t\t\t\trb_node);\n\t\t\tBUG_ON(offset_in_entry(test, offset));\n\t\t}\n\t\tnode = prev;\n\t}\n\tfor (; node; node = rb_prev(node)) {\n\t\ttest = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\n\t\t/* We treat this entry as if it doesnt exist */\n\t\tif (test_bit(BTRFS_ORDERED_UPDATED_ISIZE, &test->flags))\n\t\t\tcontinue;\n\t\tif (test->file_offset + test->len <= disk_i_size)\n\t\t\tbreak;\n\t\tif (test->file_offset >= i_size)\n\t\t\tbreak;\n\t\tif (entry_end(test) > disk_i_size) {\n\t\t\t/*\n\t\t\t * we don't update disk_i_size now, so record this\n\t\t\t * undealt i_size. Or we will not know the real\n\t\t\t * i_size.\n\t\t\t */\n\t\t\tif (test->outstanding_isize < offset)\n\t\t\t\ttest->outstanding_isize = offset;\n\t\t\tif (ordered &&\n\t\t\t    ordered->outstanding_isize >\n\t\t\t    test->outstanding_isize)\n\t\t\t\ttest->outstanding_isize =\n\t\t\t\t\t\tordered->outstanding_isize;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnew_i_size = min_t(u64, offset, i_size);\n\n\t/*\n\t * Some ordered extents may completed before the current one, and\n\t * we hold the real i_size in ->outstanding_isize.\n\t */\n\tif (ordered && ordered->outstanding_isize > new_i_size)\n\t\tnew_i_size = min_t(u64, ordered->outstanding_isize, i_size);\n\tBTRFS_I(inode)->disk_i_size = new_i_size;\n\tret = 0;\nout:\n\t/*\n\t * We need to do this because we can't remove ordered extents until\n\t * after the i_disk_size has been updated and then the inode has been\n\t * updated to reflect the change, so we need to tell anybody who finds\n\t * this ordered extent that we've already done all the real work, we\n\t * just haven't completed all the other work.\n\t */\n\tif (ordered)\n\t\tset_bit(BTRFS_ORDERED_UPDATED_ISIZE, &ordered->flags);\n\tspin_unlock_irq(&tree->lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tree->lock"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_ORDERED_UPDATED_ISIZE",
            "&ordered->flags"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "ordered->outstanding_isize",
            "i_size"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "offset",
            "i_size"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry_end",
          "args": [
            "test"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "entry_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "31-36",
          "snippet": "static u64 entry_end(struct btrfs_ordered_extent *entry)\n{\n\tif (entry->file_offset + entry->len < entry->file_offset)\n\t\treturn (u64)-1;\n\treturn entry->file_offset + entry->len;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic u64 entry_end(struct btrfs_ordered_extent *entry)\n{\n\tif (entry->file_offset + entry->len < entry->file_offset)\n\t\treturn (u64)-1;\n\treturn entry->file_offset + entry->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ORDERED_UPDATED_ISIZE",
            "&test->flags"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_ordered_extent",
            "rb_node"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "node"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset_in_entry(test, offset)"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_entry",
          "args": [
            "test",
            "offset"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "offset_in_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "130-136",
          "snippet": "static int offset_in_entry(struct btrfs_ordered_extent *entry, u64 file_offset)\n{\n\tif (file_offset < entry->file_offset ||\n\t    entry->file_offset + entry->len <= file_offset)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic int offset_in_entry(struct btrfs_ordered_extent *entry, u64 file_offset)\n{\n\tif (file_offset < entry->file_offset ||\n\t    entry->file_offset + entry->len <= file_offset)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "prev",
            "structbtrfs_ordered_extent",
            "rb_node"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "tree",
            "offset"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "151-171",
          "snippet": "static inline struct rb_node *tree_search(struct btrfs_ordered_inode_tree *tree,\n\t\t\t\t\t  u64 file_offset)\n{\n\tstruct rb_root *root = &tree->tree;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\tstruct btrfs_ordered_extent *entry;\n\n\tif (tree->last) {\n\t\tentry = rb_entry(tree->last, struct btrfs_ordered_extent,\n\t\t\t\t rb_node);\n\t\tif (offset_in_entry(entry, file_offset))\n\t\t\treturn tree->last;\n\t}\n\tret = __tree_search(root, file_offset, &prev);\n\tif (!ret)\n\t\tret = prev;\n\tif (ret)\n\t\ttree->last = ret;\n\treturn ret;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic inline struct rb_node *tree_search(struct btrfs_ordered_inode_tree *tree,\n\t\t\t\t\t  u64 file_offset)\n{\n\tstruct rb_root *root = &tree->tree;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\tstruct btrfs_ordered_extent *entry;\n\n\tif (tree->last) {\n\t\tentry = rb_entry(tree->last, struct btrfs_ordered_extent,\n\t\t\t\t rb_node);\n\t\tif (offset_in_entry(entry, file_offset))\n\t\t\treturn tree->last;\n\t}\n\tret = __tree_search(root, file_offset, &prev);\n\tif (!ret)\n\t\tret = prev;\n\tif (ret)\n\t\ttree->last = ret;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&ordered->rb_node"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "offset",
            "BTRFS_I(inode)->root->sectorsize"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "offset",
            "ordered->file_offset +\n\t\t\t\t     ordered->truncated_len"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tree->lock"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_ordered_update_i_size(struct inode *inode, u64 offset,\n\t\t\t\tstruct btrfs_ordered_extent *ordered)\n{\n\tstruct btrfs_ordered_inode_tree *tree = &BTRFS_I(inode)->ordered_tree;\n\tu64 disk_i_size;\n\tu64 new_i_size;\n\tu64 i_size = i_size_read(inode);\n\tstruct rb_node *node;\n\tstruct rb_node *prev = NULL;\n\tstruct btrfs_ordered_extent *test;\n\tint ret = 1;\n\n\tspin_lock_irq(&tree->lock);\n\tif (ordered) {\n\t\toffset = entry_end(ordered);\n\t\tif (test_bit(BTRFS_ORDERED_TRUNCATED, &ordered->flags))\n\t\t\toffset = min(offset,\n\t\t\t\t     ordered->file_offset +\n\t\t\t\t     ordered->truncated_len);\n\t} else {\n\t\toffset = ALIGN(offset, BTRFS_I(inode)->root->sectorsize);\n\t}\n\tdisk_i_size = BTRFS_I(inode)->disk_i_size;\n\n\t/* truncate file */\n\tif (disk_i_size > i_size) {\n\t\tBTRFS_I(inode)->disk_i_size = i_size;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * if the disk i_size is already at the inode->i_size, or\n\t * this ordered extent is inside the disk i_size, we're done\n\t */\n\tif (disk_i_size == i_size)\n\t\tgoto out;\n\n\t/*\n\t * We still need to update disk_i_size if outstanding_isize is greater\n\t * than disk_i_size.\n\t */\n\tif (offset <= disk_i_size &&\n\t    (!ordered || ordered->outstanding_isize <= disk_i_size))\n\t\tgoto out;\n\n\t/*\n\t * walk backward from this ordered extent to disk_i_size.\n\t * if we find an ordered extent then we can't update disk i_size\n\t * yet\n\t */\n\tif (ordered) {\n\t\tnode = rb_prev(&ordered->rb_node);\n\t} else {\n\t\tprev = tree_search(tree, offset);\n\t\t/*\n\t\t * we insert file extents without involving ordered struct,\n\t\t * so there should be no ordered struct cover this offset\n\t\t */\n\t\tif (prev) {\n\t\t\ttest = rb_entry(prev, struct btrfs_ordered_extent,\n\t\t\t\t\trb_node);\n\t\t\tBUG_ON(offset_in_entry(test, offset));\n\t\t}\n\t\tnode = prev;\n\t}\n\tfor (; node; node = rb_prev(node)) {\n\t\ttest = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\n\t\t/* We treat this entry as if it doesnt exist */\n\t\tif (test_bit(BTRFS_ORDERED_UPDATED_ISIZE, &test->flags))\n\t\t\tcontinue;\n\t\tif (test->file_offset + test->len <= disk_i_size)\n\t\t\tbreak;\n\t\tif (test->file_offset >= i_size)\n\t\t\tbreak;\n\t\tif (entry_end(test) > disk_i_size) {\n\t\t\t/*\n\t\t\t * we don't update disk_i_size now, so record this\n\t\t\t * undealt i_size. Or we will not know the real\n\t\t\t * i_size.\n\t\t\t */\n\t\t\tif (test->outstanding_isize < offset)\n\t\t\t\ttest->outstanding_isize = offset;\n\t\t\tif (ordered &&\n\t\t\t    ordered->outstanding_isize >\n\t\t\t    test->outstanding_isize)\n\t\t\t\ttest->outstanding_isize =\n\t\t\t\t\t\tordered->outstanding_isize;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnew_i_size = min_t(u64, offset, i_size);\n\n\t/*\n\t * Some ordered extents may completed before the current one, and\n\t * we hold the real i_size in ->outstanding_isize.\n\t */\n\tif (ordered && ordered->outstanding_isize > new_i_size)\n\t\tnew_i_size = min_t(u64, ordered->outstanding_isize, i_size);\n\tBTRFS_I(inode)->disk_i_size = new_i_size;\n\tret = 0;\nout:\n\t/*\n\t * We need to do this because we can't remove ordered extents until\n\t * after the i_disk_size has been updated and then the inode has been\n\t * updated to reflect the change, so we need to tell anybody who finds\n\t * this ordered extent that we've already done all the real work, we\n\t * just haven't completed all the other work.\n\t */\n\tif (ordered)\n\t\tset_bit(BTRFS_ORDERED_UPDATED_ISIZE, &ordered->flags);\n\tspin_unlock_irq(&tree->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_lookup_first_ordered_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "845-863",
    "snippet": "struct btrfs_ordered_extent *\nbtrfs_lookup_first_ordered_extent(struct inode *inode, u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tree->lock"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&entry->refs"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_ordered_extent",
            "rb_node"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "tree",
            "file_offset"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "151-171",
          "snippet": "static inline struct rb_node *tree_search(struct btrfs_ordered_inode_tree *tree,\n\t\t\t\t\t  u64 file_offset)\n{\n\tstruct rb_root *root = &tree->tree;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\tstruct btrfs_ordered_extent *entry;\n\n\tif (tree->last) {\n\t\tentry = rb_entry(tree->last, struct btrfs_ordered_extent,\n\t\t\t\t rb_node);\n\t\tif (offset_in_entry(entry, file_offset))\n\t\t\treturn tree->last;\n\t}\n\tret = __tree_search(root, file_offset, &prev);\n\tif (!ret)\n\t\tret = prev;\n\tif (ret)\n\t\ttree->last = ret;\n\treturn ret;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic inline struct rb_node *tree_search(struct btrfs_ordered_inode_tree *tree,\n\t\t\t\t\t  u64 file_offset)\n{\n\tstruct rb_root *root = &tree->tree;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\tstruct btrfs_ordered_extent *entry;\n\n\tif (tree->last) {\n\t\tentry = rb_entry(tree->last, struct btrfs_ordered_extent,\n\t\t\t\t rb_node);\n\t\tif (offset_in_entry(entry, file_offset))\n\t\t\treturn tree->last;\n\t}\n\tret = __tree_search(root, file_offset, &prev);\n\tif (!ret)\n\t\tret = prev;\n\tif (ret)\n\t\ttree->last = ret;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tree->lock"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstruct btrfs_ordered_extent *\nbtrfs_lookup_first_ordered_extent(struct inode *inode, u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}"
  },
  {
    "function_name": "btrfs_lookup_ordered_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "803-839",
    "snippet": "struct btrfs_ordered_extent *btrfs_lookup_ordered_range(struct inode *inode,\n\t\t\t\t\t\t\tu64 file_offset,\n\t\t\t\t\t\t\tu64 len)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node) {\n\t\tnode = tree_search(tree, file_offset + len);\n\t\tif (!node)\n\t\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\t\tif (range_overlaps(entry, file_offset, len))\n\t\t\tbreak;\n\n\t\tif (entry->file_offset >= file_offset + len) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tentry = NULL;\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tree->lock"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&entry->refs"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_overlaps",
          "args": [
            "entry",
            "file_offset",
            "len"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "range_overlaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "138-145",
          "snippet": "static int range_overlaps(struct btrfs_ordered_extent *entry, u64 file_offset,\n\t\t\t  u64 len)\n{\n\tif (file_offset + len <= entry->file_offset ||\n\t    entry->file_offset + entry->len <= file_offset)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic int range_overlaps(struct btrfs_ordered_extent *entry, u64 file_offset,\n\t\t\t  u64 len)\n{\n\tif (file_offset + len <= entry->file_offset ||\n\t    entry->file_offset + entry->len <= file_offset)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_ordered_extent",
            "rb_node"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "tree",
            "file_offset + len"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "151-171",
          "snippet": "static inline struct rb_node *tree_search(struct btrfs_ordered_inode_tree *tree,\n\t\t\t\t\t  u64 file_offset)\n{\n\tstruct rb_root *root = &tree->tree;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\tstruct btrfs_ordered_extent *entry;\n\n\tif (tree->last) {\n\t\tentry = rb_entry(tree->last, struct btrfs_ordered_extent,\n\t\t\t\t rb_node);\n\t\tif (offset_in_entry(entry, file_offset))\n\t\t\treturn tree->last;\n\t}\n\tret = __tree_search(root, file_offset, &prev);\n\tif (!ret)\n\t\tret = prev;\n\tif (ret)\n\t\ttree->last = ret;\n\treturn ret;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic inline struct rb_node *tree_search(struct btrfs_ordered_inode_tree *tree,\n\t\t\t\t\t  u64 file_offset)\n{\n\tstruct rb_root *root = &tree->tree;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\tstruct btrfs_ordered_extent *entry;\n\n\tif (tree->last) {\n\t\tentry = rb_entry(tree->last, struct btrfs_ordered_extent,\n\t\t\t\t rb_node);\n\t\tif (offset_in_entry(entry, file_offset))\n\t\t\treturn tree->last;\n\t}\n\tret = __tree_search(root, file_offset, &prev);\n\tif (!ret)\n\t\tret = prev;\n\tif (ret)\n\t\ttree->last = ret;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tree->lock"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstruct btrfs_ordered_extent *btrfs_lookup_ordered_range(struct inode *inode,\n\t\t\t\t\t\t\tu64 file_offset,\n\t\t\t\t\t\t\tu64 len)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node) {\n\t\tnode = tree_search(tree, file_offset + len);\n\t\tif (!node)\n\t\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\t\tif (range_overlaps(entry, file_offset, len))\n\t\t\tbreak;\n\n\t\tif (entry->file_offset >= file_offset + len) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tentry = NULL;\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}"
  },
  {
    "function_name": "btrfs_lookup_ordered_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "777-798",
    "snippet": "struct btrfs_ordered_extent *btrfs_lookup_ordered_extent(struct inode *inode,\n\t\t\t\t\t\t\t u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tif (!offset_in_entry(entry, file_offset))\n\t\tentry = NULL;\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tree->lock"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&entry->refs"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_entry",
          "args": [
            "entry",
            "file_offset"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "offset_in_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "130-136",
          "snippet": "static int offset_in_entry(struct btrfs_ordered_extent *entry, u64 file_offset)\n{\n\tif (file_offset < entry->file_offset ||\n\t    entry->file_offset + entry->len <= file_offset)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic int offset_in_entry(struct btrfs_ordered_extent *entry, u64 file_offset)\n{\n\tif (file_offset < entry->file_offset ||\n\t    entry->file_offset + entry->len <= file_offset)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_ordered_extent",
            "rb_node"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "tree",
            "file_offset"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "151-171",
          "snippet": "static inline struct rb_node *tree_search(struct btrfs_ordered_inode_tree *tree,\n\t\t\t\t\t  u64 file_offset)\n{\n\tstruct rb_root *root = &tree->tree;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\tstruct btrfs_ordered_extent *entry;\n\n\tif (tree->last) {\n\t\tentry = rb_entry(tree->last, struct btrfs_ordered_extent,\n\t\t\t\t rb_node);\n\t\tif (offset_in_entry(entry, file_offset))\n\t\t\treturn tree->last;\n\t}\n\tret = __tree_search(root, file_offset, &prev);\n\tif (!ret)\n\t\tret = prev;\n\tif (ret)\n\t\ttree->last = ret;\n\treturn ret;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic inline struct rb_node *tree_search(struct btrfs_ordered_inode_tree *tree,\n\t\t\t\t\t  u64 file_offset)\n{\n\tstruct rb_root *root = &tree->tree;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\tstruct btrfs_ordered_extent *entry;\n\n\tif (tree->last) {\n\t\tentry = rb_entry(tree->last, struct btrfs_ordered_extent,\n\t\t\t\t rb_node);\n\t\tif (offset_in_entry(entry, file_offset))\n\t\t\treturn tree->last;\n\t}\n\tret = __tree_search(root, file_offset, &prev);\n\tif (!ret)\n\t\tret = prev;\n\tif (ret)\n\t\ttree->last = ret;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tree->lock"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstruct btrfs_ordered_extent *btrfs_lookup_ordered_extent(struct inode *inode,\n\t\t\t\t\t\t\t u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tif (!offset_in_entry(entry, file_offset))\n\t\tentry = NULL;\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}"
  },
  {
    "function_name": "btrfs_wait_ordered_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "722-771",
    "snippet": "int btrfs_wait_ordered_range(struct inode *inode, u64 start, u64 len)\n{\n\tint ret = 0;\n\tu64 end;\n\tu64 orig_end;\n\tstruct btrfs_ordered_extent *ordered;\n\n\tif (start + len < start) {\n\t\torig_end = INT_LIMIT(loff_t);\n\t} else {\n\t\torig_end = start + len - 1;\n\t\tif (orig_end > INT_LIMIT(loff_t))\n\t\t\torig_end = INT_LIMIT(loff_t);\n\t}\n\n\t/* start IO across the range first to instantiate any delalloc\n\t * extents\n\t */\n\tret = btrfs_fdatawrite_range(inode, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tret = filemap_fdatawait_range(inode->i_mapping, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tend = orig_end;\n\twhile (1) {\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, end);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tif (ordered->file_offset > orig_end) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered->file_offset + ordered->len <= start) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tend = ordered->file_offset;\n\t\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered->flags))\n\t\t\tret = -EIO;\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tif (ret || end == 0 || end == start)\n\t\t\tbreak;\n\t\tend--;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_put_ordered_extent",
          "args": [
            "ordered"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "540-558",
          "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ORDERED_IOERR",
            "&ordered->flags"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_start_ordered_extent",
          "args": [
            "inode",
            "ordered",
            "1"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "697-717",
          "snippet": "void btrfs_start_ordered_extent(struct inode *inode,\n\t\t\t\t       struct btrfs_ordered_extent *entry,\n\t\t\t\t       int wait)\n{\n\tu64 start = entry->file_offset;\n\tu64 end = start + entry->len - 1;\n\n\ttrace_btrfs_ordered_extent_start(inode, entry);\n\n\t/*\n\t * pages in the range can be dirty, clean or writeback.  We\n\t * start IO on any dirty ones so the wait doesn't stall waiting\n\t * for the flusher thread to find them\n\t */\n\tif (!test_bit(BTRFS_ORDERED_DIRECT, &entry->flags))\n\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (wait) {\n\t\twait_event(entry->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags));\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_start_ordered_extent(struct inode *inode,\n\t\t\t\t       struct btrfs_ordered_extent *entry,\n\t\t\t\t       int wait)\n{\n\tu64 start = entry->file_offset;\n\tu64 end = start + entry->len - 1;\n\n\ttrace_btrfs_ordered_extent_start(inode, entry);\n\n\t/*\n\t * pages in the range can be dirty, clean or writeback.  We\n\t * start IO on any dirty ones so the wait doesn't stall waiting\n\t * for the flusher thread to find them\n\t */\n\tif (!test_bit(BTRFS_ORDERED_DIRECT, &entry->flags))\n\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (wait) {\n\t\twait_event(entry->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_first_ordered_extent",
          "args": [
            "inode",
            "end"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_first_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "845-863",
          "snippet": "struct btrfs_ordered_extent *\nbtrfs_lookup_first_ordered_extent(struct inode *inode, u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstruct btrfs_ordered_extent *\nbtrfs_lookup_first_ordered_extent(struct inode *inode, u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "orig_end"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_fdatawrite_range",
          "args": [
            "inode",
            "start",
            "orig_end"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_fdatawrite_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "2843-2867",
          "snippet": "int btrfs_fdatawrite_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tint ret;\n\n\t/*\n\t * So with compression we will find and lock a dirty page and clear the\n\t * first one as dirty, setup an async extent, and immediately return\n\t * with the entire range locked but with nobody actually marked with\n\t * writeback.  So we can't just filemap_write_and_wait_range() and\n\t * expect it to work since it will just kick off a thread to do the\n\t * actual work.  So we need to call filemap_fdatawrite_range _again_\n\t * since it will wait on the page lock, which won't be unlocked until\n\t * after the pages have been marked as writeback and so we're good to go\n\t * from there.  We have to do this otherwise we'll miss the ordered\n\t * extents and that results in badness.  Please Josef, do not think you\n\t * know better and pull this out at some point in the future, it is\n\t * right and you are wrong.\n\t */\n\tret = filemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (!ret && test_bit(BTRFS_INODE_HAS_ASYNC_EXTENT,\n\t\t\t     &BTRFS_I(inode)->runtime_flags))\n\t\tret = filemap_fdatawrite_range(inode->i_mapping, start, end);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint btrfs_fdatawrite_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tint ret;\n\n\t/*\n\t * So with compression we will find and lock a dirty page and clear the\n\t * first one as dirty, setup an async extent, and immediately return\n\t * with the entire range locked but with nobody actually marked with\n\t * writeback.  So we can't just filemap_write_and_wait_range() and\n\t * expect it to work since it will just kick off a thread to do the\n\t * actual work.  So we need to call filemap_fdatawrite_range _again_\n\t * since it will wait on the page lock, which won't be unlocked until\n\t * after the pages have been marked as writeback and so we're good to go\n\t * from there.  We have to do this otherwise we'll miss the ordered\n\t * extents and that results in badness.  Please Josef, do not think you\n\t * know better and pull this out at some point in the future, it is\n\t * right and you are wrong.\n\t */\n\tret = filemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (!ret && test_bit(BTRFS_INODE_HAS_ASYNC_EXTENT,\n\t\t\t     &BTRFS_I(inode)->runtime_flags))\n\t\tret = filemap_fdatawrite_range(inode->i_mapping, start, end);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INT_LIMIT",
          "args": [
            "loff_t"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT_LIMIT",
          "args": [
            "loff_t"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT_LIMIT",
          "args": [
            "loff_t"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_wait_ordered_range(struct inode *inode, u64 start, u64 len)\n{\n\tint ret = 0;\n\tu64 end;\n\tu64 orig_end;\n\tstruct btrfs_ordered_extent *ordered;\n\n\tif (start + len < start) {\n\t\torig_end = INT_LIMIT(loff_t);\n\t} else {\n\t\torig_end = start + len - 1;\n\t\tif (orig_end > INT_LIMIT(loff_t))\n\t\t\torig_end = INT_LIMIT(loff_t);\n\t}\n\n\t/* start IO across the range first to instantiate any delalloc\n\t * extents\n\t */\n\tret = btrfs_fdatawrite_range(inode, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tret = filemap_fdatawait_range(inode->i_mapping, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tend = orig_end;\n\twhile (1) {\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, end);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tif (ordered->file_offset > orig_end) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered->file_offset + ordered->len <= start) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tend = ordered->file_offset;\n\t\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered->flags))\n\t\t\tret = -EIO;\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tif (ret || end == 0 || end == start)\n\t\t\tbreak;\n\t\tend--;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_start_ordered_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "697-717",
    "snippet": "void btrfs_start_ordered_extent(struct inode *inode,\n\t\t\t\t       struct btrfs_ordered_extent *entry,\n\t\t\t\t       int wait)\n{\n\tu64 start = entry->file_offset;\n\tu64 end = start + entry->len - 1;\n\n\ttrace_btrfs_ordered_extent_start(inode, entry);\n\n\t/*\n\t * pages in the range can be dirty, clean or writeback.  We\n\t * start IO on any dirty ones so the wait doesn't stall waiting\n\t * for the flusher thread to find them\n\t */\n\tif (!test_bit(BTRFS_ORDERED_DIRECT, &entry->flags))\n\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (wait) {\n\t\twait_event(entry->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags));\n\t}\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "entry->wait",
            "test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags)"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ORDERED_COMPLETE",
            "&entry->flags"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_btrfs_ordered_extent_start",
          "args": [
            "inode",
            "entry"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_start_ordered_extent(struct inode *inode,\n\t\t\t\t       struct btrfs_ordered_extent *entry,\n\t\t\t\t       int wait)\n{\n\tu64 start = entry->file_offset;\n\tu64 end = start + entry->len - 1;\n\n\ttrace_btrfs_ordered_extent_start(inode, entry);\n\n\t/*\n\t * pages in the range can be dirty, clean or writeback.  We\n\t * start IO on any dirty ones so the wait doesn't stall waiting\n\t * for the flusher thread to find them\n\t */\n\tif (!test_bit(BTRFS_ORDERED_DIRECT, &entry->flags))\n\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (wait) {\n\t\twait_event(entry->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags));\n\t}\n}"
  },
  {
    "function_name": "btrfs_wait_ordered_roots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "656-688",
    "snippet": "void btrfs_wait_ordered_roots(struct btrfs_fs_info *fs_info, int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint done;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->ordered_operations_mutex);\n\tspin_lock(&fs_info->ordered_root_lock);\n\tlist_splice_init(&fs_info->ordered_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tordered_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->ordered_root,\n\t\t\t       &fs_info->ordered_roots);\n\t\tspin_unlock(&fs_info->ordered_root_lock);\n\n\t\tdone = btrfs_wait_ordered_extents(root, nr);\n\t\tbtrfs_put_fs_root(root);\n\n\t\tspin_lock(&fs_info->ordered_root_lock);\n\t\tif (nr != -1) {\n\t\t\tnr -= done;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t}\n\tlist_splice_tail(&splice, &fs_info->ordered_roots);\n\tspin_unlock(&fs_info->ordered_root_lock);\n\tmutex_unlock(&fs_info->ordered_operations_mutex);\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->ordered_operations_mutex"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->ordered_root_lock"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_tail",
          "args": [
            "&splice",
            "&fs_info->ordered_roots"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "nr < 0"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->ordered_root_lock"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_fs_root",
          "args": [
            "root"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "108-112",
          "snippet": "static inline void btrfs_put_fs_root(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->refs))\n\t\tkfree(root);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void btrfs_put_fs_root(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->refs))\n\t\tkfree(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_wait_ordered_extents",
          "args": [
            "root",
            "nr"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_ordered_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "609-654",
          "snippet": "int btrfs_wait_ordered_extents(struct btrfs_root *root, int nr)\n{\n\tstruct list_head splice, works;\n\tstruct btrfs_ordered_extent *ordered, *next;\n\tint count = 0;\n\n\tINIT_LIST_HEAD(&splice);\n\tINIT_LIST_HEAD(&works);\n\n\tmutex_lock(&root->ordered_extent_mutex);\n\tspin_lock(&root->ordered_extent_lock);\n\tlist_splice_init(&root->ordered_extents, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\tordered = list_first_entry(&splice, struct btrfs_ordered_extent,\n\t\t\t\t\t   root_extent_list);\n\t\tlist_move_tail(&ordered->root_extent_list,\n\t\t\t       &root->ordered_extents);\n\t\tatomic_inc(&ordered->refs);\n\t\tspin_unlock(&root->ordered_extent_lock);\n\n\t\tbtrfs_init_work(&ordered->flush_work,\n\t\t\t\tbtrfs_flush_delalloc_helper,\n\t\t\t\tbtrfs_run_ordered_extent_work, NULL, NULL);\n\t\tlist_add_tail(&ordered->work_list, &works);\n\t\tbtrfs_queue_work(root->fs_info->flush_workers,\n\t\t\t\t &ordered->flush_work);\n\n\t\tcond_resched();\n\t\tspin_lock(&root->ordered_extent_lock);\n\t\tif (nr != -1)\n\t\t\tnr--;\n\t\tcount++;\n\t}\n\tlist_splice_tail(&splice, &root->ordered_extents);\n\tspin_unlock(&root->ordered_extent_lock);\n\n\tlist_for_each_entry_safe(ordered, next, &works, work_list) {\n\t\tlist_del_init(&ordered->work_list);\n\t\twait_for_completion(&ordered->completion);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&root->ordered_extent_mutex);\n\n\treturn count;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_wait_ordered_extents(struct btrfs_root *root, int nr)\n{\n\tstruct list_head splice, works;\n\tstruct btrfs_ordered_extent *ordered, *next;\n\tint count = 0;\n\n\tINIT_LIST_HEAD(&splice);\n\tINIT_LIST_HEAD(&works);\n\n\tmutex_lock(&root->ordered_extent_mutex);\n\tspin_lock(&root->ordered_extent_lock);\n\tlist_splice_init(&root->ordered_extents, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\tordered = list_first_entry(&splice, struct btrfs_ordered_extent,\n\t\t\t\t\t   root_extent_list);\n\t\tlist_move_tail(&ordered->root_extent_list,\n\t\t\t       &root->ordered_extents);\n\t\tatomic_inc(&ordered->refs);\n\t\tspin_unlock(&root->ordered_extent_lock);\n\n\t\tbtrfs_init_work(&ordered->flush_work,\n\t\t\t\tbtrfs_flush_delalloc_helper,\n\t\t\t\tbtrfs_run_ordered_extent_work, NULL, NULL);\n\t\tlist_add_tail(&ordered->work_list, &works);\n\t\tbtrfs_queue_work(root->fs_info->flush_workers,\n\t\t\t\t &ordered->flush_work);\n\n\t\tcond_resched();\n\t\tspin_lock(&root->ordered_extent_lock);\n\t\tif (nr != -1)\n\t\t\tnr--;\n\t\tcount++;\n\t}\n\tlist_splice_tail(&splice, &root->ordered_extents);\n\tspin_unlock(&root->ordered_extent_lock);\n\n\tlist_for_each_entry_safe(ordered, next, &works, work_list) {\n\t\tlist_del_init(&ordered->work_list);\n\t\twait_for_completion(&ordered->completion);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&root->ordered_extent_mutex);\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&root->ordered_root",
            "&fs_info->ordered_roots"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!root"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_grab_fs_root",
          "args": [
            "root"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_grab_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "101-106",
          "snippet": "static inline struct btrfs_root *btrfs_grab_fs_root(struct btrfs_root *root)\n{\n\tif (atomic_inc_not_zero(&root->refs))\n\t\treturn root;\n\treturn NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *btrfs_grab_fs_root(struct btrfs_root *root)\n{\n\tif (atomic_inc_not_zero(&root->refs))\n\t\treturn root;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&splice",
            "structbtrfs_root",
            "ordered_root"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&splice"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&fs_info->ordered_roots",
            "&splice"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->ordered_operations_mutex"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&splice"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_wait_ordered_roots(struct btrfs_fs_info *fs_info, int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint done;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->ordered_operations_mutex);\n\tspin_lock(&fs_info->ordered_root_lock);\n\tlist_splice_init(&fs_info->ordered_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tordered_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->ordered_root,\n\t\t\t       &fs_info->ordered_roots);\n\t\tspin_unlock(&fs_info->ordered_root_lock);\n\n\t\tdone = btrfs_wait_ordered_extents(root, nr);\n\t\tbtrfs_put_fs_root(root);\n\n\t\tspin_lock(&fs_info->ordered_root_lock);\n\t\tif (nr != -1) {\n\t\t\tnr -= done;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t}\n\tlist_splice_tail(&splice, &fs_info->ordered_roots);\n\tspin_unlock(&fs_info->ordered_root_lock);\n\tmutex_unlock(&fs_info->ordered_operations_mutex);\n}"
  },
  {
    "function_name": "btrfs_wait_ordered_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "609-654",
    "snippet": "int btrfs_wait_ordered_extents(struct btrfs_root *root, int nr)\n{\n\tstruct list_head splice, works;\n\tstruct btrfs_ordered_extent *ordered, *next;\n\tint count = 0;\n\n\tINIT_LIST_HEAD(&splice);\n\tINIT_LIST_HEAD(&works);\n\n\tmutex_lock(&root->ordered_extent_mutex);\n\tspin_lock(&root->ordered_extent_lock);\n\tlist_splice_init(&root->ordered_extents, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\tordered = list_first_entry(&splice, struct btrfs_ordered_extent,\n\t\t\t\t\t   root_extent_list);\n\t\tlist_move_tail(&ordered->root_extent_list,\n\t\t\t       &root->ordered_extents);\n\t\tatomic_inc(&ordered->refs);\n\t\tspin_unlock(&root->ordered_extent_lock);\n\n\t\tbtrfs_init_work(&ordered->flush_work,\n\t\t\t\tbtrfs_flush_delalloc_helper,\n\t\t\t\tbtrfs_run_ordered_extent_work, NULL, NULL);\n\t\tlist_add_tail(&ordered->work_list, &works);\n\t\tbtrfs_queue_work(root->fs_info->flush_workers,\n\t\t\t\t &ordered->flush_work);\n\n\t\tcond_resched();\n\t\tspin_lock(&root->ordered_extent_lock);\n\t\tif (nr != -1)\n\t\t\tnr--;\n\t\tcount++;\n\t}\n\tlist_splice_tail(&splice, &root->ordered_extents);\n\tspin_unlock(&root->ordered_extent_lock);\n\n\tlist_for_each_entry_safe(ordered, next, &works, work_list) {\n\t\tlist_del_init(&ordered->work_list);\n\t\twait_for_completion(&ordered->completion);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&root->ordered_extent_mutex);\n\n\treturn count;\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->ordered_extent_mutex"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_ordered_extent",
          "args": [
            "ordered"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "540-558",
          "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&ordered->completion"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_qgroup_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2798-2814",
          "snippet": "int btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info)\n{\n\tint running;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tspin_lock(&fs_info->qgroup_lock);\n\trunning = fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\tspin_unlock(&fs_info->qgroup_lock);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tif (running)\n\t\tret = wait_for_completion_interruptible(\n\t\t\t\t\t&fs_info->qgroup_rescan_completion);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info)\n{\n\tint running;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tspin_lock(&fs_info->qgroup_lock);\n\trunning = fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\tspin_unlock(&fs_info->qgroup_lock);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tif (running)\n\t\tret = wait_for_completion_interruptible(\n\t\t\t\t\t&fs_info->qgroup_rescan_completion);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ordered->work_list"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ordered",
            "next",
            "&works",
            "work_list"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->ordered_extent_lock"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_tail",
          "args": [
            "&splice",
            "&root->ordered_extents"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->ordered_extent_lock"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_queue_work",
          "args": [
            "root->fs_info->flush_workers",
            "&ordered->flush_work"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ordered->work_list",
            "&works"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_work",
          "args": [
            "&ordered->flush_work",
            "btrfs_flush_delalloc_helper",
            "btrfs_run_ordered_extent_work",
            "NULL",
            "NULL"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "294-305",
          "snippet": "void btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic void normal_work_helper(struct btrfs_work *work);\n\nvoid btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ordered->refs"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&ordered->root_extent_list",
            "&root->ordered_extents"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&splice",
            "structbtrfs_ordered_extent",
            "root_extent_list"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&splice"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&root->ordered_extents",
            "&splice"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->ordered_extent_mutex"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&works"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&splice"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_wait_ordered_extents(struct btrfs_root *root, int nr)\n{\n\tstruct list_head splice, works;\n\tstruct btrfs_ordered_extent *ordered, *next;\n\tint count = 0;\n\n\tINIT_LIST_HEAD(&splice);\n\tINIT_LIST_HEAD(&works);\n\n\tmutex_lock(&root->ordered_extent_mutex);\n\tspin_lock(&root->ordered_extent_lock);\n\tlist_splice_init(&root->ordered_extents, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\tordered = list_first_entry(&splice, struct btrfs_ordered_extent,\n\t\t\t\t\t   root_extent_list);\n\t\tlist_move_tail(&ordered->root_extent_list,\n\t\t\t       &root->ordered_extents);\n\t\tatomic_inc(&ordered->refs);\n\t\tspin_unlock(&root->ordered_extent_lock);\n\n\t\tbtrfs_init_work(&ordered->flush_work,\n\t\t\t\tbtrfs_flush_delalloc_helper,\n\t\t\t\tbtrfs_run_ordered_extent_work, NULL, NULL);\n\t\tlist_add_tail(&ordered->work_list, &works);\n\t\tbtrfs_queue_work(root->fs_info->flush_workers,\n\t\t\t\t &ordered->flush_work);\n\n\t\tcond_resched();\n\t\tspin_lock(&root->ordered_extent_lock);\n\t\tif (nr != -1)\n\t\t\tnr--;\n\t\tcount++;\n\t}\n\tlist_splice_tail(&splice, &root->ordered_extents);\n\tspin_unlock(&root->ordered_extent_lock);\n\n\tlist_for_each_entry_safe(ordered, next, &works, work_list) {\n\t\tlist_del_init(&ordered->work_list);\n\t\twait_for_completion(&ordered->completion);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&root->ordered_extent_mutex);\n\n\treturn count;\n}"
  },
  {
    "function_name": "btrfs_run_ordered_extent_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "596-603",
    "snippet": "static void btrfs_run_ordered_extent_work(struct btrfs_work *work)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\n\tordered = container_of(work, struct btrfs_ordered_extent, flush_work);\n\tbtrfs_start_ordered_extent(ordered->inode, ordered, 1);\n\tcomplete(&ordered->completion);\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&ordered->completion"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_block_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2357-2383",
          "snippet": "static void scrub_block_complete(struct scrub_block *sblock)\n{\n\tint corrupted = 0;\n\n\tif (!sblock->no_io_error_seen) {\n\t\tcorrupted = 1;\n\t\tscrub_handle_errored_block(sblock);\n\t} else {\n\t\t/*\n\t\t * if has checksum error, write via repair mechanism in\n\t\t * dev replace case, otherwise write here in dev replace\n\t\t * case.\n\t\t */\n\t\tcorrupted = scrub_checksum(sblock);\n\t\tif (!corrupted && sblock->sctx->is_dev_replace)\n\t\t\tscrub_write_block_to_dev_replace(sblock);\n\t}\n\n\tif (sblock->sparity && corrupted && !sblock->data_corrected) {\n\t\tu64 start = sblock->pagev[0]->logical;\n\t\tu64 end = sblock->pagev[sblock->page_count - 1]->logical +\n\t\t\t  PAGE_SIZE;\n\n\t\tscrub_parity_mark_sectors_error(sblock->sparity,\n\t\t\t\t\t\tstart, end - start);\n\t}\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_write_block_to_dev_replace(struct scrub_block *sblock);",
            "static int scrub_checksum_data(struct scrub_block *sblock);",
            "static int scrub_checksum_tree_block(struct scrub_block *sblock);",
            "static int scrub_checksum_super(struct scrub_block *sblock);",
            "static void scrub_block_get(struct scrub_block *sblock);",
            "static void scrub_block_put(struct scrub_block *sblock);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_block_complete(struct scrub_block *sblock);",
            "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_write_block_to_dev_replace(struct scrub_block *sblock);\nstatic int scrub_checksum_data(struct scrub_block *sblock);\nstatic int scrub_checksum_tree_block(struct scrub_block *sblock);\nstatic int scrub_checksum_super(struct scrub_block *sblock);\nstatic void scrub_block_get(struct scrub_block *sblock);\nstatic void scrub_block_put(struct scrub_block *sblock);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_block_complete(struct scrub_block *sblock);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_block_complete(struct scrub_block *sblock)\n{\n\tint corrupted = 0;\n\n\tif (!sblock->no_io_error_seen) {\n\t\tcorrupted = 1;\n\t\tscrub_handle_errored_block(sblock);\n\t} else {\n\t\t/*\n\t\t * if has checksum error, write via repair mechanism in\n\t\t * dev replace case, otherwise write here in dev replace\n\t\t * case.\n\t\t */\n\t\tcorrupted = scrub_checksum(sblock);\n\t\tif (!corrupted && sblock->sctx->is_dev_replace)\n\t\t\tscrub_write_block_to_dev_replace(sblock);\n\t}\n\n\tif (sblock->sparity && corrupted && !sblock->data_corrected) {\n\t\tu64 start = sblock->pagev[0]->logical;\n\t\tu64 end = sblock->pagev[sblock->page_count - 1]->logical +\n\t\t\t  PAGE_SIZE;\n\n\t\tscrub_parity_mark_sectors_error(sblock->sparity,\n\t\t\t\t\t\tstart, end - start);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_start_ordered_extent",
          "args": [
            "ordered->inode",
            "ordered",
            "1"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "697-717",
          "snippet": "void btrfs_start_ordered_extent(struct inode *inode,\n\t\t\t\t       struct btrfs_ordered_extent *entry,\n\t\t\t\t       int wait)\n{\n\tu64 start = entry->file_offset;\n\tu64 end = start + entry->len - 1;\n\n\ttrace_btrfs_ordered_extent_start(inode, entry);\n\n\t/*\n\t * pages in the range can be dirty, clean or writeback.  We\n\t * start IO on any dirty ones so the wait doesn't stall waiting\n\t * for the flusher thread to find them\n\t */\n\tif (!test_bit(BTRFS_ORDERED_DIRECT, &entry->flags))\n\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (wait) {\n\t\twait_event(entry->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags));\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_start_ordered_extent(struct inode *inode,\n\t\t\t\t       struct btrfs_ordered_extent *entry,\n\t\t\t\t       int wait)\n{\n\tu64 start = entry->file_offset;\n\tu64 end = start + entry->len - 1;\n\n\ttrace_btrfs_ordered_extent_start(inode, entry);\n\n\t/*\n\t * pages in the range can be dirty, clean or writeback.  We\n\t * start IO on any dirty ones so the wait doesn't stall waiting\n\t * for the flusher thread to find them\n\t */\n\tif (!test_bit(BTRFS_ORDERED_DIRECT, &entry->flags))\n\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (wait) {\n\t\twait_event(entry->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbtrfs_ordered_extent",
            "flush_work"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic void btrfs_run_ordered_extent_work(struct btrfs_work *work)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\n\tordered = container_of(work, struct btrfs_ordered_extent, flush_work);\n\tbtrfs_start_ordered_extent(ordered->inode, ordered, 1);\n\tcomplete(&ordered->completion);\n}"
  },
  {
    "function_name": "btrfs_remove_ordered_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "564-594",
    "snippet": "void btrfs_remove_ordered_extent(struct inode *inode,\n\t\t\t\t struct btrfs_ordered_extent *entry)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct rb_node *node;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = &entry->rb_node;\n\trb_erase(node, &tree->tree);\n\tif (tree->last == node)\n\t\ttree->last = NULL;\n\tset_bit(BTRFS_ORDERED_COMPLETE, &entry->flags);\n\tspin_unlock_irq(&tree->lock);\n\n\tspin_lock(&root->ordered_extent_lock);\n\tlist_del_init(&entry->root_extent_list);\n\troot->nr_ordered_extents--;\n\n\ttrace_btrfs_ordered_extent_remove(inode, entry);\n\n\tif (!root->nr_ordered_extents) {\n\t\tspin_lock(&root->fs_info->ordered_root_lock);\n\t\tBUG_ON(list_empty(&root->ordered_root));\n\t\tlist_del_init(&root->ordered_root);\n\t\tspin_unlock(&root->fs_info->ordered_root_lock);\n\t}\n\tspin_unlock(&root->ordered_extent_lock);\n\twake_up(&entry->wait);\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&entry->wait"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->ordered_extent_lock"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&root->ordered_root"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "list_empty(&root->ordered_root)"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&root->ordered_root"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->ordered_root_lock"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_btrfs_ordered_extent_remove",
          "args": [
            "inode",
            "entry"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&entry->root_extent_list"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tree->lock"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_ORDERED_COMPLETE",
            "&entry->flags"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "node",
            "&tree->tree"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tree->lock"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_remove_ordered_extent(struct inode *inode,\n\t\t\t\t struct btrfs_ordered_extent *entry)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct rb_node *node;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = &entry->rb_node;\n\trb_erase(node, &tree->tree);\n\tif (tree->last == node)\n\t\ttree->last = NULL;\n\tset_bit(BTRFS_ORDERED_COMPLETE, &entry->flags);\n\tspin_unlock_irq(&tree->lock);\n\n\tspin_lock(&root->ordered_extent_lock);\n\tlist_del_init(&entry->root_extent_list);\n\troot->nr_ordered_extents--;\n\n\ttrace_btrfs_ordered_extent_remove(inode, entry);\n\n\tif (!root->nr_ordered_extents) {\n\t\tspin_lock(&root->fs_info->ordered_root_lock);\n\t\tBUG_ON(list_empty(&root->ordered_root));\n\t\tlist_del_init(&root->ordered_root);\n\t\tspin_unlock(&root->fs_info->ordered_root_lock);\n\t}\n\tspin_unlock(&root->ordered_extent_lock);\n\twake_up(&entry->wait);\n}"
  },
  {
    "function_name": "btrfs_put_ordered_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "540-558",
    "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *btrfs_ordered_extent_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_ordered_extent_cache",
            "entry"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sum"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&sum->list"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "cur",
            "structbtrfs_ordered_sum",
            "list"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&entry->list"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_add_delayed_iput",
          "args": [
            "entry->inode"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_add_delayed_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3084-3098",
          "snippet": "void btrfs_add_delayed_iput(struct inode *inode)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct delayed_iput *delayed;\n\n\tif (atomic_add_unless(&inode->i_count, -1, 1))\n\t\treturn;\n\n\tdelayed = kmalloc(sizeof(*delayed), GFP_NOFS | __GFP_NOFAIL);\n\tdelayed->inode = inode;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_add_tail(&delayed->list, &fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_add_delayed_iput(struct inode *inode)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct delayed_iput *delayed;\n\n\tif (atomic_add_unless(&inode->i_count, -1, 1))\n\t\treturn;\n\n\tdelayed = kmalloc(sizeof(*delayed), GFP_NOFS | __GFP_NOFAIL);\n\tdelayed->inode = inode;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_add_tail(&delayed->list, &fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&entry->refs"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_btrfs_ordered_extent_put",
          "args": [
            "entry->inode",
            "entry"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
  },
  {
    "function_name": "btrfs_free_logged_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "518-534",
    "snippet": "void btrfs_free_logged_extents(struct btrfs_root *log, u64 transid)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tint index = transid % 2;\n\n\tspin_lock_irq(&log->log_extents_lock[index]);\n\twhile (!list_empty(&log->logged_list[index])) {\n\t\tordered = list_first_entry(&log->logged_list[index],\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   log_list);\n\t\tlist_del_init(&ordered->log_list);\n\t\tspin_unlock_irq(&log->log_extents_lock[index]);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tspin_lock_irq(&log->log_extents_lock[index]);\n\t}\n\tspin_unlock_irq(&log->log_extents_lock[index]);\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&log->log_extents_lock[index]"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&log->log_extents_lock[index]"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_ordered_extent",
          "args": [
            "ordered"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "540-558",
          "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&log->log_extents_lock[index]"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ordered->log_list"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&log->logged_list[index]",
            "structbtrfs_ordered_extent",
            "log_list"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&log->logged_list[index]"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&log->log_extents_lock[index]"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_free_logged_extents(struct btrfs_root *log, u64 transid)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tint index = transid % 2;\n\n\tspin_lock_irq(&log->log_extents_lock[index]);\n\twhile (!list_empty(&log->logged_list[index])) {\n\t\tordered = list_first_entry(&log->logged_list[index],\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   log_list);\n\t\tlist_del_init(&ordered->log_list);\n\t\tspin_unlock_irq(&log->log_extents_lock[index]);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tspin_lock_irq(&log->log_extents_lock[index]);\n\t}\n\tspin_unlock_irq(&log->log_extents_lock[index]);\n}"
  },
  {
    "function_name": "btrfs_wait_logged_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "486-516",
    "snippet": "void btrfs_wait_logged_extents(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *log, u64 transid)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tint index = transid % 2;\n\n\tspin_lock_irq(&log->log_extents_lock[index]);\n\twhile (!list_empty(&log->logged_list[index])) {\n\t\tordered = list_first_entry(&log->logged_list[index],\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   log_list);\n\t\tlist_del_init(&ordered->log_list);\n\t\tspin_unlock_irq(&log->log_extents_lock[index]);\n\n\t\tif (!test_bit(BTRFS_ORDERED_IO_DONE, &ordered->flags) &&\n\t\t    !test_bit(BTRFS_ORDERED_DIRECT, &ordered->flags)) {\n\t\t\tstruct inode *inode = ordered->inode;\n\t\t\tu64 start = ordered->file_offset;\n\t\t\tu64 end = ordered->file_offset + ordered->len - 1;\n\n\t\t\tWARN_ON(!inode);\n\t\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\t\t}\n\t\twait_event(ordered->wait, test_bit(BTRFS_ORDERED_IO_DONE,\n\t\t\t\t\t\t   &ordered->flags));\n\n\t\tlist_add_tail(&ordered->trans_list, &trans->ordered);\n\t\tspin_lock_irq(&log->log_extents_lock[index]);\n\t}\n\tspin_unlock_irq(&log->log_extents_lock[index]);\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&log->log_extents_lock[index]"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&log->log_extents_lock[index]"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ordered->trans_list",
            "&trans->ordered"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "ordered->wait",
            "test_bit(BTRFS_ORDERED_IO_DONE,\n\t\t\t\t\t\t   &ordered->flags)"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ORDERED_IO_DONE",
            "&ordered->flags"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!inode"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&log->log_extents_lock[index]"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ordered->log_list"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&log->logged_list[index]",
            "structbtrfs_ordered_extent",
            "log_list"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&log->logged_list[index]"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&log->log_extents_lock[index]"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_wait_logged_extents(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *log, u64 transid)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tint index = transid % 2;\n\n\tspin_lock_irq(&log->log_extents_lock[index]);\n\twhile (!list_empty(&log->logged_list[index])) {\n\t\tordered = list_first_entry(&log->logged_list[index],\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   log_list);\n\t\tlist_del_init(&ordered->log_list);\n\t\tspin_unlock_irq(&log->log_extents_lock[index]);\n\n\t\tif (!test_bit(BTRFS_ORDERED_IO_DONE, &ordered->flags) &&\n\t\t    !test_bit(BTRFS_ORDERED_DIRECT, &ordered->flags)) {\n\t\t\tstruct inode *inode = ordered->inode;\n\t\t\tu64 start = ordered->file_offset;\n\t\t\tu64 end = ordered->file_offset + ordered->len - 1;\n\n\t\t\tWARN_ON(!inode);\n\t\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\t\t}\n\t\twait_event(ordered->wait, test_bit(BTRFS_ORDERED_IO_DONE,\n\t\t\t\t\t\t   &ordered->flags));\n\n\t\tlist_add_tail(&ordered->trans_list, &trans->ordered);\n\t\tspin_lock_irq(&log->log_extents_lock[index]);\n\t}\n\tspin_unlock_irq(&log->log_extents_lock[index]);\n}"
  },
  {
    "function_name": "btrfs_submit_logged_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "476-484",
    "snippet": "void btrfs_submit_logged_extents(struct list_head *logged_list,\n\t\t\t\t struct btrfs_root *log)\n{\n\tint index = log->log_transid % 2;\n\n\tspin_lock_irq(&log->log_extents_lock[index]);\n\tlist_splice_tail(logged_list, &log->logged_list[index]);\n\tspin_unlock_irq(&log->log_extents_lock[index]);\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&log->log_extents_lock[index]"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_tail",
          "args": [
            "logged_list",
            "&log->logged_list[index]"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&log->log_extents_lock[index]"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_submit_logged_extents(struct list_head *logged_list,\n\t\t\t\t struct btrfs_root *log)\n{\n\tint index = log->log_transid % 2;\n\n\tspin_lock_irq(&log->log_extents_lock[index]);\n\tlist_splice_tail(logged_list, &log->logged_list[index]);\n\tspin_unlock_irq(&log->log_extents_lock[index]);\n}"
  },
  {
    "function_name": "btrfs_put_logged_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "463-474",
    "snippet": "void btrfs_put_logged_extents(struct list_head *logged_list)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\n\twhile (!list_empty(logged_list)) {\n\t\tordered = list_first_entry(logged_list,\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   log_list);\n\t\tlist_del_init(&ordered->log_list);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_put_ordered_extent",
          "args": [
            "ordered"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "540-558",
          "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ordered->log_list"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "logged_list",
            "structbtrfs_ordered_extent",
            "log_list"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "logged_list"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_put_logged_extents(struct list_head *logged_list)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\n\twhile (!list_empty(logged_list)) {\n\t\tordered = list_first_entry(logged_list,\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   log_list);\n\t\tlist_del_init(&ordered->log_list);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n}"
  },
  {
    "function_name": "btrfs_get_logged_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "434-461",
    "snippet": "void btrfs_get_logged_extents(struct inode *inode,\n\t\t\t      struct list_head *logged_list,\n\t\t\t      const loff_t start,\n\t\t\t      const loff_t end)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct rb_node *n;\n\tstruct rb_node *prev;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tn = __tree_search(&tree->tree, end, &prev);\n\tif (!n)\n\t\tn = prev;\n\tfor (; n; n = rb_prev(n)) {\n\t\tordered = rb_entry(n, struct btrfs_ordered_extent, rb_node);\n\t\tif (ordered->file_offset > end)\n\t\t\tcontinue;\n\t\tif (entry_end(ordered) <= start)\n\t\t\tbreak;\n\t\tif (test_and_set_bit(BTRFS_ORDERED_LOGGED, &ordered->flags))\n\t\t\tcontinue;\n\t\tlist_add(&ordered->log_list, logged_list);\n\t\tatomic_inc(&ordered->refs);\n\t}\n\tspin_unlock_irq(&tree->lock);\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tree->lock"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ordered->refs"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ordered->log_list",
            "logged_list"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "BTRFS_ORDERED_LOGGED",
            "&ordered->flags"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry_end",
          "args": [
            "ordered"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "entry_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "31-36",
          "snippet": "static u64 entry_end(struct btrfs_ordered_extent *entry)\n{\n\tif (entry->file_offset + entry->len < entry->file_offset)\n\t\treturn (u64)-1;\n\treturn entry->file_offset + entry->len;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic u64 entry_end(struct btrfs_ordered_extent *entry)\n{\n\tif (entry->file_offset + entry->len < entry->file_offset)\n\t\treturn (u64)-1;\n\treturn entry->file_offset + entry->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_ordered_extent",
            "rb_node"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "n"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__tree_search",
          "args": [
            "&tree->tree",
            "end",
            "&prev"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "__tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "77-125",
          "snippet": "static struct rb_node *__tree_search(struct rb_root *root, u64 file_offset,\n\t\t\t\t     struct rb_node **prev_ret)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *test;\n\tstruct btrfs_ordered_extent *entry;\n\tstruct btrfs_ordered_extent *prev_entry = NULL;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct btrfs_ordered_extent, rb_node);\n\t\tprev = n;\n\t\tprev_entry = entry;\n\n\t\tif (file_offset < entry->file_offset)\n\t\t\tn = n->rb_left;\n\t\telse if (file_offset >= entry_end(entry))\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\tif (!prev_ret)\n\t\treturn NULL;\n\n\twhile (prev && file_offset >= entry_end(prev_entry)) {\n\t\ttest = rb_next(prev);\n\t\tif (!test)\n\t\t\tbreak;\n\t\tprev_entry = rb_entry(test, struct btrfs_ordered_extent,\n\t\t\t\t      rb_node);\n\t\tif (file_offset < entry_end(prev_entry))\n\t\t\tbreak;\n\n\t\tprev = test;\n\t}\n\tif (prev)\n\t\tprev_entry = rb_entry(prev, struct btrfs_ordered_extent,\n\t\t\t\t      rb_node);\n\twhile (prev && file_offset < entry_end(prev_entry)) {\n\t\ttest = rb_prev(prev);\n\t\tif (!test)\n\t\t\tbreak;\n\t\tprev_entry = rb_entry(test, struct btrfs_ordered_extent,\n\t\t\t\t      rb_node);\n\t\tprev = test;\n\t}\n\t*prev_ret = prev;\n\treturn NULL;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct rb_node *__tree_search(struct rb_root *root, u64 file_offset,\n\t\t\t\t     struct rb_node **prev_ret)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *test;\n\tstruct btrfs_ordered_extent *entry;\n\tstruct btrfs_ordered_extent *prev_entry = NULL;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct btrfs_ordered_extent, rb_node);\n\t\tprev = n;\n\t\tprev_entry = entry;\n\n\t\tif (file_offset < entry->file_offset)\n\t\t\tn = n->rb_left;\n\t\telse if (file_offset >= entry_end(entry))\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\tif (!prev_ret)\n\t\treturn NULL;\n\n\twhile (prev && file_offset >= entry_end(prev_entry)) {\n\t\ttest = rb_next(prev);\n\t\tif (!test)\n\t\t\tbreak;\n\t\tprev_entry = rb_entry(test, struct btrfs_ordered_extent,\n\t\t\t\t      rb_node);\n\t\tif (file_offset < entry_end(prev_entry))\n\t\t\tbreak;\n\n\t\tprev = test;\n\t}\n\tif (prev)\n\t\tprev_entry = rb_entry(prev, struct btrfs_ordered_extent,\n\t\t\t\t      rb_node);\n\twhile (prev && file_offset < entry_end(prev_entry)) {\n\t\ttest = rb_prev(prev);\n\t\tif (!test)\n\t\t\tbreak;\n\t\tprev_entry = rb_entry(test, struct btrfs_ordered_extent,\n\t\t\t\t      rb_node);\n\t\tprev = test;\n\t}\n\t*prev_ret = prev;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tree->lock"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_get_logged_extents(struct inode *inode,\n\t\t\t      struct list_head *logged_list,\n\t\t\t      const loff_t start,\n\t\t\t      const loff_t end)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct rb_node *n;\n\tstruct rb_node *prev;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tn = __tree_search(&tree->tree, end, &prev);\n\tif (!n)\n\t\tn = prev;\n\tfor (; n; n = rb_prev(n)) {\n\t\tordered = rb_entry(n, struct btrfs_ordered_extent, rb_node);\n\t\tif (ordered->file_offset > end)\n\t\t\tcontinue;\n\t\tif (entry_end(ordered) <= start)\n\t\t\tbreak;\n\t\tif (test_and_set_bit(BTRFS_ORDERED_LOGGED, &ordered->flags))\n\t\t\tcontinue;\n\t\tlist_add(&ordered->log_list, logged_list);\n\t\tatomic_inc(&ordered->refs);\n\t}\n\tspin_unlock_irq(&tree->lock);\n}"
  },
  {
    "function_name": "btrfs_dec_test_ordered_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "378-431",
    "snippet": "int btrfs_dec_test_ordered_pending(struct inode *inode,\n\t\t\t\t   struct btrfs_ordered_extent **cached,\n\t\t\t\t   u64 file_offset, u64 io_size, int uptodate)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\tunsigned long flags;\n\tint ret;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irqsave(&tree->lock, flags);\n\tif (cached && *cached) {\n\t\tentry = *cached;\n\t\tgoto have_entry;\n\t}\n\n\tnode = tree_search(tree, file_offset);\n\tif (!node) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\nhave_entry:\n\tif (!offset_in_entry(entry, file_offset)) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (io_size > entry->bytes_left) {\n\t\tbtrfs_crit(BTRFS_I(inode)->root->fs_info,\n\t\t\t   \"bad ordered accounting left %llu size %llu\",\n\t\t       entry->bytes_left, io_size);\n\t}\n\tentry->bytes_left -= io_size;\n\tif (!uptodate)\n\t\tset_bit(BTRFS_ORDERED_IOERR, &entry->flags);\n\n\tif (entry->bytes_left == 0) {\n\t\tret = test_and_set_bit(BTRFS_ORDERED_IO_DONE, &entry->flags);\n\t\tif (waitqueue_active(&entry->wait))\n\t\t\twake_up(&entry->wait);\n\t} else {\n\t\tret = 1;\n\t}\nout:\n\tif (!ret && cached && entry) {\n\t\t*cached = entry;\n\t\tatomic_inc(&entry->refs);\n\t}\n\tspin_unlock_irqrestore(&tree->lock, flags);\n\treturn ret == 0;\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&tree->lock",
            "flags"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&entry->refs"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&entry->wait"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&entry->wait"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "BTRFS_ORDERED_IO_DONE",
            "&entry->flags"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_ORDERED_IOERR",
            "&entry->flags"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_crit",
          "args": [
            "BTRFS_I(inode)->root->fs_info",
            "\"bad ordered accounting left %llu size %llu\"",
            "entry->bytes_left",
            "io_size"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_in_entry",
          "args": [
            "entry",
            "file_offset"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "offset_in_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "130-136",
          "snippet": "static int offset_in_entry(struct btrfs_ordered_extent *entry, u64 file_offset)\n{\n\tif (file_offset < entry->file_offset ||\n\t    entry->file_offset + entry->len <= file_offset)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic int offset_in_entry(struct btrfs_ordered_extent *entry, u64 file_offset)\n{\n\tif (file_offset < entry->file_offset ||\n\t    entry->file_offset + entry->len <= file_offset)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_ordered_extent",
            "rb_node"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "tree",
            "file_offset"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "151-171",
          "snippet": "static inline struct rb_node *tree_search(struct btrfs_ordered_inode_tree *tree,\n\t\t\t\t\t  u64 file_offset)\n{\n\tstruct rb_root *root = &tree->tree;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\tstruct btrfs_ordered_extent *entry;\n\n\tif (tree->last) {\n\t\tentry = rb_entry(tree->last, struct btrfs_ordered_extent,\n\t\t\t\t rb_node);\n\t\tif (offset_in_entry(entry, file_offset))\n\t\t\treturn tree->last;\n\t}\n\tret = __tree_search(root, file_offset, &prev);\n\tif (!ret)\n\t\tret = prev;\n\tif (ret)\n\t\ttree->last = ret;\n\treturn ret;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic inline struct rb_node *tree_search(struct btrfs_ordered_inode_tree *tree,\n\t\t\t\t\t  u64 file_offset)\n{\n\tstruct rb_root *root = &tree->tree;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\tstruct btrfs_ordered_extent *entry;\n\n\tif (tree->last) {\n\t\tentry = rb_entry(tree->last, struct btrfs_ordered_extent,\n\t\t\t\t rb_node);\n\t\tif (offset_in_entry(entry, file_offset))\n\t\t\treturn tree->last;\n\t}\n\tret = __tree_search(root, file_offset, &prev);\n\tif (!ret)\n\t\tret = prev;\n\tif (ret)\n\t\ttree->last = ret;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&tree->lock",
            "flags"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_dec_test_ordered_pending(struct inode *inode,\n\t\t\t\t   struct btrfs_ordered_extent **cached,\n\t\t\t\t   u64 file_offset, u64 io_size, int uptodate)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\tunsigned long flags;\n\tint ret;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irqsave(&tree->lock, flags);\n\tif (cached && *cached) {\n\t\tentry = *cached;\n\t\tgoto have_entry;\n\t}\n\n\tnode = tree_search(tree, file_offset);\n\tif (!node) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\nhave_entry:\n\tif (!offset_in_entry(entry, file_offset)) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (io_size > entry->bytes_left) {\n\t\tbtrfs_crit(BTRFS_I(inode)->root->fs_info,\n\t\t\t   \"bad ordered accounting left %llu size %llu\",\n\t\t       entry->bytes_left, io_size);\n\t}\n\tentry->bytes_left -= io_size;\n\tif (!uptodate)\n\t\tset_bit(BTRFS_ORDERED_IOERR, &entry->flags);\n\n\tif (entry->bytes_left == 0) {\n\t\tret = test_and_set_bit(BTRFS_ORDERED_IO_DONE, &entry->flags);\n\t\tif (waitqueue_active(&entry->wait))\n\t\t\twake_up(&entry->wait);\n\t} else {\n\t\tret = 1;\n\t}\nout:\n\tif (!ret && cached && entry) {\n\t\t*cached = entry;\n\t\tatomic_inc(&entry->refs);\n\t}\n\tspin_unlock_irqrestore(&tree->lock, flags);\n\treturn ret == 0;\n}"
  },
  {
    "function_name": "btrfs_dec_test_first_ordered_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "308-367",
    "snippet": "int btrfs_dec_test_first_ordered_pending(struct inode *inode,\n\t\t\t\t   struct btrfs_ordered_extent **cached,\n\t\t\t\t   u64 *file_offset, u64 io_size, int uptodate)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\tint ret;\n\tunsigned long flags;\n\tu64 dec_end;\n\tu64 dec_start;\n\tu64 to_dec;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irqsave(&tree->lock, flags);\n\tnode = tree_search(tree, *file_offset);\n\tif (!node) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tif (!offset_in_entry(entry, *file_offset)) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tdec_start = max(*file_offset, entry->file_offset);\n\tdec_end = min(*file_offset + io_size, entry->file_offset +\n\t\t      entry->len);\n\t*file_offset = dec_end;\n\tif (dec_start > dec_end) {\n\t\tbtrfs_crit(BTRFS_I(inode)->root->fs_info,\n\t\t\t\"bad ordering dec_start %llu end %llu\", dec_start, dec_end);\n\t}\n\tto_dec = dec_end - dec_start;\n\tif (to_dec > entry->bytes_left) {\n\t\tbtrfs_crit(BTRFS_I(inode)->root->fs_info,\n\t\t\t\"bad ordered accounting left %llu size %llu\",\n\t\t\tentry->bytes_left, to_dec);\n\t}\n\tentry->bytes_left -= to_dec;\n\tif (!uptodate)\n\t\tset_bit(BTRFS_ORDERED_IOERR, &entry->flags);\n\n\tif (entry->bytes_left == 0) {\n\t\tret = test_and_set_bit(BTRFS_ORDERED_IO_DONE, &entry->flags);\n\t\tif (waitqueue_active(&entry->wait))\n\t\t\twake_up(&entry->wait);\n\t} else {\n\t\tret = 1;\n\t}\nout:\n\tif (!ret && cached && entry) {\n\t\t*cached = entry;\n\t\tatomic_inc(&entry->refs);\n\t}\n\tspin_unlock_irqrestore(&tree->lock, flags);\n\treturn ret == 0;\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&tree->lock",
            "flags"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&entry->refs"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&entry->wait"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&entry->wait"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "BTRFS_ORDERED_IO_DONE",
            "&entry->flags"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_ORDERED_IOERR",
            "&entry->flags"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_crit",
          "args": [
            "BTRFS_I(inode)->root->fs_info",
            "\"bad ordered accounting left %llu size %llu\"",
            "entry->bytes_left",
            "to_dec"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_crit",
          "args": [
            "BTRFS_I(inode)->root->fs_info",
            "\"bad ordering dec_start %llu end %llu\"",
            "dec_start",
            "dec_end"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "*file_offset + io_size",
            "entry->file_offset +\n\t\t      entry->len"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "*file_offset",
            "entry->file_offset"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_workqueue_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "353-360",
          "snippet": "void btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_in_entry",
          "args": [
            "entry",
            "*file_offset"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "offset_in_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "130-136",
          "snippet": "static int offset_in_entry(struct btrfs_ordered_extent *entry, u64 file_offset)\n{\n\tif (file_offset < entry->file_offset ||\n\t    entry->file_offset + entry->len <= file_offset)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic int offset_in_entry(struct btrfs_ordered_extent *entry, u64 file_offset)\n{\n\tif (file_offset < entry->file_offset ||\n\t    entry->file_offset + entry->len <= file_offset)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_ordered_extent",
            "rb_node"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "tree",
            "*file_offset"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "151-171",
          "snippet": "static inline struct rb_node *tree_search(struct btrfs_ordered_inode_tree *tree,\n\t\t\t\t\t  u64 file_offset)\n{\n\tstruct rb_root *root = &tree->tree;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\tstruct btrfs_ordered_extent *entry;\n\n\tif (tree->last) {\n\t\tentry = rb_entry(tree->last, struct btrfs_ordered_extent,\n\t\t\t\t rb_node);\n\t\tif (offset_in_entry(entry, file_offset))\n\t\t\treturn tree->last;\n\t}\n\tret = __tree_search(root, file_offset, &prev);\n\tif (!ret)\n\t\tret = prev;\n\tif (ret)\n\t\ttree->last = ret;\n\treturn ret;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic inline struct rb_node *tree_search(struct btrfs_ordered_inode_tree *tree,\n\t\t\t\t\t  u64 file_offset)\n{\n\tstruct rb_root *root = &tree->tree;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\tstruct btrfs_ordered_extent *entry;\n\n\tif (tree->last) {\n\t\tentry = rb_entry(tree->last, struct btrfs_ordered_extent,\n\t\t\t\t rb_node);\n\t\tif (offset_in_entry(entry, file_offset))\n\t\t\treturn tree->last;\n\t}\n\tret = __tree_search(root, file_offset, &prev);\n\tif (!ret)\n\t\tret = prev;\n\tif (ret)\n\t\ttree->last = ret;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&tree->lock",
            "flags"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_dec_test_first_ordered_pending(struct inode *inode,\n\t\t\t\t   struct btrfs_ordered_extent **cached,\n\t\t\t\t   u64 *file_offset, u64 io_size, int uptodate)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\tint ret;\n\tunsigned long flags;\n\tu64 dec_end;\n\tu64 dec_start;\n\tu64 to_dec;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irqsave(&tree->lock, flags);\n\tnode = tree_search(tree, *file_offset);\n\tif (!node) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tif (!offset_in_entry(entry, *file_offset)) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tdec_start = max(*file_offset, entry->file_offset);\n\tdec_end = min(*file_offset + io_size, entry->file_offset +\n\t\t      entry->len);\n\t*file_offset = dec_end;\n\tif (dec_start > dec_end) {\n\t\tbtrfs_crit(BTRFS_I(inode)->root->fs_info,\n\t\t\t\"bad ordering dec_start %llu end %llu\", dec_start, dec_end);\n\t}\n\tto_dec = dec_end - dec_start;\n\tif (to_dec > entry->bytes_left) {\n\t\tbtrfs_crit(BTRFS_I(inode)->root->fs_info,\n\t\t\t\"bad ordered accounting left %llu size %llu\",\n\t\t\tentry->bytes_left, to_dec);\n\t}\n\tentry->bytes_left -= to_dec;\n\tif (!uptodate)\n\t\tset_bit(BTRFS_ORDERED_IOERR, &entry->flags);\n\n\tif (entry->bytes_left == 0) {\n\t\tret = test_and_set_bit(BTRFS_ORDERED_IO_DONE, &entry->flags);\n\t\tif (waitqueue_active(&entry->wait))\n\t\t\twake_up(&entry->wait);\n\t} else {\n\t\tret = 1;\n\t}\nout:\n\tif (!ret && cached && entry) {\n\t\t*cached = entry;\n\t\tatomic_inc(&entry->refs);\n\t}\n\tspin_unlock_irqrestore(&tree->lock, flags);\n\treturn ret == 0;\n}"
  },
  {
    "function_name": "btrfs_add_ordered_sum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "280-294",
    "snippet": "void btrfs_add_ordered_sum(struct inode *inode,\n\t\t\t   struct btrfs_ordered_extent *entry,\n\t\t\t   struct btrfs_ordered_sum *sum)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tlist_add_tail(&sum->list, &entry->list);\n\tWARN_ON(entry->csum_bytes_left < sum->len);\n\tentry->csum_bytes_left -= sum->len;\n\tif (entry->csum_bytes_left == 0)\n\t\twake_up(&entry->wait);\n\tspin_unlock_irq(&tree->lock);\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tree->lock"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&entry->wait"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "entry->csum_bytes_left < sum->len"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&sum->list",
            "&entry->list"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tree->lock"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_add_ordered_sum(struct inode *inode,\n\t\t\t   struct btrfs_ordered_extent *entry,\n\t\t\t   struct btrfs_ordered_sum *sum)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tlist_add_tail(&sum->list, &entry->list);\n\tWARN_ON(entry->csum_bytes_left < sum->len);\n\tentry->csum_bytes_left -= sum->len;\n\tif (entry->csum_bytes_left == 0)\n\t\twake_up(&entry->wait);\n\tspin_unlock_irq(&tree->lock);\n}"
  },
  {
    "function_name": "btrfs_add_ordered_extent_compress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "266-273",
    "snippet": "int btrfs_add_ordered_extent_compress(struct inode *inode, u64 file_offset,\n\t\t\t\t      u64 start, u64 len, u64 disk_len,\n\t\t\t\t      int type, int compress_type)\n{\n\treturn __btrfs_add_ordered_extent(inode, file_offset, start, len,\n\t\t\t\t\t  disk_len, type, 0,\n\t\t\t\t\t  compress_type);\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_add_ordered_extent",
          "args": [
            "inode",
            "file_offset",
            "start",
            "len",
            "disk_len",
            "type",
            "0",
            "compress_type"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_add_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "184-248",
          "snippet": "static int __btrfs_add_ordered_extent(struct inode *inode, u64 file_offset,\n\t\t\t\t      u64 start, u64 len, u64 disk_len,\n\t\t\t\t      int type, int dio, int compress_type)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tentry = kmem_cache_zalloc(btrfs_ordered_extent_cache, GFP_NOFS);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->file_offset = file_offset;\n\tentry->start = start;\n\tentry->len = len;\n\tif (!(BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM) &&\n\t    !(type == BTRFS_ORDERED_NOCOW))\n\t\tentry->csum_bytes_left = disk_len;\n\tentry->disk_len = disk_len;\n\tentry->bytes_left = len;\n\tentry->inode = igrab(inode);\n\tentry->compress_type = compress_type;\n\tentry->truncated_len = (u64)-1;\n\tif (type != BTRFS_ORDERED_IO_DONE && type != BTRFS_ORDERED_COMPLETE)\n\t\tset_bit(type, &entry->flags);\n\n\tif (dio)\n\t\tset_bit(BTRFS_ORDERED_DIRECT, &entry->flags);\n\n\t/* one ref for the tree */\n\tatomic_set(&entry->refs, 1);\n\tinit_waitqueue_head(&entry->wait);\n\tINIT_LIST_HEAD(&entry->list);\n\tINIT_LIST_HEAD(&entry->root_extent_list);\n\tINIT_LIST_HEAD(&entry->work_list);\n\tinit_completion(&entry->completion);\n\tINIT_LIST_HEAD(&entry->log_list);\n\tINIT_LIST_HEAD(&entry->trans_list);\n\n\ttrace_btrfs_ordered_extent_add(inode, entry);\n\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_insert(&tree->tree, file_offset,\n\t\t\t   &entry->rb_node);\n\tif (node)\n\t\tordered_data_tree_panic(inode, -EEXIST, file_offset);\n\tspin_unlock_irq(&tree->lock);\n\n\tspin_lock(&root->ordered_extent_lock);\n\tlist_add_tail(&entry->root_extent_list,\n\t\t      &root->ordered_extents);\n\troot->nr_ordered_extents++;\n\tif (root->nr_ordered_extents == 1) {\n\t\tspin_lock(&root->fs_info->ordered_root_lock);\n\t\tBUG_ON(!list_empty(&root->ordered_root));\n\t\tlist_add_tail(&root->ordered_root,\n\t\t\t      &root->fs_info->ordered_roots);\n\t\tspin_unlock(&root->fs_info->ordered_root_lock);\n\t}\n\tspin_unlock(&root->ordered_extent_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nstatic int __btrfs_add_ordered_extent(struct inode *inode, u64 file_offset,\n\t\t\t\t      u64 start, u64 len, u64 disk_len,\n\t\t\t\t      int type, int dio, int compress_type)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tentry = kmem_cache_zalloc(btrfs_ordered_extent_cache, GFP_NOFS);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->file_offset = file_offset;\n\tentry->start = start;\n\tentry->len = len;\n\tif (!(BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM) &&\n\t    !(type == BTRFS_ORDERED_NOCOW))\n\t\tentry->csum_bytes_left = disk_len;\n\tentry->disk_len = disk_len;\n\tentry->bytes_left = len;\n\tentry->inode = igrab(inode);\n\tentry->compress_type = compress_type;\n\tentry->truncated_len = (u64)-1;\n\tif (type != BTRFS_ORDERED_IO_DONE && type != BTRFS_ORDERED_COMPLETE)\n\t\tset_bit(type, &entry->flags);\n\n\tif (dio)\n\t\tset_bit(BTRFS_ORDERED_DIRECT, &entry->flags);\n\n\t/* one ref for the tree */\n\tatomic_set(&entry->refs, 1);\n\tinit_waitqueue_head(&entry->wait);\n\tINIT_LIST_HEAD(&entry->list);\n\tINIT_LIST_HEAD(&entry->root_extent_list);\n\tINIT_LIST_HEAD(&entry->work_list);\n\tinit_completion(&entry->completion);\n\tINIT_LIST_HEAD(&entry->log_list);\n\tINIT_LIST_HEAD(&entry->trans_list);\n\n\ttrace_btrfs_ordered_extent_add(inode, entry);\n\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_insert(&tree->tree, file_offset,\n\t\t\t   &entry->rb_node);\n\tif (node)\n\t\tordered_data_tree_panic(inode, -EEXIST, file_offset);\n\tspin_unlock_irq(&tree->lock);\n\n\tspin_lock(&root->ordered_extent_lock);\n\tlist_add_tail(&entry->root_extent_list,\n\t\t      &root->ordered_extents);\n\troot->nr_ordered_extents++;\n\tif (root->nr_ordered_extents == 1) {\n\t\tspin_lock(&root->fs_info->ordered_root_lock);\n\t\tBUG_ON(!list_empty(&root->ordered_root));\n\t\tlist_add_tail(&root->ordered_root,\n\t\t\t      &root->fs_info->ordered_roots);\n\t\tspin_unlock(&root->fs_info->ordered_root_lock);\n\t}\n\tspin_unlock(&root->ordered_extent_lock);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_add_ordered_extent_compress(struct inode *inode, u64 file_offset,\n\t\t\t\t      u64 start, u64 len, u64 disk_len,\n\t\t\t\t      int type, int compress_type)\n{\n\treturn __btrfs_add_ordered_extent(inode, file_offset, start, len,\n\t\t\t\t\t  disk_len, type, 0,\n\t\t\t\t\t  compress_type);\n}"
  },
  {
    "function_name": "btrfs_add_ordered_extent_dio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "258-264",
    "snippet": "int btrfs_add_ordered_extent_dio(struct inode *inode, u64 file_offset,\n\t\t\t\t u64 start, u64 len, u64 disk_len, int type)\n{\n\treturn __btrfs_add_ordered_extent(inode, file_offset, start, len,\n\t\t\t\t\t  disk_len, type, 1,\n\t\t\t\t\t  BTRFS_COMPRESS_NONE);\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_add_ordered_extent",
          "args": [
            "inode",
            "file_offset",
            "start",
            "len",
            "disk_len",
            "type",
            "1",
            "BTRFS_COMPRESS_NONE"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_add_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "184-248",
          "snippet": "static int __btrfs_add_ordered_extent(struct inode *inode, u64 file_offset,\n\t\t\t\t      u64 start, u64 len, u64 disk_len,\n\t\t\t\t      int type, int dio, int compress_type)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tentry = kmem_cache_zalloc(btrfs_ordered_extent_cache, GFP_NOFS);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->file_offset = file_offset;\n\tentry->start = start;\n\tentry->len = len;\n\tif (!(BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM) &&\n\t    !(type == BTRFS_ORDERED_NOCOW))\n\t\tentry->csum_bytes_left = disk_len;\n\tentry->disk_len = disk_len;\n\tentry->bytes_left = len;\n\tentry->inode = igrab(inode);\n\tentry->compress_type = compress_type;\n\tentry->truncated_len = (u64)-1;\n\tif (type != BTRFS_ORDERED_IO_DONE && type != BTRFS_ORDERED_COMPLETE)\n\t\tset_bit(type, &entry->flags);\n\n\tif (dio)\n\t\tset_bit(BTRFS_ORDERED_DIRECT, &entry->flags);\n\n\t/* one ref for the tree */\n\tatomic_set(&entry->refs, 1);\n\tinit_waitqueue_head(&entry->wait);\n\tINIT_LIST_HEAD(&entry->list);\n\tINIT_LIST_HEAD(&entry->root_extent_list);\n\tINIT_LIST_HEAD(&entry->work_list);\n\tinit_completion(&entry->completion);\n\tINIT_LIST_HEAD(&entry->log_list);\n\tINIT_LIST_HEAD(&entry->trans_list);\n\n\ttrace_btrfs_ordered_extent_add(inode, entry);\n\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_insert(&tree->tree, file_offset,\n\t\t\t   &entry->rb_node);\n\tif (node)\n\t\tordered_data_tree_panic(inode, -EEXIST, file_offset);\n\tspin_unlock_irq(&tree->lock);\n\n\tspin_lock(&root->ordered_extent_lock);\n\tlist_add_tail(&entry->root_extent_list,\n\t\t      &root->ordered_extents);\n\troot->nr_ordered_extents++;\n\tif (root->nr_ordered_extents == 1) {\n\t\tspin_lock(&root->fs_info->ordered_root_lock);\n\t\tBUG_ON(!list_empty(&root->ordered_root));\n\t\tlist_add_tail(&root->ordered_root,\n\t\t\t      &root->fs_info->ordered_roots);\n\t\tspin_unlock(&root->fs_info->ordered_root_lock);\n\t}\n\tspin_unlock(&root->ordered_extent_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nstatic int __btrfs_add_ordered_extent(struct inode *inode, u64 file_offset,\n\t\t\t\t      u64 start, u64 len, u64 disk_len,\n\t\t\t\t      int type, int dio, int compress_type)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tentry = kmem_cache_zalloc(btrfs_ordered_extent_cache, GFP_NOFS);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->file_offset = file_offset;\n\tentry->start = start;\n\tentry->len = len;\n\tif (!(BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM) &&\n\t    !(type == BTRFS_ORDERED_NOCOW))\n\t\tentry->csum_bytes_left = disk_len;\n\tentry->disk_len = disk_len;\n\tentry->bytes_left = len;\n\tentry->inode = igrab(inode);\n\tentry->compress_type = compress_type;\n\tentry->truncated_len = (u64)-1;\n\tif (type != BTRFS_ORDERED_IO_DONE && type != BTRFS_ORDERED_COMPLETE)\n\t\tset_bit(type, &entry->flags);\n\n\tif (dio)\n\t\tset_bit(BTRFS_ORDERED_DIRECT, &entry->flags);\n\n\t/* one ref for the tree */\n\tatomic_set(&entry->refs, 1);\n\tinit_waitqueue_head(&entry->wait);\n\tINIT_LIST_HEAD(&entry->list);\n\tINIT_LIST_HEAD(&entry->root_extent_list);\n\tINIT_LIST_HEAD(&entry->work_list);\n\tinit_completion(&entry->completion);\n\tINIT_LIST_HEAD(&entry->log_list);\n\tINIT_LIST_HEAD(&entry->trans_list);\n\n\ttrace_btrfs_ordered_extent_add(inode, entry);\n\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_insert(&tree->tree, file_offset,\n\t\t\t   &entry->rb_node);\n\tif (node)\n\t\tordered_data_tree_panic(inode, -EEXIST, file_offset);\n\tspin_unlock_irq(&tree->lock);\n\n\tspin_lock(&root->ordered_extent_lock);\n\tlist_add_tail(&entry->root_extent_list,\n\t\t      &root->ordered_extents);\n\troot->nr_ordered_extents++;\n\tif (root->nr_ordered_extents == 1) {\n\t\tspin_lock(&root->fs_info->ordered_root_lock);\n\t\tBUG_ON(!list_empty(&root->ordered_root));\n\t\tlist_add_tail(&root->ordered_root,\n\t\t\t      &root->fs_info->ordered_roots);\n\t\tspin_unlock(&root->fs_info->ordered_root_lock);\n\t}\n\tspin_unlock(&root->ordered_extent_lock);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_add_ordered_extent_dio(struct inode *inode, u64 file_offset,\n\t\t\t\t u64 start, u64 len, u64 disk_len, int type)\n{\n\treturn __btrfs_add_ordered_extent(inode, file_offset, start, len,\n\t\t\t\t\t  disk_len, type, 1,\n\t\t\t\t\t  BTRFS_COMPRESS_NONE);\n}"
  },
  {
    "function_name": "btrfs_add_ordered_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "250-256",
    "snippet": "int btrfs_add_ordered_extent(struct inode *inode, u64 file_offset,\n\t\t\t     u64 start, u64 len, u64 disk_len, int type)\n{\n\treturn __btrfs_add_ordered_extent(inode, file_offset, start, len,\n\t\t\t\t\t  disk_len, type, 0,\n\t\t\t\t\t  BTRFS_COMPRESS_NONE);\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_add_ordered_extent",
          "args": [
            "inode",
            "file_offset",
            "start",
            "len",
            "disk_len",
            "type",
            "0",
            "BTRFS_COMPRESS_NONE"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_add_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "184-248",
          "snippet": "static int __btrfs_add_ordered_extent(struct inode *inode, u64 file_offset,\n\t\t\t\t      u64 start, u64 len, u64 disk_len,\n\t\t\t\t      int type, int dio, int compress_type)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tentry = kmem_cache_zalloc(btrfs_ordered_extent_cache, GFP_NOFS);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->file_offset = file_offset;\n\tentry->start = start;\n\tentry->len = len;\n\tif (!(BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM) &&\n\t    !(type == BTRFS_ORDERED_NOCOW))\n\t\tentry->csum_bytes_left = disk_len;\n\tentry->disk_len = disk_len;\n\tentry->bytes_left = len;\n\tentry->inode = igrab(inode);\n\tentry->compress_type = compress_type;\n\tentry->truncated_len = (u64)-1;\n\tif (type != BTRFS_ORDERED_IO_DONE && type != BTRFS_ORDERED_COMPLETE)\n\t\tset_bit(type, &entry->flags);\n\n\tif (dio)\n\t\tset_bit(BTRFS_ORDERED_DIRECT, &entry->flags);\n\n\t/* one ref for the tree */\n\tatomic_set(&entry->refs, 1);\n\tinit_waitqueue_head(&entry->wait);\n\tINIT_LIST_HEAD(&entry->list);\n\tINIT_LIST_HEAD(&entry->root_extent_list);\n\tINIT_LIST_HEAD(&entry->work_list);\n\tinit_completion(&entry->completion);\n\tINIT_LIST_HEAD(&entry->log_list);\n\tINIT_LIST_HEAD(&entry->trans_list);\n\n\ttrace_btrfs_ordered_extent_add(inode, entry);\n\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_insert(&tree->tree, file_offset,\n\t\t\t   &entry->rb_node);\n\tif (node)\n\t\tordered_data_tree_panic(inode, -EEXIST, file_offset);\n\tspin_unlock_irq(&tree->lock);\n\n\tspin_lock(&root->ordered_extent_lock);\n\tlist_add_tail(&entry->root_extent_list,\n\t\t      &root->ordered_extents);\n\troot->nr_ordered_extents++;\n\tif (root->nr_ordered_extents == 1) {\n\t\tspin_lock(&root->fs_info->ordered_root_lock);\n\t\tBUG_ON(!list_empty(&root->ordered_root));\n\t\tlist_add_tail(&root->ordered_root,\n\t\t\t      &root->fs_info->ordered_roots);\n\t\tspin_unlock(&root->fs_info->ordered_root_lock);\n\t}\n\tspin_unlock(&root->ordered_extent_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nstatic int __btrfs_add_ordered_extent(struct inode *inode, u64 file_offset,\n\t\t\t\t      u64 start, u64 len, u64 disk_len,\n\t\t\t\t      int type, int dio, int compress_type)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tentry = kmem_cache_zalloc(btrfs_ordered_extent_cache, GFP_NOFS);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->file_offset = file_offset;\n\tentry->start = start;\n\tentry->len = len;\n\tif (!(BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM) &&\n\t    !(type == BTRFS_ORDERED_NOCOW))\n\t\tentry->csum_bytes_left = disk_len;\n\tentry->disk_len = disk_len;\n\tentry->bytes_left = len;\n\tentry->inode = igrab(inode);\n\tentry->compress_type = compress_type;\n\tentry->truncated_len = (u64)-1;\n\tif (type != BTRFS_ORDERED_IO_DONE && type != BTRFS_ORDERED_COMPLETE)\n\t\tset_bit(type, &entry->flags);\n\n\tif (dio)\n\t\tset_bit(BTRFS_ORDERED_DIRECT, &entry->flags);\n\n\t/* one ref for the tree */\n\tatomic_set(&entry->refs, 1);\n\tinit_waitqueue_head(&entry->wait);\n\tINIT_LIST_HEAD(&entry->list);\n\tINIT_LIST_HEAD(&entry->root_extent_list);\n\tINIT_LIST_HEAD(&entry->work_list);\n\tinit_completion(&entry->completion);\n\tINIT_LIST_HEAD(&entry->log_list);\n\tINIT_LIST_HEAD(&entry->trans_list);\n\n\ttrace_btrfs_ordered_extent_add(inode, entry);\n\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_insert(&tree->tree, file_offset,\n\t\t\t   &entry->rb_node);\n\tif (node)\n\t\tordered_data_tree_panic(inode, -EEXIST, file_offset);\n\tspin_unlock_irq(&tree->lock);\n\n\tspin_lock(&root->ordered_extent_lock);\n\tlist_add_tail(&entry->root_extent_list,\n\t\t      &root->ordered_extents);\n\troot->nr_ordered_extents++;\n\tif (root->nr_ordered_extents == 1) {\n\t\tspin_lock(&root->fs_info->ordered_root_lock);\n\t\tBUG_ON(!list_empty(&root->ordered_root));\n\t\tlist_add_tail(&root->ordered_root,\n\t\t\t      &root->fs_info->ordered_roots);\n\t\tspin_unlock(&root->fs_info->ordered_root_lock);\n\t}\n\tspin_unlock(&root->ordered_extent_lock);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_add_ordered_extent(struct inode *inode, u64 file_offset,\n\t\t\t     u64 start, u64 len, u64 disk_len, int type)\n{\n\treturn __btrfs_add_ordered_extent(inode, file_offset, start, len,\n\t\t\t\t\t  disk_len, type, 0,\n\t\t\t\t\t  BTRFS_COMPRESS_NONE);\n}"
  },
  {
    "function_name": "__btrfs_add_ordered_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "184-248",
    "snippet": "static int __btrfs_add_ordered_extent(struct inode *inode, u64 file_offset,\n\t\t\t\t      u64 start, u64 len, u64 disk_len,\n\t\t\t\t      int type, int dio, int compress_type)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tentry = kmem_cache_zalloc(btrfs_ordered_extent_cache, GFP_NOFS);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->file_offset = file_offset;\n\tentry->start = start;\n\tentry->len = len;\n\tif (!(BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM) &&\n\t    !(type == BTRFS_ORDERED_NOCOW))\n\t\tentry->csum_bytes_left = disk_len;\n\tentry->disk_len = disk_len;\n\tentry->bytes_left = len;\n\tentry->inode = igrab(inode);\n\tentry->compress_type = compress_type;\n\tentry->truncated_len = (u64)-1;\n\tif (type != BTRFS_ORDERED_IO_DONE && type != BTRFS_ORDERED_COMPLETE)\n\t\tset_bit(type, &entry->flags);\n\n\tif (dio)\n\t\tset_bit(BTRFS_ORDERED_DIRECT, &entry->flags);\n\n\t/* one ref for the tree */\n\tatomic_set(&entry->refs, 1);\n\tinit_waitqueue_head(&entry->wait);\n\tINIT_LIST_HEAD(&entry->list);\n\tINIT_LIST_HEAD(&entry->root_extent_list);\n\tINIT_LIST_HEAD(&entry->work_list);\n\tinit_completion(&entry->completion);\n\tINIT_LIST_HEAD(&entry->log_list);\n\tINIT_LIST_HEAD(&entry->trans_list);\n\n\ttrace_btrfs_ordered_extent_add(inode, entry);\n\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_insert(&tree->tree, file_offset,\n\t\t\t   &entry->rb_node);\n\tif (node)\n\t\tordered_data_tree_panic(inode, -EEXIST, file_offset);\n\tspin_unlock_irq(&tree->lock);\n\n\tspin_lock(&root->ordered_extent_lock);\n\tlist_add_tail(&entry->root_extent_list,\n\t\t      &root->ordered_extents);\n\troot->nr_ordered_extents++;\n\tif (root->nr_ordered_extents == 1) {\n\t\tspin_lock(&root->fs_info->ordered_root_lock);\n\t\tBUG_ON(!list_empty(&root->ordered_root));\n\t\tlist_add_tail(&root->ordered_root,\n\t\t\t      &root->fs_info->ordered_roots);\n\t\tspin_unlock(&root->fs_info->ordered_root_lock);\n\t}\n\tspin_unlock(&root->ordered_extent_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *btrfs_ordered_extent_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->ordered_extent_lock"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&root->ordered_root",
            "&root->fs_info->ordered_roots"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&root->ordered_root)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&root->ordered_root"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->ordered_root_lock"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&entry->root_extent_list",
            "&root->ordered_extents"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tree->lock"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ordered_data_tree_panic",
          "args": [
            "inode",
            "-EEXIST",
            "file_offset"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "ordered_data_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "65-71",
          "snippet": "static void ordered_data_tree_panic(struct inode *inode, int errno,\n\t\t\t\t\t       u64 offset)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tbtrfs_panic(fs_info, errno, \"Inconsistency in ordered tree at offset \"\n\t\t    \"%llu\", offset);\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic void ordered_data_tree_panic(struct inode *inode, int errno,\n\t\t\t\t\t       u64 offset)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tbtrfs_panic(fs_info, errno, \"Inconsistency in ordered tree at offset \"\n\t\t    \"%llu\", offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_insert",
          "args": [
            "&tree->tree",
            "file_offset",
            "&entry->rb_node"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "41-63",
          "snippet": "static struct rb_node *tree_insert(struct rb_root *root, u64 file_offset,\n\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_ordered_extent *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct btrfs_ordered_extent, rb_node);\n\n\t\tif (file_offset < entry->file_offset)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (file_offset >= entry_end(entry))\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct rb_node *tree_insert(struct rb_root *root, u64 file_offset,\n\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_ordered_extent *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct btrfs_ordered_extent, rb_node);\n\n\t\tif (file_offset < entry->file_offset)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (file_offset >= entry_end(entry))\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tree->lock"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_btrfs_ordered_extent_add",
          "args": [
            "inode",
            "entry"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&entry->trans_list"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&entry->log_list"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&entry->completion"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&entry->work_list"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&entry->root_extent_list"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&entry->list"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&entry->wait"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&entry->refs",
            "1"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_ORDERED_DIRECT",
            "&entry->flags"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "inode"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "btrfs_ordered_extent_cache",
            "GFP_NOFS"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nstatic int __btrfs_add_ordered_extent(struct inode *inode, u64 file_offset,\n\t\t\t\t      u64 start, u64 len, u64 disk_len,\n\t\t\t\t      int type, int dio, int compress_type)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tentry = kmem_cache_zalloc(btrfs_ordered_extent_cache, GFP_NOFS);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->file_offset = file_offset;\n\tentry->start = start;\n\tentry->len = len;\n\tif (!(BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM) &&\n\t    !(type == BTRFS_ORDERED_NOCOW))\n\t\tentry->csum_bytes_left = disk_len;\n\tentry->disk_len = disk_len;\n\tentry->bytes_left = len;\n\tentry->inode = igrab(inode);\n\tentry->compress_type = compress_type;\n\tentry->truncated_len = (u64)-1;\n\tif (type != BTRFS_ORDERED_IO_DONE && type != BTRFS_ORDERED_COMPLETE)\n\t\tset_bit(type, &entry->flags);\n\n\tif (dio)\n\t\tset_bit(BTRFS_ORDERED_DIRECT, &entry->flags);\n\n\t/* one ref for the tree */\n\tatomic_set(&entry->refs, 1);\n\tinit_waitqueue_head(&entry->wait);\n\tINIT_LIST_HEAD(&entry->list);\n\tINIT_LIST_HEAD(&entry->root_extent_list);\n\tINIT_LIST_HEAD(&entry->work_list);\n\tinit_completion(&entry->completion);\n\tINIT_LIST_HEAD(&entry->log_list);\n\tINIT_LIST_HEAD(&entry->trans_list);\n\n\ttrace_btrfs_ordered_extent_add(inode, entry);\n\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_insert(&tree->tree, file_offset,\n\t\t\t   &entry->rb_node);\n\tif (node)\n\t\tordered_data_tree_panic(inode, -EEXIST, file_offset);\n\tspin_unlock_irq(&tree->lock);\n\n\tspin_lock(&root->ordered_extent_lock);\n\tlist_add_tail(&entry->root_extent_list,\n\t\t      &root->ordered_extents);\n\troot->nr_ordered_extents++;\n\tif (root->nr_ordered_extents == 1) {\n\t\tspin_lock(&root->fs_info->ordered_root_lock);\n\t\tBUG_ON(!list_empty(&root->ordered_root));\n\t\tlist_add_tail(&root->ordered_root,\n\t\t\t      &root->fs_info->ordered_roots);\n\t\tspin_unlock(&root->fs_info->ordered_root_lock);\n\t}\n\tspin_unlock(&root->ordered_extent_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tree_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "151-171",
    "snippet": "static inline struct rb_node *tree_search(struct btrfs_ordered_inode_tree *tree,\n\t\t\t\t\t  u64 file_offset)\n{\n\tstruct rb_root *root = &tree->tree;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\tstruct btrfs_ordered_extent *entry;\n\n\tif (tree->last) {\n\t\tentry = rb_entry(tree->last, struct btrfs_ordered_extent,\n\t\t\t\t rb_node);\n\t\tif (offset_in_entry(entry, file_offset))\n\t\t\treturn tree->last;\n\t}\n\tret = __tree_search(root, file_offset, &prev);\n\tif (!ret)\n\t\tret = prev;\n\tif (ret)\n\t\ttree->last = ret;\n\treturn ret;\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__tree_search",
          "args": [
            "root",
            "file_offset",
            "&prev"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "__tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "77-125",
          "snippet": "static struct rb_node *__tree_search(struct rb_root *root, u64 file_offset,\n\t\t\t\t     struct rb_node **prev_ret)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *test;\n\tstruct btrfs_ordered_extent *entry;\n\tstruct btrfs_ordered_extent *prev_entry = NULL;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct btrfs_ordered_extent, rb_node);\n\t\tprev = n;\n\t\tprev_entry = entry;\n\n\t\tif (file_offset < entry->file_offset)\n\t\t\tn = n->rb_left;\n\t\telse if (file_offset >= entry_end(entry))\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\tif (!prev_ret)\n\t\treturn NULL;\n\n\twhile (prev && file_offset >= entry_end(prev_entry)) {\n\t\ttest = rb_next(prev);\n\t\tif (!test)\n\t\t\tbreak;\n\t\tprev_entry = rb_entry(test, struct btrfs_ordered_extent,\n\t\t\t\t      rb_node);\n\t\tif (file_offset < entry_end(prev_entry))\n\t\t\tbreak;\n\n\t\tprev = test;\n\t}\n\tif (prev)\n\t\tprev_entry = rb_entry(prev, struct btrfs_ordered_extent,\n\t\t\t\t      rb_node);\n\twhile (prev && file_offset < entry_end(prev_entry)) {\n\t\ttest = rb_prev(prev);\n\t\tif (!test)\n\t\t\tbreak;\n\t\tprev_entry = rb_entry(test, struct btrfs_ordered_extent,\n\t\t\t\t      rb_node);\n\t\tprev = test;\n\t}\n\t*prev_ret = prev;\n\treturn NULL;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct rb_node *__tree_search(struct rb_root *root, u64 file_offset,\n\t\t\t\t     struct rb_node **prev_ret)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *test;\n\tstruct btrfs_ordered_extent *entry;\n\tstruct btrfs_ordered_extent *prev_entry = NULL;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct btrfs_ordered_extent, rb_node);\n\t\tprev = n;\n\t\tprev_entry = entry;\n\n\t\tif (file_offset < entry->file_offset)\n\t\t\tn = n->rb_left;\n\t\telse if (file_offset >= entry_end(entry))\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\tif (!prev_ret)\n\t\treturn NULL;\n\n\twhile (prev && file_offset >= entry_end(prev_entry)) {\n\t\ttest = rb_next(prev);\n\t\tif (!test)\n\t\t\tbreak;\n\t\tprev_entry = rb_entry(test, struct btrfs_ordered_extent,\n\t\t\t\t      rb_node);\n\t\tif (file_offset < entry_end(prev_entry))\n\t\t\tbreak;\n\n\t\tprev = test;\n\t}\n\tif (prev)\n\t\tprev_entry = rb_entry(prev, struct btrfs_ordered_extent,\n\t\t\t\t      rb_node);\n\twhile (prev && file_offset < entry_end(prev_entry)) {\n\t\ttest = rb_prev(prev);\n\t\tif (!test)\n\t\t\tbreak;\n\t\tprev_entry = rb_entry(test, struct btrfs_ordered_extent,\n\t\t\t\t      rb_node);\n\t\tprev = test;\n\t}\n\t*prev_ret = prev;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_in_entry",
          "args": [
            "entry",
            "file_offset"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "offset_in_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "130-136",
          "snippet": "static int offset_in_entry(struct btrfs_ordered_extent *entry, u64 file_offset)\n{\n\tif (file_offset < entry->file_offset ||\n\t    entry->file_offset + entry->len <= file_offset)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic int offset_in_entry(struct btrfs_ordered_extent *entry, u64 file_offset)\n{\n\tif (file_offset < entry->file_offset ||\n\t    entry->file_offset + entry->len <= file_offset)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "tree->last",
            "structbtrfs_ordered_extent",
            "rb_node"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic inline struct rb_node *tree_search(struct btrfs_ordered_inode_tree *tree,\n\t\t\t\t\t  u64 file_offset)\n{\n\tstruct rb_root *root = &tree->tree;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\tstruct btrfs_ordered_extent *entry;\n\n\tif (tree->last) {\n\t\tentry = rb_entry(tree->last, struct btrfs_ordered_extent,\n\t\t\t\t rb_node);\n\t\tif (offset_in_entry(entry, file_offset))\n\t\t\treturn tree->last;\n\t}\n\tret = __tree_search(root, file_offset, &prev);\n\tif (!ret)\n\t\tret = prev;\n\tif (ret)\n\t\ttree->last = ret;\n\treturn ret;\n}"
  },
  {
    "function_name": "range_overlaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "138-145",
    "snippet": "static int range_overlaps(struct btrfs_ordered_extent *entry, u64 file_offset,\n\t\t\t  u64 len)\n{\n\tif (file_offset + len <= entry->file_offset ||\n\t    entry->file_offset + entry->len <= file_offset)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic int range_overlaps(struct btrfs_ordered_extent *entry, u64 file_offset,\n\t\t\t  u64 len)\n{\n\tif (file_offset + len <= entry->file_offset ||\n\t    entry->file_offset + entry->len <= file_offset)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "offset_in_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "130-136",
    "snippet": "static int offset_in_entry(struct btrfs_ordered_extent *entry, u64 file_offset)\n{\n\tif (file_offset < entry->file_offset ||\n\t    entry->file_offset + entry->len <= file_offset)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic int offset_in_entry(struct btrfs_ordered_extent *entry, u64 file_offset)\n{\n\tif (file_offset < entry->file_offset ||\n\t    entry->file_offset + entry->len <= file_offset)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "__tree_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "77-125",
    "snippet": "static struct rb_node *__tree_search(struct rb_root *root, u64 file_offset,\n\t\t\t\t     struct rb_node **prev_ret)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *test;\n\tstruct btrfs_ordered_extent *entry;\n\tstruct btrfs_ordered_extent *prev_entry = NULL;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct btrfs_ordered_extent, rb_node);\n\t\tprev = n;\n\t\tprev_entry = entry;\n\n\t\tif (file_offset < entry->file_offset)\n\t\t\tn = n->rb_left;\n\t\telse if (file_offset >= entry_end(entry))\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\tif (!prev_ret)\n\t\treturn NULL;\n\n\twhile (prev && file_offset >= entry_end(prev_entry)) {\n\t\ttest = rb_next(prev);\n\t\tif (!test)\n\t\t\tbreak;\n\t\tprev_entry = rb_entry(test, struct btrfs_ordered_extent,\n\t\t\t\t      rb_node);\n\t\tif (file_offset < entry_end(prev_entry))\n\t\t\tbreak;\n\n\t\tprev = test;\n\t}\n\tif (prev)\n\t\tprev_entry = rb_entry(prev, struct btrfs_ordered_extent,\n\t\t\t\t      rb_node);\n\twhile (prev && file_offset < entry_end(prev_entry)) {\n\t\ttest = rb_prev(prev);\n\t\tif (!test)\n\t\t\tbreak;\n\t\tprev_entry = rb_entry(test, struct btrfs_ordered_extent,\n\t\t\t\t      rb_node);\n\t\tprev = test;\n\t}\n\t*prev_ret = prev;\n\treturn NULL;\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "test",
            "structbtrfs_ordered_extent",
            "rb_node"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "prev"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry_end",
          "args": [
            "prev_entry"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "entry_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "31-36",
          "snippet": "static u64 entry_end(struct btrfs_ordered_extent *entry)\n{\n\tif (entry->file_offset + entry->len < entry->file_offset)\n\t\treturn (u64)-1;\n\treturn entry->file_offset + entry->len;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic u64 entry_end(struct btrfs_ordered_extent *entry)\n{\n\tif (entry->file_offset + entry->len < entry->file_offset)\n\t\treturn (u64)-1;\n\treturn entry->file_offset + entry->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "prev",
            "structbtrfs_ordered_extent",
            "rb_node"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "test",
            "structbtrfs_ordered_extent",
            "rb_node"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "prev"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_ordered_extent",
            "rb_node"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct rb_node *__tree_search(struct rb_root *root, u64 file_offset,\n\t\t\t\t     struct rb_node **prev_ret)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *test;\n\tstruct btrfs_ordered_extent *entry;\n\tstruct btrfs_ordered_extent *prev_entry = NULL;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct btrfs_ordered_extent, rb_node);\n\t\tprev = n;\n\t\tprev_entry = entry;\n\n\t\tif (file_offset < entry->file_offset)\n\t\t\tn = n->rb_left;\n\t\telse if (file_offset >= entry_end(entry))\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\tif (!prev_ret)\n\t\treturn NULL;\n\n\twhile (prev && file_offset >= entry_end(prev_entry)) {\n\t\ttest = rb_next(prev);\n\t\tif (!test)\n\t\t\tbreak;\n\t\tprev_entry = rb_entry(test, struct btrfs_ordered_extent,\n\t\t\t\t      rb_node);\n\t\tif (file_offset < entry_end(prev_entry))\n\t\t\tbreak;\n\n\t\tprev = test;\n\t}\n\tif (prev)\n\t\tprev_entry = rb_entry(prev, struct btrfs_ordered_extent,\n\t\t\t\t      rb_node);\n\twhile (prev && file_offset < entry_end(prev_entry)) {\n\t\ttest = rb_prev(prev);\n\t\tif (!test)\n\t\t\tbreak;\n\t\tprev_entry = rb_entry(test, struct btrfs_ordered_extent,\n\t\t\t\t      rb_node);\n\t\tprev = test;\n\t}\n\t*prev_ret = prev;\n\treturn NULL;\n}"
  },
  {
    "function_name": "ordered_data_tree_panic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "65-71",
    "snippet": "static void ordered_data_tree_panic(struct inode *inode, int errno,\n\t\t\t\t\t       u64 offset)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tbtrfs_panic(fs_info, errno, \"Inconsistency in ordered tree at offset \"\n\t\t    \"%llu\", offset);\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_panic",
          "args": [
            "fs_info",
            "errno",
            "\"Inconsistency in ordered tree at offset \"\n\t\t    \"%llu\"",
            "offset"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_sb",
          "args": [
            "inode->i_sb"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3272-3275",
          "snippet": "static inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic void ordered_data_tree_panic(struct inode *inode, int errno,\n\t\t\t\t\t       u64 offset)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tbtrfs_panic(fs_info, errno, \"Inconsistency in ordered tree at offset \"\n\t\t    \"%llu\", offset);\n}"
  },
  {
    "function_name": "tree_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "41-63",
    "snippet": "static struct rb_node *tree_insert(struct rb_root *root, u64 file_offset,\n\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_ordered_extent *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct btrfs_ordered_extent, rb_node);\n\n\t\tif (file_offset < entry->file_offset)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (file_offset >= entry_end(entry))\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "node",
            "root"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "node",
            "parent",
            "p"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry_end",
          "args": [
            "entry"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "entry_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "31-36",
          "snippet": "static u64 entry_end(struct btrfs_ordered_extent *entry)\n{\n\tif (entry->file_offset + entry->len < entry->file_offset)\n\t\treturn (u64)-1;\n\treturn entry->file_offset + entry->len;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic u64 entry_end(struct btrfs_ordered_extent *entry)\n{\n\tif (entry->file_offset + entry->len < entry->file_offset)\n\t\treturn (u64)-1;\n\treturn entry->file_offset + entry->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structbtrfs_ordered_extent",
            "rb_node"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct rb_node *tree_insert(struct rb_root *root, u64 file_offset,\n\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_ordered_extent *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct btrfs_ordered_extent, rb_node);\n\n\t\tif (file_offset < entry->file_offset)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (file_offset >= entry_end(entry))\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}"
  },
  {
    "function_name": "entry_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
    "lines": "31-36",
    "snippet": "static u64 entry_end(struct btrfs_ordered_extent *entry)\n{\n\tif (entry->file_offset + entry->len < entry->file_offset)\n\t\treturn (u64)-1;\n\treturn entry->file_offset + entry->len;\n}",
    "includes": [
      "#include \"disk-io.h\"",
      "#include \"extent_io.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic u64 entry_end(struct btrfs_ordered_extent *entry)\n{\n\tif (entry->file_offset + entry->len < entry->file_offset)\n\t\treturn (u64)-1;\n\treturn entry->file_offset + entry->len;\n}"
  }
]