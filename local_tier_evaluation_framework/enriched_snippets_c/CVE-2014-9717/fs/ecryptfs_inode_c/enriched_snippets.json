[
  {
    "function_name": "ecryptfs_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "1082-1097",
    "snippet": "static int ecryptfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tint rc = 0;\n\tstruct dentry *lower_dentry;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tif (!lower_dentry->d_inode->i_op->removexattr) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tmutex_lock(&lower_dentry->d_inode->i_mutex);\n\trc = lower_dentry->d_inode->i_op->removexattr(lower_dentry, name);\n\tmutex_unlock(&lower_dentry->d_inode->i_mutex);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&lower_dentry->d_inode->i_mutex"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lower_dentry->d_inode->i_op->removexattr",
          "args": [
            "lower_dentry",
            "name"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "600-613",
          "snippet": "static long\nremovexattr(struct dentry *d, const char __user *name)\n{\n\tint error;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\treturn vfs_removexattr(d, kname);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic long\nremovexattr(struct dentry *d, const char __user *name)\n{\n\tint error;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\treturn vfs_removexattr(d, kname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&lower_dentry->d_inode->i_mutex"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower",
          "args": [
            "dentry"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tint rc = 0;\n\tstruct dentry *lower_dentry;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tif (!lower_dentry->d_inode->i_op->removexattr) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tmutex_lock(&lower_dentry->d_inode->i_mutex);\n\trc = lower_dentry->d_inode->i_op->removexattr(lower_dentry, name);\n\tmutex_unlock(&lower_dentry->d_inode->i_mutex);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "1064-1080",
    "snippet": "static ssize_t\necryptfs_listxattr(struct dentry *dentry, char *list, size_t size)\n{\n\tint rc = 0;\n\tstruct dentry *lower_dentry;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tif (!lower_dentry->d_inode->i_op->listxattr) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tmutex_lock(&lower_dentry->d_inode->i_mutex);\n\trc = lower_dentry->d_inode->i_op->listxattr(lower_dentry, list, size);\n\tmutex_unlock(&lower_dentry->d_inode->i_mutex);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&lower_dentry->d_inode->i_mutex"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lower_dentry->d_inode->i_op->listxattr",
          "args": [
            "lower_dentry",
            "list",
            "size"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "listxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "519-552",
          "snippet": "static ssize_t\nlistxattr(struct dentry *d, char __user *list, size_t size)\n{\n\tssize_t error;\n\tchar *klist = NULL;\n\tchar *vlist = NULL;\t/* If non-NULL, we used vmalloc() */\n\n\tif (size) {\n\t\tif (size > XATTR_LIST_MAX)\n\t\t\tsize = XATTR_LIST_MAX;\n\t\tklist = kmalloc(size, __GFP_NOWARN | GFP_KERNEL);\n\t\tif (!klist) {\n\t\t\tvlist = vmalloc(size);\n\t\t\tif (!vlist)\n\t\t\t\treturn -ENOMEM;\n\t\t\tklist = vlist;\n\t\t}\n\t}\n\n\terror = vfs_listxattr(d, klist, size);\n\tif (error > 0) {\n\t\tif (size && copy_to_user(list, klist, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_LIST_MAX) {\n\t\t/* The file system tried to returned a list bigger\n\t\t   than XATTR_LIST_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\tif (vlist)\n\t\tvfree(vlist);\n\telse\n\t\tkfree(klist);\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t\nlistxattr(struct dentry *d, char __user *list, size_t size)\n{\n\tssize_t error;\n\tchar *klist = NULL;\n\tchar *vlist = NULL;\t/* If non-NULL, we used vmalloc() */\n\n\tif (size) {\n\t\tif (size > XATTR_LIST_MAX)\n\t\t\tsize = XATTR_LIST_MAX;\n\t\tklist = kmalloc(size, __GFP_NOWARN | GFP_KERNEL);\n\t\tif (!klist) {\n\t\t\tvlist = vmalloc(size);\n\t\t\tif (!vlist)\n\t\t\t\treturn -ENOMEM;\n\t\t\tklist = vlist;\n\t\t}\n\t}\n\n\terror = vfs_listxattr(d, klist, size);\n\tif (error > 0) {\n\t\tif (size && copy_to_user(list, klist, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_LIST_MAX) {\n\t\t/* The file system tried to returned a list bigger\n\t\t   than XATTR_LIST_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\tif (vlist)\n\t\tvfree(vlist);\n\telse\n\t\tkfree(klist);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&lower_dentry->d_inode->i_mutex"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower",
          "args": [
            "dentry"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic ssize_t\necryptfs_listxattr(struct dentry *dentry, char *list, size_t size)\n{\n\tint rc = 0;\n\tstruct dentry *lower_dentry;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tif (!lower_dentry->d_inode->i_op->listxattr) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tmutex_lock(&lower_dentry->d_inode->i_mutex);\n\trc = lower_dentry->d_inode->i_op->listxattr(lower_dentry, list, size);\n\tmutex_unlock(&lower_dentry->d_inode->i_mutex);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "1056-1062",
    "snippet": "static ssize_t\necryptfs_getxattr(struct dentry *dentry, const char *name, void *value,\n\t\t  size_t size)\n{\n\treturn ecryptfs_getxattr_lower(ecryptfs_dentry_to_lower(dentry), name,\n\t\t\t\t       value, size);\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_getxattr_lower",
          "args": [
            "ecryptfs_dentry_to_lower(dentry)",
            "name",
            "value",
            "size"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_getxattr_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "1038-1054",
          "snippet": "ssize_t\necryptfs_getxattr_lower(struct dentry *lower_dentry, const char *name,\n\t\t\tvoid *value, size_t size)\n{\n\tint rc = 0;\n\n\tif (!lower_dentry->d_inode->i_op->getxattr) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tmutex_lock(&lower_dentry->d_inode->i_mutex);\n\trc = lower_dentry->d_inode->i_op->getxattr(lower_dentry, name, value,\n\t\t\t\t\t\t   size);\n\tmutex_unlock(&lower_dentry->d_inode->i_mutex);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nssize_t\necryptfs_getxattr_lower(struct dentry *lower_dentry, const char *name,\n\t\t\tvoid *value, size_t size)\n{\n\tint rc = 0;\n\n\tif (!lower_dentry->d_inode->i_op->getxattr) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tmutex_lock(&lower_dentry->d_inode->i_mutex);\n\trc = lower_dentry->d_inode->i_op->getxattr(lower_dentry, name, value,\n\t\t\t\t\t\t   size);\n\tmutex_unlock(&lower_dentry->d_inode->i_mutex);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower",
          "args": [
            "dentry"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic ssize_t\necryptfs_getxattr(struct dentry *dentry, const char *name, void *value,\n\t\t  size_t size)\n{\n\treturn ecryptfs_getxattr_lower(ecryptfs_dentry_to_lower(dentry), name,\n\t\t\t\t       value, size);\n}"
  },
  {
    "function_name": "ecryptfs_getxattr_lower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "1038-1054",
    "snippet": "ssize_t\necryptfs_getxattr_lower(struct dentry *lower_dentry, const char *name,\n\t\t\tvoid *value, size_t size)\n{\n\tint rc = 0;\n\n\tif (!lower_dentry->d_inode->i_op->getxattr) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tmutex_lock(&lower_dentry->d_inode->i_mutex);\n\trc = lower_dentry->d_inode->i_op->getxattr(lower_dentry, name, value,\n\t\t\t\t\t\t   size);\n\tmutex_unlock(&lower_dentry->d_inode->i_mutex);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&lower_dentry->d_inode->i_mutex"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lower_dentry->d_inode->i_op->getxattr",
          "args": [
            "lower_dentry",
            "name",
            "value",
            "size"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "425-469",
          "snippet": "static ssize_t\ngetxattr(struct dentry *d, const char __user *name, void __user *value,\n\t size_t size)\n{\n\tssize_t error;\n\tvoid *kvalue = NULL;\n\tvoid *vvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\tsize = XATTR_SIZE_MAX;\n\t\tkvalue = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!kvalue) {\n\t\t\tvvalue = vmalloc(size);\n\t\t\tif (!vvalue)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkvalue = vvalue;\n\t\t}\n\t}\n\n\terror = vfs_getxattr(d, kname, kvalue, size);\n\tif (error > 0) {\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_to_user(kvalue, size);\n\t\tif (size && copy_to_user(value, kvalue, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_SIZE_MAX) {\n\t\t/* The file system tried to returned a value bigger\n\t\t   than XATTR_SIZE_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\tif (vvalue)\n\t\tvfree(vvalue);\n\telse\n\t\tkfree(kvalue);\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t\ngetxattr(struct dentry *d, const char __user *name, void __user *value,\n\t size_t size)\n{\n\tssize_t error;\n\tvoid *kvalue = NULL;\n\tvoid *vvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\tsize = XATTR_SIZE_MAX;\n\t\tkvalue = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!kvalue) {\n\t\t\tvvalue = vmalloc(size);\n\t\t\tif (!vvalue)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkvalue = vvalue;\n\t\t}\n\t}\n\n\terror = vfs_getxattr(d, kname, kvalue, size);\n\tif (error > 0) {\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_to_user(kvalue, size);\n\t\tif (size && copy_to_user(value, kvalue, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_SIZE_MAX) {\n\t\t/* The file system tried to returned a value bigger\n\t\t   than XATTR_SIZE_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\tif (vvalue)\n\t\tvfree(vvalue);\n\telse\n\t\tkfree(kvalue);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&lower_dentry->d_inode->i_mutex"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nssize_t\necryptfs_getxattr_lower(struct dentry *lower_dentry, const char *name,\n\t\t\tvoid *value, size_t size)\n{\n\tint rc = 0;\n\n\tif (!lower_dentry->d_inode->i_op->getxattr) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tmutex_lock(&lower_dentry->d_inode->i_mutex);\n\trc = lower_dentry->d_inode->i_op->getxattr(lower_dentry, name, value,\n\t\t\t\t\t\t   size);\n\tmutex_unlock(&lower_dentry->d_inode->i_mutex);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "1018-1036",
    "snippet": "int\necryptfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\t  size_t size, int flags)\n{\n\tint rc = 0;\n\tstruct dentry *lower_dentry;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tif (!lower_dentry->d_inode->i_op->setxattr) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\trc = vfs_setxattr(lower_dentry, name, value, size, flags);\n\tif (!rc && dentry->d_inode)\n\t\tfsstack_copy_attr_all(dentry->d_inode, lower_dentry->d_inode);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsstack_copy_attr_all",
          "args": [
            "dentry->d_inode",
            "lower_dentry->d_inode"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "fsstack_copy_attr_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stack.c",
          "lines": "63-75",
          "snippet": "void fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\n\tdest->i_mode = src->i_mode;\n\tdest->i_uid = src->i_uid;\n\tdest->i_gid = src->i_gid;\n\tdest->i_rdev = src->i_rdev;\n\tdest->i_atime = src->i_atime;\n\tdest->i_mtime = src->i_mtime;\n\tdest->i_ctime = src->i_ctime;\n\tdest->i_blkbits = src->i_blkbits;\n\tdest->i_flags = src->i_flags;\n\tset_nlink(dest, src->i_nlink);\n}",
          "includes": [
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\n\tdest->i_mode = src->i_mode;\n\tdest->i_uid = src->i_uid;\n\tdest->i_gid = src->i_gid;\n\tdest->i_rdev = src->i_rdev;\n\tdest->i_atime = src->i_atime;\n\tdest->i_mtime = src->i_mtime;\n\tdest->i_ctime = src->i_ctime;\n\tdest->i_blkbits = src->i_blkbits;\n\tdest->i_flags = src->i_flags;\n\tset_nlink(dest, src->i_nlink);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_setxattr",
          "args": [
            "lower_dentry",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "121-142",
          "snippet": "int\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower",
          "args": [
            "dentry"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nint\necryptfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\t  size_t size, int flags)\n{\n\tint rc = 0;\n\tstruct dentry *lower_dentry;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tif (!lower_dentry->d_inode->i_op->setxattr) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\trc = vfs_setxattr(lower_dentry, name, value, size, flags);\n\tif (!rc && dentry->d_inode)\n\t\tfsstack_copy_attr_all(dentry->d_inode, lower_dentry->d_inode);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "1002-1016",
    "snippet": "static int ecryptfs_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t\t    struct kstat *stat)\n{\n\tstruct kstat lower_stat;\n\tint rc;\n\n\trc = vfs_getattr(ecryptfs_dentry_to_lower_path(dentry), &lower_stat);\n\tif (!rc) {\n\t\tfsstack_copy_attr_all(dentry->d_inode,\n\t\t\t\t      ecryptfs_inode_to_lower(dentry->d_inode));\n\t\tgeneric_fillattr(dentry->d_inode, stat);\n\t\tstat->blocks = lower_stat.blocks;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "dentry->d_inode",
            "stat"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsstack_copy_attr_all",
          "args": [
            "dentry->d_inode",
            "ecryptfs_inode_to_lower(dentry->d_inode)"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "fsstack_copy_attr_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stack.c",
          "lines": "63-75",
          "snippet": "void fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\n\tdest->i_mode = src->i_mode;\n\tdest->i_uid = src->i_uid;\n\tdest->i_gid = src->i_gid;\n\tdest->i_rdev = src->i_rdev;\n\tdest->i_atime = src->i_atime;\n\tdest->i_mtime = src->i_mtime;\n\tdest->i_ctime = src->i_ctime;\n\tdest->i_blkbits = src->i_blkbits;\n\tdest->i_flags = src->i_flags;\n\tset_nlink(dest, src->i_nlink);\n}",
          "includes": [
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\n\tdest->i_mode = src->i_mode;\n\tdest->i_uid = src->i_uid;\n\tdest->i_gid = src->i_gid;\n\tdest->i_rdev = src->i_rdev;\n\tdest->i_atime = src->i_atime;\n\tdest->i_mtime = src->i_mtime;\n\tdest->i_ctime = src->i_ctime;\n\tdest->i_blkbits = src->i_blkbits;\n\tdest->i_flags = src->i_flags;\n\tset_nlink(dest, src->i_nlink);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_lower",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "462-465",
          "snippet": "static inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_getattr",
          "args": [
            "ecryptfs_dentry_to_lower_path(dentry)",
            "&lower_stat"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "65-73",
          "snippet": "int vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint retval;\n\n\tretval = security_inode_getattr(path->mnt, path->dentry);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nint vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint retval;\n\n\tretval = security_inode_getattr(path->mnt, path->dentry);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower_path",
          "args": [
            "dentry"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t\t    struct kstat *stat)\n{\n\tstruct kstat lower_stat;\n\tint rc;\n\n\trc = vfs_getattr(ecryptfs_dentry_to_lower_path(dentry), &lower_stat);\n\tif (!rc) {\n\t\tfsstack_copy_attr_all(dentry->d_inode,\n\t\t\t\t      ecryptfs_inode_to_lower(dentry->d_inode));\n\t\tgeneric_fillattr(dentry->d_inode, stat);\n\t\tstat->blocks = lower_stat.blocks;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_getattr_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "978-1000",
    "snippet": "static int ecryptfs_getattr_link(struct vfsmount *mnt, struct dentry *dentry,\n\t\t\t\t struct kstat *stat)\n{\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tint rc = 0;\n\n\tmount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\t\t\t\t\tdentry->d_sb)->mount_crypt_stat;\n\tgeneric_fillattr(dentry->d_inode, stat);\n\tif (mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) {\n\t\tchar *target;\n\t\tsize_t targetsiz;\n\n\t\ttarget = ecryptfs_readlink_lower(dentry, &targetsiz);\n\t\tif (!IS_ERR(target)) {\n\t\t\tkfree(target);\n\t\t\tstat->size = targetsiz;\n\t\t} else {\n\t\t\trc = PTR_ERR(target);\n\t\t}\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "target"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "target"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "target"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_readlink_lower",
          "args": [
            "dentry",
            "&targetsiz"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_readlink_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "652-676",
          "snippet": "static char *ecryptfs_readlink_lower(struct dentry *dentry, size_t *bufsiz)\n{\n\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tchar *lower_buf;\n\tchar *buf;\n\tmm_segment_t old_fs;\n\tint rc;\n\n\tlower_buf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!lower_buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\trc = lower_dentry->d_inode->i_op->readlink(lower_dentry,\n\t\t\t\t\t\t   (char __user *)lower_buf,\n\t\t\t\t\t\t   PATH_MAX);\n\tset_fs(old_fs);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = ecryptfs_decode_and_decrypt_filename(&buf, bufsiz, dentry->d_sb,\n\t\t\t\t\t\t  lower_buf, rc);\nout:\n\tkfree(lower_buf);\n\treturn rc ? ERR_PTR(rc) : buf;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic char *ecryptfs_readlink_lower(struct dentry *dentry, size_t *bufsiz)\n{\n\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tchar *lower_buf;\n\tchar *buf;\n\tmm_segment_t old_fs;\n\tint rc;\n\n\tlower_buf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!lower_buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\trc = lower_dentry->d_inode->i_op->readlink(lower_dentry,\n\t\t\t\t\t\t   (char __user *)lower_buf,\n\t\t\t\t\t\t   PATH_MAX);\n\tset_fs(old_fs);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = ecryptfs_decode_and_decrypt_filename(&buf, bufsiz, dentry->d_sb,\n\t\t\t\t\t\t  lower_buf, rc);\nout:\n\tkfree(lower_buf);\n\treturn rc ? ERR_PTR(rc) : buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "dentry->d_inode",
            "stat"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_superblock_to_private",
          "args": [
            "dentry->d_sb"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_superblock_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "473-477",
          "snippet": "static inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_getattr_link(struct vfsmount *mnt, struct dentry *dentry,\n\t\t\t\t struct kstat *stat)\n{\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tint rc = 0;\n\n\tmount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\t\t\t\t\tdentry->d_sb)->mount_crypt_stat;\n\tgeneric_fillattr(dentry->d_inode, stat);\n\tif (mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) {\n\t\tchar *target;\n\t\tsize_t targetsiz;\n\n\t\ttarget = ecryptfs_readlink_lower(dentry, &targetsiz);\n\t\tif (!IS_ERR(target)) {\n\t\t\tkfree(target);\n\t\t\tstat->size = targetsiz;\n\t\t} else {\n\t\t\trc = PTR_ERR(target);\n\t\t}\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "894-976",
    "snippet": "static int ecryptfs_setattr(struct dentry *dentry, struct iattr *ia)\n{\n\tint rc = 0;\n\tstruct dentry *lower_dentry;\n\tstruct iattr lower_ia;\n\tstruct inode *inode;\n\tstruct inode *lower_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(dentry->d_inode)->crypt_stat;\n\tif (!(crypt_stat->flags & ECRYPTFS_STRUCT_INITIALIZED))\n\t\tecryptfs_init_crypt_stat(crypt_stat);\n\tinode = dentry->d_inode;\n\tlower_inode = ecryptfs_inode_to_lower(inode);\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tmutex_lock(&crypt_stat->cs_mutex);\n\tif (d_is_dir(dentry))\n\t\tcrypt_stat->flags &= ~(ECRYPTFS_ENCRYPTED);\n\telse if (d_is_reg(dentry)\n\t\t && (!(crypt_stat->flags & ECRYPTFS_POLICY_APPLIED)\n\t\t     || !(crypt_stat->flags & ECRYPTFS_KEY_VALID))) {\n\t\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\n\t\tmount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\t\tdentry->d_sb)->mount_crypt_stat;\n\t\trc = ecryptfs_get_lower_file(dentry, inode);\n\t\tif (rc) {\n\t\t\tmutex_unlock(&crypt_stat->cs_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\trc = ecryptfs_read_metadata(dentry);\n\t\tecryptfs_put_lower_file(inode);\n\t\tif (rc) {\n\t\t\tif (!(mount_crypt_stat->flags\n\t\t\t      & ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED)) {\n\t\t\t\trc = -EIO;\n\t\t\t\tprintk(KERN_WARNING \"Either the lower file \"\n\t\t\t\t       \"is not in a valid eCryptfs format, \"\n\t\t\t\t       \"or the key could not be retrieved. \"\n\t\t\t\t       \"Plaintext passthrough mode is not \"\n\t\t\t\t       \"enabled; returning -EIO\\n\");\n\t\t\t\tmutex_unlock(&crypt_stat->cs_mutex);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trc = 0;\n\t\t\tcrypt_stat->flags &= ~(ECRYPTFS_I_SIZE_INITIALIZED\n\t\t\t\t\t       | ECRYPTFS_ENCRYPTED);\n\t\t}\n\t}\n\tmutex_unlock(&crypt_stat->cs_mutex);\n\n\trc = inode_change_ok(inode, ia);\n\tif (rc)\n\t\tgoto out;\n\tif (ia->ia_valid & ATTR_SIZE) {\n\t\trc = ecryptfs_inode_newsize_ok(inode, ia->ia_size);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tmemcpy(&lower_ia, ia, sizeof(lower_ia));\n\tif (ia->ia_valid & ATTR_FILE)\n\t\tlower_ia.ia_file = ecryptfs_file_to_lower(ia->ia_file);\n\tif (ia->ia_valid & ATTR_SIZE) {\n\t\trc = truncate_upper(dentry, ia, &lower_ia);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * mode change is for clearing setuid/setgid bits. Allow lower fs\n\t * to interpret this in its own way.\n\t */\n\tif (lower_ia.ia_valid & (ATTR_KILL_SUID | ATTR_KILL_SGID))\n\t\tlower_ia.ia_valid &= ~ATTR_MODE;\n\n\tmutex_lock(&lower_dentry->d_inode->i_mutex);\n\trc = notify_change(lower_dentry, &lower_ia, NULL);\n\tmutex_unlock(&lower_dentry->d_inode->i_mutex);\nout:\n\tfsstack_copy_attr_all(inode, lower_inode);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsstack_copy_attr_all",
          "args": [
            "inode",
            "lower_inode"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "fsstack_copy_attr_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stack.c",
          "lines": "63-75",
          "snippet": "void fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\n\tdest->i_mode = src->i_mode;\n\tdest->i_uid = src->i_uid;\n\tdest->i_gid = src->i_gid;\n\tdest->i_rdev = src->i_rdev;\n\tdest->i_atime = src->i_atime;\n\tdest->i_mtime = src->i_mtime;\n\tdest->i_ctime = src->i_ctime;\n\tdest->i_blkbits = src->i_blkbits;\n\tdest->i_flags = src->i_flags;\n\tset_nlink(dest, src->i_nlink);\n}",
          "includes": [
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\n\tdest->i_mode = src->i_mode;\n\tdest->i_uid = src->i_uid;\n\tdest->i_gid = src->i_gid;\n\tdest->i_rdev = src->i_rdev;\n\tdest->i_atime = src->i_atime;\n\tdest->i_mtime = src->i_mtime;\n\tdest->i_ctime = src->i_ctime;\n\tdest->i_blkbits = src->i_blkbits;\n\tdest->i_flags = src->i_flags;\n\tset_nlink(dest, src->i_nlink);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&lower_dentry->d_inode->i_mutex"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "lower_dentry",
            "&lower_ia",
            "NULL"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "190-277",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&lower_dentry->d_inode->i_mutex"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_upper",
          "args": [
            "dentry",
            "ia",
            "&lower_ia"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "737-821",
          "snippet": "static int truncate_upper(struct dentry *dentry, struct iattr *ia,\n\t\t\t  struct iattr *lower_ia)\n{\n\tint rc = 0;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t i_size = i_size_read(inode);\n\tloff_t lower_size_before_truncate;\n\tloff_t lower_size_after_truncate;\n\n\tif (unlikely((ia->ia_size == i_size))) {\n\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t\treturn 0;\n\t}\n\trc = ecryptfs_get_lower_file(dentry, inode);\n\tif (rc)\n\t\treturn rc;\n\tcrypt_stat = &ecryptfs_inode_to_private(dentry->d_inode)->crypt_stat;\n\t/* Switch on growing or shrinking file */\n\tif (ia->ia_size > i_size) {\n\t\tchar zero[] = { 0x00 };\n\n\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t\t/* Write a single 0 at the last position of the file;\n\t\t * this triggers code that will fill in 0's throughout\n\t\t * the intermediate portion of the previous end of the\n\t\t * file and the new and of the file */\n\t\trc = ecryptfs_write(inode, zero,\n\t\t\t\t    (ia->ia_size - 1), 1);\n\t} else { /* ia->ia_size < i_size_read(inode) */\n\t\t/* We're chopping off all the pages down to the page\n\t\t * in which ia->ia_size is located. Fill in the end of\n\t\t * that page from (ia->ia_size & ~PAGE_CACHE_MASK) to\n\t\t * PAGE_CACHE_SIZE with zeros. */\n\t\tsize_t num_zeros = (PAGE_CACHE_SIZE\n\t\t\t\t    - (ia->ia_size & ~PAGE_CACHE_MASK));\n\n\t\tif (!(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\t\ttruncate_setsize(inode, ia->ia_size);\n\t\t\tlower_ia->ia_size = ia->ia_size;\n\t\t\tlower_ia->ia_valid |= ATTR_SIZE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (num_zeros) {\n\t\t\tchar *zeros_virt;\n\n\t\t\tzeros_virt = kzalloc(num_zeros, GFP_KERNEL);\n\t\t\tif (!zeros_virt) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trc = ecryptfs_write(inode, zeros_virt,\n\t\t\t\t\t    ia->ia_size, num_zeros);\n\t\t\tkfree(zeros_virt);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to zero out \"\n\t\t\t\t       \"the remainder of the end page on \"\n\t\t\t\t       \"reducing truncate; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\ttruncate_setsize(inode, ia->ia_size);\n\t\trc = ecryptfs_write_inode_size_to_metadata(inode);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR\t\"Problem with \"\n\t\t\t       \"ecryptfs_write_inode_size_to_metadata; \"\n\t\t\t       \"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t\t/* We are reducing the size of the ecryptfs file, and need to\n\t\t * know if we need to reduce the size of the lower file. */\n\t\tlower_size_before_truncate =\n\t\t    upper_size_to_lower_size(crypt_stat, i_size);\n\t\tlower_size_after_truncate =\n\t\t    upper_size_to_lower_size(crypt_stat, ia->ia_size);\n\t\tif (lower_size_after_truncate < lower_size_before_truncate) {\n\t\t\tlower_ia->ia_size = lower_size_after_truncate;\n\t\t\tlower_ia->ia_valid |= ATTR_SIZE;\n\t\t} else\n\t\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t}\nout:\n\tecryptfs_put_lower_file(inode);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int truncate_upper(struct dentry *dentry, struct iattr *ia,\n\t\t\t  struct iattr *lower_ia)\n{\n\tint rc = 0;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t i_size = i_size_read(inode);\n\tloff_t lower_size_before_truncate;\n\tloff_t lower_size_after_truncate;\n\n\tif (unlikely((ia->ia_size == i_size))) {\n\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t\treturn 0;\n\t}\n\trc = ecryptfs_get_lower_file(dentry, inode);\n\tif (rc)\n\t\treturn rc;\n\tcrypt_stat = &ecryptfs_inode_to_private(dentry->d_inode)->crypt_stat;\n\t/* Switch on growing or shrinking file */\n\tif (ia->ia_size > i_size) {\n\t\tchar zero[] = { 0x00 };\n\n\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t\t/* Write a single 0 at the last position of the file;\n\t\t * this triggers code that will fill in 0's throughout\n\t\t * the intermediate portion of the previous end of the\n\t\t * file and the new and of the file */\n\t\trc = ecryptfs_write(inode, zero,\n\t\t\t\t    (ia->ia_size - 1), 1);\n\t} else { /* ia->ia_size < i_size_read(inode) */\n\t\t/* We're chopping off all the pages down to the page\n\t\t * in which ia->ia_size is located. Fill in the end of\n\t\t * that page from (ia->ia_size & ~PAGE_CACHE_MASK) to\n\t\t * PAGE_CACHE_SIZE with zeros. */\n\t\tsize_t num_zeros = (PAGE_CACHE_SIZE\n\t\t\t\t    - (ia->ia_size & ~PAGE_CACHE_MASK));\n\n\t\tif (!(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\t\ttruncate_setsize(inode, ia->ia_size);\n\t\t\tlower_ia->ia_size = ia->ia_size;\n\t\t\tlower_ia->ia_valid |= ATTR_SIZE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (num_zeros) {\n\t\t\tchar *zeros_virt;\n\n\t\t\tzeros_virt = kzalloc(num_zeros, GFP_KERNEL);\n\t\t\tif (!zeros_virt) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trc = ecryptfs_write(inode, zeros_virt,\n\t\t\t\t\t    ia->ia_size, num_zeros);\n\t\t\tkfree(zeros_virt);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to zero out \"\n\t\t\t\t       \"the remainder of the end page on \"\n\t\t\t\t       \"reducing truncate; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\ttruncate_setsize(inode, ia->ia_size);\n\t\trc = ecryptfs_write_inode_size_to_metadata(inode);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR\t\"Problem with \"\n\t\t\t       \"ecryptfs_write_inode_size_to_metadata; \"\n\t\t\t       \"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t\t/* We are reducing the size of the ecryptfs file, and need to\n\t\t * know if we need to reduce the size of the lower file. */\n\t\tlower_size_before_truncate =\n\t\t    upper_size_to_lower_size(crypt_stat, i_size);\n\t\tlower_size_after_truncate =\n\t\t    upper_size_to_lower_size(crypt_stat, ia->ia_size);\n\t\tif (lower_size_after_truncate < lower_size_before_truncate) {\n\t\t\tlower_ia->ia_size = lower_size_after_truncate;\n\t\t\tlower_ia->ia_valid |= ATTR_SIZE;\n\t\t} else\n\t\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t}\nout:\n\tecryptfs_put_lower_file(inode);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_file_to_lower",
          "args": [
            "ia->ia_file"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_file_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "444-447",
          "snippet": "static inline struct file *ecryptfs_file_to_lower(struct file *file)\n{\n\treturn ((struct ecryptfs_file_info *)file->private_data)->wfi_file;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct file *ecryptfs_file_to_lower(struct file *file)\n{\n\treturn ((struct ecryptfs_file_info *)file->private_data)->wfi_file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lower_ia",
            "ia",
            "sizeof(lower_ia)"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_newsize_ok",
          "args": [
            "inode",
            "ia->ia_size"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "823-843",
          "snippet": "static int ecryptfs_inode_newsize_ok(struct inode *inode, loff_t offset)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t lower_oldsize, lower_newsize;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tlower_oldsize = upper_size_to_lower_size(crypt_stat,\n\t\t\t\t\t\t i_size_read(inode));\n\tlower_newsize = upper_size_to_lower_size(crypt_stat, offset);\n\tif (lower_newsize > lower_oldsize) {\n\t\t/*\n\t\t * The eCryptfs inode and the new *lower* size are mixed here\n\t\t * because we may not have the lower i_mutex held and/or it may\n\t\t * not be appropriate to call inode_newsize_ok() with inodes\n\t\t * from other filesystems.\n\t\t */\n\t\treturn inode_newsize_ok(inode, lower_newsize);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_inode_newsize_ok(struct inode *inode, loff_t offset)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t lower_oldsize, lower_newsize;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tlower_oldsize = upper_size_to_lower_size(crypt_stat,\n\t\t\t\t\t\t i_size_read(inode));\n\tlower_newsize = upper_size_to_lower_size(crypt_stat, offset);\n\tif (lower_newsize > lower_oldsize) {\n\t\t/*\n\t\t * The eCryptfs inode and the new *lower* size are mixed here\n\t\t * because we may not have the lower i_mutex held and/or it may\n\t\t * not be appropriate to call inode_newsize_ok() with inodes\n\t\t * from other filesystems.\n\t\t */\n\t\treturn inode_newsize_ok(inode, lower_newsize);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "ia"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&crypt_stat->cs_mutex"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&crypt_stat->cs_mutex"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Either the lower file \"\n\t\t\t\t       \"is not in a valid eCryptfs format, \"\n\t\t\t\t       \"or the key could not be retrieved. \"\n\t\t\t\t       \"Plaintext passthrough mode is not \"\n\t\t\t\t       \"enabled; returning -EIO\\n\""
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_put_lower_file",
          "args": [
            "inode"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_put_lower_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "157-169",
          "snippet": "void ecryptfs_put_lower_file(struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tif (atomic_dec_and_mutex_lock(&inode_info->lower_file_count,\n\t\t\t\t      &inode_info->lower_file_mutex)) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tfput(inode_info->lower_file);\n\t\tinode_info->lower_file = NULL;\n\t\tmutex_unlock(&inode_info->lower_file_mutex);\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nvoid ecryptfs_put_lower_file(struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tif (atomic_dec_and_mutex_lock(&inode_info->lower_file_count,\n\t\t\t\t      &inode_info->lower_file_mutex)) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tfput(inode_info->lower_file);\n\t\tinode_info->lower_file = NULL;\n\t\tmutex_unlock(&inode_info->lower_file_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_read_metadata",
          "args": [
            "dentry"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_read_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1424-1490",
          "snippet": "int ecryptfs_read_metadata(struct dentry *ecryptfs_dentry)\n{\n\tint rc;\n\tchar *page_virt;\n\tstruct inode *ecryptfs_inode = ecryptfs_dentry->d_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t    &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(\n\t\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\t/* Read the first page from the underlying file */\n\tpage_virt = kmem_cache_alloc(ecryptfs_header_cache, GFP_USER);\n\tif (!page_virt) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: Unable to allocate page_virt\\n\",\n\t\t       __func__);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_read_lower(page_virt, 0, crypt_stat->extent_size,\n\t\t\t\t ecryptfs_inode);\n\tif (rc >= 0)\n\t\trc = ecryptfs_read_headers_virt(page_virt, crypt_stat,\n\t\t\t\t\t\tecryptfs_dentry,\n\t\t\t\t\t\tECRYPTFS_VALIDATE_HEADER_SIZE);\n\tif (rc) {\n\t\t/* metadata is not in the file header, so try xattrs */\n\t\tmemset(page_virt, 0, PAGE_CACHE_SIZE);\n\t\trc = ecryptfs_read_xattr_region(page_virt, ecryptfs_inode);\n\t\tif (rc) {\n\t\t\tprintk(KERN_DEBUG \"Valid eCryptfs headers not found in \"\n\t\t\t       \"file header region or xattr region, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\trc = ecryptfs_read_headers_virt(page_virt, crypt_stat,\n\t\t\t\t\t\tecryptfs_dentry,\n\t\t\t\t\t\tECRYPTFS_DONT_VALIDATE_HEADER_SIZE);\n\t\tif (rc) {\n\t\t\tprintk(KERN_DEBUG \"Valid eCryptfs headers not found in \"\n\t\t\t       \"file xattr region either, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t}\n\t\tif (crypt_stat->mount_crypt_stat->flags\n\t\t    & ECRYPTFS_XATTR_METADATA_ENABLED) {\n\t\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"Attempt to access file with \"\n\t\t\t       \"crypto metadata only in the extended attribute \"\n\t\t\t       \"region, but eCryptfs was mounted without \"\n\t\t\t       \"xattr support enabled. eCryptfs will not treat \"\n\t\t\t       \"this like an encrypted file, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t}\n\t}\nout:\n\tif (page_virt) {\n\t\tmemset(page_virt, 0, PAGE_CACHE_SIZE);\n\t\tkmem_cache_free(ecryptfs_header_cache, page_virt);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ECRYPTFS_VALIDATE_HEADER_SIZE 1",
            "#define ECRYPTFS_DONT_VALIDATE_HEADER_SIZE 0"
          ],
          "globals_used": [
            "struct kmem_cache *ecryptfs_header_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\n#define ECRYPTFS_VALIDATE_HEADER_SIZE 1\n#define ECRYPTFS_DONT_VALIDATE_HEADER_SIZE 0\n\nstruct kmem_cache *ecryptfs_header_cache;\n\nint ecryptfs_read_metadata(struct dentry *ecryptfs_dentry)\n{\n\tint rc;\n\tchar *page_virt;\n\tstruct inode *ecryptfs_inode = ecryptfs_dentry->d_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t    &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(\n\t\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\t/* Read the first page from the underlying file */\n\tpage_virt = kmem_cache_alloc(ecryptfs_header_cache, GFP_USER);\n\tif (!page_virt) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: Unable to allocate page_virt\\n\",\n\t\t       __func__);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_read_lower(page_virt, 0, crypt_stat->extent_size,\n\t\t\t\t ecryptfs_inode);\n\tif (rc >= 0)\n\t\trc = ecryptfs_read_headers_virt(page_virt, crypt_stat,\n\t\t\t\t\t\tecryptfs_dentry,\n\t\t\t\t\t\tECRYPTFS_VALIDATE_HEADER_SIZE);\n\tif (rc) {\n\t\t/* metadata is not in the file header, so try xattrs */\n\t\tmemset(page_virt, 0, PAGE_CACHE_SIZE);\n\t\trc = ecryptfs_read_xattr_region(page_virt, ecryptfs_inode);\n\t\tif (rc) {\n\t\t\tprintk(KERN_DEBUG \"Valid eCryptfs headers not found in \"\n\t\t\t       \"file header region or xattr region, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\trc = ecryptfs_read_headers_virt(page_virt, crypt_stat,\n\t\t\t\t\t\tecryptfs_dentry,\n\t\t\t\t\t\tECRYPTFS_DONT_VALIDATE_HEADER_SIZE);\n\t\tif (rc) {\n\t\t\tprintk(KERN_DEBUG \"Valid eCryptfs headers not found in \"\n\t\t\t       \"file xattr region either, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t}\n\t\tif (crypt_stat->mount_crypt_stat->flags\n\t\t    & ECRYPTFS_XATTR_METADATA_ENABLED) {\n\t\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"Attempt to access file with \"\n\t\t\t       \"crypto metadata only in the extended attribute \"\n\t\t\t       \"region, but eCryptfs was mounted without \"\n\t\t\t       \"xattr support enabled. eCryptfs will not treat \"\n\t\t\t       \"this like an encrypted file, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t}\n\t}\nout:\n\tif (page_virt) {\n\t\tmemset(page_virt, 0, PAGE_CACHE_SIZE);\n\t\tkmem_cache_free(ecryptfs_header_cache, page_virt);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&crypt_stat->cs_mutex"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_lower_file",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_lower_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "137-155",
          "snippet": "int ecryptfs_get_lower_file(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\tint count, rc = 0;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tmutex_lock(&inode_info->lower_file_mutex);\n\tcount = atomic_inc_return(&inode_info->lower_file_count);\n\tif (WARN_ON_ONCE(count < 1))\n\t\trc = -EINVAL;\n\telse if (count == 1) {\n\t\trc = ecryptfs_init_lower_file(dentry,\n\t\t\t\t\t      &inode_info->lower_file);\n\t\tif (rc)\n\t\t\tatomic_set(&inode_info->lower_file_count, 0);\n\t}\n\tmutex_unlock(&inode_info->lower_file_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_get_lower_file(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\tint count, rc = 0;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tmutex_lock(&inode_info->lower_file_mutex);\n\tcount = atomic_inc_return(&inode_info->lower_file_count);\n\tif (WARN_ON_ONCE(count < 1))\n\t\trc = -EINVAL;\n\telse if (count == 1) {\n\t\trc = ecryptfs_init_lower_file(dentry,\n\t\t\t\t\t      &inode_info->lower_file);\n\t\tif (rc)\n\t\t\tatomic_set(&inode_info->lower_file_count, 0);\n\t}\n\tmutex_unlock(&inode_info->lower_file_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_superblock_to_private",
          "args": [
            "dentry->d_sb"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_superblock_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "473-477",
          "snippet": "static inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_reg",
          "args": [
            "dentry"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "dentry"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&crypt_stat->cs_mutex"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower",
          "args": [
            "dentry"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_lower",
          "args": [
            "inode"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "462-465",
          "snippet": "static inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_init_crypt_stat",
          "args": [
            "crypt_stat"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_init_crypt_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "215-225",
          "snippet": "void\necryptfs_init_crypt_stat(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tmemset((void *)crypt_stat, 0, sizeof(struct ecryptfs_crypt_stat));\n\tINIT_LIST_HEAD(&crypt_stat->keysig_list);\n\tmutex_init(&crypt_stat->keysig_list_mutex);\n\tmutex_init(&crypt_stat->cs_mutex);\n\tmutex_init(&crypt_stat->cs_tfm_mutex);\n\tmutex_init(&crypt_stat->cs_hash_tfm_mutex);\n\tcrypt_stat->flags |= ECRYPTFS_STRUCT_INITIALIZED;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid\necryptfs_init_crypt_stat(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tmemset((void *)crypt_stat, 0, sizeof(struct ecryptfs_crypt_stat));\n\tINIT_LIST_HEAD(&crypt_stat->keysig_list);\n\tmutex_init(&crypt_stat->keysig_list_mutex);\n\tmutex_init(&crypt_stat->cs_mutex);\n\tmutex_init(&crypt_stat->cs_tfm_mutex);\n\tmutex_init(&crypt_stat->cs_hash_tfm_mutex);\n\tcrypt_stat->flags |= ECRYPTFS_STRUCT_INITIALIZED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "dentry->d_inode"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_setattr(struct dentry *dentry, struct iattr *ia)\n{\n\tint rc = 0;\n\tstruct dentry *lower_dentry;\n\tstruct iattr lower_ia;\n\tstruct inode *inode;\n\tstruct inode *lower_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(dentry->d_inode)->crypt_stat;\n\tif (!(crypt_stat->flags & ECRYPTFS_STRUCT_INITIALIZED))\n\t\tecryptfs_init_crypt_stat(crypt_stat);\n\tinode = dentry->d_inode;\n\tlower_inode = ecryptfs_inode_to_lower(inode);\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tmutex_lock(&crypt_stat->cs_mutex);\n\tif (d_is_dir(dentry))\n\t\tcrypt_stat->flags &= ~(ECRYPTFS_ENCRYPTED);\n\telse if (d_is_reg(dentry)\n\t\t && (!(crypt_stat->flags & ECRYPTFS_POLICY_APPLIED)\n\t\t     || !(crypt_stat->flags & ECRYPTFS_KEY_VALID))) {\n\t\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\n\t\tmount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\t\tdentry->d_sb)->mount_crypt_stat;\n\t\trc = ecryptfs_get_lower_file(dentry, inode);\n\t\tif (rc) {\n\t\t\tmutex_unlock(&crypt_stat->cs_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\trc = ecryptfs_read_metadata(dentry);\n\t\tecryptfs_put_lower_file(inode);\n\t\tif (rc) {\n\t\t\tif (!(mount_crypt_stat->flags\n\t\t\t      & ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED)) {\n\t\t\t\trc = -EIO;\n\t\t\t\tprintk(KERN_WARNING \"Either the lower file \"\n\t\t\t\t       \"is not in a valid eCryptfs format, \"\n\t\t\t\t       \"or the key could not be retrieved. \"\n\t\t\t\t       \"Plaintext passthrough mode is not \"\n\t\t\t\t       \"enabled; returning -EIO\\n\");\n\t\t\t\tmutex_unlock(&crypt_stat->cs_mutex);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trc = 0;\n\t\t\tcrypt_stat->flags &= ~(ECRYPTFS_I_SIZE_INITIALIZED\n\t\t\t\t\t       | ECRYPTFS_ENCRYPTED);\n\t\t}\n\t}\n\tmutex_unlock(&crypt_stat->cs_mutex);\n\n\trc = inode_change_ok(inode, ia);\n\tif (rc)\n\t\tgoto out;\n\tif (ia->ia_valid & ATTR_SIZE) {\n\t\trc = ecryptfs_inode_newsize_ok(inode, ia->ia_size);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tmemcpy(&lower_ia, ia, sizeof(lower_ia));\n\tif (ia->ia_valid & ATTR_FILE)\n\t\tlower_ia.ia_file = ecryptfs_file_to_lower(ia->ia_file);\n\tif (ia->ia_valid & ATTR_SIZE) {\n\t\trc = truncate_upper(dentry, ia, &lower_ia);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * mode change is for clearing setuid/setgid bits. Allow lower fs\n\t * to interpret this in its own way.\n\t */\n\tif (lower_ia.ia_valid & (ATTR_KILL_SUID | ATTR_KILL_SGID))\n\t\tlower_ia.ia_valid &= ~ATTR_MODE;\n\n\tmutex_lock(&lower_dentry->d_inode->i_mutex);\n\trc = notify_change(lower_dentry, &lower_ia, NULL);\n\tmutex_unlock(&lower_dentry->d_inode->i_mutex);\nout:\n\tfsstack_copy_attr_all(inode, lower_inode);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "876-880",
    "snippet": "static int\necryptfs_permission(struct inode *inode, int mask)\n{\n\treturn inode_permission(ecryptfs_inode_to_lower(inode), mask);\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "ecryptfs_inode_to_lower(inode)",
            "mask"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "459-467",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_lower",
          "args": [
            "inode"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "462-465",
          "snippet": "static inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int\necryptfs_permission(struct inode *inode, int mask)\n{\n\treturn inode_permission(ecryptfs_inode_to_lower(inode), mask);\n}"
  },
  {
    "function_name": "ecryptfs_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "855-874",
    "snippet": "int ecryptfs_truncate(struct dentry *dentry, loff_t new_length)\n{\n\tstruct iattr ia = { .ia_valid = ATTR_SIZE, .ia_size = new_length };\n\tstruct iattr lower_ia = { .ia_valid = 0 };\n\tint rc;\n\n\trc = ecryptfs_inode_newsize_ok(dentry->d_inode, new_length);\n\tif (rc)\n\t\treturn rc;\n\n\trc = truncate_upper(dentry, &ia, &lower_ia);\n\tif (!rc && lower_ia.ia_valid & ATTR_SIZE) {\n\t\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\n\t\tmutex_lock(&lower_dentry->d_inode->i_mutex);\n\t\trc = notify_change(lower_dentry, &lower_ia, NULL);\n\t\tmutex_unlock(&lower_dentry->d_inode->i_mutex);\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&lower_dentry->d_inode->i_mutex"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "lower_dentry",
            "&lower_ia",
            "NULL"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "190-277",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&lower_dentry->d_inode->i_mutex"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower",
          "args": [
            "dentry"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_upper",
          "args": [
            "dentry",
            "&ia",
            "&lower_ia"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "737-821",
          "snippet": "static int truncate_upper(struct dentry *dentry, struct iattr *ia,\n\t\t\t  struct iattr *lower_ia)\n{\n\tint rc = 0;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t i_size = i_size_read(inode);\n\tloff_t lower_size_before_truncate;\n\tloff_t lower_size_after_truncate;\n\n\tif (unlikely((ia->ia_size == i_size))) {\n\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t\treturn 0;\n\t}\n\trc = ecryptfs_get_lower_file(dentry, inode);\n\tif (rc)\n\t\treturn rc;\n\tcrypt_stat = &ecryptfs_inode_to_private(dentry->d_inode)->crypt_stat;\n\t/* Switch on growing or shrinking file */\n\tif (ia->ia_size > i_size) {\n\t\tchar zero[] = { 0x00 };\n\n\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t\t/* Write a single 0 at the last position of the file;\n\t\t * this triggers code that will fill in 0's throughout\n\t\t * the intermediate portion of the previous end of the\n\t\t * file and the new and of the file */\n\t\trc = ecryptfs_write(inode, zero,\n\t\t\t\t    (ia->ia_size - 1), 1);\n\t} else { /* ia->ia_size < i_size_read(inode) */\n\t\t/* We're chopping off all the pages down to the page\n\t\t * in which ia->ia_size is located. Fill in the end of\n\t\t * that page from (ia->ia_size & ~PAGE_CACHE_MASK) to\n\t\t * PAGE_CACHE_SIZE with zeros. */\n\t\tsize_t num_zeros = (PAGE_CACHE_SIZE\n\t\t\t\t    - (ia->ia_size & ~PAGE_CACHE_MASK));\n\n\t\tif (!(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\t\ttruncate_setsize(inode, ia->ia_size);\n\t\t\tlower_ia->ia_size = ia->ia_size;\n\t\t\tlower_ia->ia_valid |= ATTR_SIZE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (num_zeros) {\n\t\t\tchar *zeros_virt;\n\n\t\t\tzeros_virt = kzalloc(num_zeros, GFP_KERNEL);\n\t\t\tif (!zeros_virt) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trc = ecryptfs_write(inode, zeros_virt,\n\t\t\t\t\t    ia->ia_size, num_zeros);\n\t\t\tkfree(zeros_virt);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to zero out \"\n\t\t\t\t       \"the remainder of the end page on \"\n\t\t\t\t       \"reducing truncate; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\ttruncate_setsize(inode, ia->ia_size);\n\t\trc = ecryptfs_write_inode_size_to_metadata(inode);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR\t\"Problem with \"\n\t\t\t       \"ecryptfs_write_inode_size_to_metadata; \"\n\t\t\t       \"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t\t/* We are reducing the size of the ecryptfs file, and need to\n\t\t * know if we need to reduce the size of the lower file. */\n\t\tlower_size_before_truncate =\n\t\t    upper_size_to_lower_size(crypt_stat, i_size);\n\t\tlower_size_after_truncate =\n\t\t    upper_size_to_lower_size(crypt_stat, ia->ia_size);\n\t\tif (lower_size_after_truncate < lower_size_before_truncate) {\n\t\t\tlower_ia->ia_size = lower_size_after_truncate;\n\t\t\tlower_ia->ia_valid |= ATTR_SIZE;\n\t\t} else\n\t\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t}\nout:\n\tecryptfs_put_lower_file(inode);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int truncate_upper(struct dentry *dentry, struct iattr *ia,\n\t\t\t  struct iattr *lower_ia)\n{\n\tint rc = 0;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t i_size = i_size_read(inode);\n\tloff_t lower_size_before_truncate;\n\tloff_t lower_size_after_truncate;\n\n\tif (unlikely((ia->ia_size == i_size))) {\n\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t\treturn 0;\n\t}\n\trc = ecryptfs_get_lower_file(dentry, inode);\n\tif (rc)\n\t\treturn rc;\n\tcrypt_stat = &ecryptfs_inode_to_private(dentry->d_inode)->crypt_stat;\n\t/* Switch on growing or shrinking file */\n\tif (ia->ia_size > i_size) {\n\t\tchar zero[] = { 0x00 };\n\n\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t\t/* Write a single 0 at the last position of the file;\n\t\t * this triggers code that will fill in 0's throughout\n\t\t * the intermediate portion of the previous end of the\n\t\t * file and the new and of the file */\n\t\trc = ecryptfs_write(inode, zero,\n\t\t\t\t    (ia->ia_size - 1), 1);\n\t} else { /* ia->ia_size < i_size_read(inode) */\n\t\t/* We're chopping off all the pages down to the page\n\t\t * in which ia->ia_size is located. Fill in the end of\n\t\t * that page from (ia->ia_size & ~PAGE_CACHE_MASK) to\n\t\t * PAGE_CACHE_SIZE with zeros. */\n\t\tsize_t num_zeros = (PAGE_CACHE_SIZE\n\t\t\t\t    - (ia->ia_size & ~PAGE_CACHE_MASK));\n\n\t\tif (!(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\t\ttruncate_setsize(inode, ia->ia_size);\n\t\t\tlower_ia->ia_size = ia->ia_size;\n\t\t\tlower_ia->ia_valid |= ATTR_SIZE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (num_zeros) {\n\t\t\tchar *zeros_virt;\n\n\t\t\tzeros_virt = kzalloc(num_zeros, GFP_KERNEL);\n\t\t\tif (!zeros_virt) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trc = ecryptfs_write(inode, zeros_virt,\n\t\t\t\t\t    ia->ia_size, num_zeros);\n\t\t\tkfree(zeros_virt);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to zero out \"\n\t\t\t\t       \"the remainder of the end page on \"\n\t\t\t\t       \"reducing truncate; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\ttruncate_setsize(inode, ia->ia_size);\n\t\trc = ecryptfs_write_inode_size_to_metadata(inode);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR\t\"Problem with \"\n\t\t\t       \"ecryptfs_write_inode_size_to_metadata; \"\n\t\t\t       \"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t\t/* We are reducing the size of the ecryptfs file, and need to\n\t\t * know if we need to reduce the size of the lower file. */\n\t\tlower_size_before_truncate =\n\t\t    upper_size_to_lower_size(crypt_stat, i_size);\n\t\tlower_size_after_truncate =\n\t\t    upper_size_to_lower_size(crypt_stat, ia->ia_size);\n\t\tif (lower_size_after_truncate < lower_size_before_truncate) {\n\t\t\tlower_ia->ia_size = lower_size_after_truncate;\n\t\t\tlower_ia->ia_valid |= ATTR_SIZE;\n\t\t} else\n\t\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t}\nout:\n\tecryptfs_put_lower_file(inode);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_newsize_ok",
          "args": [
            "dentry->d_inode",
            "new_length"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "823-843",
          "snippet": "static int ecryptfs_inode_newsize_ok(struct inode *inode, loff_t offset)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t lower_oldsize, lower_newsize;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tlower_oldsize = upper_size_to_lower_size(crypt_stat,\n\t\t\t\t\t\t i_size_read(inode));\n\tlower_newsize = upper_size_to_lower_size(crypt_stat, offset);\n\tif (lower_newsize > lower_oldsize) {\n\t\t/*\n\t\t * The eCryptfs inode and the new *lower* size are mixed here\n\t\t * because we may not have the lower i_mutex held and/or it may\n\t\t * not be appropriate to call inode_newsize_ok() with inodes\n\t\t * from other filesystems.\n\t\t */\n\t\treturn inode_newsize_ok(inode, lower_newsize);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_inode_newsize_ok(struct inode *inode, loff_t offset)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t lower_oldsize, lower_newsize;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tlower_oldsize = upper_size_to_lower_size(crypt_stat,\n\t\t\t\t\t\t i_size_read(inode));\n\tlower_newsize = upper_size_to_lower_size(crypt_stat, offset);\n\tif (lower_newsize > lower_oldsize) {\n\t\t/*\n\t\t * The eCryptfs inode and the new *lower* size are mixed here\n\t\t * because we may not have the lower i_mutex held and/or it may\n\t\t * not be appropriate to call inode_newsize_ok() with inodes\n\t\t * from other filesystems.\n\t\t */\n\t\treturn inode_newsize_ok(inode, lower_newsize);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nint ecryptfs_truncate(struct dentry *dentry, loff_t new_length)\n{\n\tstruct iattr ia = { .ia_valid = ATTR_SIZE, .ia_size = new_length };\n\tstruct iattr lower_ia = { .ia_valid = 0 };\n\tint rc;\n\n\trc = ecryptfs_inode_newsize_ok(dentry->d_inode, new_length);\n\tif (rc)\n\t\treturn rc;\n\n\trc = truncate_upper(dentry, &ia, &lower_ia);\n\tif (!rc && lower_ia.ia_valid & ATTR_SIZE) {\n\t\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\n\t\tmutex_lock(&lower_dentry->d_inode->i_mutex);\n\t\trc = notify_change(lower_dentry, &lower_ia, NULL);\n\t\tmutex_unlock(&lower_dentry->d_inode->i_mutex);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_inode_newsize_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "823-843",
    "snippet": "static int ecryptfs_inode_newsize_ok(struct inode *inode, loff_t offset)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t lower_oldsize, lower_newsize;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tlower_oldsize = upper_size_to_lower_size(crypt_stat,\n\t\t\t\t\t\t i_size_read(inode));\n\tlower_newsize = upper_size_to_lower_size(crypt_stat, offset);\n\tif (lower_newsize > lower_oldsize) {\n\t\t/*\n\t\t * The eCryptfs inode and the new *lower* size are mixed here\n\t\t * because we may not have the lower i_mutex held and/or it may\n\t\t * not be appropriate to call inode_newsize_ok() with inodes\n\t\t * from other filesystems.\n\t\t */\n\t\treturn inode_newsize_ok(inode, lower_newsize);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "lower_newsize"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "823-843",
          "snippet": "static int ecryptfs_inode_newsize_ok(struct inode *inode, loff_t offset)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t lower_oldsize, lower_newsize;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tlower_oldsize = upper_size_to_lower_size(crypt_stat,\n\t\t\t\t\t\t i_size_read(inode));\n\tlower_newsize = upper_size_to_lower_size(crypt_stat, offset);\n\tif (lower_newsize > lower_oldsize) {\n\t\t/*\n\t\t * The eCryptfs inode and the new *lower* size are mixed here\n\t\t * because we may not have the lower i_mutex held and/or it may\n\t\t * not be appropriate to call inode_newsize_ok() with inodes\n\t\t * from other filesystems.\n\t\t */\n\t\treturn inode_newsize_ok(inode, lower_newsize);\n\t}\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "upper_size_to_lower_size",
          "args": [
            "crypt_stat",
            "offset"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "upper_size_to_lower_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "703-719",
          "snippet": "static loff_t\nupper_size_to_lower_size(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t loff_t upper_size)\n{\n\tloff_t lower_size;\n\n\tlower_size = ecryptfs_lower_header_size(crypt_stat);\n\tif (upper_size != 0) {\n\t\tloff_t num_extents;\n\n\t\tnum_extents = upper_size >> crypt_stat->extent_shift;\n\t\tif (upper_size & ~crypt_stat->extent_mask)\n\t\t\tnum_extents++;\n\t\tlower_size += (num_extents * crypt_stat->extent_size);\n\t}\n\treturn lower_size;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic loff_t\nupper_size_to_lower_size(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t loff_t upper_size)\n{\n\tloff_t lower_size;\n\n\tlower_size = ecryptfs_lower_header_size(crypt_stat);\n\tif (upper_size != 0) {\n\t\tloff_t num_extents;\n\n\t\tnum_extents = upper_size >> crypt_stat->extent_shift;\n\t\tif (upper_size & ~crypt_stat->extent_mask)\n\t\t\tnum_extents++;\n\t\tlower_size += (num_extents * crypt_stat->extent_size);\n\t}\n\treturn lower_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "inode"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_inode_newsize_ok(struct inode *inode, loff_t offset)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t lower_oldsize, lower_newsize;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tlower_oldsize = upper_size_to_lower_size(crypt_stat,\n\t\t\t\t\t\t i_size_read(inode));\n\tlower_newsize = upper_size_to_lower_size(crypt_stat, offset);\n\tif (lower_newsize > lower_oldsize) {\n\t\t/*\n\t\t * The eCryptfs inode and the new *lower* size are mixed here\n\t\t * because we may not have the lower i_mutex held and/or it may\n\t\t * not be appropriate to call inode_newsize_ok() with inodes\n\t\t * from other filesystems.\n\t\t */\n\t\treturn inode_newsize_ok(inode, lower_newsize);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "truncate_upper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "737-821",
    "snippet": "static int truncate_upper(struct dentry *dentry, struct iattr *ia,\n\t\t\t  struct iattr *lower_ia)\n{\n\tint rc = 0;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t i_size = i_size_read(inode);\n\tloff_t lower_size_before_truncate;\n\tloff_t lower_size_after_truncate;\n\n\tif (unlikely((ia->ia_size == i_size))) {\n\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t\treturn 0;\n\t}\n\trc = ecryptfs_get_lower_file(dentry, inode);\n\tif (rc)\n\t\treturn rc;\n\tcrypt_stat = &ecryptfs_inode_to_private(dentry->d_inode)->crypt_stat;\n\t/* Switch on growing or shrinking file */\n\tif (ia->ia_size > i_size) {\n\t\tchar zero[] = { 0x00 };\n\n\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t\t/* Write a single 0 at the last position of the file;\n\t\t * this triggers code that will fill in 0's throughout\n\t\t * the intermediate portion of the previous end of the\n\t\t * file and the new and of the file */\n\t\trc = ecryptfs_write(inode, zero,\n\t\t\t\t    (ia->ia_size - 1), 1);\n\t} else { /* ia->ia_size < i_size_read(inode) */\n\t\t/* We're chopping off all the pages down to the page\n\t\t * in which ia->ia_size is located. Fill in the end of\n\t\t * that page from (ia->ia_size & ~PAGE_CACHE_MASK) to\n\t\t * PAGE_CACHE_SIZE with zeros. */\n\t\tsize_t num_zeros = (PAGE_CACHE_SIZE\n\t\t\t\t    - (ia->ia_size & ~PAGE_CACHE_MASK));\n\n\t\tif (!(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\t\ttruncate_setsize(inode, ia->ia_size);\n\t\t\tlower_ia->ia_size = ia->ia_size;\n\t\t\tlower_ia->ia_valid |= ATTR_SIZE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (num_zeros) {\n\t\t\tchar *zeros_virt;\n\n\t\t\tzeros_virt = kzalloc(num_zeros, GFP_KERNEL);\n\t\t\tif (!zeros_virt) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trc = ecryptfs_write(inode, zeros_virt,\n\t\t\t\t\t    ia->ia_size, num_zeros);\n\t\t\tkfree(zeros_virt);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to zero out \"\n\t\t\t\t       \"the remainder of the end page on \"\n\t\t\t\t       \"reducing truncate; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\ttruncate_setsize(inode, ia->ia_size);\n\t\trc = ecryptfs_write_inode_size_to_metadata(inode);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR\t\"Problem with \"\n\t\t\t       \"ecryptfs_write_inode_size_to_metadata; \"\n\t\t\t       \"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t\t/* We are reducing the size of the ecryptfs file, and need to\n\t\t * know if we need to reduce the size of the lower file. */\n\t\tlower_size_before_truncate =\n\t\t    upper_size_to_lower_size(crypt_stat, i_size);\n\t\tlower_size_after_truncate =\n\t\t    upper_size_to_lower_size(crypt_stat, ia->ia_size);\n\t\tif (lower_size_after_truncate < lower_size_before_truncate) {\n\t\t\tlower_ia->ia_size = lower_size_after_truncate;\n\t\t\tlower_ia->ia_valid |= ATTR_SIZE;\n\t\t} else\n\t\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t}\nout:\n\tecryptfs_put_lower_file(inode);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_put_lower_file",
          "args": [
            "inode"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_put_lower_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "157-169",
          "snippet": "void ecryptfs_put_lower_file(struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tif (atomic_dec_and_mutex_lock(&inode_info->lower_file_count,\n\t\t\t\t      &inode_info->lower_file_mutex)) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tfput(inode_info->lower_file);\n\t\tinode_info->lower_file = NULL;\n\t\tmutex_unlock(&inode_info->lower_file_mutex);\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nvoid ecryptfs_put_lower_file(struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tif (atomic_dec_and_mutex_lock(&inode_info->lower_file_count,\n\t\t\t\t      &inode_info->lower_file_mutex)) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tfput(inode_info->lower_file);\n\t\tinode_info->lower_file = NULL;\n\t\tmutex_unlock(&inode_info->lower_file_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "upper_size_to_lower_size",
          "args": [
            "crypt_stat",
            "ia->ia_size"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "upper_size_to_lower_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "703-719",
          "snippet": "static loff_t\nupper_size_to_lower_size(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t loff_t upper_size)\n{\n\tloff_t lower_size;\n\n\tlower_size = ecryptfs_lower_header_size(crypt_stat);\n\tif (upper_size != 0) {\n\t\tloff_t num_extents;\n\n\t\tnum_extents = upper_size >> crypt_stat->extent_shift;\n\t\tif (upper_size & ~crypt_stat->extent_mask)\n\t\t\tnum_extents++;\n\t\tlower_size += (num_extents * crypt_stat->extent_size);\n\t}\n\treturn lower_size;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic loff_t\nupper_size_to_lower_size(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t loff_t upper_size)\n{\n\tloff_t lower_size;\n\n\tlower_size = ecryptfs_lower_header_size(crypt_stat);\n\tif (upper_size != 0) {\n\t\tloff_t num_extents;\n\n\t\tnum_extents = upper_size >> crypt_stat->extent_shift;\n\t\tif (upper_size & ~crypt_stat->extent_mask)\n\t\t\tnum_extents++;\n\t\tlower_size += (num_extents * crypt_stat->extent_size);\n\t}\n\treturn lower_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\t\"Problem with \"\n\t\t\t       \"ecryptfs_write_inode_size_to_metadata; \"\n\t\t\t       \"rc = [%d]\\n\"",
            "rc"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_inode_size_to_metadata",
          "args": [
            "inode"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_inode_size_to_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
          "lines": "456-466",
          "snippet": "int ecryptfs_write_inode_size_to_metadata(struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\treturn ecryptfs_write_inode_size_to_xattr(ecryptfs_inode);\n\telse\n\t\treturn ecryptfs_write_inode_size_to_header(ecryptfs_inode);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint ecryptfs_write_inode_size_to_metadata(struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\treturn ecryptfs_write_inode_size_to_xattr(ecryptfs_inode);\n\telse\n\t\treturn ecryptfs_write_inode_size_to_header(ecryptfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "ia->ia_size"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "zeros_virt"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_write",
          "args": [
            "inode",
            "zeros_virt",
            "ia->ia_size",
            "num_zeros"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
          "lines": "105-216",
          "snippet": "int ecryptfs_write(struct inode *ecryptfs_inode, char *data, loff_t offset,\n\t\t   size_t size)\n{\n\tstruct page *ecryptfs_page;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *ecryptfs_page_virt;\n\tloff_t ecryptfs_file_size = i_size_read(ecryptfs_inode);\n\tloff_t data_offset = 0;\n\tloff_t pos;\n\tint rc = 0;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\t/*\n\t * if we are writing beyond current size, then start pos\n\t * at the current size - we'll fill in zeros from there.\n\t */\n\tif (offset > ecryptfs_file_size)\n\t\tpos = ecryptfs_file_size;\n\telse\n\t\tpos = offset;\n\twhile (pos < (offset + size)) {\n\t\tpgoff_t ecryptfs_page_idx = (pos >> PAGE_CACHE_SHIFT);\n\t\tsize_t start_offset_in_page = (pos & ~PAGE_CACHE_MASK);\n\t\tsize_t num_bytes = (PAGE_CACHE_SIZE - start_offset_in_page);\n\t\tloff_t total_remaining_bytes = ((offset + size) - pos);\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\trc = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (num_bytes > total_remaining_bytes)\n\t\t\tnum_bytes = total_remaining_bytes;\n\t\tif (pos < offset) {\n\t\t\t/* remaining zeros to write, up to destination offset */\n\t\t\tloff_t total_remaining_zeros = (offset - pos);\n\n\t\t\tif (num_bytes > total_remaining_zeros)\n\t\t\t\tnum_bytes = total_remaining_zeros;\n\t\t}\n\t\tecryptfs_page = ecryptfs_get_locked_page(ecryptfs_inode,\n\t\t\t\t\t\t\t ecryptfs_page_idx);\n\t\tif (IS_ERR(ecryptfs_page)) {\n\t\t\trc = PTR_ERR(ecryptfs_page);\n\t\t\tprintk(KERN_ERR \"%s: Error getting page at \"\n\t\t\t       \"index [%ld] from eCryptfs inode \"\n\t\t\t       \"mapping; rc = [%d]\\n\", __func__,\n\t\t\t       ecryptfs_page_idx, rc);\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_page_virt = kmap_atomic(ecryptfs_page);\n\n\t\t/*\n\t\t * pos: where we're now writing, offset: where the request was\n\t\t * If current pos is before request, we are filling zeros\n\t\t * If we are at or beyond request, we are writing the *data*\n\t\t * If we're in a fresh page beyond eof, zero it in either case\n\t\t */\n\t\tif (pos < offset || !start_offset_in_page) {\n\t\t\t/* We are extending past the previous end of the file.\n\t\t\t * Fill in zero values to the end of the page */\n\t\t\tmemset(((char *)ecryptfs_page_virt\n\t\t\t\t+ start_offset_in_page), 0,\n\t\t\t\tPAGE_CACHE_SIZE - start_offset_in_page);\n\t\t}\n\n\t\t/* pos >= offset, we are now writing the data request */\n\t\tif (pos >= offset) {\n\t\t\tmemcpy(((char *)ecryptfs_page_virt\n\t\t\t\t+ start_offset_in_page),\n\t\t\t       (data + data_offset), num_bytes);\n\t\t\tdata_offset += num_bytes;\n\t\t}\n\t\tkunmap_atomic(ecryptfs_page_virt);\n\t\tflush_dcache_page(ecryptfs_page);\n\t\tSetPageUptodate(ecryptfs_page);\n\t\tunlock_page(ecryptfs_page);\n\t\tif (crypt_stat->flags & ECRYPTFS_ENCRYPTED)\n\t\t\trc = ecryptfs_encrypt_page(ecryptfs_page);\n\t\telse\n\t\t\trc = ecryptfs_write_lower_page_segment(ecryptfs_inode,\n\t\t\t\t\t\tecryptfs_page,\n\t\t\t\t\t\tstart_offset_in_page,\n\t\t\t\t\t\tdata_offset);\n\t\tpage_cache_release(ecryptfs_page);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting \"\n\t\t\t       \"page; rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t\tpos += num_bytes;\n\t}\n\tif (pos > ecryptfs_file_size) {\n\t\ti_size_write(ecryptfs_inode, pos);\n\t\tif (crypt_stat->flags & ECRYPTFS_ENCRYPTED) {\n\t\t\tint rc2;\n\n\t\t\trc2 = ecryptfs_write_inode_size_to_metadata(\n\t\t\t\t\t\t\t\tecryptfs_inode);\n\t\t\tif (rc2) {\n\t\t\t\tprintk(KERN_ERR\t\"Problem with \"\n\t\t\t\t       \"ecryptfs_write_inode_size_to_metadata; \"\n\t\t\t\t       \"rc = [%d]\\n\", rc2);\n\t\t\t\tif (!rc)\n\t\t\t\t\trc = rc2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint ecryptfs_write(struct inode *ecryptfs_inode, char *data, loff_t offset,\n\t\t   size_t size)\n{\n\tstruct page *ecryptfs_page;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *ecryptfs_page_virt;\n\tloff_t ecryptfs_file_size = i_size_read(ecryptfs_inode);\n\tloff_t data_offset = 0;\n\tloff_t pos;\n\tint rc = 0;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\t/*\n\t * if we are writing beyond current size, then start pos\n\t * at the current size - we'll fill in zeros from there.\n\t */\n\tif (offset > ecryptfs_file_size)\n\t\tpos = ecryptfs_file_size;\n\telse\n\t\tpos = offset;\n\twhile (pos < (offset + size)) {\n\t\tpgoff_t ecryptfs_page_idx = (pos >> PAGE_CACHE_SHIFT);\n\t\tsize_t start_offset_in_page = (pos & ~PAGE_CACHE_MASK);\n\t\tsize_t num_bytes = (PAGE_CACHE_SIZE - start_offset_in_page);\n\t\tloff_t total_remaining_bytes = ((offset + size) - pos);\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\trc = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (num_bytes > total_remaining_bytes)\n\t\t\tnum_bytes = total_remaining_bytes;\n\t\tif (pos < offset) {\n\t\t\t/* remaining zeros to write, up to destination offset */\n\t\t\tloff_t total_remaining_zeros = (offset - pos);\n\n\t\t\tif (num_bytes > total_remaining_zeros)\n\t\t\t\tnum_bytes = total_remaining_zeros;\n\t\t}\n\t\tecryptfs_page = ecryptfs_get_locked_page(ecryptfs_inode,\n\t\t\t\t\t\t\t ecryptfs_page_idx);\n\t\tif (IS_ERR(ecryptfs_page)) {\n\t\t\trc = PTR_ERR(ecryptfs_page);\n\t\t\tprintk(KERN_ERR \"%s: Error getting page at \"\n\t\t\t       \"index [%ld] from eCryptfs inode \"\n\t\t\t       \"mapping; rc = [%d]\\n\", __func__,\n\t\t\t       ecryptfs_page_idx, rc);\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_page_virt = kmap_atomic(ecryptfs_page);\n\n\t\t/*\n\t\t * pos: where we're now writing, offset: where the request was\n\t\t * If current pos is before request, we are filling zeros\n\t\t * If we are at or beyond request, we are writing the *data*\n\t\t * If we're in a fresh page beyond eof, zero it in either case\n\t\t */\n\t\tif (pos < offset || !start_offset_in_page) {\n\t\t\t/* We are extending past the previous end of the file.\n\t\t\t * Fill in zero values to the end of the page */\n\t\t\tmemset(((char *)ecryptfs_page_virt\n\t\t\t\t+ start_offset_in_page), 0,\n\t\t\t\tPAGE_CACHE_SIZE - start_offset_in_page);\n\t\t}\n\n\t\t/* pos >= offset, we are now writing the data request */\n\t\tif (pos >= offset) {\n\t\t\tmemcpy(((char *)ecryptfs_page_virt\n\t\t\t\t+ start_offset_in_page),\n\t\t\t       (data + data_offset), num_bytes);\n\t\t\tdata_offset += num_bytes;\n\t\t}\n\t\tkunmap_atomic(ecryptfs_page_virt);\n\t\tflush_dcache_page(ecryptfs_page);\n\t\tSetPageUptodate(ecryptfs_page);\n\t\tunlock_page(ecryptfs_page);\n\t\tif (crypt_stat->flags & ECRYPTFS_ENCRYPTED)\n\t\t\trc = ecryptfs_encrypt_page(ecryptfs_page);\n\t\telse\n\t\t\trc = ecryptfs_write_lower_page_segment(ecryptfs_inode,\n\t\t\t\t\t\tecryptfs_page,\n\t\t\t\t\t\tstart_offset_in_page,\n\t\t\t\t\t\tdata_offset);\n\t\tpage_cache_release(ecryptfs_page);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting \"\n\t\t\t       \"page; rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t\tpos += num_bytes;\n\t}\n\tif (pos > ecryptfs_file_size) {\n\t\ti_size_write(ecryptfs_inode, pos);\n\t\tif (crypt_stat->flags & ECRYPTFS_ENCRYPTED) {\n\t\t\tint rc2;\n\n\t\t\trc2 = ecryptfs_write_inode_size_to_metadata(\n\t\t\t\t\t\t\t\tecryptfs_inode);\n\t\t\tif (rc2) {\n\t\t\t\tprintk(KERN_ERR\t\"Problem with \"\n\t\t\t\t       \"ecryptfs_write_inode_size_to_metadata; \"\n\t\t\t\t       \"rc = [%d]\\n\", rc2);\n\t\t\t\tif (!rc)\n\t\t\t\t\trc = rc2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "num_zeros",
            "GFP_KERNEL"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "ia->ia_size"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "dentry->d_inode"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_lower_file",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_lower_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "137-155",
          "snippet": "int ecryptfs_get_lower_file(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\tint count, rc = 0;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tmutex_lock(&inode_info->lower_file_mutex);\n\tcount = atomic_inc_return(&inode_info->lower_file_count);\n\tif (WARN_ON_ONCE(count < 1))\n\t\trc = -EINVAL;\n\telse if (count == 1) {\n\t\trc = ecryptfs_init_lower_file(dentry,\n\t\t\t\t\t      &inode_info->lower_file);\n\t\tif (rc)\n\t\t\tatomic_set(&inode_info->lower_file_count, 0);\n\t}\n\tmutex_unlock(&inode_info->lower_file_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_get_lower_file(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\tint count, rc = 0;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tmutex_lock(&inode_info->lower_file_mutex);\n\tcount = atomic_inc_return(&inode_info->lower_file_count);\n\tif (WARN_ON_ONCE(count < 1))\n\t\trc = -EINVAL;\n\telse if (count == 1) {\n\t\trc = ecryptfs_init_lower_file(dentry,\n\t\t\t\t\t      &inode_info->lower_file);\n\t\tif (rc)\n\t\t\tatomic_set(&inode_info->lower_file_count, 0);\n\t}\n\tmutex_unlock(&inode_info->lower_file_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(ia->ia_size == i_size)"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int truncate_upper(struct dentry *dentry, struct iattr *ia,\n\t\t\t  struct iattr *lower_ia)\n{\n\tint rc = 0;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t i_size = i_size_read(inode);\n\tloff_t lower_size_before_truncate;\n\tloff_t lower_size_after_truncate;\n\n\tif (unlikely((ia->ia_size == i_size))) {\n\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t\treturn 0;\n\t}\n\trc = ecryptfs_get_lower_file(dentry, inode);\n\tif (rc)\n\t\treturn rc;\n\tcrypt_stat = &ecryptfs_inode_to_private(dentry->d_inode)->crypt_stat;\n\t/* Switch on growing or shrinking file */\n\tif (ia->ia_size > i_size) {\n\t\tchar zero[] = { 0x00 };\n\n\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t\t/* Write a single 0 at the last position of the file;\n\t\t * this triggers code that will fill in 0's throughout\n\t\t * the intermediate portion of the previous end of the\n\t\t * file and the new and of the file */\n\t\trc = ecryptfs_write(inode, zero,\n\t\t\t\t    (ia->ia_size - 1), 1);\n\t} else { /* ia->ia_size < i_size_read(inode) */\n\t\t/* We're chopping off all the pages down to the page\n\t\t * in which ia->ia_size is located. Fill in the end of\n\t\t * that page from (ia->ia_size & ~PAGE_CACHE_MASK) to\n\t\t * PAGE_CACHE_SIZE with zeros. */\n\t\tsize_t num_zeros = (PAGE_CACHE_SIZE\n\t\t\t\t    - (ia->ia_size & ~PAGE_CACHE_MASK));\n\n\t\tif (!(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\t\ttruncate_setsize(inode, ia->ia_size);\n\t\t\tlower_ia->ia_size = ia->ia_size;\n\t\t\tlower_ia->ia_valid |= ATTR_SIZE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (num_zeros) {\n\t\t\tchar *zeros_virt;\n\n\t\t\tzeros_virt = kzalloc(num_zeros, GFP_KERNEL);\n\t\t\tif (!zeros_virt) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trc = ecryptfs_write(inode, zeros_virt,\n\t\t\t\t\t    ia->ia_size, num_zeros);\n\t\t\tkfree(zeros_virt);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to zero out \"\n\t\t\t\t       \"the remainder of the end page on \"\n\t\t\t\t       \"reducing truncate; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\ttruncate_setsize(inode, ia->ia_size);\n\t\trc = ecryptfs_write_inode_size_to_metadata(inode);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR\t\"Problem with \"\n\t\t\t       \"ecryptfs_write_inode_size_to_metadata; \"\n\t\t\t       \"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t\t/* We are reducing the size of the ecryptfs file, and need to\n\t\t * know if we need to reduce the size of the lower file. */\n\t\tlower_size_before_truncate =\n\t\t    upper_size_to_lower_size(crypt_stat, i_size);\n\t\tlower_size_after_truncate =\n\t\t    upper_size_to_lower_size(crypt_stat, ia->ia_size);\n\t\tif (lower_size_after_truncate < lower_size_before_truncate) {\n\t\t\tlower_ia->ia_size = lower_size_after_truncate;\n\t\t\tlower_ia->ia_valid |= ATTR_SIZE;\n\t\t} else\n\t\t\tlower_ia->ia_valid &= ~ATTR_SIZE;\n\t}\nout:\n\tecryptfs_put_lower_file(inode);\n\treturn rc;\n}"
  },
  {
    "function_name": "upper_size_to_lower_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "703-719",
    "snippet": "static loff_t\nupper_size_to_lower_size(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t loff_t upper_size)\n{\n\tloff_t lower_size;\n\n\tlower_size = ecryptfs_lower_header_size(crypt_stat);\n\tif (upper_size != 0) {\n\t\tloff_t num_extents;\n\n\t\tnum_extents = upper_size >> crypt_stat->extent_shift;\n\t\tif (upper_size & ~crypt_stat->extent_mask)\n\t\t\tnum_extents++;\n\t\tlower_size += (num_extents * crypt_stat->extent_size);\n\t}\n\treturn lower_size;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_lower_header_size",
          "args": [
            "crypt_stat"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_lower_header_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "423-429",
          "snippet": "static inline size_t\necryptfs_lower_header_size(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\treturn 0;\n\treturn crypt_stat->metadata_size;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [
            "#define ECRYPTFS_METADATA_IN_XATTR    0x00000080"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\n#define ECRYPTFS_METADATA_IN_XATTR    0x00000080\n\nstatic inline size_t\necryptfs_lower_header_size(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\treturn 0;\n\treturn crypt_stat->metadata_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic loff_t\nupper_size_to_lower_size(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t loff_t upper_size)\n{\n\tloff_t lower_size;\n\n\tlower_size = ecryptfs_lower_header_size(crypt_stat);\n\tif (upper_size != 0) {\n\t\tloff_t num_extents;\n\n\t\tnum_extents = upper_size >> crypt_stat->extent_shift;\n\t\tif (upper_size & ~crypt_stat->extent_mask)\n\t\t\tnum_extents++;\n\t\tlower_size += (num_extents * crypt_stat->extent_size);\n\t}\n\treturn lower_size;\n}"
  },
  {
    "function_name": "ecryptfs_follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "678-690",
    "snippet": "static void *ecryptfs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tsize_t len;\n\tchar *buf = ecryptfs_readlink_lower(dentry, &len);\n\tif (IS_ERR(buf))\n\t\tgoto out;\n\tfsstack_copy_attr_atime(dentry->d_inode,\n\t\t\t\tecryptfs_dentry_to_lower(dentry)->d_inode);\n\tbuf[len] = '\\0';\nout:\n\tnd_set_link(nd, buf);\n\treturn NULL;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nd_set_link",
          "args": [
            "nd",
            "buf"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "nd_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "717-720",
          "snippet": "void nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nvoid nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsstack_copy_attr_atime",
          "args": [
            "dentry->d_inode",
            "ecryptfs_dentry_to_lower(dentry)->d_inode"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower",
          "args": [
            "dentry"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "buf"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_readlink_lower",
          "args": [
            "dentry",
            "&len"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_readlink_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "652-676",
          "snippet": "static char *ecryptfs_readlink_lower(struct dentry *dentry, size_t *bufsiz)\n{\n\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tchar *lower_buf;\n\tchar *buf;\n\tmm_segment_t old_fs;\n\tint rc;\n\n\tlower_buf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!lower_buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\trc = lower_dentry->d_inode->i_op->readlink(lower_dentry,\n\t\t\t\t\t\t   (char __user *)lower_buf,\n\t\t\t\t\t\t   PATH_MAX);\n\tset_fs(old_fs);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = ecryptfs_decode_and_decrypt_filename(&buf, bufsiz, dentry->d_sb,\n\t\t\t\t\t\t  lower_buf, rc);\nout:\n\tkfree(lower_buf);\n\treturn rc ? ERR_PTR(rc) : buf;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic char *ecryptfs_readlink_lower(struct dentry *dentry, size_t *bufsiz)\n{\n\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tchar *lower_buf;\n\tchar *buf;\n\tmm_segment_t old_fs;\n\tint rc;\n\n\tlower_buf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!lower_buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\trc = lower_dentry->d_inode->i_op->readlink(lower_dentry,\n\t\t\t\t\t\t   (char __user *)lower_buf,\n\t\t\t\t\t\t   PATH_MAX);\n\tset_fs(old_fs);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = ecryptfs_decode_and_decrypt_filename(&buf, bufsiz, dentry->d_sb,\n\t\t\t\t\t\t  lower_buf, rc);\nout:\n\tkfree(lower_buf);\n\treturn rc ? ERR_PTR(rc) : buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic void *ecryptfs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tsize_t len;\n\tchar *buf = ecryptfs_readlink_lower(dentry, &len);\n\tif (IS_ERR(buf))\n\t\tgoto out;\n\tfsstack_copy_attr_atime(dentry->d_inode,\n\t\t\t\tecryptfs_dentry_to_lower(dentry)->d_inode);\n\tbuf[len] = '\\0';\nout:\n\tnd_set_link(nd, buf);\n\treturn NULL;\n}"
  },
  {
    "function_name": "ecryptfs_readlink_lower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "652-676",
    "snippet": "static char *ecryptfs_readlink_lower(struct dentry *dentry, size_t *bufsiz)\n{\n\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tchar *lower_buf;\n\tchar *buf;\n\tmm_segment_t old_fs;\n\tint rc;\n\n\tlower_buf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!lower_buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\trc = lower_dentry->d_inode->i_op->readlink(lower_dentry,\n\t\t\t\t\t\t   (char __user *)lower_buf,\n\t\t\t\t\t\t   PATH_MAX);\n\tset_fs(old_fs);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = ecryptfs_decode_and_decrypt_filename(&buf, bufsiz, dentry->d_sb,\n\t\t\t\t\t\t  lower_buf, rc);\nout:\n\tkfree(lower_buf);\n\treturn rc ? ERR_PTR(rc) : buf;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lower_buf"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_decode_and_decrypt_filename",
          "args": [
            "&buf",
            "bufsiz",
            "dentry->d_sb",
            "lower_buf",
            "rc"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_decode_and_decrypt_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "2058-2117",
          "snippet": "int ecryptfs_decode_and_decrypt_filename(char **plaintext_name,\n\t\t\t\t\t size_t *plaintext_name_size,\n\t\t\t\t\t struct super_block *sb,\n\t\t\t\t\t const char *name, size_t name_size)\n{\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(sb)->mount_crypt_stat;\n\tchar *decoded_name;\n\tsize_t decoded_name_size;\n\tsize_t packet_size;\n\tint rc = 0;\n\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !(mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\n\t    && (name_size > ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE)\n\t    && (strncmp(name, ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX,\n\t\t\tECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE) == 0)) {\n\t\tconst char *orig_name = name;\n\t\tsize_t orig_name_size = name_size;\n\n\t\tname += ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\n\t\tname_size -= ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\n\t\tecryptfs_decode_from_filename(NULL, &decoded_name_size,\n\t\t\t\t\t      name, name_size);\n\t\tdecoded_name = kmalloc(decoded_name_size, GFP_KERNEL);\n\t\tif (!decoded_name) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kmalloc [%zd] bytes\\n\", __func__,\n\t\t\t       decoded_name_size);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_decode_from_filename(decoded_name, &decoded_name_size,\n\t\t\t\t\t      name, name_size);\n\t\trc = ecryptfs_parse_tag_70_packet(plaintext_name,\n\t\t\t\t\t\t  plaintext_name_size,\n\t\t\t\t\t\t  &packet_size,\n\t\t\t\t\t\t  mount_crypt_stat,\n\t\t\t\t\t\t  decoded_name,\n\t\t\t\t\t\t  decoded_name_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_INFO \"%s: Could not parse tag 70 packet \"\n\t\t\t       \"from filename; copying through filename \"\n\t\t\t       \"as-is\\n\", __func__);\n\t\t\trc = ecryptfs_copy_filename(plaintext_name,\n\t\t\t\t\t\t    plaintext_name_size,\n\t\t\t\t\t\t    orig_name, orig_name_size);\n\t\t\tgoto out_free;\n\t\t}\n\t} else {\n\t\trc = ecryptfs_copy_filename(plaintext_name,\n\t\t\t\t\t    plaintext_name_size,\n\t\t\t\t\t    name, name_size);\n\t\tgoto out;\n\t}\nout_free:\n\tkfree(decoded_name);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_decode_and_decrypt_filename(char **plaintext_name,\n\t\t\t\t\t size_t *plaintext_name_size,\n\t\t\t\t\t struct super_block *sb,\n\t\t\t\t\t const char *name, size_t name_size)\n{\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(sb)->mount_crypt_stat;\n\tchar *decoded_name;\n\tsize_t decoded_name_size;\n\tsize_t packet_size;\n\tint rc = 0;\n\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !(mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\n\t    && (name_size > ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE)\n\t    && (strncmp(name, ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX,\n\t\t\tECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE) == 0)) {\n\t\tconst char *orig_name = name;\n\t\tsize_t orig_name_size = name_size;\n\n\t\tname += ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\n\t\tname_size -= ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\n\t\tecryptfs_decode_from_filename(NULL, &decoded_name_size,\n\t\t\t\t\t      name, name_size);\n\t\tdecoded_name = kmalloc(decoded_name_size, GFP_KERNEL);\n\t\tif (!decoded_name) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kmalloc [%zd] bytes\\n\", __func__,\n\t\t\t       decoded_name_size);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_decode_from_filename(decoded_name, &decoded_name_size,\n\t\t\t\t\t      name, name_size);\n\t\trc = ecryptfs_parse_tag_70_packet(plaintext_name,\n\t\t\t\t\t\t  plaintext_name_size,\n\t\t\t\t\t\t  &packet_size,\n\t\t\t\t\t\t  mount_crypt_stat,\n\t\t\t\t\t\t  decoded_name,\n\t\t\t\t\t\t  decoded_name_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_INFO \"%s: Could not parse tag 70 packet \"\n\t\t\t       \"from filename; copying through filename \"\n\t\t\t       \"as-is\\n\", __func__);\n\t\t\trc = ecryptfs_copy_filename(plaintext_name,\n\t\t\t\t\t\t    plaintext_name_size,\n\t\t\t\t\t\t    orig_name, orig_name_size);\n\t\t\tgoto out_free;\n\t\t}\n\t} else {\n\t\trc = ecryptfs_copy_filename(plaintext_name,\n\t\t\t\t\t    plaintext_name_size,\n\t\t\t\t\t    name, name_size);\n\t\tgoto out;\n\t}\nout_free:\n\tkfree(decoded_name);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lower_dentry->d_inode->i_op->readlink",
          "args": [
            "lower_dentry",
            "(char __user *)lower_buf",
            "PATH_MAX"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "get_ds()"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ds",
          "args": [],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PATH_MAX",
            "GFP_KERNEL"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower",
          "args": [
            "dentry"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic char *ecryptfs_readlink_lower(struct dentry *dentry, size_t *bufsiz)\n{\n\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tchar *lower_buf;\n\tchar *buf;\n\tmm_segment_t old_fs;\n\tint rc;\n\n\tlower_buf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!lower_buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\trc = lower_dentry->d_inode->i_op->readlink(lower_dentry,\n\t\t\t\t\t\t   (char __user *)lower_buf,\n\t\t\t\t\t\t   PATH_MAX);\n\tset_fs(old_fs);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = ecryptfs_decode_and_decrypt_filename(&buf, bufsiz, dentry->d_sb,\n\t\t\t\t\t\t  lower_buf, rc);\nout:\n\tkfree(lower_buf);\n\treturn rc ? ERR_PTR(rc) : buf;\n}"
  },
  {
    "function_name": "ecryptfs_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "602-650",
    "snippet": "static int\necryptfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tint rc;\n\tstruct dentry *lower_old_dentry;\n\tstruct dentry *lower_new_dentry;\n\tstruct dentry *lower_old_dir_dentry;\n\tstruct dentry *lower_new_dir_dentry;\n\tstruct dentry *trap = NULL;\n\tstruct inode *target_inode;\n\n\tlower_old_dentry = ecryptfs_dentry_to_lower(old_dentry);\n\tlower_new_dentry = ecryptfs_dentry_to_lower(new_dentry);\n\tdget(lower_old_dentry);\n\tdget(lower_new_dentry);\n\tlower_old_dir_dentry = dget_parent(lower_old_dentry);\n\tlower_new_dir_dentry = dget_parent(lower_new_dentry);\n\ttarget_inode = new_dentry->d_inode;\n\ttrap = lock_rename(lower_old_dir_dentry, lower_new_dir_dentry);\n\t/* source should not be ancestor of target */\n\tif (trap == lower_old_dentry) {\n\t\trc = -EINVAL;\n\t\tgoto out_lock;\n\t}\n\t/* target should not be ancestor of source */\n\tif (trap == lower_new_dentry) {\n\t\trc = -ENOTEMPTY;\n\t\tgoto out_lock;\n\t}\n\trc = vfs_rename(lower_old_dir_dentry->d_inode, lower_old_dentry,\n\t\t\tlower_new_dir_dentry->d_inode, lower_new_dentry,\n\t\t\tNULL, 0);\n\tif (rc)\n\t\tgoto out_lock;\n\tif (target_inode)\n\t\tfsstack_copy_attr_all(target_inode,\n\t\t\t\t      ecryptfs_inode_to_lower(target_inode));\n\tfsstack_copy_attr_all(new_dir, lower_new_dir_dentry->d_inode);\n\tif (new_dir != old_dir)\n\t\tfsstack_copy_attr_all(old_dir, lower_old_dir_dentry->d_inode);\nout_lock:\n\tunlock_rename(lower_old_dir_dentry, lower_new_dir_dentry);\n\tdput(lower_new_dir_dentry);\n\tdput(lower_old_dir_dentry);\n\tdput(lower_new_dentry);\n\tdput(lower_old_dentry);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "lower_old_dentry"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rename",
          "args": [
            "lower_old_dir_dentry",
            "lower_new_dir_dentry"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2537-2544",
          "snippet": "void unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsstack_copy_attr_all",
          "args": [
            "old_dir",
            "lower_old_dir_dentry->d_inode"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "fsstack_copy_attr_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stack.c",
          "lines": "63-75",
          "snippet": "void fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\n\tdest->i_mode = src->i_mode;\n\tdest->i_uid = src->i_uid;\n\tdest->i_gid = src->i_gid;\n\tdest->i_rdev = src->i_rdev;\n\tdest->i_atime = src->i_atime;\n\tdest->i_mtime = src->i_mtime;\n\tdest->i_ctime = src->i_ctime;\n\tdest->i_blkbits = src->i_blkbits;\n\tdest->i_flags = src->i_flags;\n\tset_nlink(dest, src->i_nlink);\n}",
          "includes": [
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\n\tdest->i_mode = src->i_mode;\n\tdest->i_uid = src->i_uid;\n\tdest->i_gid = src->i_gid;\n\tdest->i_rdev = src->i_rdev;\n\tdest->i_atime = src->i_atime;\n\tdest->i_mtime = src->i_mtime;\n\tdest->i_ctime = src->i_ctime;\n\tdest->i_blkbits = src->i_blkbits;\n\tdest->i_flags = src->i_flags;\n\tset_nlink(dest, src->i_nlink);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_lower",
          "args": [
            "target_inode"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "462-465",
          "snippet": "static inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_rename",
          "args": [
            "lower_old_dir_dentry->d_inode",
            "lower_old_dentry",
            "lower_new_dir_dentry->d_inode",
            "lower_new_dentry",
            "NULL",
            "0"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "4106-4237",
          "snippet": "int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tconst unsigned char *old_name;\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\n\tif (source == target)\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename && !old_dir->i_op->rename2)\n\t\treturn -EPERM;\n\n\tif (flags && !old_dir->i_op->rename2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_lock(&target->i_mutex);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (is_dir && !(flags & RENAME_EXCHANGE) && target)\n\t\tshrink_dcache_parent(new_dentry);\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (!old_dir->i_op->rename2) {\n\t\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t\t      new_dir, new_dentry);\n\t} else {\n\t\tWARN_ON(old_dir->i_op->rename != NULL);\n\t\terror = old_dir->i_op->rename2(old_dir, old_dentry,\n\t\t\t\t\t       new_dir, new_dentry, flags);\n\t}\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir)\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\tdont_mount(new_dentry);\n\t\tdetach_mounts(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tunlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_unlock(&target->i_mutex);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, old_name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, old_dentry->d_name.name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\tfsnotify_oldname_free(old_name);\n\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tconst unsigned char *old_name;\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\n\tif (source == target)\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename && !old_dir->i_op->rename2)\n\t\treturn -EPERM;\n\n\tif (flags && !old_dir->i_op->rename2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_lock(&target->i_mutex);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (is_dir && !(flags & RENAME_EXCHANGE) && target)\n\t\tshrink_dcache_parent(new_dentry);\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (!old_dir->i_op->rename2) {\n\t\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t\t      new_dir, new_dentry);\n\t} else {\n\t\tWARN_ON(old_dir->i_op->rename != NULL);\n\t\terror = old_dir->i_op->rename2(old_dir, old_dentry,\n\t\t\t\t\t       new_dir, new_dentry, flags);\n\t}\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir)\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\tdont_mount(new_dentry);\n\t\tdetach_mounts(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tunlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_unlock(&target->i_mutex);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, old_name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, old_dentry->d_name.name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\tfsnotify_oldname_free(old_name);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "lower_new_dentry"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower",
          "args": [
            "new_dentry"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int\necryptfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tint rc;\n\tstruct dentry *lower_old_dentry;\n\tstruct dentry *lower_new_dentry;\n\tstruct dentry *lower_old_dir_dentry;\n\tstruct dentry *lower_new_dir_dentry;\n\tstruct dentry *trap = NULL;\n\tstruct inode *target_inode;\n\n\tlower_old_dentry = ecryptfs_dentry_to_lower(old_dentry);\n\tlower_new_dentry = ecryptfs_dentry_to_lower(new_dentry);\n\tdget(lower_old_dentry);\n\tdget(lower_new_dentry);\n\tlower_old_dir_dentry = dget_parent(lower_old_dentry);\n\tlower_new_dir_dentry = dget_parent(lower_new_dentry);\n\ttarget_inode = new_dentry->d_inode;\n\ttrap = lock_rename(lower_old_dir_dentry, lower_new_dir_dentry);\n\t/* source should not be ancestor of target */\n\tif (trap == lower_old_dentry) {\n\t\trc = -EINVAL;\n\t\tgoto out_lock;\n\t}\n\t/* target should not be ancestor of source */\n\tif (trap == lower_new_dentry) {\n\t\trc = -ENOTEMPTY;\n\t\tgoto out_lock;\n\t}\n\trc = vfs_rename(lower_old_dir_dentry->d_inode, lower_old_dentry,\n\t\t\tlower_new_dir_dentry->d_inode, lower_new_dentry,\n\t\t\tNULL, 0);\n\tif (rc)\n\t\tgoto out_lock;\n\tif (target_inode)\n\t\tfsstack_copy_attr_all(target_inode,\n\t\t\t\t      ecryptfs_inode_to_lower(target_inode));\n\tfsstack_copy_attr_all(new_dir, lower_new_dir_dentry->d_inode);\n\tif (new_dir != old_dir)\n\t\tfsstack_copy_attr_all(old_dir, lower_old_dir_dentry->d_inode);\nout_lock:\n\tunlock_rename(lower_old_dir_dentry, lower_new_dir_dentry);\n\tdput(lower_new_dir_dentry);\n\tdput(lower_old_dir_dentry);\n\tdput(lower_new_dentry);\n\tdput(lower_old_dentry);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "578-600",
    "snippet": "static int\necryptfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tint rc;\n\tstruct dentry *lower_dentry;\n\tstruct dentry *lower_dir_dentry;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tlower_dir_dentry = lock_parent(lower_dentry);\n\trc = vfs_mknod(lower_dir_dentry->d_inode, lower_dentry, mode, dev);\n\tif (rc || !lower_dentry->d_inode)\n\t\tgoto out;\n\trc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb);\n\tif (rc)\n\t\tgoto out;\n\tfsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);\n\tfsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);\nout:\n\tunlock_dir(lower_dir_dentry);\n\tif (!dentry->d_inode)\n\t\td_drop(dentry);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_dir",
          "args": [
            "lower_dir_dentry"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "48-52",
          "snippet": "static void unlock_dir(struct dentry *dir)\n{\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic void unlock_dir(struct dentry *dir)\n{\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsstack_copy_inode_size",
          "args": [
            "dir",
            "lower_dir_dentry->d_inode"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "fsstack_copy_inode_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stack.c",
          "lines": "10-59",
          "snippet": "void fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n\tloff_t i_size;\n\tblkcnt_t i_blocks;\n\n\t/*\n\t * i_size_read() includes its own seqlocking and protection from\n\t * preemption (see include/linux/fs.h): we need nothing extra for\n\t * that here, and prefer to avoid nesting locks than attempt to keep\n\t * i_size and i_blocks in sync together.\n\t */\n\ti_size = i_size_read(src);\n\n\t/*\n\t * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to\n\t * keep the two halves of i_blocks in sync despite SMP or PREEMPT -\n\t * though stat's generic_fillattr() doesn't bother, and we won't be\n\t * applying quotas (where i_blocks does become important) at the\n\t * upper level.\n\t *\n\t * We don't actually know what locking is used at the lower level;\n\t * but if it's a filesystem that supports quotas, it will be using\n\t * i_lock as in inode_add_bytes().\n\t */\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&src->i_lock);\n\ti_blocks = src->i_blocks;\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&src->i_lock);\n\n\t/*\n\t * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for\n\t * fsstack_copy_inode_size() to hold some lock around\n\t * i_size_write(), otherwise i_size_read() may spin forever (see\n\t * include/linux/fs.h).  We don't necessarily hold i_mutex when this\n\t * is called, so take i_lock for that case.\n\t *\n\t * And if CONFIG_LBDAF (on 32-bit), continue our effort to keep the\n\t * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock\n\t * for that case too, and do both at once by combining the tests.\n\t *\n\t * There is none of this locking overhead in the 64-bit case.\n\t */\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&dst->i_lock);\n\ti_size_write(dst, i_size);\n\tdst->i_blocks = i_blocks;\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&dst->i_lock);\n}",
          "includes": [
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n\tloff_t i_size;\n\tblkcnt_t i_blocks;\n\n\t/*\n\t * i_size_read() includes its own seqlocking and protection from\n\t * preemption (see include/linux/fs.h): we need nothing extra for\n\t * that here, and prefer to avoid nesting locks than attempt to keep\n\t * i_size and i_blocks in sync together.\n\t */\n\ti_size = i_size_read(src);\n\n\t/*\n\t * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to\n\t * keep the two halves of i_blocks in sync despite SMP or PREEMPT -\n\t * though stat's generic_fillattr() doesn't bother, and we won't be\n\t * applying quotas (where i_blocks does become important) at the\n\t * upper level.\n\t *\n\t * We don't actually know what locking is used at the lower level;\n\t * but if it's a filesystem that supports quotas, it will be using\n\t * i_lock as in inode_add_bytes().\n\t */\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&src->i_lock);\n\ti_blocks = src->i_blocks;\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&src->i_lock);\n\n\t/*\n\t * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for\n\t * fsstack_copy_inode_size() to hold some lock around\n\t * i_size_write(), otherwise i_size_read() may spin forever (see\n\t * include/linux/fs.h).  We don't necessarily hold i_mutex when this\n\t * is called, so take i_lock for that case.\n\t *\n\t * And if CONFIG_LBDAF (on 32-bit), continue our effort to keep the\n\t * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock\n\t * for that case too, and do both at once by combining the tests.\n\t *\n\t * There is none of this locking overhead in the 64-bit case.\n\t */\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&dst->i_lock);\n\ti_size_write(dst, i_size);\n\tdst->i_blocks = i_blocks;\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&dst->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsstack_copy_attr_times",
          "args": [
            "dir",
            "lower_dir_dentry->d_inode"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_interpose",
          "args": [
            "lower_dentry",
            "dentry",
            "dir->i_sb"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_interpose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "131-141",
          "snippet": "static int ecryptfs_interpose(struct dentry *lower_dentry,\n\t\t\t      struct dentry *dentry, struct super_block *sb)\n{\n\tstruct inode *inode = ecryptfs_get_inode(lower_dentry->d_inode, sb);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_interpose(struct dentry *lower_dentry,\n\t\t\t      struct dentry *dentry, struct super_block *sb)\n{\n\tstruct inode *inode = ecryptfs_get_inode(lower_dentry->d_inode, sb);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_mknod",
          "args": [
            "lower_dir_dentry->d_inode",
            "lower_dentry",
            "mode",
            "dev"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_mknod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3423-3448",
          "snippet": "int vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif ((S_ISCHR(mode) || S_ISBLK(mode)) && !capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\n\tif (!dir->i_op->mknod)\n\t\treturn -EPERM;\n\n\terror = devcgroup_inode_mknod(mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_mknod(dir, dentry, mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->mknod(dir, dentry, mode, dev);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif ((S_ISCHR(mode) || S_ISBLK(mode)) && !capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\n\tif (!dir->i_op->mknod)\n\t\treturn -EPERM;\n\n\terror = devcgroup_inode_mknod(mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_mknod(dir, dentry, mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->mknod(dir, dentry, mode, dev);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_parent",
          "args": [
            "lower_dentry"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "lock_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "39-46",
          "snippet": "static struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *dir;\n\n\tdir = dget_parent(dentry);\n\tmutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);\n\treturn dir;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *dir;\n\n\tdir = dget_parent(dentry);\n\tmutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);\n\treturn dir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower",
          "args": [
            "dentry"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int\necryptfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tint rc;\n\tstruct dentry *lower_dentry;\n\tstruct dentry *lower_dir_dentry;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tlower_dir_dentry = lock_parent(lower_dentry);\n\trc = vfs_mknod(lower_dir_dentry->d_inode, lower_dentry, mode, dev);\n\tif (rc || !lower_dentry->d_inode)\n\t\tgoto out;\n\trc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb);\n\tif (rc)\n\t\tgoto out;\n\tfsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);\n\tfsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);\nout:\n\tunlock_dir(lower_dir_dentry);\n\tif (!dentry->d_inode)\n\t\td_drop(dentry);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "555-576",
    "snippet": "static int ecryptfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct dentry *lower_dentry;\n\tstruct dentry *lower_dir_dentry;\n\tint rc;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tdget(dentry);\n\tlower_dir_dentry = lock_parent(lower_dentry);\n\tdget(lower_dentry);\n\trc = vfs_rmdir(lower_dir_dentry->d_inode, lower_dentry);\n\tdput(lower_dentry);\n\tif (!rc && dentry->d_inode)\n\t\tclear_nlink(dentry->d_inode);\n\tfsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);\n\tset_nlink(dir, lower_dir_dentry->d_inode->i_nlink);\n\tunlock_dir(lower_dir_dentry);\n\tif (!rc)\n\t\td_drop(dentry);\n\tdput(dentry);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_dir",
          "args": [
            "lower_dir_dentry"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "48-52",
          "snippet": "static void unlock_dir(struct dentry *dir)\n{\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic void unlock_dir(struct dentry *dir)\n{\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "dir",
            "lower_dir_dentry->d_inode->i_nlink"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsstack_copy_attr_times",
          "args": [
            "dir",
            "lower_dir_dentry->d_inode"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "dentry->d_inode"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_rmdir",
          "args": [
            "lower_dir_dentry->d_inode",
            "lower_dentry"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3596-3632",
          "snippet": "int vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tdget(dentry);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(dentry))\n\t\tgoto out;\n\n\terror = security_inode_rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tshrink_dcache_parent(dentry);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tdetach_mounts(dentry);\n\nout:\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tdput(dentry);\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tdget(dentry);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(dentry))\n\t\tgoto out;\n\n\terror = security_inode_rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tshrink_dcache_parent(dentry);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tdetach_mounts(dentry);\n\nout:\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tdput(dentry);\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "lower_dentry"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_parent",
          "args": [
            "lower_dentry"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "lock_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "39-46",
          "snippet": "static struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *dir;\n\n\tdir = dget_parent(dentry);\n\tmutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);\n\treturn dir;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *dir;\n\n\tdir = dget_parent(dentry);\n\tmutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);\n\treturn dir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower",
          "args": [
            "dentry"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct dentry *lower_dentry;\n\tstruct dentry *lower_dir_dentry;\n\tint rc;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tdget(dentry);\n\tlower_dir_dentry = lock_parent(lower_dentry);\n\tdget(lower_dentry);\n\trc = vfs_rmdir(lower_dir_dentry->d_inode, lower_dentry);\n\tdput(lower_dentry);\n\tif (!rc && dentry->d_inode)\n\t\tclear_nlink(dentry->d_inode);\n\tfsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);\n\tset_nlink(dir, lower_dir_dentry->d_inode->i_nlink);\n\tunlock_dir(lower_dir_dentry);\n\tif (!rc)\n\t\td_drop(dentry);\n\tdput(dentry);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "531-553",
    "snippet": "static int ecryptfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint rc;\n\tstruct dentry *lower_dentry;\n\tstruct dentry *lower_dir_dentry;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tlower_dir_dentry = lock_parent(lower_dentry);\n\trc = vfs_mkdir(lower_dir_dentry->d_inode, lower_dentry, mode);\n\tif (rc || !lower_dentry->d_inode)\n\t\tgoto out;\n\trc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb);\n\tif (rc)\n\t\tgoto out;\n\tfsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);\n\tfsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);\n\tset_nlink(dir, lower_dir_dentry->d_inode->i_nlink);\nout:\n\tunlock_dir(lower_dir_dentry);\n\tif (!dentry->d_inode)\n\t\td_drop(dentry);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_dir",
          "args": [
            "lower_dir_dentry"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "48-52",
          "snippet": "static void unlock_dir(struct dentry *dir)\n{\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic void unlock_dir(struct dentry *dir)\n{\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "dir",
            "lower_dir_dentry->d_inode->i_nlink"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsstack_copy_inode_size",
          "args": [
            "dir",
            "lower_dir_dentry->d_inode"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "fsstack_copy_inode_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stack.c",
          "lines": "10-59",
          "snippet": "void fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n\tloff_t i_size;\n\tblkcnt_t i_blocks;\n\n\t/*\n\t * i_size_read() includes its own seqlocking and protection from\n\t * preemption (see include/linux/fs.h): we need nothing extra for\n\t * that here, and prefer to avoid nesting locks than attempt to keep\n\t * i_size and i_blocks in sync together.\n\t */\n\ti_size = i_size_read(src);\n\n\t/*\n\t * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to\n\t * keep the two halves of i_blocks in sync despite SMP or PREEMPT -\n\t * though stat's generic_fillattr() doesn't bother, and we won't be\n\t * applying quotas (where i_blocks does become important) at the\n\t * upper level.\n\t *\n\t * We don't actually know what locking is used at the lower level;\n\t * but if it's a filesystem that supports quotas, it will be using\n\t * i_lock as in inode_add_bytes().\n\t */\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&src->i_lock);\n\ti_blocks = src->i_blocks;\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&src->i_lock);\n\n\t/*\n\t * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for\n\t * fsstack_copy_inode_size() to hold some lock around\n\t * i_size_write(), otherwise i_size_read() may spin forever (see\n\t * include/linux/fs.h).  We don't necessarily hold i_mutex when this\n\t * is called, so take i_lock for that case.\n\t *\n\t * And if CONFIG_LBDAF (on 32-bit), continue our effort to keep the\n\t * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock\n\t * for that case too, and do both at once by combining the tests.\n\t *\n\t * There is none of this locking overhead in the 64-bit case.\n\t */\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&dst->i_lock);\n\ti_size_write(dst, i_size);\n\tdst->i_blocks = i_blocks;\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&dst->i_lock);\n}",
          "includes": [
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n\tloff_t i_size;\n\tblkcnt_t i_blocks;\n\n\t/*\n\t * i_size_read() includes its own seqlocking and protection from\n\t * preemption (see include/linux/fs.h): we need nothing extra for\n\t * that here, and prefer to avoid nesting locks than attempt to keep\n\t * i_size and i_blocks in sync together.\n\t */\n\ti_size = i_size_read(src);\n\n\t/*\n\t * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to\n\t * keep the two halves of i_blocks in sync despite SMP or PREEMPT -\n\t * though stat's generic_fillattr() doesn't bother, and we won't be\n\t * applying quotas (where i_blocks does become important) at the\n\t * upper level.\n\t *\n\t * We don't actually know what locking is used at the lower level;\n\t * but if it's a filesystem that supports quotas, it will be using\n\t * i_lock as in inode_add_bytes().\n\t */\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&src->i_lock);\n\ti_blocks = src->i_blocks;\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&src->i_lock);\n\n\t/*\n\t * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for\n\t * fsstack_copy_inode_size() to hold some lock around\n\t * i_size_write(), otherwise i_size_read() may spin forever (see\n\t * include/linux/fs.h).  We don't necessarily hold i_mutex when this\n\t * is called, so take i_lock for that case.\n\t *\n\t * And if CONFIG_LBDAF (on 32-bit), continue our effort to keep the\n\t * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock\n\t * for that case too, and do both at once by combining the tests.\n\t *\n\t * There is none of this locking overhead in the 64-bit case.\n\t */\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&dst->i_lock);\n\ti_size_write(dst, i_size);\n\tdst->i_blocks = i_blocks;\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&dst->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsstack_copy_attr_times",
          "args": [
            "dir",
            "lower_dir_dentry->d_inode"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_interpose",
          "args": [
            "lower_dentry",
            "dentry",
            "dir->i_sb"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_interpose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "131-141",
          "snippet": "static int ecryptfs_interpose(struct dentry *lower_dentry,\n\t\t\t      struct dentry *dentry, struct super_block *sb)\n{\n\tstruct inode *inode = ecryptfs_get_inode(lower_dentry->d_inode, sb);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_interpose(struct dentry *lower_dentry,\n\t\t\t      struct dentry *dentry, struct super_block *sb)\n{\n\tstruct inode *inode = ecryptfs_get_inode(lower_dentry->d_inode, sb);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_mkdir",
          "args": [
            "lower_dir_dentry->d_inode",
            "lower_dentry",
            "mode"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3515-3538",
          "snippet": "int vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error = may_create(dir, dentry);\n\tunsigned max_links = dir->i_sb->s_max_links;\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tif (max_links && dir->i_nlink >= max_links)\n\t\treturn -EMLINK;\n\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error = may_create(dir, dentry);\n\tunsigned max_links = dir->i_sb->s_max_links;\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tif (max_links && dir->i_nlink >= max_links)\n\t\treturn -EMLINK;\n\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_parent",
          "args": [
            "lower_dentry"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "lock_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "39-46",
          "snippet": "static struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *dir;\n\n\tdir = dget_parent(dentry);\n\tmutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);\n\treturn dir;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *dir;\n\n\tdir = dget_parent(dentry);\n\tmutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);\n\treturn dir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower",
          "args": [
            "dentry"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint rc;\n\tstruct dentry *lower_dentry;\n\tstruct dentry *lower_dir_dentry;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tlower_dir_dentry = lock_parent(lower_dentry);\n\trc = vfs_mkdir(lower_dir_dentry->d_inode, lower_dentry, mode);\n\tif (rc || !lower_dentry->d_inode)\n\t\tgoto out;\n\trc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb);\n\tif (rc)\n\t\tgoto out;\n\tfsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);\n\tfsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);\n\tset_nlink(dir, lower_dir_dentry->d_inode->i_nlink);\nout:\n\tunlock_dir(lower_dir_dentry);\n\tif (!dentry->d_inode)\n\t\td_drop(dentry);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "491-529",
    "snippet": "static int ecryptfs_symlink(struct inode *dir, struct dentry *dentry,\n\t\t\t    const char *symname)\n{\n\tint rc;\n\tstruct dentry *lower_dentry;\n\tstruct dentry *lower_dir_dentry;\n\tchar *encoded_symname;\n\tsize_t encoded_symlen;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat = NULL;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tdget(lower_dentry);\n\tlower_dir_dentry = lock_parent(lower_dentry);\n\tmount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\tdir->i_sb)->mount_crypt_stat;\n\trc = ecryptfs_encrypt_and_encode_filename(&encoded_symname,\n\t\t\t\t\t\t  &encoded_symlen,\n\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t  mount_crypt_stat, symname,\n\t\t\t\t\t\t  strlen(symname));\n\tif (rc)\n\t\tgoto out_lock;\n\trc = vfs_symlink(lower_dir_dentry->d_inode, lower_dentry,\n\t\t\t encoded_symname);\n\tkfree(encoded_symname);\n\tif (rc || !lower_dentry->d_inode)\n\t\tgoto out_lock;\n\trc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb);\n\tif (rc)\n\t\tgoto out_lock;\n\tfsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);\n\tfsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);\nout_lock:\n\tunlock_dir(lower_dir_dentry);\n\tdput(lower_dentry);\n\tif (!dentry->d_inode)\n\t\td_drop(dentry);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "lower_dentry"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_dir",
          "args": [
            "lower_dir_dentry"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "48-52",
          "snippet": "static void unlock_dir(struct dentry *dir)\n{\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic void unlock_dir(struct dentry *dir)\n{\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsstack_copy_inode_size",
          "args": [
            "dir",
            "lower_dir_dentry->d_inode"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "fsstack_copy_inode_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stack.c",
          "lines": "10-59",
          "snippet": "void fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n\tloff_t i_size;\n\tblkcnt_t i_blocks;\n\n\t/*\n\t * i_size_read() includes its own seqlocking and protection from\n\t * preemption (see include/linux/fs.h): we need nothing extra for\n\t * that here, and prefer to avoid nesting locks than attempt to keep\n\t * i_size and i_blocks in sync together.\n\t */\n\ti_size = i_size_read(src);\n\n\t/*\n\t * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to\n\t * keep the two halves of i_blocks in sync despite SMP or PREEMPT -\n\t * though stat's generic_fillattr() doesn't bother, and we won't be\n\t * applying quotas (where i_blocks does become important) at the\n\t * upper level.\n\t *\n\t * We don't actually know what locking is used at the lower level;\n\t * but if it's a filesystem that supports quotas, it will be using\n\t * i_lock as in inode_add_bytes().\n\t */\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&src->i_lock);\n\ti_blocks = src->i_blocks;\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&src->i_lock);\n\n\t/*\n\t * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for\n\t * fsstack_copy_inode_size() to hold some lock around\n\t * i_size_write(), otherwise i_size_read() may spin forever (see\n\t * include/linux/fs.h).  We don't necessarily hold i_mutex when this\n\t * is called, so take i_lock for that case.\n\t *\n\t * And if CONFIG_LBDAF (on 32-bit), continue our effort to keep the\n\t * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock\n\t * for that case too, and do both at once by combining the tests.\n\t *\n\t * There is none of this locking overhead in the 64-bit case.\n\t */\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&dst->i_lock);\n\ti_size_write(dst, i_size);\n\tdst->i_blocks = i_blocks;\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&dst->i_lock);\n}",
          "includes": [
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n\tloff_t i_size;\n\tblkcnt_t i_blocks;\n\n\t/*\n\t * i_size_read() includes its own seqlocking and protection from\n\t * preemption (see include/linux/fs.h): we need nothing extra for\n\t * that here, and prefer to avoid nesting locks than attempt to keep\n\t * i_size and i_blocks in sync together.\n\t */\n\ti_size = i_size_read(src);\n\n\t/*\n\t * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to\n\t * keep the two halves of i_blocks in sync despite SMP or PREEMPT -\n\t * though stat's generic_fillattr() doesn't bother, and we won't be\n\t * applying quotas (where i_blocks does become important) at the\n\t * upper level.\n\t *\n\t * We don't actually know what locking is used at the lower level;\n\t * but if it's a filesystem that supports quotas, it will be using\n\t * i_lock as in inode_add_bytes().\n\t */\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&src->i_lock);\n\ti_blocks = src->i_blocks;\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&src->i_lock);\n\n\t/*\n\t * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for\n\t * fsstack_copy_inode_size() to hold some lock around\n\t * i_size_write(), otherwise i_size_read() may spin forever (see\n\t * include/linux/fs.h).  We don't necessarily hold i_mutex when this\n\t * is called, so take i_lock for that case.\n\t *\n\t * And if CONFIG_LBDAF (on 32-bit), continue our effort to keep the\n\t * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock\n\t * for that case too, and do both at once by combining the tests.\n\t *\n\t * There is none of this locking overhead in the 64-bit case.\n\t */\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&dst->i_lock);\n\ti_size_write(dst, i_size);\n\tdst->i_blocks = i_blocks;\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&dst->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsstack_copy_attr_times",
          "args": [
            "dir",
            "lower_dir_dentry->d_inode"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_interpose",
          "args": [
            "lower_dentry",
            "dentry",
            "dir->i_sb"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_interpose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "131-141",
          "snippet": "static int ecryptfs_interpose(struct dentry *lower_dentry,\n\t\t\t      struct dentry *dentry, struct super_block *sb)\n{\n\tstruct inode *inode = ecryptfs_get_inode(lower_dentry->d_inode, sb);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_interpose(struct dentry *lower_dentry,\n\t\t\t      struct dentry *dentry, struct super_block *sb)\n{\n\tstruct inode *inode = ecryptfs_get_inode(lower_dentry->d_inode, sb);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "encoded_symname"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_symlink",
          "args": [
            "lower_dir_dentry->d_inode",
            "lower_dentry",
            "encoded_symname"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3848-3866",
          "snippet": "int vfs_symlink(struct inode *dir, struct dentry *dentry, const char *oldname)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->symlink)\n\t\treturn -EPERM;\n\n\terror = security_inode_symlink(dir, dentry, oldname);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->symlink(dir, dentry, oldname);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_symlink(struct inode *dir, struct dentry *dentry, const char *oldname)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->symlink)\n\t\treturn -EPERM;\n\n\terror = security_inode_symlink(dir, dentry, oldname);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->symlink(dir, dentry, oldname);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_encrypt_and_encode_filename",
          "args": [
            "&encoded_symname",
            "&encoded_symlen",
            "NULL",
            "mount_crypt_stat",
            "symname",
            "strlen(symname)"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_encrypt_and_encode_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1945-2044",
          "snippet": "int ecryptfs_encrypt_and_encode_filename(\n\tchar **encoded_name,\n\tsize_t *encoded_name_size,\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\tconst char *name, size_t name_size)\n{\n\tsize_t encoded_name_no_prefix_size;\n\tint rc = 0;\n\n\t(*encoded_name) = NULL;\n\t(*encoded_name_size) = 0;\n\tif ((crypt_stat && (crypt_stat->flags & ECRYPTFS_ENCRYPT_FILENAMES))\n\t    || (mount_crypt_stat && (mount_crypt_stat->flags\n\t\t\t\t     & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES))) {\n\t\tstruct ecryptfs_filename *filename;\n\n\t\tfilename = kzalloc(sizeof(*filename), GFP_KERNEL);\n\t\tif (!filename) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kzalloc [%zd] bytes\\n\", __func__,\n\t\t\t       sizeof(*filename));\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfilename->filename = (char *)name;\n\t\tfilename->filename_size = name_size;\n\t\trc = ecryptfs_encrypt_filename(filename, crypt_stat,\n\t\t\t\t\t       mount_crypt_stat);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to encrypt \"\n\t\t\t       \"filename; rc = [%d]\\n\", __func__, rc);\n\t\t\tkfree(filename);\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_encode_for_filename(\n\t\t\tNULL, &encoded_name_no_prefix_size,\n\t\t\tfilename->encrypted_filename,\n\t\t\tfilename->encrypted_filename_size);\n\t\tif ((crypt_stat && (crypt_stat->flags\n\t\t\t\t    & ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\n\t\t    || (mount_crypt_stat\n\t\t\t&& (mount_crypt_stat->flags\n\t\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)))\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\telse\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\t(*encoded_name) = kmalloc((*encoded_name_size) + 1, GFP_KERNEL);\n\t\tif (!(*encoded_name)) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kzalloc [%zd] bytes\\n\", __func__,\n\t\t\t       (*encoded_name_size));\n\t\t\trc = -ENOMEM;\n\t\t\tkfree(filename->encrypted_filename);\n\t\t\tkfree(filename);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((crypt_stat && (crypt_stat->flags\n\t\t\t\t    & ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\n\t\t    || (mount_crypt_stat\n\t\t\t&& (mount_crypt_stat->flags\n\t\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK))) {\n\t\t\tmemcpy((*encoded_name),\n\t\t\t       ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX,\n\t\t\t       ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE);\n\t\t\tecryptfs_encode_for_filename(\n\t\t\t    ((*encoded_name)\n\t\t\t     + ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE),\n\t\t\t    &encoded_name_no_prefix_size,\n\t\t\t    filename->encrypted_filename,\n\t\t\t    filename->encrypted_filename_size);\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\t\t(*encoded_name)[(*encoded_name_size)] = '\\0';\n\t\t} else {\n\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to encode \"\n\t\t\t       \"encrypted filename; rc = [%d]\\n\", __func__,\n\t\t\t       rc);\n\t\t\tkfree((*encoded_name));\n\t\t\t(*encoded_name) = NULL;\n\t\t\t(*encoded_name_size) = 0;\n\t\t}\n\t\tkfree(filename->encrypted_filename);\n\t\tkfree(filename);\n\t} else {\n\t\trc = ecryptfs_copy_filename(encoded_name,\n\t\t\t\t\t    encoded_name_size,\n\t\t\t\t\t    name, name_size);\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_encrypt_and_encode_filename(\n\tchar **encoded_name,\n\tsize_t *encoded_name_size,\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\tconst char *name, size_t name_size)\n{\n\tsize_t encoded_name_no_prefix_size;\n\tint rc = 0;\n\n\t(*encoded_name) = NULL;\n\t(*encoded_name_size) = 0;\n\tif ((crypt_stat && (crypt_stat->flags & ECRYPTFS_ENCRYPT_FILENAMES))\n\t    || (mount_crypt_stat && (mount_crypt_stat->flags\n\t\t\t\t     & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES))) {\n\t\tstruct ecryptfs_filename *filename;\n\n\t\tfilename = kzalloc(sizeof(*filename), GFP_KERNEL);\n\t\tif (!filename) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kzalloc [%zd] bytes\\n\", __func__,\n\t\t\t       sizeof(*filename));\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfilename->filename = (char *)name;\n\t\tfilename->filename_size = name_size;\n\t\trc = ecryptfs_encrypt_filename(filename, crypt_stat,\n\t\t\t\t\t       mount_crypt_stat);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to encrypt \"\n\t\t\t       \"filename; rc = [%d]\\n\", __func__, rc);\n\t\t\tkfree(filename);\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_encode_for_filename(\n\t\t\tNULL, &encoded_name_no_prefix_size,\n\t\t\tfilename->encrypted_filename,\n\t\t\tfilename->encrypted_filename_size);\n\t\tif ((crypt_stat && (crypt_stat->flags\n\t\t\t\t    & ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\n\t\t    || (mount_crypt_stat\n\t\t\t&& (mount_crypt_stat->flags\n\t\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)))\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\telse\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\t(*encoded_name) = kmalloc((*encoded_name_size) + 1, GFP_KERNEL);\n\t\tif (!(*encoded_name)) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kzalloc [%zd] bytes\\n\", __func__,\n\t\t\t       (*encoded_name_size));\n\t\t\trc = -ENOMEM;\n\t\t\tkfree(filename->encrypted_filename);\n\t\t\tkfree(filename);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((crypt_stat && (crypt_stat->flags\n\t\t\t\t    & ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\n\t\t    || (mount_crypt_stat\n\t\t\t&& (mount_crypt_stat->flags\n\t\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK))) {\n\t\t\tmemcpy((*encoded_name),\n\t\t\t       ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX,\n\t\t\t       ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE);\n\t\t\tecryptfs_encode_for_filename(\n\t\t\t    ((*encoded_name)\n\t\t\t     + ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE),\n\t\t\t    &encoded_name_no_prefix_size,\n\t\t\t    filename->encrypted_filename,\n\t\t\t    filename->encrypted_filename_size);\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\t\t(*encoded_name)[(*encoded_name_size)] = '\\0';\n\t\t} else {\n\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to encode \"\n\t\t\t       \"encrypted filename; rc = [%d]\\n\", __func__,\n\t\t\t       rc);\n\t\t\tkfree((*encoded_name));\n\t\t\t(*encoded_name) = NULL;\n\t\t\t(*encoded_name_size) = 0;\n\t\t}\n\t\tkfree(filename->encrypted_filename);\n\t\tkfree(filename);\n\t} else {\n\t\trc = ecryptfs_copy_filename(encoded_name,\n\t\t\t\t\t    encoded_name_size,\n\t\t\t\t\t    name, name_size);\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symname"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_superblock_to_private",
          "args": [
            "dir->i_sb"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_superblock_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "473-477",
          "snippet": "static inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_parent",
          "args": [
            "lower_dentry"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "lock_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "39-46",
          "snippet": "static struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *dir;\n\n\tdir = dget_parent(dentry);\n\tmutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);\n\treturn dir;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *dir;\n\n\tdir = dget_parent(dentry);\n\tmutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);\n\treturn dir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "lower_dentry"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower",
          "args": [
            "dentry"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_symlink(struct inode *dir, struct dentry *dentry,\n\t\t\t    const char *symname)\n{\n\tint rc;\n\tstruct dentry *lower_dentry;\n\tstruct dentry *lower_dir_dentry;\n\tchar *encoded_symname;\n\tsize_t encoded_symlen;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat = NULL;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tdget(lower_dentry);\n\tlower_dir_dentry = lock_parent(lower_dentry);\n\tmount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\tdir->i_sb)->mount_crypt_stat;\n\trc = ecryptfs_encrypt_and_encode_filename(&encoded_symname,\n\t\t\t\t\t\t  &encoded_symlen,\n\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t  mount_crypt_stat, symname,\n\t\t\t\t\t\t  strlen(symname));\n\tif (rc)\n\t\tgoto out_lock;\n\trc = vfs_symlink(lower_dir_dentry->d_inode, lower_dentry,\n\t\t\t encoded_symname);\n\tkfree(encoded_symname);\n\tif (rc || !lower_dentry->d_inode)\n\t\tgoto out_lock;\n\trc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb);\n\tif (rc)\n\t\tgoto out_lock;\n\tfsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);\n\tfsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);\nout_lock:\n\tunlock_dir(lower_dir_dentry);\n\tdput(lower_dentry);\n\tif (!dentry->d_inode)\n\t\td_drop(dentry);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "486-489",
    "snippet": "static int ecryptfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\treturn ecryptfs_do_unlink(dir, dentry, dentry->d_inode);\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_do_unlink",
          "args": [
            "dir",
            "dentry",
            "dentry->d_inode"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_do_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "143-166",
          "snippet": "static int ecryptfs_do_unlink(struct inode *dir, struct dentry *dentry,\n\t\t\t      struct inode *inode)\n{\n\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tstruct inode *lower_dir_inode = ecryptfs_inode_to_lower(dir);\n\tstruct dentry *lower_dir_dentry;\n\tint rc;\n\n\tdget(lower_dentry);\n\tlower_dir_dentry = lock_parent(lower_dentry);\n\trc = vfs_unlink(lower_dir_inode, lower_dentry, NULL);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error in vfs_unlink; rc = [%d]\\n\", rc);\n\t\tgoto out_unlock;\n\t}\n\tfsstack_copy_attr_times(dir, lower_dir_inode);\n\tset_nlink(inode, ecryptfs_inode_to_lower(inode)->i_nlink);\n\tinode->i_ctime = dir->i_ctime;\n\td_drop(dentry);\nout_unlock:\n\tunlock_dir(lower_dir_dentry);\n\tdput(lower_dentry);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_do_unlink(struct inode *dir, struct dentry *dentry,\n\t\t\t      struct inode *inode)\n{\n\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tstruct inode *lower_dir_inode = ecryptfs_inode_to_lower(dir);\n\tstruct dentry *lower_dir_dentry;\n\tint rc;\n\n\tdget(lower_dentry);\n\tlower_dir_dentry = lock_parent(lower_dentry);\n\trc = vfs_unlink(lower_dir_inode, lower_dentry, NULL);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error in vfs_unlink; rc = [%d]\\n\", rc);\n\t\tgoto out_unlock;\n\t}\n\tfsstack_copy_attr_times(dir, lower_dir_inode);\n\tset_nlink(inode, ecryptfs_inode_to_lower(inode)->i_nlink);\n\tinode->i_ctime = dir->i_ctime;\n\td_drop(dentry);\nout_unlock:\n\tunlock_dir(lower_dir_dentry);\n\tdput(lower_dentry);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\treturn ecryptfs_do_unlink(dir, dentry, dentry->d_inode);\n}"
  },
  {
    "function_name": "ecryptfs_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "452-484",
    "snippet": "static int ecryptfs_link(struct dentry *old_dentry, struct inode *dir,\n\t\t\t struct dentry *new_dentry)\n{\n\tstruct dentry *lower_old_dentry;\n\tstruct dentry *lower_new_dentry;\n\tstruct dentry *lower_dir_dentry;\n\tu64 file_size_save;\n\tint rc;\n\n\tfile_size_save = i_size_read(old_dentry->d_inode);\n\tlower_old_dentry = ecryptfs_dentry_to_lower(old_dentry);\n\tlower_new_dentry = ecryptfs_dentry_to_lower(new_dentry);\n\tdget(lower_old_dentry);\n\tdget(lower_new_dentry);\n\tlower_dir_dentry = lock_parent(lower_new_dentry);\n\trc = vfs_link(lower_old_dentry, lower_dir_dentry->d_inode,\n\t\t      lower_new_dentry, NULL);\n\tif (rc || !lower_new_dentry->d_inode)\n\t\tgoto out_lock;\n\trc = ecryptfs_interpose(lower_new_dentry, new_dentry, dir->i_sb);\n\tif (rc)\n\t\tgoto out_lock;\n\tfsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);\n\tfsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);\n\tset_nlink(old_dentry->d_inode,\n\t\t  ecryptfs_inode_to_lower(old_dentry->d_inode)->i_nlink);\n\ti_size_write(new_dentry->d_inode, file_size_save);\nout_lock:\n\tunlock_dir(lower_dir_dentry);\n\tdput(lower_new_dentry);\n\tdput(lower_old_dentry);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "lower_old_dentry"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_dir",
          "args": [
            "lower_dir_dentry"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "48-52",
          "snippet": "static void unlock_dir(struct dentry *dir)\n{\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic void unlock_dir(struct dentry *dir)\n{\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "new_dentry->d_inode",
            "file_size_save"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "old_dentry->d_inode",
            "ecryptfs_inode_to_lower(old_dentry->d_inode)->i_nlink"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_lower",
          "args": [
            "old_dentry->d_inode"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "462-465",
          "snippet": "static inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsstack_copy_inode_size",
          "args": [
            "dir",
            "lower_dir_dentry->d_inode"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "fsstack_copy_inode_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stack.c",
          "lines": "10-59",
          "snippet": "void fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n\tloff_t i_size;\n\tblkcnt_t i_blocks;\n\n\t/*\n\t * i_size_read() includes its own seqlocking and protection from\n\t * preemption (see include/linux/fs.h): we need nothing extra for\n\t * that here, and prefer to avoid nesting locks than attempt to keep\n\t * i_size and i_blocks in sync together.\n\t */\n\ti_size = i_size_read(src);\n\n\t/*\n\t * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to\n\t * keep the two halves of i_blocks in sync despite SMP or PREEMPT -\n\t * though stat's generic_fillattr() doesn't bother, and we won't be\n\t * applying quotas (where i_blocks does become important) at the\n\t * upper level.\n\t *\n\t * We don't actually know what locking is used at the lower level;\n\t * but if it's a filesystem that supports quotas, it will be using\n\t * i_lock as in inode_add_bytes().\n\t */\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&src->i_lock);\n\ti_blocks = src->i_blocks;\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&src->i_lock);\n\n\t/*\n\t * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for\n\t * fsstack_copy_inode_size() to hold some lock around\n\t * i_size_write(), otherwise i_size_read() may spin forever (see\n\t * include/linux/fs.h).  We don't necessarily hold i_mutex when this\n\t * is called, so take i_lock for that case.\n\t *\n\t * And if CONFIG_LBDAF (on 32-bit), continue our effort to keep the\n\t * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock\n\t * for that case too, and do both at once by combining the tests.\n\t *\n\t * There is none of this locking overhead in the 64-bit case.\n\t */\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&dst->i_lock);\n\ti_size_write(dst, i_size);\n\tdst->i_blocks = i_blocks;\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&dst->i_lock);\n}",
          "includes": [
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n\tloff_t i_size;\n\tblkcnt_t i_blocks;\n\n\t/*\n\t * i_size_read() includes its own seqlocking and protection from\n\t * preemption (see include/linux/fs.h): we need nothing extra for\n\t * that here, and prefer to avoid nesting locks than attempt to keep\n\t * i_size and i_blocks in sync together.\n\t */\n\ti_size = i_size_read(src);\n\n\t/*\n\t * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to\n\t * keep the two halves of i_blocks in sync despite SMP or PREEMPT -\n\t * though stat's generic_fillattr() doesn't bother, and we won't be\n\t * applying quotas (where i_blocks does become important) at the\n\t * upper level.\n\t *\n\t * We don't actually know what locking is used at the lower level;\n\t * but if it's a filesystem that supports quotas, it will be using\n\t * i_lock as in inode_add_bytes().\n\t */\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&src->i_lock);\n\ti_blocks = src->i_blocks;\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&src->i_lock);\n\n\t/*\n\t * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for\n\t * fsstack_copy_inode_size() to hold some lock around\n\t * i_size_write(), otherwise i_size_read() may spin forever (see\n\t * include/linux/fs.h).  We don't necessarily hold i_mutex when this\n\t * is called, so take i_lock for that case.\n\t *\n\t * And if CONFIG_LBDAF (on 32-bit), continue our effort to keep the\n\t * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock\n\t * for that case too, and do both at once by combining the tests.\n\t *\n\t * There is none of this locking overhead in the 64-bit case.\n\t */\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&dst->i_lock);\n\ti_size_write(dst, i_size);\n\tdst->i_blocks = i_blocks;\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&dst->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsstack_copy_attr_times",
          "args": [
            "dir",
            "lower_dir_dentry->d_inode"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_interpose",
          "args": [
            "lower_new_dentry",
            "new_dentry",
            "dir->i_sb"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_interpose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "131-141",
          "snippet": "static int ecryptfs_interpose(struct dentry *lower_dentry,\n\t\t\t      struct dentry *dentry, struct super_block *sb)\n{\n\tstruct inode *inode = ecryptfs_get_inode(lower_dentry->d_inode, sb);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_interpose(struct dentry *lower_dentry,\n\t\t\t      struct dentry *dentry, struct super_block *sb)\n{\n\tstruct inode *inode = ecryptfs_get_inode(lower_dentry->d_inode, sb);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_link",
          "args": [
            "lower_old_dentry",
            "lower_dir_dentry->d_inode",
            "lower_new_dentry",
            "NULL"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3924-3975",
          "snippet": "int vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry, struct inode **delegated_inode)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tunsigned max_links = dir->i_sb->s_max_links;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\terror = may_create(dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (dir->i_sb != inode->i_sb)\n\t\treturn -EXDEV;\n\n\t/*\n\t * A link to an append-only or immutable file cannot be created.\n\t */\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\tif (!dir->i_op->link)\n\t\treturn -EPERM;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\terror = security_inode_link(old_dentry, dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\t/* Make sure we don't allow creating hardlink to an unlinked file */\n\tif (inode->i_nlink == 0 && !(inode->i_state & I_LINKABLE))\n\t\terror =  -ENOENT;\n\telse if (max_links && inode->i_nlink >= max_links)\n\t\terror = -EMLINK;\n\telse {\n\t\terror = try_break_deleg(inode, delegated_inode);\n\t\tif (!error)\n\t\t\terror = dir->i_op->link(old_dentry, dir, new_dentry);\n\t}\n\n\tif (!error && (inode->i_state & I_LINKABLE)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state &= ~I_LINKABLE;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (!error)\n\t\tfsnotify_link(dir, inode, new_dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry, struct inode **delegated_inode)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tunsigned max_links = dir->i_sb->s_max_links;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\terror = may_create(dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (dir->i_sb != inode->i_sb)\n\t\treturn -EXDEV;\n\n\t/*\n\t * A link to an append-only or immutable file cannot be created.\n\t */\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\tif (!dir->i_op->link)\n\t\treturn -EPERM;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\terror = security_inode_link(old_dentry, dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\t/* Make sure we don't allow creating hardlink to an unlinked file */\n\tif (inode->i_nlink == 0 && !(inode->i_state & I_LINKABLE))\n\t\terror =  -ENOENT;\n\telse if (max_links && inode->i_nlink >= max_links)\n\t\terror = -EMLINK;\n\telse {\n\t\terror = try_break_deleg(inode, delegated_inode);\n\t\tif (!error)\n\t\t\terror = dir->i_op->link(old_dentry, dir, new_dentry);\n\t}\n\n\tif (!error && (inode->i_state & I_LINKABLE)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state &= ~I_LINKABLE;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (!error)\n\t\tfsnotify_link(dir, inode, new_dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_parent",
          "args": [
            "lower_new_dentry"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "lock_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "39-46",
          "snippet": "static struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *dir;\n\n\tdir = dget_parent(dentry);\n\tmutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);\n\treturn dir;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *dir;\n\n\tdir = dget_parent(dentry);\n\tmutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);\n\treturn dir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "lower_new_dentry"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower",
          "args": [
            "new_dentry"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "old_dentry->d_inode"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_link(struct dentry *old_dentry, struct inode *dir,\n\t\t\t struct dentry *new_dentry)\n{\n\tstruct dentry *lower_old_dentry;\n\tstruct dentry *lower_new_dentry;\n\tstruct dentry *lower_dir_dentry;\n\tu64 file_size_save;\n\tint rc;\n\n\tfile_size_save = i_size_read(old_dentry->d_inode);\n\tlower_old_dentry = ecryptfs_dentry_to_lower(old_dentry);\n\tlower_new_dentry = ecryptfs_dentry_to_lower(new_dentry);\n\tdget(lower_old_dentry);\n\tdget(lower_new_dentry);\n\tlower_dir_dentry = lock_parent(lower_new_dentry);\n\trc = vfs_link(lower_old_dentry, lower_dir_dentry->d_inode,\n\t\t      lower_new_dentry, NULL);\n\tif (rc || !lower_new_dentry->d_inode)\n\t\tgoto out_lock;\n\trc = ecryptfs_interpose(lower_new_dentry, new_dentry, dir->i_sb);\n\tif (rc)\n\t\tgoto out_lock;\n\tfsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);\n\tfsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);\n\tset_nlink(old_dentry->d_inode,\n\t\t  ecryptfs_inode_to_lower(old_dentry->d_inode)->i_nlink);\n\ti_size_write(new_dentry->d_inode, file_size_save);\nout_lock:\n\tunlock_dir(lower_dir_dentry);\n\tdput(lower_new_dentry);\n\tdput(lower_old_dentry);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "392-450",
    "snippet": "static struct dentry *ecryptfs_lookup(struct inode *ecryptfs_dir_inode,\n\t\t\t\t      struct dentry *ecryptfs_dentry,\n\t\t\t\t      unsigned int flags)\n{\n\tchar *encrypted_and_encoded_name = NULL;\n\tsize_t encrypted_and_encoded_name_size;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat = NULL;\n\tstruct dentry *lower_dir_dentry, *lower_dentry;\n\tint rc = 0;\n\n\tlower_dir_dentry = ecryptfs_dentry_to_lower(ecryptfs_dentry->d_parent);\n\tmutex_lock(&lower_dir_dentry->d_inode->i_mutex);\n\tlower_dentry = lookup_one_len(ecryptfs_dentry->d_name.name,\n\t\t\t\t      lower_dir_dentry,\n\t\t\t\t      ecryptfs_dentry->d_name.len);\n\tmutex_unlock(&lower_dir_dentry->d_inode->i_mutex);\n\tif (IS_ERR(lower_dentry)) {\n\t\trc = PTR_ERR(lower_dentry);\n\t\tecryptfs_printk(KERN_DEBUG, \"%s: lookup_one_len() returned \"\n\t\t\t\t\"[%d] on lower_dentry = [%pd]\\n\", __func__, rc,\n\t\t\t\tecryptfs_dentry);\n\t\tgoto out;\n\t}\n\tif (lower_dentry->d_inode)\n\t\tgoto interpose;\n\tmount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\t\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\tif (!(mount_crypt_stat\n\t    && (mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)))\n\t\tgoto interpose;\n\tdput(lower_dentry);\n\trc = ecryptfs_encrypt_and_encode_filename(\n\t\t&encrypted_and_encoded_name, &encrypted_and_encoded_name_size,\n\t\tNULL, mount_crypt_stat, ecryptfs_dentry->d_name.name,\n\t\tecryptfs_dentry->d_name.len);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to encrypt and encode \"\n\t\t       \"filename; rc = [%d]\\n\", __func__, rc);\n\t\tgoto out;\n\t}\n\tmutex_lock(&lower_dir_dentry->d_inode->i_mutex);\n\tlower_dentry = lookup_one_len(encrypted_and_encoded_name,\n\t\t\t\t      lower_dir_dentry,\n\t\t\t\t      encrypted_and_encoded_name_size);\n\tmutex_unlock(&lower_dir_dentry->d_inode->i_mutex);\n\tif (IS_ERR(lower_dentry)) {\n\t\trc = PTR_ERR(lower_dentry);\n\t\tecryptfs_printk(KERN_DEBUG, \"%s: lookup_one_len() returned \"\n\t\t\t\t\"[%d] on lower_dentry = [%s]\\n\", __func__, rc,\n\t\t\t\tencrypted_and_encoded_name);\n\t\tgoto out;\n\t}\ninterpose:\n\trc = ecryptfs_lookup_interpose(ecryptfs_dentry, lower_dentry,\n\t\t\t\t       ecryptfs_dir_inode);\nout:\n\tkfree(encrypted_and_encoded_name);\n\treturn ERR_PTR(rc);\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "encrypted_and_encoded_name"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_lookup_interpose",
          "args": [
            "ecryptfs_dentry",
            "lower_dentry",
            "ecryptfs_dir_inode"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_lookup_interpose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "331-381",
          "snippet": "static int ecryptfs_lookup_interpose(struct dentry *dentry,\n\t\t\t\t     struct dentry *lower_dentry,\n\t\t\t\t     struct inode *dir_inode)\n{\n\tstruct inode *inode, *lower_inode = lower_dentry->d_inode;\n\tstruct ecryptfs_dentry_info *dentry_info;\n\tstruct vfsmount *lower_mnt;\n\tint rc = 0;\n\n\tdentry_info = kmem_cache_alloc(ecryptfs_dentry_info_cache, GFP_KERNEL);\n\tif (!dentry_info) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t       \"to allocate ecryptfs_dentry_info struct\\n\",\n\t\t\t__func__);\n\t\tdput(lower_dentry);\n\t\treturn -ENOMEM;\n\t}\n\n\tlower_mnt = mntget(ecryptfs_dentry_to_lower_mnt(dentry->d_parent));\n\tfsstack_copy_attr_atime(dir_inode, lower_dentry->d_parent->d_inode);\n\tBUG_ON(!d_count(lower_dentry));\n\n\tecryptfs_set_dentry_private(dentry, dentry_info);\n\tdentry_info->lower_path.mnt = lower_mnt;\n\tdentry_info->lower_path.dentry = lower_dentry;\n\n\tif (!lower_dentry->d_inode) {\n\t\t/* We want to add because we couldn't find in lower */\n\t\td_add(dentry, NULL);\n\t\treturn 0;\n\t}\n\tinode = __ecryptfs_get_inode(lower_inode, dir_inode->i_sb);\n\tif (IS_ERR(inode)) {\n\t\tprintk(KERN_ERR \"%s: Error interposing; rc = [%ld]\\n\",\n\t\t       __func__, PTR_ERR(inode));\n\t\treturn PTR_ERR(inode);\n\t}\n\tif (S_ISREG(inode->i_mode)) {\n\t\trc = ecryptfs_i_size_read(dentry, inode);\n\t\tif (rc) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (inode->i_state & I_NEW)\n\t\tunlock_new_inode(inode);\n\td_add(dentry, inode);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_lookup_interpose(struct dentry *dentry,\n\t\t\t\t     struct dentry *lower_dentry,\n\t\t\t\t     struct inode *dir_inode)\n{\n\tstruct inode *inode, *lower_inode = lower_dentry->d_inode;\n\tstruct ecryptfs_dentry_info *dentry_info;\n\tstruct vfsmount *lower_mnt;\n\tint rc = 0;\n\n\tdentry_info = kmem_cache_alloc(ecryptfs_dentry_info_cache, GFP_KERNEL);\n\tif (!dentry_info) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t       \"to allocate ecryptfs_dentry_info struct\\n\",\n\t\t\t__func__);\n\t\tdput(lower_dentry);\n\t\treturn -ENOMEM;\n\t}\n\n\tlower_mnt = mntget(ecryptfs_dentry_to_lower_mnt(dentry->d_parent));\n\tfsstack_copy_attr_atime(dir_inode, lower_dentry->d_parent->d_inode);\n\tBUG_ON(!d_count(lower_dentry));\n\n\tecryptfs_set_dentry_private(dentry, dentry_info);\n\tdentry_info->lower_path.mnt = lower_mnt;\n\tdentry_info->lower_path.dentry = lower_dentry;\n\n\tif (!lower_dentry->d_inode) {\n\t\t/* We want to add because we couldn't find in lower */\n\t\td_add(dentry, NULL);\n\t\treturn 0;\n\t}\n\tinode = __ecryptfs_get_inode(lower_inode, dir_inode->i_sb);\n\tif (IS_ERR(inode)) {\n\t\tprintk(KERN_ERR \"%s: Error interposing; rc = [%ld]\\n\",\n\t\t       __func__, PTR_ERR(inode));\n\t\treturn PTR_ERR(inode);\n\t}\n\tif (S_ISREG(inode->i_mode)) {\n\t\trc = ecryptfs_i_size_read(dentry, inode);\n\t\tif (rc) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (inode->i_state & I_NEW)\n\t\tunlock_new_inode(inode);\n\td_add(dentry, inode);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_DEBUG",
            "\"%s: lookup_one_len() returned \"\n\t\t\t\t\"[%d] on lower_dentry = [%s]\\n\"",
            "__func__",
            "rc",
            "encrypted_and_encoded_name"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "lower_dentry"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "lower_dentry"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&lower_dir_dentry->d_inode->i_mutex"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "encrypted_and_encoded_name",
            "lower_dir_dentry",
            "encrypted_and_encoded_name_size"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&lower_dir_dentry->d_inode->i_mutex"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_encrypt_and_encode_filename",
          "args": [
            "&encrypted_and_encoded_name",
            "&encrypted_and_encoded_name_size",
            "NULL",
            "mount_crypt_stat",
            "ecryptfs_dentry->d_name.name",
            "ecryptfs_dentry->d_name.len"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_encrypt_and_encode_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1945-2044",
          "snippet": "int ecryptfs_encrypt_and_encode_filename(\n\tchar **encoded_name,\n\tsize_t *encoded_name_size,\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\tconst char *name, size_t name_size)\n{\n\tsize_t encoded_name_no_prefix_size;\n\tint rc = 0;\n\n\t(*encoded_name) = NULL;\n\t(*encoded_name_size) = 0;\n\tif ((crypt_stat && (crypt_stat->flags & ECRYPTFS_ENCRYPT_FILENAMES))\n\t    || (mount_crypt_stat && (mount_crypt_stat->flags\n\t\t\t\t     & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES))) {\n\t\tstruct ecryptfs_filename *filename;\n\n\t\tfilename = kzalloc(sizeof(*filename), GFP_KERNEL);\n\t\tif (!filename) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kzalloc [%zd] bytes\\n\", __func__,\n\t\t\t       sizeof(*filename));\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfilename->filename = (char *)name;\n\t\tfilename->filename_size = name_size;\n\t\trc = ecryptfs_encrypt_filename(filename, crypt_stat,\n\t\t\t\t\t       mount_crypt_stat);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to encrypt \"\n\t\t\t       \"filename; rc = [%d]\\n\", __func__, rc);\n\t\t\tkfree(filename);\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_encode_for_filename(\n\t\t\tNULL, &encoded_name_no_prefix_size,\n\t\t\tfilename->encrypted_filename,\n\t\t\tfilename->encrypted_filename_size);\n\t\tif ((crypt_stat && (crypt_stat->flags\n\t\t\t\t    & ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\n\t\t    || (mount_crypt_stat\n\t\t\t&& (mount_crypt_stat->flags\n\t\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)))\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\telse\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\t(*encoded_name) = kmalloc((*encoded_name_size) + 1, GFP_KERNEL);\n\t\tif (!(*encoded_name)) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kzalloc [%zd] bytes\\n\", __func__,\n\t\t\t       (*encoded_name_size));\n\t\t\trc = -ENOMEM;\n\t\t\tkfree(filename->encrypted_filename);\n\t\t\tkfree(filename);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((crypt_stat && (crypt_stat->flags\n\t\t\t\t    & ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\n\t\t    || (mount_crypt_stat\n\t\t\t&& (mount_crypt_stat->flags\n\t\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK))) {\n\t\t\tmemcpy((*encoded_name),\n\t\t\t       ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX,\n\t\t\t       ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE);\n\t\t\tecryptfs_encode_for_filename(\n\t\t\t    ((*encoded_name)\n\t\t\t     + ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE),\n\t\t\t    &encoded_name_no_prefix_size,\n\t\t\t    filename->encrypted_filename,\n\t\t\t    filename->encrypted_filename_size);\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\t\t(*encoded_name)[(*encoded_name_size)] = '\\0';\n\t\t} else {\n\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to encode \"\n\t\t\t       \"encrypted filename; rc = [%d]\\n\", __func__,\n\t\t\t       rc);\n\t\t\tkfree((*encoded_name));\n\t\t\t(*encoded_name) = NULL;\n\t\t\t(*encoded_name_size) = 0;\n\t\t}\n\t\tkfree(filename->encrypted_filename);\n\t\tkfree(filename);\n\t} else {\n\t\trc = ecryptfs_copy_filename(encoded_name,\n\t\t\t\t\t    encoded_name_size,\n\t\t\t\t\t    name, name_size);\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_encrypt_and_encode_filename(\n\tchar **encoded_name,\n\tsize_t *encoded_name_size,\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\tconst char *name, size_t name_size)\n{\n\tsize_t encoded_name_no_prefix_size;\n\tint rc = 0;\n\n\t(*encoded_name) = NULL;\n\t(*encoded_name_size) = 0;\n\tif ((crypt_stat && (crypt_stat->flags & ECRYPTFS_ENCRYPT_FILENAMES))\n\t    || (mount_crypt_stat && (mount_crypt_stat->flags\n\t\t\t\t     & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES))) {\n\t\tstruct ecryptfs_filename *filename;\n\n\t\tfilename = kzalloc(sizeof(*filename), GFP_KERNEL);\n\t\tif (!filename) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kzalloc [%zd] bytes\\n\", __func__,\n\t\t\t       sizeof(*filename));\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfilename->filename = (char *)name;\n\t\tfilename->filename_size = name_size;\n\t\trc = ecryptfs_encrypt_filename(filename, crypt_stat,\n\t\t\t\t\t       mount_crypt_stat);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to encrypt \"\n\t\t\t       \"filename; rc = [%d]\\n\", __func__, rc);\n\t\t\tkfree(filename);\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_encode_for_filename(\n\t\t\tNULL, &encoded_name_no_prefix_size,\n\t\t\tfilename->encrypted_filename,\n\t\t\tfilename->encrypted_filename_size);\n\t\tif ((crypt_stat && (crypt_stat->flags\n\t\t\t\t    & ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\n\t\t    || (mount_crypt_stat\n\t\t\t&& (mount_crypt_stat->flags\n\t\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)))\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\telse\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\t(*encoded_name) = kmalloc((*encoded_name_size) + 1, GFP_KERNEL);\n\t\tif (!(*encoded_name)) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kzalloc [%zd] bytes\\n\", __func__,\n\t\t\t       (*encoded_name_size));\n\t\t\trc = -ENOMEM;\n\t\t\tkfree(filename->encrypted_filename);\n\t\t\tkfree(filename);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((crypt_stat && (crypt_stat->flags\n\t\t\t\t    & ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\n\t\t    || (mount_crypt_stat\n\t\t\t&& (mount_crypt_stat->flags\n\t\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK))) {\n\t\t\tmemcpy((*encoded_name),\n\t\t\t       ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX,\n\t\t\t       ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE);\n\t\t\tecryptfs_encode_for_filename(\n\t\t\t    ((*encoded_name)\n\t\t\t     + ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE),\n\t\t\t    &encoded_name_no_prefix_size,\n\t\t\t    filename->encrypted_filename,\n\t\t\t    filename->encrypted_filename_size);\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\t\t(*encoded_name)[(*encoded_name_size)] = '\\0';\n\t\t} else {\n\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to encode \"\n\t\t\t       \"encrypted filename; rc = [%d]\\n\", __func__,\n\t\t\t       rc);\n\t\t\tkfree((*encoded_name));\n\t\t\t(*encoded_name) = NULL;\n\t\t\t(*encoded_name_size) = 0;\n\t\t}\n\t\tkfree(filename->encrypted_filename);\n\t\tkfree(filename);\n\t} else {\n\t\trc = ecryptfs_copy_filename(encoded_name,\n\t\t\t\t\t    encoded_name_size,\n\t\t\t\t\t    name, name_size);\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "lower_dentry"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_superblock_to_private",
          "args": [
            "ecryptfs_dentry->d_sb"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_superblock_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "473-477",
          "snippet": "static inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "lower_dentry"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "lower_dentry"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&lower_dir_dentry->d_inode->i_mutex"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&lower_dir_dentry->d_inode->i_mutex"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower",
          "args": [
            "ecryptfs_dentry->d_parent"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic struct dentry *ecryptfs_lookup(struct inode *ecryptfs_dir_inode,\n\t\t\t\t      struct dentry *ecryptfs_dentry,\n\t\t\t\t      unsigned int flags)\n{\n\tchar *encrypted_and_encoded_name = NULL;\n\tsize_t encrypted_and_encoded_name_size;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat = NULL;\n\tstruct dentry *lower_dir_dentry, *lower_dentry;\n\tint rc = 0;\n\n\tlower_dir_dentry = ecryptfs_dentry_to_lower(ecryptfs_dentry->d_parent);\n\tmutex_lock(&lower_dir_dentry->d_inode->i_mutex);\n\tlower_dentry = lookup_one_len(ecryptfs_dentry->d_name.name,\n\t\t\t\t      lower_dir_dentry,\n\t\t\t\t      ecryptfs_dentry->d_name.len);\n\tmutex_unlock(&lower_dir_dentry->d_inode->i_mutex);\n\tif (IS_ERR(lower_dentry)) {\n\t\trc = PTR_ERR(lower_dentry);\n\t\tecryptfs_printk(KERN_DEBUG, \"%s: lookup_one_len() returned \"\n\t\t\t\t\"[%d] on lower_dentry = [%pd]\\n\", __func__, rc,\n\t\t\t\tecryptfs_dentry);\n\t\tgoto out;\n\t}\n\tif (lower_dentry->d_inode)\n\t\tgoto interpose;\n\tmount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\t\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\tif (!(mount_crypt_stat\n\t    && (mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)))\n\t\tgoto interpose;\n\tdput(lower_dentry);\n\trc = ecryptfs_encrypt_and_encode_filename(\n\t\t&encrypted_and_encoded_name, &encrypted_and_encoded_name_size,\n\t\tNULL, mount_crypt_stat, ecryptfs_dentry->d_name.name,\n\t\tecryptfs_dentry->d_name.len);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to encrypt and encode \"\n\t\t       \"filename; rc = [%d]\\n\", __func__, rc);\n\t\tgoto out;\n\t}\n\tmutex_lock(&lower_dir_dentry->d_inode->i_mutex);\n\tlower_dentry = lookup_one_len(encrypted_and_encoded_name,\n\t\t\t\t      lower_dir_dentry,\n\t\t\t\t      encrypted_and_encoded_name_size);\n\tmutex_unlock(&lower_dir_dentry->d_inode->i_mutex);\n\tif (IS_ERR(lower_dentry)) {\n\t\trc = PTR_ERR(lower_dentry);\n\t\tecryptfs_printk(KERN_DEBUG, \"%s: lookup_one_len() returned \"\n\t\t\t\t\"[%d] on lower_dentry = [%s]\\n\", __func__, rc,\n\t\t\t\tencrypted_and_encoded_name);\n\t\tgoto out;\n\t}\ninterpose:\n\trc = ecryptfs_lookup_interpose(ecryptfs_dentry, lower_dentry,\n\t\t\t\t       ecryptfs_dir_inode);\nout:\n\tkfree(encrypted_and_encoded_name);\n\treturn ERR_PTR(rc);\n}"
  },
  {
    "function_name": "ecryptfs_lookup_interpose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "331-381",
    "snippet": "static int ecryptfs_lookup_interpose(struct dentry *dentry,\n\t\t\t\t     struct dentry *lower_dentry,\n\t\t\t\t     struct inode *dir_inode)\n{\n\tstruct inode *inode, *lower_inode = lower_dentry->d_inode;\n\tstruct ecryptfs_dentry_info *dentry_info;\n\tstruct vfsmount *lower_mnt;\n\tint rc = 0;\n\n\tdentry_info = kmem_cache_alloc(ecryptfs_dentry_info_cache, GFP_KERNEL);\n\tif (!dentry_info) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t       \"to allocate ecryptfs_dentry_info struct\\n\",\n\t\t\t__func__);\n\t\tdput(lower_dentry);\n\t\treturn -ENOMEM;\n\t}\n\n\tlower_mnt = mntget(ecryptfs_dentry_to_lower_mnt(dentry->d_parent));\n\tfsstack_copy_attr_atime(dir_inode, lower_dentry->d_parent->d_inode);\n\tBUG_ON(!d_count(lower_dentry));\n\n\tecryptfs_set_dentry_private(dentry, dentry_info);\n\tdentry_info->lower_path.mnt = lower_mnt;\n\tdentry_info->lower_path.dentry = lower_dentry;\n\n\tif (!lower_dentry->d_inode) {\n\t\t/* We want to add because we couldn't find in lower */\n\t\td_add(dentry, NULL);\n\t\treturn 0;\n\t}\n\tinode = __ecryptfs_get_inode(lower_inode, dir_inode->i_sb);\n\tif (IS_ERR(inode)) {\n\t\tprintk(KERN_ERR \"%s: Error interposing; rc = [%ld]\\n\",\n\t\t       __func__, PTR_ERR(inode));\n\t\treturn PTR_ERR(inode);\n\t}\n\tif (S_ISREG(inode->i_mode)) {\n\t\trc = ecryptfs_i_size_read(dentry, inode);\n\t\tif (rc) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (inode->i_state & I_NEW)\n\t\tunlock_new_inode(inode);\n\td_add(dentry, inode);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_i_size_read",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_i_size_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "297-326",
          "snippet": "static int ecryptfs_i_size_read(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tint rc;\n\n\trc = ecryptfs_get_lower_file(dentry, inode);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to initialize \"\n\t\t\t\"the lower file for the dentry with name \"\n\t\t\t\"[%pd]; rc = [%d]\\n\", __func__,\n\t\t\tdentry, rc);\n\t\treturn rc;\n\t}\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\t/* TODO: lock for crypt_stat comparison */\n\tif (!(crypt_stat->flags & ECRYPTFS_POLICY_APPLIED))\n\t\tecryptfs_set_default_sizes(crypt_stat);\n\n\trc = ecryptfs_read_and_validate_header_region(inode);\n\tecryptfs_put_lower_file(inode);\n\tif (rc) {\n\t\trc = ecryptfs_read_and_validate_xattr_region(dentry, inode);\n\t\tif (!rc)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\t}\n\n\t/* Must return 0 to allow non-eCryptfs files to be looked up, too */\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_i_size_read(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tint rc;\n\n\trc = ecryptfs_get_lower_file(dentry, inode);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to initialize \"\n\t\t\t\"the lower file for the dentry with name \"\n\t\t\t\"[%pd]; rc = [%d]\\n\", __func__,\n\t\t\tdentry, rc);\n\t\treturn rc;\n\t}\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\t/* TODO: lock for crypt_stat comparison */\n\tif (!(crypt_stat->flags & ECRYPTFS_POLICY_APPLIED))\n\t\tecryptfs_set_default_sizes(crypt_stat);\n\n\trc = ecryptfs_read_and_validate_header_region(inode);\n\tecryptfs_put_lower_file(inode);\n\tif (rc) {\n\t\trc = ecryptfs_read_and_validate_xattr_region(dentry, inode);\n\t\tif (!rc)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\t}\n\n\t/* Must return 0 to allow non-eCryptfs files to be looked up, too */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Error interposing; rc = [%ld]\\n\"",
            "__func__",
            "PTR_ERR(inode)"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ecryptfs_get_inode",
          "args": [
            "lower_inode",
            "dir_inode->i_sb"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "88-108",
          "snippet": "static struct inode *__ecryptfs_get_inode(struct inode *lower_inode,\n\t\t\t\t\t  struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (lower_inode->i_sb != ecryptfs_superblock_to_lower(sb))\n\t\treturn ERR_PTR(-EXDEV);\n\tif (!igrab(lower_inode))\n\t\treturn ERR_PTR(-ESTALE);\n\tinode = iget5_locked(sb, (unsigned long)lower_inode,\n\t\t\t     ecryptfs_inode_test, ecryptfs_inode_set,\n\t\t\t     lower_inode);\n\tif (!inode) {\n\t\tiput(lower_inode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\tif (!(inode->i_state & I_NEW))\n\t\tiput(lower_inode);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic struct inode *__ecryptfs_get_inode(struct inode *lower_inode,\n\t\t\t\t\t  struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (lower_inode->i_sb != ecryptfs_superblock_to_lower(sb))\n\t\treturn ERR_PTR(-EXDEV);\n\tif (!igrab(lower_inode))\n\t\treturn ERR_PTR(-ESTALE);\n\tinode = iget5_locked(sb, (unsigned long)lower_inode,\n\t\t\t     ecryptfs_inode_test, ecryptfs_inode_set,\n\t\t\t     lower_inode);\n\tif (!inode) {\n\t\tiput(lower_inode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\tif (!(inode->i_state & I_NEW))\n\t\tiput(lower_inode);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_set_dentry_private",
          "args": [
            "dentry",
            "dentry_info"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_set_dentry_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "505-510",
          "snippet": "static inline void\necryptfs_set_dentry_private(struct dentry *dentry,\n\t\t\t    struct ecryptfs_dentry_info *dentry_info)\n{\n\tdentry->d_fsdata = dentry_info;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline void\necryptfs_set_dentry_private(struct dentry *dentry,\n\t\t\t    struct ecryptfs_dentry_info *dentry_info)\n{\n\tdentry->d_fsdata = dentry_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!d_count(lower_dentry)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_count",
          "args": [
            "lower_dentry"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_destroy_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "464-468",
          "snippet": "static void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsstack_copy_attr_atime",
          "args": [
            "dir_inode",
            "lower_dentry->d_parent->d_inode"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mntget",
          "args": [
            "ecryptfs_dentry_to_lower_mnt(dentry->d_parent)"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "mntget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1130-1135",
          "snippet": "struct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower_mnt",
          "args": [
            "dentry->d_parent"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "518-522",
          "snippet": "static inline struct vfsmount *\necryptfs_dentry_to_lower_mnt(struct dentry *dentry)\n{\n\treturn ((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path.mnt;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct vfsmount *\necryptfs_dentry_to_lower_mnt(struct dentry *dentry)\n{\n\treturn ((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path.mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "lower_dentry"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ecryptfs_dentry_info_cache",
            "GFP_KERNEL"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_lookup_interpose(struct dentry *dentry,\n\t\t\t\t     struct dentry *lower_dentry,\n\t\t\t\t     struct inode *dir_inode)\n{\n\tstruct inode *inode, *lower_inode = lower_dentry->d_inode;\n\tstruct ecryptfs_dentry_info *dentry_info;\n\tstruct vfsmount *lower_mnt;\n\tint rc = 0;\n\n\tdentry_info = kmem_cache_alloc(ecryptfs_dentry_info_cache, GFP_KERNEL);\n\tif (!dentry_info) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t       \"to allocate ecryptfs_dentry_info struct\\n\",\n\t\t\t__func__);\n\t\tdput(lower_dentry);\n\t\treturn -ENOMEM;\n\t}\n\n\tlower_mnt = mntget(ecryptfs_dentry_to_lower_mnt(dentry->d_parent));\n\tfsstack_copy_attr_atime(dir_inode, lower_dentry->d_parent->d_inode);\n\tBUG_ON(!d_count(lower_dentry));\n\n\tecryptfs_set_dentry_private(dentry, dentry_info);\n\tdentry_info->lower_path.mnt = lower_mnt;\n\tdentry_info->lower_path.dentry = lower_dentry;\n\n\tif (!lower_dentry->d_inode) {\n\t\t/* We want to add because we couldn't find in lower */\n\t\td_add(dentry, NULL);\n\t\treturn 0;\n\t}\n\tinode = __ecryptfs_get_inode(lower_inode, dir_inode->i_sb);\n\tif (IS_ERR(inode)) {\n\t\tprintk(KERN_ERR \"%s: Error interposing; rc = [%ld]\\n\",\n\t\t       __func__, PTR_ERR(inode));\n\t\treturn PTR_ERR(inode);\n\t}\n\tif (S_ISREG(inode->i_mode)) {\n\t\trc = ecryptfs_i_size_read(dentry, inode);\n\t\tif (rc) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (inode->i_state & I_NEW)\n\t\tunlock_new_inode(inode);\n\td_add(dentry, inode);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_i_size_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "297-326",
    "snippet": "static int ecryptfs_i_size_read(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tint rc;\n\n\trc = ecryptfs_get_lower_file(dentry, inode);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to initialize \"\n\t\t\t\"the lower file for the dentry with name \"\n\t\t\t\"[%pd]; rc = [%d]\\n\", __func__,\n\t\t\tdentry, rc);\n\t\treturn rc;\n\t}\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\t/* TODO: lock for crypt_stat comparison */\n\tif (!(crypt_stat->flags & ECRYPTFS_POLICY_APPLIED))\n\t\tecryptfs_set_default_sizes(crypt_stat);\n\n\trc = ecryptfs_read_and_validate_header_region(inode);\n\tecryptfs_put_lower_file(inode);\n\tif (rc) {\n\t\trc = ecryptfs_read_and_validate_xattr_region(dentry, inode);\n\t\tif (!rc)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\t}\n\n\t/* Must return 0 to allow non-eCryptfs files to be looked up, too */\n\treturn 0;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_read_and_validate_xattr_region",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_read_and_validate_xattr_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1394-1410",
          "snippet": "int ecryptfs_read_and_validate_xattr_region(struct dentry *dentry,\n\t\t\t\t\t    struct inode *inode)\n{\n\tu8 file_size[ECRYPTFS_SIZE_AND_MARKER_BYTES];\n\tu8 *marker = file_size + ECRYPTFS_FILE_SIZE_BYTES;\n\tint rc;\n\n\trc = ecryptfs_getxattr_lower(ecryptfs_dentry_to_lower(dentry),\n\t\t\t\t     ECRYPTFS_XATTR_NAME, file_size,\n\t\t\t\t     ECRYPTFS_SIZE_AND_MARKER_BYTES);\n\tif (rc < ECRYPTFS_SIZE_AND_MARKER_BYTES)\n\t\treturn rc >= 0 ? -EINVAL : rc;\n\trc = ecryptfs_validate_marker(marker);\n\tif (!rc)\n\t\tecryptfs_i_size_init(file_size, inode);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_read_and_validate_xattr_region(struct dentry *dentry,\n\t\t\t\t\t    struct inode *inode)\n{\n\tu8 file_size[ECRYPTFS_SIZE_AND_MARKER_BYTES];\n\tu8 *marker = file_size + ECRYPTFS_FILE_SIZE_BYTES;\n\tint rc;\n\n\trc = ecryptfs_getxattr_lower(ecryptfs_dentry_to_lower(dentry),\n\t\t\t\t     ECRYPTFS_XATTR_NAME, file_size,\n\t\t\t\t     ECRYPTFS_SIZE_AND_MARKER_BYTES);\n\tif (rc < ECRYPTFS_SIZE_AND_MARKER_BYTES)\n\t\treturn rc >= 0 ? -EINVAL : rc;\n\trc = ecryptfs_validate_marker(marker);\n\tif (!rc)\n\t\tecryptfs_i_size_init(file_size, inode);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_put_lower_file",
          "args": [
            "inode"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_put_lower_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "157-169",
          "snippet": "void ecryptfs_put_lower_file(struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tif (atomic_dec_and_mutex_lock(&inode_info->lower_file_count,\n\t\t\t\t      &inode_info->lower_file_mutex)) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tfput(inode_info->lower_file);\n\t\tinode_info->lower_file = NULL;\n\t\tmutex_unlock(&inode_info->lower_file_mutex);\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nvoid ecryptfs_put_lower_file(struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tif (atomic_dec_and_mutex_lock(&inode_info->lower_file_count,\n\t\t\t\t      &inode_info->lower_file_mutex)) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tfput(inode_info->lower_file);\n\t\tinode_info->lower_file = NULL;\n\t\tmutex_unlock(&inode_info->lower_file_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_read_and_validate_header_region",
          "args": [
            "inode"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_read_and_validate_header_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1037-1051",
          "snippet": "int ecryptfs_read_and_validate_header_region(struct inode *inode)\n{\n\tu8 file_size[ECRYPTFS_SIZE_AND_MARKER_BYTES];\n\tu8 *marker = file_size + ECRYPTFS_FILE_SIZE_BYTES;\n\tint rc;\n\n\trc = ecryptfs_read_lower(file_size, 0, ECRYPTFS_SIZE_AND_MARKER_BYTES,\n\t\t\t\t inode);\n\tif (rc < ECRYPTFS_SIZE_AND_MARKER_BYTES)\n\t\treturn rc >= 0 ? -EINVAL : rc;\n\trc = ecryptfs_validate_marker(marker);\n\tif (!rc)\n\t\tecryptfs_i_size_init(file_size, inode);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_read_and_validate_header_region(struct inode *inode)\n{\n\tu8 file_size[ECRYPTFS_SIZE_AND_MARKER_BYTES];\n\tu8 *marker = file_size + ECRYPTFS_FILE_SIZE_BYTES;\n\tint rc;\n\n\trc = ecryptfs_read_lower(file_size, 0, ECRYPTFS_SIZE_AND_MARKER_BYTES,\n\t\t\t\t inode);\n\tif (rc < ECRYPTFS_SIZE_AND_MARKER_BYTES)\n\t\treturn rc >= 0 ? -EINVAL : rc;\n\trc = ecryptfs_validate_marker(marker);\n\tif (!rc)\n\t\tecryptfs_i_size_init(file_size, inode);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_set_default_sizes",
          "args": [
            "crypt_stat"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_set_default_sizes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "660-676",
          "snippet": "void ecryptfs_set_default_sizes(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\t/* Default values; may be overwritten as we are parsing the\n\t * packets. */\n\tcrypt_stat->extent_size = ECRYPTFS_DEFAULT_EXTENT_SIZE;\n\tset_extent_mask_and_shift(crypt_stat);\n\tcrypt_stat->iv_bytes = ECRYPTFS_DEFAULT_IV_BYTES;\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\tcrypt_stat->metadata_size = ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n\telse {\n\t\tif (PAGE_CACHE_SIZE <= ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE)\n\t\t\tcrypt_stat->metadata_size =\n\t\t\t\tECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n\t\telse\n\t\t\tcrypt_stat->metadata_size = PAGE_CACHE_SIZE;\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_set_default_sizes(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\t/* Default values; may be overwritten as we are parsing the\n\t * packets. */\n\tcrypt_stat->extent_size = ECRYPTFS_DEFAULT_EXTENT_SIZE;\n\tset_extent_mask_and_shift(crypt_stat);\n\tcrypt_stat->iv_bytes = ECRYPTFS_DEFAULT_IV_BYTES;\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\tcrypt_stat->metadata_size = ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n\telse {\n\t\tif (PAGE_CACHE_SIZE <= ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE)\n\t\t\tcrypt_stat->metadata_size =\n\t\t\t\tECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n\t\telse\n\t\t\tcrypt_stat->metadata_size = PAGE_CACHE_SIZE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "inode"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Error attempting to initialize \"\n\t\t\t\"the lower file for the dentry with name \"\n\t\t\t\"[%pd]; rc = [%d]\\n\"",
            "__func__",
            "dentry",
            "rc"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_lower_file",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_lower_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "137-155",
          "snippet": "int ecryptfs_get_lower_file(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\tint count, rc = 0;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tmutex_lock(&inode_info->lower_file_mutex);\n\tcount = atomic_inc_return(&inode_info->lower_file_count);\n\tif (WARN_ON_ONCE(count < 1))\n\t\trc = -EINVAL;\n\telse if (count == 1) {\n\t\trc = ecryptfs_init_lower_file(dentry,\n\t\t\t\t\t      &inode_info->lower_file);\n\t\tif (rc)\n\t\t\tatomic_set(&inode_info->lower_file_count, 0);\n\t}\n\tmutex_unlock(&inode_info->lower_file_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_get_lower_file(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\tint count, rc = 0;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tmutex_lock(&inode_info->lower_file_mutex);\n\tcount = atomic_inc_return(&inode_info->lower_file_count);\n\tif (WARN_ON_ONCE(count < 1))\n\t\trc = -EINVAL;\n\telse if (count == 1) {\n\t\trc = ecryptfs_init_lower_file(dentry,\n\t\t\t\t\t      &inode_info->lower_file);\n\t\tif (rc)\n\t\t\tatomic_set(&inode_info->lower_file_count, 0);\n\t}\n\tmutex_unlock(&inode_info->lower_file_mutex);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_i_size_read(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tint rc;\n\n\trc = ecryptfs_get_lower_file(dentry, inode);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to initialize \"\n\t\t\t\"the lower file for the dentry with name \"\n\t\t\t\"[%pd]; rc = [%d]\\n\", __func__,\n\t\t\tdentry, rc);\n\t\treturn rc;\n\t}\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\t/* TODO: lock for crypt_stat comparison */\n\tif (!(crypt_stat->flags & ECRYPTFS_POLICY_APPLIED))\n\t\tecryptfs_set_default_sizes(crypt_stat);\n\n\trc = ecryptfs_read_and_validate_header_region(inode);\n\tecryptfs_put_lower_file(inode);\n\tif (rc) {\n\t\trc = ecryptfs_read_and_validate_xattr_region(dentry, inode);\n\t\tif (!rc)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\t}\n\n\t/* Must return 0 to allow non-eCryptfs files to be looked up, too */\n\treturn 0;\n}"
  },
  {
    "function_name": "ecryptfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "265-295",
    "snippet": "static int\necryptfs_create(struct inode *directory_inode, struct dentry *ecryptfs_dentry,\n\t\tumode_t mode, bool excl)\n{\n\tstruct inode *ecryptfs_inode;\n\tint rc;\n\n\tecryptfs_inode = ecryptfs_do_create(directory_inode, ecryptfs_dentry,\n\t\t\t\t\t    mode);\n\tif (unlikely(IS_ERR(ecryptfs_inode))) {\n\t\tecryptfs_printk(KERN_WARNING, \"Failed to create file in\"\n\t\t\t\t\"lower filesystem\\n\");\n\t\trc = PTR_ERR(ecryptfs_inode);\n\t\tgoto out;\n\t}\n\t/* At this point, a file exists on \"disk\"; we need to make sure\n\t * that this on disk file is prepared to be an ecryptfs file */\n\trc = ecryptfs_initialize_file(ecryptfs_dentry, ecryptfs_inode);\n\tif (rc) {\n\t\tecryptfs_do_unlink(directory_inode, ecryptfs_dentry,\n\t\t\t\t   ecryptfs_inode);\n\t\tmake_bad_inode(ecryptfs_inode);\n\t\tunlock_new_inode(ecryptfs_inode);\n\t\tiput(ecryptfs_inode);\n\t\tgoto out;\n\t}\n\tunlock_new_inode(ecryptfs_inode);\n\td_instantiate(ecryptfs_dentry, ecryptfs_inode);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "ecryptfs_dentry",
            "ecryptfs_inode"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_do_unlink",
          "args": [
            "directory_inode",
            "ecryptfs_dentry",
            "ecryptfs_inode"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_do_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "143-166",
          "snippet": "static int ecryptfs_do_unlink(struct inode *dir, struct dentry *dentry,\n\t\t\t      struct inode *inode)\n{\n\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tstruct inode *lower_dir_inode = ecryptfs_inode_to_lower(dir);\n\tstruct dentry *lower_dir_dentry;\n\tint rc;\n\n\tdget(lower_dentry);\n\tlower_dir_dentry = lock_parent(lower_dentry);\n\trc = vfs_unlink(lower_dir_inode, lower_dentry, NULL);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error in vfs_unlink; rc = [%d]\\n\", rc);\n\t\tgoto out_unlock;\n\t}\n\tfsstack_copy_attr_times(dir, lower_dir_inode);\n\tset_nlink(inode, ecryptfs_inode_to_lower(inode)->i_nlink);\n\tinode->i_ctime = dir->i_ctime;\n\td_drop(dentry);\nout_unlock:\n\tunlock_dir(lower_dir_dentry);\n\tdput(lower_dentry);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_do_unlink(struct inode *dir, struct dentry *dentry,\n\t\t\t      struct inode *inode)\n{\n\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tstruct inode *lower_dir_inode = ecryptfs_inode_to_lower(dir);\n\tstruct dentry *lower_dir_dentry;\n\tint rc;\n\n\tdget(lower_dentry);\n\tlower_dir_dentry = lock_parent(lower_dentry);\n\trc = vfs_unlink(lower_dir_inode, lower_dentry, NULL);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error in vfs_unlink; rc = [%d]\\n\", rc);\n\t\tgoto out_unlock;\n\t}\n\tfsstack_copy_attr_times(dir, lower_dir_inode);\n\tset_nlink(inode, ecryptfs_inode_to_lower(inode)->i_nlink);\n\tinode->i_ctime = dir->i_ctime;\n\td_drop(dentry);\nout_unlock:\n\tunlock_dir(lower_dir_dentry);\n\tdput(lower_dentry);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_initialize_file",
          "args": [
            "ecryptfs_dentry",
            "ecryptfs_inode"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_initialize_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "220-253",
          "snippet": "int ecryptfs_initialize_file(struct dentry *ecryptfs_dentry,\n\t\t\t     struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tint rc = 0;\n\n\tif (S_ISDIR(ecryptfs_inode->i_mode)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"This is a directory\\n\");\n\t\tcrypt_stat->flags &= ~(ECRYPTFS_ENCRYPTED);\n\t\tgoto out;\n\t}\n\tecryptfs_printk(KERN_DEBUG, \"Initializing crypto context\\n\");\n\trc = ecryptfs_new_file_context(ecryptfs_inode);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error creating new file \"\n\t\t\t\t\"context; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_get_lower_file(ecryptfs_dentry, ecryptfs_inode);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to initialize \"\n\t\t\t\"the lower file for the dentry with name \"\n\t\t\t\"[%pd]; rc = [%d]\\n\", __func__,\n\t\t\tecryptfs_dentry, rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_write_metadata(ecryptfs_dentry, ecryptfs_inode);\n\tif (rc)\n\t\tprintk(KERN_ERR \"Error writing headers; rc = [%d]\\n\", rc);\n\tecryptfs_put_lower_file(ecryptfs_inode);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nint ecryptfs_initialize_file(struct dentry *ecryptfs_dentry,\n\t\t\t     struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tint rc = 0;\n\n\tif (S_ISDIR(ecryptfs_inode->i_mode)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"This is a directory\\n\");\n\t\tcrypt_stat->flags &= ~(ECRYPTFS_ENCRYPTED);\n\t\tgoto out;\n\t}\n\tecryptfs_printk(KERN_DEBUG, \"Initializing crypto context\\n\");\n\trc = ecryptfs_new_file_context(ecryptfs_inode);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error creating new file \"\n\t\t\t\t\"context; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_get_lower_file(ecryptfs_dentry, ecryptfs_inode);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to initialize \"\n\t\t\t\"the lower file for the dentry with name \"\n\t\t\t\"[%pd]; rc = [%d]\\n\", __func__,\n\t\t\tecryptfs_dentry, rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_write_metadata(ecryptfs_dentry, ecryptfs_inode);\n\tif (rc)\n\t\tprintk(KERN_ERR \"Error writing headers; rc = [%d]\\n\", rc);\n\tecryptfs_put_lower_file(ecryptfs_inode);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_WARNING",
            "\"Failed to create file in\"\n\t\t\t\t\"lower filesystem\\n\""
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "IS_ERR(ecryptfs_inode)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_do_create",
          "args": [
            "directory_inode",
            "ecryptfs_dentry",
            "mode"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_do_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "181-210",
          "snippet": "static struct inode *\necryptfs_do_create(struct inode *directory_inode,\n\t\t   struct dentry *ecryptfs_dentry, umode_t mode)\n{\n\tint rc;\n\tstruct dentry *lower_dentry;\n\tstruct dentry *lower_dir_dentry;\n\tstruct inode *inode;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(ecryptfs_dentry);\n\tlower_dir_dentry = lock_parent(lower_dentry);\n\trc = vfs_create(lower_dir_dentry->d_inode, lower_dentry, mode, true);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Failure to create dentry in lower fs; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tinode = ERR_PTR(rc);\n\t\tgoto out_lock;\n\t}\n\tinode = __ecryptfs_get_inode(lower_dentry->d_inode,\n\t\t\t\t     directory_inode->i_sb);\n\tif (IS_ERR(inode)) {\n\t\tvfs_unlink(lower_dir_dentry->d_inode, lower_dentry, NULL);\n\t\tgoto out_lock;\n\t}\n\tfsstack_copy_attr_times(directory_inode, lower_dir_dentry->d_inode);\n\tfsstack_copy_inode_size(directory_inode, lower_dir_dentry->d_inode);\nout_lock:\n\tunlock_dir(lower_dir_dentry);\n\treturn inode;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic struct inode *\necryptfs_do_create(struct inode *directory_inode,\n\t\t   struct dentry *ecryptfs_dentry, umode_t mode)\n{\n\tint rc;\n\tstruct dentry *lower_dentry;\n\tstruct dentry *lower_dir_dentry;\n\tstruct inode *inode;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(ecryptfs_dentry);\n\tlower_dir_dentry = lock_parent(lower_dentry);\n\trc = vfs_create(lower_dir_dentry->d_inode, lower_dentry, mode, true);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Failure to create dentry in lower fs; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tinode = ERR_PTR(rc);\n\t\tgoto out_lock;\n\t}\n\tinode = __ecryptfs_get_inode(lower_dentry->d_inode,\n\t\t\t\t     directory_inode->i_sb);\n\tif (IS_ERR(inode)) {\n\t\tvfs_unlink(lower_dir_dentry->d_inode, lower_dentry, NULL);\n\t\tgoto out_lock;\n\t}\n\tfsstack_copy_attr_times(directory_inode, lower_dir_dentry->d_inode);\n\tfsstack_copy_inode_size(directory_inode, lower_dir_dentry->d_inode);\nout_lock:\n\tunlock_dir(lower_dir_dentry);\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int\necryptfs_create(struct inode *directory_inode, struct dentry *ecryptfs_dentry,\n\t\tumode_t mode, bool excl)\n{\n\tstruct inode *ecryptfs_inode;\n\tint rc;\n\n\tecryptfs_inode = ecryptfs_do_create(directory_inode, ecryptfs_dentry,\n\t\t\t\t\t    mode);\n\tif (unlikely(IS_ERR(ecryptfs_inode))) {\n\t\tecryptfs_printk(KERN_WARNING, \"Failed to create file in\"\n\t\t\t\t\"lower filesystem\\n\");\n\t\trc = PTR_ERR(ecryptfs_inode);\n\t\tgoto out;\n\t}\n\t/* At this point, a file exists on \"disk\"; we need to make sure\n\t * that this on disk file is prepared to be an ecryptfs file */\n\trc = ecryptfs_initialize_file(ecryptfs_dentry, ecryptfs_inode);\n\tif (rc) {\n\t\tecryptfs_do_unlink(directory_inode, ecryptfs_dentry,\n\t\t\t\t   ecryptfs_inode);\n\t\tmake_bad_inode(ecryptfs_inode);\n\t\tunlock_new_inode(ecryptfs_inode);\n\t\tiput(ecryptfs_inode);\n\t\tgoto out;\n\t}\n\tunlock_new_inode(ecryptfs_inode);\n\td_instantiate(ecryptfs_dentry, ecryptfs_inode);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_initialize_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "220-253",
    "snippet": "int ecryptfs_initialize_file(struct dentry *ecryptfs_dentry,\n\t\t\t     struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tint rc = 0;\n\n\tif (S_ISDIR(ecryptfs_inode->i_mode)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"This is a directory\\n\");\n\t\tcrypt_stat->flags &= ~(ECRYPTFS_ENCRYPTED);\n\t\tgoto out;\n\t}\n\tecryptfs_printk(KERN_DEBUG, \"Initializing crypto context\\n\");\n\trc = ecryptfs_new_file_context(ecryptfs_inode);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error creating new file \"\n\t\t\t\t\"context; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_get_lower_file(ecryptfs_dentry, ecryptfs_inode);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to initialize \"\n\t\t\t\"the lower file for the dentry with name \"\n\t\t\t\"[%pd]; rc = [%d]\\n\", __func__,\n\t\t\tecryptfs_dentry, rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_write_metadata(ecryptfs_dentry, ecryptfs_inode);\n\tif (rc)\n\t\tprintk(KERN_ERR \"Error writing headers; rc = [%d]\\n\", rc);\n\tecryptfs_put_lower_file(ecryptfs_inode);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_put_lower_file",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_put_lower_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "157-169",
          "snippet": "void ecryptfs_put_lower_file(struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tif (atomic_dec_and_mutex_lock(&inode_info->lower_file_count,\n\t\t\t\t      &inode_info->lower_file_mutex)) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tfput(inode_info->lower_file);\n\t\tinode_info->lower_file = NULL;\n\t\tmutex_unlock(&inode_info->lower_file_mutex);\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nvoid ecryptfs_put_lower_file(struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tif (atomic_dec_and_mutex_lock(&inode_info->lower_file_count,\n\t\t\t\t      &inode_info->lower_file_mutex)) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tfput(inode_info->lower_file);\n\t\tinode_info->lower_file = NULL;\n\t\tmutex_unlock(&inode_info->lower_file_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Error writing headers; rc = [%d]\\n\"",
            "rc"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_metadata",
          "args": [
            "ecryptfs_dentry",
            "ecryptfs_inode"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1185-1240",
          "snippet": "int ecryptfs_write_metadata(struct dentry *ecryptfs_dentry,\n\t\t\t    struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tunsigned int order;\n\tchar *virt;\n\tsize_t virt_len;\n\tsize_t size = 0;\n\tint rc = 0;\n\n\tif (likely(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\tif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {\n\t\t\tprintk(KERN_ERR \"Key is invalid; bailing out\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tprintk(KERN_WARNING \"%s: Encrypted flag not set\\n\",\n\t\t       __func__);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tvirt_len = crypt_stat->metadata_size;\n\torder = get_order(virt_len);\n\t/* Released in this function */\n\tvirt = (char *)ecryptfs_get_zeroed_pages(GFP_KERNEL, order);\n\tif (!virt) {\n\t\tprintk(KERN_ERR \"%s: Out of memory\\n\", __func__);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\t/* Zeroed page ensures the in-header unencrypted i_size is set to 0 */\n\trc = ecryptfs_write_headers_virt(virt, virt_len, &size, crypt_stat,\n\t\t\t\t\t ecryptfs_dentry);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"%s: Error whilst writing headers; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_free;\n\t}\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\trc = ecryptfs_write_metadata_to_xattr(ecryptfs_dentry, virt,\n\t\t\t\t\t\t      size);\n\telse\n\t\trc = ecryptfs_write_metadata_to_contents(ecryptfs_inode, virt,\n\t\t\t\t\t\t\t virt_len);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error writing metadata out to lower file; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_free;\n\t}\nout_free:\n\tfree_pages((unsigned long)virt, order);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_write_metadata(struct dentry *ecryptfs_dentry,\n\t\t\t    struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tunsigned int order;\n\tchar *virt;\n\tsize_t virt_len;\n\tsize_t size = 0;\n\tint rc = 0;\n\n\tif (likely(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\tif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {\n\t\t\tprintk(KERN_ERR \"Key is invalid; bailing out\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tprintk(KERN_WARNING \"%s: Encrypted flag not set\\n\",\n\t\t       __func__);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tvirt_len = crypt_stat->metadata_size;\n\torder = get_order(virt_len);\n\t/* Released in this function */\n\tvirt = (char *)ecryptfs_get_zeroed_pages(GFP_KERNEL, order);\n\tif (!virt) {\n\t\tprintk(KERN_ERR \"%s: Out of memory\\n\", __func__);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\t/* Zeroed page ensures the in-header unencrypted i_size is set to 0 */\n\trc = ecryptfs_write_headers_virt(virt, virt_len, &size, crypt_stat,\n\t\t\t\t\t ecryptfs_dentry);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"%s: Error whilst writing headers; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_free;\n\t}\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\trc = ecryptfs_write_metadata_to_xattr(ecryptfs_dentry, virt,\n\t\t\t\t\t\t      size);\n\telse\n\t\trc = ecryptfs_write_metadata_to_contents(ecryptfs_inode, virt,\n\t\t\t\t\t\t\t virt_len);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error writing metadata out to lower file; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_free;\n\t}\nout_free:\n\tfree_pages((unsigned long)virt, order);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_lower_file",
          "args": [
            "ecryptfs_dentry",
            "ecryptfs_inode"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_lower_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "137-155",
          "snippet": "int ecryptfs_get_lower_file(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\tint count, rc = 0;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tmutex_lock(&inode_info->lower_file_mutex);\n\tcount = atomic_inc_return(&inode_info->lower_file_count);\n\tif (WARN_ON_ONCE(count < 1))\n\t\trc = -EINVAL;\n\telse if (count == 1) {\n\t\trc = ecryptfs_init_lower_file(dentry,\n\t\t\t\t\t      &inode_info->lower_file);\n\t\tif (rc)\n\t\t\tatomic_set(&inode_info->lower_file_count, 0);\n\t}\n\tmutex_unlock(&inode_info->lower_file_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_get_lower_file(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\tint count, rc = 0;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tmutex_lock(&inode_info->lower_file_mutex);\n\tcount = atomic_inc_return(&inode_info->lower_file_count);\n\tif (WARN_ON_ONCE(count < 1))\n\t\trc = -EINVAL;\n\telse if (count == 1) {\n\t\trc = ecryptfs_init_lower_file(dentry,\n\t\t\t\t\t      &inode_info->lower_file);\n\t\tif (rc)\n\t\t\tatomic_set(&inode_info->lower_file_count, 0);\n\t}\n\tmutex_unlock(&inode_info->lower_file_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_new_file_context",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_new_file_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "820-857",
          "snippet": "int ecryptfs_new_file_context(struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t    &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t    &ecryptfs_superblock_to_private(\n\t\t    ecryptfs_inode->i_sb)->mount_crypt_stat;\n\tint cipher_name_len;\n\tint rc = 0;\n\n\tecryptfs_set_default_crypt_stat_vals(crypt_stat, mount_crypt_stat);\n\tcrypt_stat->flags |= (ECRYPTFS_ENCRYPTED | ECRYPTFS_KEY_VALID);\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\trc = ecryptfs_copy_mount_wide_sigs_to_inode_sigs(crypt_stat,\n\t\t\t\t\t\t\t mount_crypt_stat);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to copy mount-wide key sigs \"\n\t\t       \"to the inode key sigs; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tcipher_name_len =\n\t\tstrlen(mount_crypt_stat->global_default_cipher_name);\n\tmemcpy(crypt_stat->cipher,\n\t       mount_crypt_stat->global_default_cipher_name,\n\t       cipher_name_len);\n\tcrypt_stat->cipher[cipher_name_len] = '\\0';\n\tcrypt_stat->key_size =\n\t\tmount_crypt_stat->global_default_cipher_key_size;\n\tecryptfs_generate_new_key(crypt_stat);\n\trc = ecryptfs_init_crypt_ctx(crypt_stat);\n\tif (rc)\n\t\tecryptfs_printk(KERN_ERR, \"Error initializing cryptographic \"\n\t\t\t\t\"context for cipher [%s]: rc = [%d]\\n\",\n\t\t\t\tcrypt_stat->cipher, rc);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_new_file_context(struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t    &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t    &ecryptfs_superblock_to_private(\n\t\t    ecryptfs_inode->i_sb)->mount_crypt_stat;\n\tint cipher_name_len;\n\tint rc = 0;\n\n\tecryptfs_set_default_crypt_stat_vals(crypt_stat, mount_crypt_stat);\n\tcrypt_stat->flags |= (ECRYPTFS_ENCRYPTED | ECRYPTFS_KEY_VALID);\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\trc = ecryptfs_copy_mount_wide_sigs_to_inode_sigs(crypt_stat,\n\t\t\t\t\t\t\t mount_crypt_stat);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to copy mount-wide key sigs \"\n\t\t       \"to the inode key sigs; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tcipher_name_len =\n\t\tstrlen(mount_crypt_stat->global_default_cipher_name);\n\tmemcpy(crypt_stat->cipher,\n\t       mount_crypt_stat->global_default_cipher_name,\n\t       cipher_name_len);\n\tcrypt_stat->cipher[cipher_name_len] = '\\0';\n\tcrypt_stat->key_size =\n\t\tmount_crypt_stat->global_default_cipher_key_size;\n\tecryptfs_generate_new_key(crypt_stat);\n\trc = ecryptfs_init_crypt_ctx(crypt_stat);\n\tif (rc)\n\t\tecryptfs_printk(KERN_ERR, \"Error initializing cryptographic \"\n\t\t\t\t\"context for cipher [%s]: rc = [%d]\\n\",\n\t\t\t\tcrypt_stat->cipher, rc);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ecryptfs_inode->i_mode"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nint ecryptfs_initialize_file(struct dentry *ecryptfs_dentry,\n\t\t\t     struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tint rc = 0;\n\n\tif (S_ISDIR(ecryptfs_inode->i_mode)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"This is a directory\\n\");\n\t\tcrypt_stat->flags &= ~(ECRYPTFS_ENCRYPTED);\n\t\tgoto out;\n\t}\n\tecryptfs_printk(KERN_DEBUG, \"Initializing crypto context\\n\");\n\trc = ecryptfs_new_file_context(ecryptfs_inode);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error creating new file \"\n\t\t\t\t\"context; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_get_lower_file(ecryptfs_dentry, ecryptfs_inode);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to initialize \"\n\t\t\t\"the lower file for the dentry with name \"\n\t\t\t\"[%pd]; rc = [%d]\\n\", __func__,\n\t\t\tecryptfs_dentry, rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_write_metadata(ecryptfs_dentry, ecryptfs_inode);\n\tif (rc)\n\t\tprintk(KERN_ERR \"Error writing headers; rc = [%d]\\n\", rc);\n\tecryptfs_put_lower_file(ecryptfs_inode);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_do_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "181-210",
    "snippet": "static struct inode *\necryptfs_do_create(struct inode *directory_inode,\n\t\t   struct dentry *ecryptfs_dentry, umode_t mode)\n{\n\tint rc;\n\tstruct dentry *lower_dentry;\n\tstruct dentry *lower_dir_dentry;\n\tstruct inode *inode;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(ecryptfs_dentry);\n\tlower_dir_dentry = lock_parent(lower_dentry);\n\trc = vfs_create(lower_dir_dentry->d_inode, lower_dentry, mode, true);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Failure to create dentry in lower fs; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tinode = ERR_PTR(rc);\n\t\tgoto out_lock;\n\t}\n\tinode = __ecryptfs_get_inode(lower_dentry->d_inode,\n\t\t\t\t     directory_inode->i_sb);\n\tif (IS_ERR(inode)) {\n\t\tvfs_unlink(lower_dir_dentry->d_inode, lower_dentry, NULL);\n\t\tgoto out_lock;\n\t}\n\tfsstack_copy_attr_times(directory_inode, lower_dir_dentry->d_inode);\n\tfsstack_copy_inode_size(directory_inode, lower_dir_dentry->d_inode);\nout_lock:\n\tunlock_dir(lower_dir_dentry);\n\treturn inode;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_dir",
          "args": [
            "lower_dir_dentry"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "48-52",
          "snippet": "static void unlock_dir(struct dentry *dir)\n{\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic void unlock_dir(struct dentry *dir)\n{\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsstack_copy_inode_size",
          "args": [
            "directory_inode",
            "lower_dir_dentry->d_inode"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "fsstack_copy_inode_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stack.c",
          "lines": "10-59",
          "snippet": "void fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n\tloff_t i_size;\n\tblkcnt_t i_blocks;\n\n\t/*\n\t * i_size_read() includes its own seqlocking and protection from\n\t * preemption (see include/linux/fs.h): we need nothing extra for\n\t * that here, and prefer to avoid nesting locks than attempt to keep\n\t * i_size and i_blocks in sync together.\n\t */\n\ti_size = i_size_read(src);\n\n\t/*\n\t * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to\n\t * keep the two halves of i_blocks in sync despite SMP or PREEMPT -\n\t * though stat's generic_fillattr() doesn't bother, and we won't be\n\t * applying quotas (where i_blocks does become important) at the\n\t * upper level.\n\t *\n\t * We don't actually know what locking is used at the lower level;\n\t * but if it's a filesystem that supports quotas, it will be using\n\t * i_lock as in inode_add_bytes().\n\t */\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&src->i_lock);\n\ti_blocks = src->i_blocks;\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&src->i_lock);\n\n\t/*\n\t * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for\n\t * fsstack_copy_inode_size() to hold some lock around\n\t * i_size_write(), otherwise i_size_read() may spin forever (see\n\t * include/linux/fs.h).  We don't necessarily hold i_mutex when this\n\t * is called, so take i_lock for that case.\n\t *\n\t * And if CONFIG_LBDAF (on 32-bit), continue our effort to keep the\n\t * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock\n\t * for that case too, and do both at once by combining the tests.\n\t *\n\t * There is none of this locking overhead in the 64-bit case.\n\t */\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&dst->i_lock);\n\ti_size_write(dst, i_size);\n\tdst->i_blocks = i_blocks;\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&dst->i_lock);\n}",
          "includes": [
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n\tloff_t i_size;\n\tblkcnt_t i_blocks;\n\n\t/*\n\t * i_size_read() includes its own seqlocking and protection from\n\t * preemption (see include/linux/fs.h): we need nothing extra for\n\t * that here, and prefer to avoid nesting locks than attempt to keep\n\t * i_size and i_blocks in sync together.\n\t */\n\ti_size = i_size_read(src);\n\n\t/*\n\t * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to\n\t * keep the two halves of i_blocks in sync despite SMP or PREEMPT -\n\t * though stat's generic_fillattr() doesn't bother, and we won't be\n\t * applying quotas (where i_blocks does become important) at the\n\t * upper level.\n\t *\n\t * We don't actually know what locking is used at the lower level;\n\t * but if it's a filesystem that supports quotas, it will be using\n\t * i_lock as in inode_add_bytes().\n\t */\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&src->i_lock);\n\ti_blocks = src->i_blocks;\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&src->i_lock);\n\n\t/*\n\t * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for\n\t * fsstack_copy_inode_size() to hold some lock around\n\t * i_size_write(), otherwise i_size_read() may spin forever (see\n\t * include/linux/fs.h).  We don't necessarily hold i_mutex when this\n\t * is called, so take i_lock for that case.\n\t *\n\t * And if CONFIG_LBDAF (on 32-bit), continue our effort to keep the\n\t * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock\n\t * for that case too, and do both at once by combining the tests.\n\t *\n\t * There is none of this locking overhead in the 64-bit case.\n\t */\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&dst->i_lock);\n\ti_size_write(dst, i_size);\n\tdst->i_blocks = i_blocks;\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&dst->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsstack_copy_attr_times",
          "args": [
            "directory_inode",
            "lower_dir_dentry->d_inode"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_unlink",
          "args": [
            "lower_dir_dentry->d_inode",
            "lower_dentry",
            "NULL"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3715-3752",
          "snippet": "int vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)\n{\n\tstruct inode *target = dentry->d_inode;\n\tint error = may_delete(dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tmutex_lock(&target->i_mutex);\n\tif (is_local_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = try_break_deleg(target, delegated_inode);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error) {\n\t\t\t\tdont_mount(dentry);\n\t\t\t\tdetach_mounts(dentry);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tmutex_unlock(&target->i_mutex);\n\n\t/* We don't d_delete() NFS sillyrenamed files--they still exist. */\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(target);\n\t\td_delete(dentry);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)\n{\n\tstruct inode *target = dentry->d_inode;\n\tint error = may_delete(dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tmutex_lock(&target->i_mutex);\n\tif (is_local_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = try_break_deleg(target, delegated_inode);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error) {\n\t\t\t\tdont_mount(dentry);\n\t\t\t\tdetach_mounts(dentry);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tmutex_unlock(&target->i_mutex);\n\n\t/* We don't d_delete() NFS sillyrenamed files--they still exist. */\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(target);\n\t\td_delete(dentry);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ecryptfs_get_inode",
          "args": [
            "lower_dentry->d_inode",
            "directory_inode->i_sb"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "88-108",
          "snippet": "static struct inode *__ecryptfs_get_inode(struct inode *lower_inode,\n\t\t\t\t\t  struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (lower_inode->i_sb != ecryptfs_superblock_to_lower(sb))\n\t\treturn ERR_PTR(-EXDEV);\n\tif (!igrab(lower_inode))\n\t\treturn ERR_PTR(-ESTALE);\n\tinode = iget5_locked(sb, (unsigned long)lower_inode,\n\t\t\t     ecryptfs_inode_test, ecryptfs_inode_set,\n\t\t\t     lower_inode);\n\tif (!inode) {\n\t\tiput(lower_inode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\tif (!(inode->i_state & I_NEW))\n\t\tiput(lower_inode);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic struct inode *__ecryptfs_get_inode(struct inode *lower_inode,\n\t\t\t\t\t  struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (lower_inode->i_sb != ecryptfs_superblock_to_lower(sb))\n\t\treturn ERR_PTR(-EXDEV);\n\tif (!igrab(lower_inode))\n\t\treturn ERR_PTR(-ESTALE);\n\tinode = iget5_locked(sb, (unsigned long)lower_inode,\n\t\t\t     ecryptfs_inode_test, ecryptfs_inode_set,\n\t\t\t     lower_inode);\n\tif (!inode) {\n\t\tiput(lower_inode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\tif (!(inode->i_state & I_NEW))\n\t\tiput(lower_inode);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Failure to create dentry in lower fs; \"\n\t\t       \"rc = [%d]\\n\"",
            "__func__",
            "rc"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_create",
          "args": [
            "lower_dir_dentry->d_inode",
            "lower_dentry",
            "mode",
            "true"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2547-2565",
          "snippet": "int vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool want_excl)\n{\n\tint error = may_create(dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->create)\n\t\treturn -EACCES;\t/* shouldn't it be ENOSYS? */\n\tmode &= S_IALLUGO;\n\tmode |= S_IFREG;\n\terror = security_inode_create(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\terror = dir->i_op->create(dir, dentry, mode, want_excl);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool want_excl)\n{\n\tint error = may_create(dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->create)\n\t\treturn -EACCES;\t/* shouldn't it be ENOSYS? */\n\tmode &= S_IALLUGO;\n\tmode |= S_IFREG;\n\terror = security_inode_create(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\terror = dir->i_op->create(dir, dentry, mode, want_excl);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_parent",
          "args": [
            "lower_dentry"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "lock_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "39-46",
          "snippet": "static struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *dir;\n\n\tdir = dget_parent(dentry);\n\tmutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);\n\treturn dir;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *dir;\n\n\tdir = dget_parent(dentry);\n\tmutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);\n\treturn dir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower",
          "args": [
            "ecryptfs_dentry"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic struct inode *\necryptfs_do_create(struct inode *directory_inode,\n\t\t   struct dentry *ecryptfs_dentry, umode_t mode)\n{\n\tint rc;\n\tstruct dentry *lower_dentry;\n\tstruct dentry *lower_dir_dentry;\n\tstruct inode *inode;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(ecryptfs_dentry);\n\tlower_dir_dentry = lock_parent(lower_dentry);\n\trc = vfs_create(lower_dir_dentry->d_inode, lower_dentry, mode, true);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Failure to create dentry in lower fs; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tinode = ERR_PTR(rc);\n\t\tgoto out_lock;\n\t}\n\tinode = __ecryptfs_get_inode(lower_dentry->d_inode,\n\t\t\t\t     directory_inode->i_sb);\n\tif (IS_ERR(inode)) {\n\t\tvfs_unlink(lower_dir_dentry->d_inode, lower_dentry, NULL);\n\t\tgoto out_lock;\n\t}\n\tfsstack_copy_attr_times(directory_inode, lower_dir_dentry->d_inode);\n\tfsstack_copy_inode_size(directory_inode, lower_dir_dentry->d_inode);\nout_lock:\n\tunlock_dir(lower_dir_dentry);\n\treturn inode;\n}"
  },
  {
    "function_name": "ecryptfs_do_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "143-166",
    "snippet": "static int ecryptfs_do_unlink(struct inode *dir, struct dentry *dentry,\n\t\t\t      struct inode *inode)\n{\n\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tstruct inode *lower_dir_inode = ecryptfs_inode_to_lower(dir);\n\tstruct dentry *lower_dir_dentry;\n\tint rc;\n\n\tdget(lower_dentry);\n\tlower_dir_dentry = lock_parent(lower_dentry);\n\trc = vfs_unlink(lower_dir_inode, lower_dentry, NULL);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error in vfs_unlink; rc = [%d]\\n\", rc);\n\t\tgoto out_unlock;\n\t}\n\tfsstack_copy_attr_times(dir, lower_dir_inode);\n\tset_nlink(inode, ecryptfs_inode_to_lower(inode)->i_nlink);\n\tinode->i_ctime = dir->i_ctime;\n\td_drop(dentry);\nout_unlock:\n\tunlock_dir(lower_dir_dentry);\n\tdput(lower_dentry);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "lower_dentry"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_dir",
          "args": [
            "lower_dir_dentry"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "48-52",
          "snippet": "static void unlock_dir(struct dentry *dir)\n{\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic void unlock_dir(struct dentry *dir)\n{\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "ecryptfs_inode_to_lower(inode)->i_nlink"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_lower",
          "args": [
            "inode"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "462-465",
          "snippet": "static inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsstack_copy_attr_times",
          "args": [
            "dir",
            "lower_dir_inode"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Error in vfs_unlink; rc = [%d]\\n\"",
            "rc"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_unlink",
          "args": [
            "lower_dir_inode",
            "lower_dentry",
            "NULL"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3715-3752",
          "snippet": "int vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)\n{\n\tstruct inode *target = dentry->d_inode;\n\tint error = may_delete(dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tmutex_lock(&target->i_mutex);\n\tif (is_local_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = try_break_deleg(target, delegated_inode);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error) {\n\t\t\t\tdont_mount(dentry);\n\t\t\t\tdetach_mounts(dentry);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tmutex_unlock(&target->i_mutex);\n\n\t/* We don't d_delete() NFS sillyrenamed files--they still exist. */\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(target);\n\t\td_delete(dentry);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)\n{\n\tstruct inode *target = dentry->d_inode;\n\tint error = may_delete(dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tmutex_lock(&target->i_mutex);\n\tif (is_local_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = try_break_deleg(target, delegated_inode);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error) {\n\t\t\t\tdont_mount(dentry);\n\t\t\t\tdetach_mounts(dentry);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tmutex_unlock(&target->i_mutex);\n\n\t/* We don't d_delete() NFS sillyrenamed files--they still exist. */\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(target);\n\t\td_delete(dentry);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_parent",
          "args": [
            "lower_dentry"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "lock_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "39-46",
          "snippet": "static struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *dir;\n\n\tdir = dget_parent(dentry);\n\tmutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);\n\treturn dir;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *dir;\n\n\tdir = dget_parent(dentry);\n\tmutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);\n\treturn dir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "lower_dentry"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower",
          "args": [
            "dentry"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_do_unlink(struct inode *dir, struct dentry *dentry,\n\t\t\t      struct inode *inode)\n{\n\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tstruct inode *lower_dir_inode = ecryptfs_inode_to_lower(dir);\n\tstruct dentry *lower_dir_dentry;\n\tint rc;\n\n\tdget(lower_dentry);\n\tlower_dir_dentry = lock_parent(lower_dentry);\n\trc = vfs_unlink(lower_dir_inode, lower_dentry, NULL);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error in vfs_unlink; rc = [%d]\\n\", rc);\n\t\tgoto out_unlock;\n\t}\n\tfsstack_copy_attr_times(dir, lower_dir_inode);\n\tset_nlink(inode, ecryptfs_inode_to_lower(inode)->i_nlink);\n\tinode->i_ctime = dir->i_ctime;\n\td_drop(dentry);\nout_unlock:\n\tunlock_dir(lower_dir_dentry);\n\tdput(lower_dentry);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_interpose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "131-141",
    "snippet": "static int ecryptfs_interpose(struct dentry *lower_dentry,\n\t\t\t      struct dentry *dentry, struct super_block *sb)\n{\n\tstruct inode *inode = ecryptfs_get_inode(lower_dentry->d_inode, sb);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_inode",
          "args": [
            "lower_dentry->d_inode",
            "sb"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "110-119",
          "snippet": "struct inode *ecryptfs_get_inode(struct inode *lower_inode,\n\t\t\t\t struct super_block *sb)\n{\n\tstruct inode *inode = __ecryptfs_get_inode(lower_inode, sb);\n\n\tif (!IS_ERR(inode) && (inode->i_state & I_NEW))\n\t\tunlock_new_inode(inode);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstruct inode *ecryptfs_get_inode(struct inode *lower_inode,\n\t\t\t\t struct super_block *sb)\n{\n\tstruct inode *inode = __ecryptfs_get_inode(lower_inode, sb);\n\n\tif (!IS_ERR(inode) && (inode->i_state & I_NEW))\n\t\tunlock_new_inode(inode);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_interpose(struct dentry *lower_dentry,\n\t\t\t      struct dentry *dentry, struct super_block *sb)\n{\n\tstruct inode *inode = ecryptfs_get_inode(lower_dentry->d_inode, sb);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ecryptfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "110-119",
    "snippet": "struct inode *ecryptfs_get_inode(struct inode *lower_inode,\n\t\t\t\t struct super_block *sb)\n{\n\tstruct inode *inode = __ecryptfs_get_inode(lower_inode, sb);\n\n\tif (!IS_ERR(inode) && (inode->i_state & I_NEW))\n\t\tunlock_new_inode(inode);\n\n\treturn inode;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ecryptfs_get_inode",
          "args": [
            "lower_inode",
            "sb"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "88-108",
          "snippet": "static struct inode *__ecryptfs_get_inode(struct inode *lower_inode,\n\t\t\t\t\t  struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (lower_inode->i_sb != ecryptfs_superblock_to_lower(sb))\n\t\treturn ERR_PTR(-EXDEV);\n\tif (!igrab(lower_inode))\n\t\treturn ERR_PTR(-ESTALE);\n\tinode = iget5_locked(sb, (unsigned long)lower_inode,\n\t\t\t     ecryptfs_inode_test, ecryptfs_inode_set,\n\t\t\t     lower_inode);\n\tif (!inode) {\n\t\tiput(lower_inode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\tif (!(inode->i_state & I_NEW))\n\t\tiput(lower_inode);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic struct inode *__ecryptfs_get_inode(struct inode *lower_inode,\n\t\t\t\t\t  struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (lower_inode->i_sb != ecryptfs_superblock_to_lower(sb))\n\t\treturn ERR_PTR(-EXDEV);\n\tif (!igrab(lower_inode))\n\t\treturn ERR_PTR(-ESTALE);\n\tinode = iget5_locked(sb, (unsigned long)lower_inode,\n\t\t\t     ecryptfs_inode_test, ecryptfs_inode_set,\n\t\t\t     lower_inode);\n\tif (!inode) {\n\t\tiput(lower_inode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\tif (!(inode->i_state & I_NEW))\n\t\tiput(lower_inode);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstruct inode *ecryptfs_get_inode(struct inode *lower_inode,\n\t\t\t\t struct super_block *sb)\n{\n\tstruct inode *inode = __ecryptfs_get_inode(lower_inode, sb);\n\n\tif (!IS_ERR(inode) && (inode->i_state & I_NEW))\n\t\tunlock_new_inode(inode);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "__ecryptfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "88-108",
    "snippet": "static struct inode *__ecryptfs_get_inode(struct inode *lower_inode,\n\t\t\t\t\t  struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (lower_inode->i_sb != ecryptfs_superblock_to_lower(sb))\n\t\treturn ERR_PTR(-EXDEV);\n\tif (!igrab(lower_inode))\n\t\treturn ERR_PTR(-ESTALE);\n\tinode = iget5_locked(sb, (unsigned long)lower_inode,\n\t\t\t     ecryptfs_inode_test, ecryptfs_inode_set,\n\t\t\t     lower_inode);\n\tif (!inode) {\n\t\tiput(lower_inode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\tif (!(inode->i_state & I_NEW))\n\t\tiput(lower_inode);\n\n\treturn inode;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "lower_inode"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EACCES"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "sb",
            "(unsigned long)lower_inode",
            "ecryptfs_inode_test",
            "ecryptfs_inode_set",
            "lower_inode"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "lower_inode"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EXDEV"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_superblock_to_lower",
          "args": [
            "sb"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_superblock_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "486-490",
          "snippet": "static inline struct super_block *\necryptfs_superblock_to_lower(struct super_block *sb)\n{\n\treturn ((struct ecryptfs_sb_info *)sb->s_fs_info)->wsi_sb;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct super_block *\necryptfs_superblock_to_lower(struct super_block *sb)\n{\n\treturn ((struct ecryptfs_sb_info *)sb->s_fs_info)->wsi_sb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic struct inode *__ecryptfs_get_inode(struct inode *lower_inode,\n\t\t\t\t\t  struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (lower_inode->i_sb != ecryptfs_superblock_to_lower(sb))\n\t\treturn ERR_PTR(-EXDEV);\n\tif (!igrab(lower_inode))\n\t\treturn ERR_PTR(-ESTALE);\n\tinode = iget5_locked(sb, (unsigned long)lower_inode,\n\t\t\t     ecryptfs_inode_test, ecryptfs_inode_set,\n\t\t\t     lower_inode);\n\tif (!inode) {\n\t\tiput(lower_inode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\tif (!(inode->i_state & I_NEW))\n\t\tiput(lower_inode);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "ecryptfs_inode_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "59-86",
    "snippet": "static int ecryptfs_inode_set(struct inode *inode, void *opaque)\n{\n\tstruct inode *lower_inode = opaque;\n\n\tecryptfs_set_inode_lower(inode, lower_inode);\n\tfsstack_copy_attr_all(inode, lower_inode);\n\t/* i_size will be overwritten for encrypted regular files */\n\tfsstack_copy_inode_size(inode, lower_inode);\n\tinode->i_ino = lower_inode->i_ino;\n\tinode->i_version++;\n\tinode->i_mapping->a_ops = &ecryptfs_aops;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\tinode->i_op = &ecryptfs_symlink_iops;\n\telse if (S_ISDIR(inode->i_mode))\n\t\tinode->i_op = &ecryptfs_dir_iops;\n\telse\n\t\tinode->i_op = &ecryptfs_main_iops;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tinode->i_fop = &ecryptfs_dir_fops;\n\telse if (special_file(inode->i_mode))\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\telse\n\t\tinode->i_fop = &ecryptfs_main_fops;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations ecryptfs_symlink_iops = {\n\t.readlink = generic_readlink,\n\t.follow_link = ecryptfs_follow_link,\n\t.put_link = kfree_put_link,\n\t.permission = ecryptfs_permission,\n\t.setattr = ecryptfs_setattr,\n\t.getattr = ecryptfs_getattr_link,\n\t.setxattr = ecryptfs_setxattr,\n\t.getxattr = ecryptfs_getxattr,\n\t.listxattr = ecryptfs_listxattr,\n\t.removexattr = ecryptfs_removexattr\n};",
      "const struct inode_operations ecryptfs_dir_iops = {\n\t.create = ecryptfs_create,\n\t.lookup = ecryptfs_lookup,\n\t.link = ecryptfs_link,\n\t.unlink = ecryptfs_unlink,\n\t.symlink = ecryptfs_symlink,\n\t.mkdir = ecryptfs_mkdir,\n\t.rmdir = ecryptfs_rmdir,\n\t.mknod = ecryptfs_mknod,\n\t.rename = ecryptfs_rename,\n\t.permission = ecryptfs_permission,\n\t.setattr = ecryptfs_setattr,\n\t.setxattr = ecryptfs_setxattr,\n\t.getxattr = ecryptfs_getxattr,\n\t.listxattr = ecryptfs_listxattr,\n\t.removexattr = ecryptfs_removexattr\n};",
      "const struct inode_operations ecryptfs_main_iops = {\n\t.permission = ecryptfs_permission,\n\t.setattr = ecryptfs_setattr,\n\t.getattr = ecryptfs_getattr,\n\t.setxattr = ecryptfs_setxattr,\n\t.getxattr = ecryptfs_getxattr,\n\t.listxattr = ecryptfs_listxattr,\n\t.removexattr = ecryptfs_removexattr\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "inode->i_rdev"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "special_file",
          "args": [
            "inode->i_mode"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsstack_copy_inode_size",
          "args": [
            "inode",
            "lower_inode"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "fsstack_copy_inode_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stack.c",
          "lines": "10-59",
          "snippet": "void fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n\tloff_t i_size;\n\tblkcnt_t i_blocks;\n\n\t/*\n\t * i_size_read() includes its own seqlocking and protection from\n\t * preemption (see include/linux/fs.h): we need nothing extra for\n\t * that here, and prefer to avoid nesting locks than attempt to keep\n\t * i_size and i_blocks in sync together.\n\t */\n\ti_size = i_size_read(src);\n\n\t/*\n\t * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to\n\t * keep the two halves of i_blocks in sync despite SMP or PREEMPT -\n\t * though stat's generic_fillattr() doesn't bother, and we won't be\n\t * applying quotas (where i_blocks does become important) at the\n\t * upper level.\n\t *\n\t * We don't actually know what locking is used at the lower level;\n\t * but if it's a filesystem that supports quotas, it will be using\n\t * i_lock as in inode_add_bytes().\n\t */\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&src->i_lock);\n\ti_blocks = src->i_blocks;\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&src->i_lock);\n\n\t/*\n\t * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for\n\t * fsstack_copy_inode_size() to hold some lock around\n\t * i_size_write(), otherwise i_size_read() may spin forever (see\n\t * include/linux/fs.h).  We don't necessarily hold i_mutex when this\n\t * is called, so take i_lock for that case.\n\t *\n\t * And if CONFIG_LBDAF (on 32-bit), continue our effort to keep the\n\t * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock\n\t * for that case too, and do both at once by combining the tests.\n\t *\n\t * There is none of this locking overhead in the 64-bit case.\n\t */\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&dst->i_lock);\n\ti_size_write(dst, i_size);\n\tdst->i_blocks = i_blocks;\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&dst->i_lock);\n}",
          "includes": [
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n\tloff_t i_size;\n\tblkcnt_t i_blocks;\n\n\t/*\n\t * i_size_read() includes its own seqlocking and protection from\n\t * preemption (see include/linux/fs.h): we need nothing extra for\n\t * that here, and prefer to avoid nesting locks than attempt to keep\n\t * i_size and i_blocks in sync together.\n\t */\n\ti_size = i_size_read(src);\n\n\t/*\n\t * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to\n\t * keep the two halves of i_blocks in sync despite SMP or PREEMPT -\n\t * though stat's generic_fillattr() doesn't bother, and we won't be\n\t * applying quotas (where i_blocks does become important) at the\n\t * upper level.\n\t *\n\t * We don't actually know what locking is used at the lower level;\n\t * but if it's a filesystem that supports quotas, it will be using\n\t * i_lock as in inode_add_bytes().\n\t */\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&src->i_lock);\n\ti_blocks = src->i_blocks;\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&src->i_lock);\n\n\t/*\n\t * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for\n\t * fsstack_copy_inode_size() to hold some lock around\n\t * i_size_write(), otherwise i_size_read() may spin forever (see\n\t * include/linux/fs.h).  We don't necessarily hold i_mutex when this\n\t * is called, so take i_lock for that case.\n\t *\n\t * And if CONFIG_LBDAF (on 32-bit), continue our effort to keep the\n\t * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock\n\t * for that case too, and do both at once by combining the tests.\n\t *\n\t * There is none of this locking overhead in the 64-bit case.\n\t */\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&dst->i_lock);\n\ti_size_write(dst, i_size);\n\tdst->i_blocks = i_blocks;\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&dst->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsstack_copy_attr_all",
          "args": [
            "inode",
            "lower_inode"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "fsstack_copy_attr_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stack.c",
          "lines": "63-75",
          "snippet": "void fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\n\tdest->i_mode = src->i_mode;\n\tdest->i_uid = src->i_uid;\n\tdest->i_gid = src->i_gid;\n\tdest->i_rdev = src->i_rdev;\n\tdest->i_atime = src->i_atime;\n\tdest->i_mtime = src->i_mtime;\n\tdest->i_ctime = src->i_ctime;\n\tdest->i_blkbits = src->i_blkbits;\n\tdest->i_flags = src->i_flags;\n\tset_nlink(dest, src->i_nlink);\n}",
          "includes": [
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\n\tdest->i_mode = src->i_mode;\n\tdest->i_uid = src->i_uid;\n\tdest->i_gid = src->i_gid;\n\tdest->i_rdev = src->i_rdev;\n\tdest->i_atime = src->i_atime;\n\tdest->i_mtime = src->i_mtime;\n\tdest->i_ctime = src->i_ctime;\n\tdest->i_blkbits = src->i_blkbits;\n\tdest->i_flags = src->i_flags;\n\tset_nlink(dest, src->i_nlink);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_set_inode_lower",
          "args": [
            "inode",
            "lower_inode"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_set_inode_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "467-471",
          "snippet": "static inline void\necryptfs_set_inode_lower(struct inode *inode, struct inode *lower_inode)\n{\n\tecryptfs_inode_to_private(inode)->wii_inode = lower_inode;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline void\necryptfs_set_inode_lower(struct inode *inode, struct inode *lower_inode)\n{\n\tecryptfs_inode_to_private(inode)->wii_inode = lower_inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nconst struct inode_operations ecryptfs_symlink_iops = {\n\t.readlink = generic_readlink,\n\t.follow_link = ecryptfs_follow_link,\n\t.put_link = kfree_put_link,\n\t.permission = ecryptfs_permission,\n\t.setattr = ecryptfs_setattr,\n\t.getattr = ecryptfs_getattr_link,\n\t.setxattr = ecryptfs_setxattr,\n\t.getxattr = ecryptfs_getxattr,\n\t.listxattr = ecryptfs_listxattr,\n\t.removexattr = ecryptfs_removexattr\n};\nconst struct inode_operations ecryptfs_dir_iops = {\n\t.create = ecryptfs_create,\n\t.lookup = ecryptfs_lookup,\n\t.link = ecryptfs_link,\n\t.unlink = ecryptfs_unlink,\n\t.symlink = ecryptfs_symlink,\n\t.mkdir = ecryptfs_mkdir,\n\t.rmdir = ecryptfs_rmdir,\n\t.mknod = ecryptfs_mknod,\n\t.rename = ecryptfs_rename,\n\t.permission = ecryptfs_permission,\n\t.setattr = ecryptfs_setattr,\n\t.setxattr = ecryptfs_setxattr,\n\t.getxattr = ecryptfs_getxattr,\n\t.listxattr = ecryptfs_listxattr,\n\t.removexattr = ecryptfs_removexattr\n};\nconst struct inode_operations ecryptfs_main_iops = {\n\t.permission = ecryptfs_permission,\n\t.setattr = ecryptfs_setattr,\n\t.getattr = ecryptfs_getattr,\n\t.setxattr = ecryptfs_setxattr,\n\t.getxattr = ecryptfs_getxattr,\n\t.listxattr = ecryptfs_listxattr,\n\t.removexattr = ecryptfs_removexattr\n};\n\nstatic int ecryptfs_inode_set(struct inode *inode, void *opaque)\n{\n\tstruct inode *lower_inode = opaque;\n\n\tecryptfs_set_inode_lower(inode, lower_inode);\n\tfsstack_copy_attr_all(inode, lower_inode);\n\t/* i_size will be overwritten for encrypted regular files */\n\tfsstack_copy_inode_size(inode, lower_inode);\n\tinode->i_ino = lower_inode->i_ino;\n\tinode->i_version++;\n\tinode->i_mapping->a_ops = &ecryptfs_aops;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\tinode->i_op = &ecryptfs_symlink_iops;\n\telse if (S_ISDIR(inode->i_mode))\n\t\tinode->i_op = &ecryptfs_dir_iops;\n\telse\n\t\tinode->i_op = &ecryptfs_main_iops;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tinode->i_fop = &ecryptfs_dir_fops;\n\telse if (special_file(inode->i_mode))\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\telse\n\t\tinode->i_fop = &ecryptfs_main_fops;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ecryptfs_inode_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "54-57",
    "snippet": "static int ecryptfs_inode_test(struct inode *inode, void *lower_inode)\n{\n\treturn ecryptfs_inode_to_lower(inode) == lower_inode;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_lower",
          "args": [
            "inode"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "462-465",
          "snippet": "static inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_inode_test(struct inode *inode, void *lower_inode)\n{\n\treturn ecryptfs_inode_to_lower(inode) == lower_inode;\n}"
  },
  {
    "function_name": "unlock_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "48-52",
    "snippet": "static void unlock_dir(struct dentry *dir)\n{\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dir"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic void unlock_dir(struct dentry *dir)\n{\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n}"
  },
  {
    "function_name": "lock_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
    "lines": "39-46",
    "snippet": "static struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *dir;\n\n\tdir = dget_parent(dentry);\n\tmutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);\n\treturn dir;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/crypto.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&(dir->d_inode->i_mutex)",
            "I_MUTEX_PARENT"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *dir;\n\n\tdir = dget_parent(dentry);\n\tmutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);\n\treturn dir;\n}"
  }
]