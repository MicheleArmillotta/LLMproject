[
  {
    "function_name": "gfs2_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "1374-1392",
    "snippet": "static void gfs2_kill_sb(struct super_block *sb)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\n\tif (sdp == NULL) {\n\t\tkill_block_super(sb);\n\t\treturn;\n\t}\n\n\tgfs2_log_flush(sdp, NULL, SYNC_FLUSH);\n\tdput(sdp->sd_root_dir);\n\tdput(sdp->sd_master_dir);\n\tsdp->sd_root_dir = NULL;\n\tsdp->sd_master_dir = NULL;\n\tshrink_dcache_sb(sb);\n\tgfs2_delete_debugfs_file(sdp);\n\tfree_percpu(sdp->sd_lkstats);\n\tkill_block_super(sb);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_block_super",
          "args": [
            "sb"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_kill_block_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "629-638",
          "snippet": "static void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_sb_info_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstruct kmem_cache *ecryptfs_sb_info_cache;\n\nstatic void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "sdp->sd_lkstats"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_delete_debugfs_file",
          "args": [
            "sdp"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_delete_debugfs_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "2080-2098",
          "snippet": "void gfs2_delete_debugfs_file(struct gfs2_sbd *sdp)\n{\n\tif (sdp->debugfs_dir) {\n\t\tif (sdp->debugfs_dentry_glocks) {\n\t\t\tdebugfs_remove(sdp->debugfs_dentry_glocks);\n\t\t\tsdp->debugfs_dentry_glocks = NULL;\n\t\t}\n\t\tif (sdp->debugfs_dentry_glstats) {\n\t\t\tdebugfs_remove(sdp->debugfs_dentry_glstats);\n\t\t\tsdp->debugfs_dentry_glstats = NULL;\n\t\t}\n\t\tif (sdp->debugfs_dentry_sbstats) {\n\t\t\tdebugfs_remove(sdp->debugfs_dentry_sbstats);\n\t\t\tsdp->debugfs_dentry_sbstats = NULL;\n\t\t}\n\t\tdebugfs_remove(sdp->debugfs_dir);\n\t\tsdp->debugfs_dir = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_delete_debugfs_file(struct gfs2_sbd *sdp)\n{\n\tif (sdp->debugfs_dir) {\n\t\tif (sdp->debugfs_dentry_glocks) {\n\t\t\tdebugfs_remove(sdp->debugfs_dentry_glocks);\n\t\t\tsdp->debugfs_dentry_glocks = NULL;\n\t\t}\n\t\tif (sdp->debugfs_dentry_glstats) {\n\t\t\tdebugfs_remove(sdp->debugfs_dentry_glstats);\n\t\t\tsdp->debugfs_dentry_glstats = NULL;\n\t\t}\n\t\tif (sdp->debugfs_dentry_sbstats) {\n\t\t\tdebugfs_remove(sdp->debugfs_dentry_sbstats);\n\t\t\tsdp->debugfs_dentry_sbstats = NULL;\n\t\t}\n\t\tdebugfs_remove(sdp->debugfs_dir);\n\t\tsdp->debugfs_dir = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_dcache_sb",
          "args": [
            "sb"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dcache_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1094-1107",
          "snippet": "void shrink_dcache_sb(struct super_block *sb)\n{\n\tlong freed;\n\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tfreed = list_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, UINT_MAX);\n\n\t\tthis_cpu_sub(nr_dentry_unused, freed);\n\t\tshrink_dentry_list(&dispose);\n\t} while (freed > 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(long, nr_dentry_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nvoid shrink_dcache_sb(struct super_block *sb)\n{\n\tlong freed;\n\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tfreed = list_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, UINT_MAX);\n\n\t\tthis_cpu_sub(nr_dentry_unused, freed);\n\t\tshrink_dentry_list(&dispose);\n\t} while (freed > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "sdp->sd_master_dir"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_log_flush",
          "args": [
            "sdp",
            "NULL",
            "SYNC_FLUSH"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "704-787",
          "snippet": "void gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void gfs2_kill_sb(struct super_block *sb)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\n\tif (sdp == NULL) {\n\t\tkill_block_super(sb);\n\t\treturn;\n\t}\n\n\tgfs2_log_flush(sdp, NULL, SYNC_FLUSH);\n\tdput(sdp->sd_root_dir);\n\tdput(sdp->sd_master_dir);\n\tsdp->sd_root_dir = NULL;\n\tsdp->sd_master_dir = NULL;\n\tshrink_dcache_sb(sb);\n\tgfs2_delete_debugfs_file(sdp);\n\tfree_percpu(sdp->sd_lkstats);\n\tkill_block_super(sb);\n}"
  },
  {
    "function_name": "gfs2_mount_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "1345-1372",
    "snippet": "static struct dentry *gfs2_mount_meta(struct file_system_type *fs_type,\n\t\t\tint flags, const char *dev_name, void *data)\n{\n\tstruct super_block *s;\n\tstruct gfs2_sbd *sdp;\n\tstruct path path;\n\tint error;\n\n\terror = kern_path(dev_name, LOOKUP_FOLLOW, &path);\n\tif (error) {\n\t\tpr_warn(\"path_lookup on %s returned error %d\\n\",\n\t\t\tdev_name, error);\n\t\treturn ERR_PTR(error);\n\t}\n\ts = sget(&gfs2_fs_type, test_gfs2_super, set_meta_super, flags,\n\t\t path.dentry->d_inode->i_sb->s_bdev);\n\tpath_put(&path);\n\tif (IS_ERR(s)) {\n\t\tpr_warn(\"gfs2 mount does not exist\\n\");\n\t\treturn ERR_CAST(s);\n\t}\n\tif ((flags ^ s->s_flags) & MS_RDONLY) {\n\t\tdeactivate_locked_super(s);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\tsdp = s->s_fs_info;\n\treturn dget(sdp->sd_master_dir);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct file_system_type gfs2_fs_type = {\n\t.name = \"gfs2\",\n\t.fs_flags = FS_REQUIRES_DEV,\n\t.mount = gfs2_mount,\n\t.kill_sb = gfs2_kill_sb,\n\t.owner = THIS_MODULE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "sdp->sd_master_dir"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBUSY"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "s"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "s"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"gfs2 mount does not exist\\n\""
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "s"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sget",
          "args": [
            "&gfs2_fs_type",
            "test_gfs2_super",
            "set_meta_super",
            "flags",
            "path.dentry->d_inode->i_sb->s_bdev"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"path_lookup on %s returned error %d\\n\"",
            "dev_name",
            "error"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "dev_name",
            "LOOKUP_FOLLOW",
            "&path"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "kern_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2089-2096",
          "snippet": "int kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct file_system_type gfs2_fs_type = {\n\t.name = \"gfs2\",\n\t.fs_flags = FS_REQUIRES_DEV,\n\t.mount = gfs2_mount,\n\t.kill_sb = gfs2_kill_sb,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct dentry *gfs2_mount_meta(struct file_system_type *fs_type,\n\t\t\tint flags, const char *dev_name, void *data)\n{\n\tstruct super_block *s;\n\tstruct gfs2_sbd *sdp;\n\tstruct path path;\n\tint error;\n\n\terror = kern_path(dev_name, LOOKUP_FOLLOW, &path);\n\tif (error) {\n\t\tpr_warn(\"path_lookup on %s returned error %d\\n\",\n\t\t\tdev_name, error);\n\t\treturn ERR_PTR(error);\n\t}\n\ts = sget(&gfs2_fs_type, test_gfs2_super, set_meta_super, flags,\n\t\t path.dentry->d_inode->i_sb->s_bdev);\n\tpath_put(&path);\n\tif (IS_ERR(s)) {\n\t\tpr_warn(\"gfs2 mount does not exist\\n\");\n\t\treturn ERR_CAST(s);\n\t}\n\tif ((flags ^ s->s_flags) & MS_RDONLY) {\n\t\tdeactivate_locked_super(s);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\tsdp = s->s_fs_info;\n\treturn dget(sdp->sd_master_dir);\n}"
  },
  {
    "function_name": "set_meta_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "1340-1343",
    "snippet": "static int set_meta_super(struct super_block *s, void *ptr)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int set_meta_super(struct super_block *s, void *ptr)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "gfs2_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "1248-1338",
    "snippet": "static struct dentry *gfs2_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data)\n{\n\tstruct block_device *bdev;\n\tstruct super_block *s;\n\tfmode_t mode = FMODE_READ | FMODE_EXCL;\n\tint error;\n\tstruct gfs2_args args;\n\tstruct gfs2_sbd *sdp;\n\n\tif (!(flags & MS_RDONLY))\n\t\tmode |= FMODE_WRITE;\n\n\tbdev = blkdev_get_by_path(dev_name, mode, fs_type);\n\tif (IS_ERR(bdev))\n\t\treturn ERR_CAST(bdev);\n\n\t/*\n\t * once the super is inserted into the list by sget, s_umount\n\t * will protect the lockfs code from trying to start a snapshot\n\t * while we are mounting\n\t */\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (bdev->bd_fsfreeze_count > 0) {\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\terror = -EBUSY;\n\t\tgoto error_bdev;\n\t}\n\ts = sget(fs_type, test_gfs2_super, set_gfs2_super, flags, bdev);\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\terror = PTR_ERR(s);\n\tif (IS_ERR(s))\n\t\tgoto error_bdev;\n\n\tif (s->s_root) {\n\t\t/*\n\t\t * s_umount nests inside bd_mutex during\n\t\t * __invalidate_device().  blkdev_put() acquires\n\t\t * bd_mutex and can't be called under s_umount.  Drop\n\t\t * s_umount temporarily.  This is safe as we're\n\t\t * holding an active reference.\n\t\t */\n\t\tup_write(&s->s_umount);\n\t\tblkdev_put(bdev, mode);\n\t\tdown_write(&s->s_umount);\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\targs.ar_quota = GFS2_QUOTA_DEFAULT;\n\targs.ar_data = GFS2_DATA_DEFAULT;\n\targs.ar_commit = 30;\n\targs.ar_statfs_quantum = 30;\n\targs.ar_quota_quantum = 60;\n\targs.ar_errors = GFS2_ERRORS_DEFAULT;\n\n\terror = gfs2_mount_args(&args, data);\n\tif (error) {\n\t\tpr_warn(\"can't parse mount arguments\\n\");\n\t\tgoto error_super;\n\t}\n\n\tif (s->s_root) {\n\t\terror = -EBUSY;\n\t\tif ((flags ^ s->s_flags) & MS_RDONLY)\n\t\t\tgoto error_super;\n\t} else {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\ts->s_mode = mode;\n\t\tstrlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));\n\t\tsb_set_blocksize(s, block_size(bdev));\n\t\terror = fill_super(s, &args, flags & MS_SILENT ? 1 : 0);\n\t\tif (error)\n\t\t\tgoto error_super;\n\t\ts->s_flags |= MS_ACTIVE;\n\t\tbdev->bd_super = s;\n\t}\n\n\tsdp = s->s_fs_info;\n\tif (args.ar_meta)\n\t\treturn dget(sdp->sd_master_dir);\n\telse\n\t\treturn dget(sdp->sd_root_dir);\n\nerror_super:\n\tdeactivate_locked_super(s);\n\treturn ERR_PTR(error);\nerror_bdev:\n\tblkdev_put(bdev, mode);\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "mode"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "s"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "sdp->sd_root_dir"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_super",
          "args": [
            "s",
            "&args",
            "flags & MS_SILENT ? 1 : 0"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "fill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "1047-1213",
          "snippet": "static int fill_super(struct super_block *sb, struct gfs2_args *args, int silent)\n{\n\tstruct gfs2_sbd *sdp;\n\tstruct gfs2_holder mount_gh;\n\tint error;\n\n\tsdp = init_sbd(sb);\n\tif (!sdp) {\n\t\tpr_warn(\"can't alloc struct gfs2_sbd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tsdp->sd_args = *args;\n\n\tif (sdp->sd_args.ar_spectator) {\n                sb->s_flags |= MS_RDONLY;\n\t\tset_bit(SDF_RORECOVERY, &sdp->sd_flags);\n\t}\n\tif (sdp->sd_args.ar_posix_acl)\n\t\tsb->s_flags |= MS_POSIXACL;\n\tif (sdp->sd_args.ar_nobarrier)\n\t\tset_bit(SDF_NOBARRIERS, &sdp->sd_flags);\n\n\tsb->s_flags |= MS_NOSEC;\n\tsb->s_magic = GFS2_MAGIC;\n\tsb->s_op = &gfs2_super_ops;\n\tsb->s_d_op = &gfs2_dops;\n\tsb->s_export_op = &gfs2_export_ops;\n\tsb->s_xattr = gfs2_xattr_handlers;\n\tsb->s_qcop = &gfs2_quotactl_ops;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;\n\tsb->s_time_gran = 1;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\n\t/* Set up the buffer cache and fill in some fake block size values\n\t   to allow us to read-in the on-disk superblock. */\n\tsdp->sd_sb.sb_bsize = sb_min_blocksize(sb, GFS2_BASIC_BLOCK);\n\tsdp->sd_sb.sb_bsize_shift = sb->s_blocksize_bits;\n\tsdp->sd_fsb2bb_shift = sdp->sd_sb.sb_bsize_shift -\n                               GFS2_BASIC_BLOCK_SHIFT;\n\tsdp->sd_fsb2bb = 1 << sdp->sd_fsb2bb_shift;\n\n\tsdp->sd_tune.gt_logd_secs = sdp->sd_args.ar_commit;\n\tsdp->sd_tune.gt_quota_quantum = sdp->sd_args.ar_quota_quantum;\n\tif (sdp->sd_args.ar_statfs_quantum) {\n\t\tsdp->sd_tune.gt_statfs_slow = 0;\n\t\tsdp->sd_tune.gt_statfs_quantum = sdp->sd_args.ar_statfs_quantum;\n\t} else {\n\t\tsdp->sd_tune.gt_statfs_slow = 1;\n\t\tsdp->sd_tune.gt_statfs_quantum = 30;\n\t}\n\n\terror = init_names(sdp, silent);\n\tif (error) {\n\t\t/* In this case, we haven't initialized sysfs, so we have to\n\t\t   manually free the sdp. */\n\t\tfree_percpu(sdp->sd_lkstats);\n\t\tkfree(sdp);\n\t\tsb->s_fs_info = NULL;\n\t\treturn error;\n\t}\n\n\tsnprintf(sdp->sd_fsname, GFS2_FSNAME_LEN, \"%s\", sdp->sd_table_name);\n\n\terror = gfs2_sys_fs_add(sdp);\n\t/*\n\t * If we hit an error here, gfs2_sys_fs_add will have called function\n\t * kobject_put which causes the sysfs usage count to go to zero, which\n\t * causes sysfs to call function gfs2_sbd_release, which frees sdp.\n\t * Subsequent error paths here will call gfs2_sys_fs_del, which also\n\t * kobject_put to free sdp.\n\t */\n\tif (error)\n\t\treturn error;\n\n\tgfs2_create_debugfs_file(sdp);\n\n\terror = gfs2_lm_mount(sdp, silent);\n\tif (error)\n\t\tgoto fail_debug;\n\n\terror = init_locking(sdp, &mount_gh, DO);\n\tif (error)\n\t\tgoto fail_lm;\n\n\terror = init_sb(sdp, silent);\n\tif (error)\n\t\tgoto fail_locking;\n\n\terror = wait_on_journal(sdp);\n\tif (error)\n\t\tgoto fail_sb;\n\n\t/*\n\t * If user space has failed to join the cluster or some similar\n\t * failure has occurred, then the journal id will contain a\n\t * negative (error) number. This will then be returned to the\n\t * caller (of the mount syscall). We do this even for spectator\n\t * mounts (which just write a jid of 0 to indicate \"ok\" even though\n\t * the jid is unused in the spectator case)\n\t */\n\tif (sdp->sd_lockstruct.ls_jid < 0) {\n\t\terror = sdp->sd_lockstruct.ls_jid;\n\t\tsdp->sd_lockstruct.ls_jid = 0;\n\t\tgoto fail_sb;\n\t}\n\n\tif (sdp->sd_args.ar_spectator)\n\t\tsnprintf(sdp->sd_fsname, GFS2_FSNAME_LEN, \"%s.s\",\n\t\t\t sdp->sd_table_name);\n\telse\n\t\tsnprintf(sdp->sd_fsname, GFS2_FSNAME_LEN, \"%s.%u\",\n\t\t\t sdp->sd_table_name, sdp->sd_lockstruct.ls_jid);\n\n\terror = init_inodes(sdp, DO);\n\tif (error)\n\t\tgoto fail_sb;\n\n\terror = init_per_node(sdp, DO);\n\tif (error)\n\t\tgoto fail_inodes;\n\n\terror = gfs2_statfs_init(sdp);\n\tif (error) {\n\t\tfs_err(sdp, \"can't initialize statfs subsystem: %d\\n\", error);\n\t\tgoto fail_per_node;\n\t}\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\terror = gfs2_make_fs_rw(sdp);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"can't make FS RW: %d\\n\", error);\n\t\t\tgoto fail_per_node;\n\t\t}\n\t}\n\n\tgfs2_glock_dq_uninit(&mount_gh);\n\tgfs2_online_uevent(sdp);\n\treturn 0;\n\nfail_per_node:\n\tinit_per_node(sdp, UNDO);\nfail_inodes:\n\tinit_inodes(sdp, UNDO);\nfail_sb:\n\tif (sdp->sd_root_dir)\n\t\tdput(sdp->sd_root_dir);\n\tif (sdp->sd_master_dir)\n\t\tdput(sdp->sd_master_dir);\n\tif (sb->s_root)\n\t\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfail_locking:\n\tinit_locking(sdp, &mount_gh, UNDO);\nfail_lm:\n\tcomplete_all(&sdp->sd_journal_ready);\n\tgfs2_gl_hash_clear(sdp);\n\tgfs2_lm_unmount(sdp);\nfail_debug:\n\tgfs2_delete_debugfs_file(sdp);\n\tfree_percpu(sdp->sd_lkstats);\n\t/* gfs2_sys_fs_del must be the last thing we do, since it causes\n\t * sysfs to call function gfs2_sbd_release, which frees sdp. */\n\tgfs2_sys_fs_del(sdp);\n\tsb->s_fs_info = NULL;\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UNDO 1",
            "#define DO 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define UNDO 1\n#define DO 0\n\nstatic int fill_super(struct super_block *sb, struct gfs2_args *args, int silent)\n{\n\tstruct gfs2_sbd *sdp;\n\tstruct gfs2_holder mount_gh;\n\tint error;\n\n\tsdp = init_sbd(sb);\n\tif (!sdp) {\n\t\tpr_warn(\"can't alloc struct gfs2_sbd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tsdp->sd_args = *args;\n\n\tif (sdp->sd_args.ar_spectator) {\n                sb->s_flags |= MS_RDONLY;\n\t\tset_bit(SDF_RORECOVERY, &sdp->sd_flags);\n\t}\n\tif (sdp->sd_args.ar_posix_acl)\n\t\tsb->s_flags |= MS_POSIXACL;\n\tif (sdp->sd_args.ar_nobarrier)\n\t\tset_bit(SDF_NOBARRIERS, &sdp->sd_flags);\n\n\tsb->s_flags |= MS_NOSEC;\n\tsb->s_magic = GFS2_MAGIC;\n\tsb->s_op = &gfs2_super_ops;\n\tsb->s_d_op = &gfs2_dops;\n\tsb->s_export_op = &gfs2_export_ops;\n\tsb->s_xattr = gfs2_xattr_handlers;\n\tsb->s_qcop = &gfs2_quotactl_ops;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;\n\tsb->s_time_gran = 1;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\n\t/* Set up the buffer cache and fill in some fake block size values\n\t   to allow us to read-in the on-disk superblock. */\n\tsdp->sd_sb.sb_bsize = sb_min_blocksize(sb, GFS2_BASIC_BLOCK);\n\tsdp->sd_sb.sb_bsize_shift = sb->s_blocksize_bits;\n\tsdp->sd_fsb2bb_shift = sdp->sd_sb.sb_bsize_shift -\n                               GFS2_BASIC_BLOCK_SHIFT;\n\tsdp->sd_fsb2bb = 1 << sdp->sd_fsb2bb_shift;\n\n\tsdp->sd_tune.gt_logd_secs = sdp->sd_args.ar_commit;\n\tsdp->sd_tune.gt_quota_quantum = sdp->sd_args.ar_quota_quantum;\n\tif (sdp->sd_args.ar_statfs_quantum) {\n\t\tsdp->sd_tune.gt_statfs_slow = 0;\n\t\tsdp->sd_tune.gt_statfs_quantum = sdp->sd_args.ar_statfs_quantum;\n\t} else {\n\t\tsdp->sd_tune.gt_statfs_slow = 1;\n\t\tsdp->sd_tune.gt_statfs_quantum = 30;\n\t}\n\n\terror = init_names(sdp, silent);\n\tif (error) {\n\t\t/* In this case, we haven't initialized sysfs, so we have to\n\t\t   manually free the sdp. */\n\t\tfree_percpu(sdp->sd_lkstats);\n\t\tkfree(sdp);\n\t\tsb->s_fs_info = NULL;\n\t\treturn error;\n\t}\n\n\tsnprintf(sdp->sd_fsname, GFS2_FSNAME_LEN, \"%s\", sdp->sd_table_name);\n\n\terror = gfs2_sys_fs_add(sdp);\n\t/*\n\t * If we hit an error here, gfs2_sys_fs_add will have called function\n\t * kobject_put which causes the sysfs usage count to go to zero, which\n\t * causes sysfs to call function gfs2_sbd_release, which frees sdp.\n\t * Subsequent error paths here will call gfs2_sys_fs_del, which also\n\t * kobject_put to free sdp.\n\t */\n\tif (error)\n\t\treturn error;\n\n\tgfs2_create_debugfs_file(sdp);\n\n\terror = gfs2_lm_mount(sdp, silent);\n\tif (error)\n\t\tgoto fail_debug;\n\n\terror = init_locking(sdp, &mount_gh, DO);\n\tif (error)\n\t\tgoto fail_lm;\n\n\terror = init_sb(sdp, silent);\n\tif (error)\n\t\tgoto fail_locking;\n\n\terror = wait_on_journal(sdp);\n\tif (error)\n\t\tgoto fail_sb;\n\n\t/*\n\t * If user space has failed to join the cluster or some similar\n\t * failure has occurred, then the journal id will contain a\n\t * negative (error) number. This will then be returned to the\n\t * caller (of the mount syscall). We do this even for spectator\n\t * mounts (which just write a jid of 0 to indicate \"ok\" even though\n\t * the jid is unused in the spectator case)\n\t */\n\tif (sdp->sd_lockstruct.ls_jid < 0) {\n\t\terror = sdp->sd_lockstruct.ls_jid;\n\t\tsdp->sd_lockstruct.ls_jid = 0;\n\t\tgoto fail_sb;\n\t}\n\n\tif (sdp->sd_args.ar_spectator)\n\t\tsnprintf(sdp->sd_fsname, GFS2_FSNAME_LEN, \"%s.s\",\n\t\t\t sdp->sd_table_name);\n\telse\n\t\tsnprintf(sdp->sd_fsname, GFS2_FSNAME_LEN, \"%s.%u\",\n\t\t\t sdp->sd_table_name, sdp->sd_lockstruct.ls_jid);\n\n\terror = init_inodes(sdp, DO);\n\tif (error)\n\t\tgoto fail_sb;\n\n\terror = init_per_node(sdp, DO);\n\tif (error)\n\t\tgoto fail_inodes;\n\n\terror = gfs2_statfs_init(sdp);\n\tif (error) {\n\t\tfs_err(sdp, \"can't initialize statfs subsystem: %d\\n\", error);\n\t\tgoto fail_per_node;\n\t}\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\terror = gfs2_make_fs_rw(sdp);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"can't make FS RW: %d\\n\", error);\n\t\t\tgoto fail_per_node;\n\t\t}\n\t}\n\n\tgfs2_glock_dq_uninit(&mount_gh);\n\tgfs2_online_uevent(sdp);\n\treturn 0;\n\nfail_per_node:\n\tinit_per_node(sdp, UNDO);\nfail_inodes:\n\tinit_inodes(sdp, UNDO);\nfail_sb:\n\tif (sdp->sd_root_dir)\n\t\tdput(sdp->sd_root_dir);\n\tif (sdp->sd_master_dir)\n\t\tdput(sdp->sd_master_dir);\n\tif (sb->s_root)\n\t\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfail_locking:\n\tinit_locking(sdp, &mount_gh, UNDO);\nfail_lm:\n\tcomplete_all(&sdp->sd_journal_ready);\n\tgfs2_gl_hash_clear(sdp);\n\tgfs2_lm_unmount(sdp);\nfail_debug:\n\tgfs2_delete_debugfs_file(sdp);\n\tfree_percpu(sdp->sd_lkstats);\n\t/* gfs2_sys_fs_del must be the last thing we do, since it causes\n\t * sysfs to call function gfs2_sbd_release, which frees sdp. */\n\tgfs2_sys_fs_del(sdp);\n\tsb->s_fs_info = NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "s",
            "block_size(bdev)"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_size",
          "args": [
            "bdev"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "block_size_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1634-1637",
          "snippet": "static inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "s->s_id",
            "bdevname(bdev, b)",
            "sizeof(s->s_id)"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "bdev",
            "b"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"can't parse mount arguments\\n\""
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_mount_args",
          "args": [
            "&args",
            "data"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_mount_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "136-289",
          "snippet": "int gfs2_mount_args(struct gfs2_args *args, char *options)\n{\n\tchar *o;\n\tint token;\n\tsubstring_t tmp[MAX_OPT_ARGS];\n\tint rv;\n\n\t/* Split the options into tokens with the \",\" character and\n\t   process them */\n\n\twhile (1) {\n\t\to = strsep(&options, \",\");\n\t\tif (o == NULL)\n\t\t\tbreak;\n\t\tif (*o == '\\0')\n\t\t\tcontinue;\n\n\t\ttoken = match_token(o, tokens, tmp);\n\t\tswitch (token) {\n\t\tcase Opt_lockproto:\n\t\t\tmatch_strlcpy(args->ar_lockproto, &tmp[0],\n\t\t\t\t      GFS2_LOCKNAME_LEN);\n\t\t\tbreak;\n\t\tcase Opt_locktable:\n\t\t\tmatch_strlcpy(args->ar_locktable, &tmp[0],\n\t\t\t\t      GFS2_LOCKNAME_LEN);\n\t\t\tbreak;\n\t\tcase Opt_hostdata:\n\t\t\tmatch_strlcpy(args->ar_hostdata, &tmp[0],\n\t\t\t\t      GFS2_LOCKNAME_LEN);\n\t\t\tbreak;\n\t\tcase Opt_spectator:\n\t\t\targs->ar_spectator = 1;\n\t\t\tbreak;\n\t\tcase Opt_ignore_local_fs:\n\t\t\t/* Retained for backwards compat only */\n\t\t\tbreak;\n\t\tcase Opt_localflocks:\n\t\t\targs->ar_localflocks = 1;\n\t\t\tbreak;\n\t\tcase Opt_localcaching:\n\t\t\t/* Retained for backwards compat only */\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tif (args->ar_errors == GFS2_ERRORS_PANIC) {\n\t\t\t\tpr_warn(\"-o debug and -o errors=panic are mutually exclusive\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\targs->ar_debug = 1;\n\t\t\tbreak;\n\t\tcase Opt_nodebug:\n\t\t\targs->ar_debug = 0;\n\t\t\tbreak;\n\t\tcase Opt_upgrade:\n\t\t\t/* Retained for backwards compat only */\n\t\t\tbreak;\n\t\tcase Opt_acl:\n\t\t\targs->ar_posix_acl = 1;\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\targs->ar_posix_acl = 0;\n\t\t\tbreak;\n\t\tcase Opt_quota_off:\n\t\tcase Opt_noquota:\n\t\t\targs->ar_quota = GFS2_QUOTA_OFF;\n\t\t\tbreak;\n\t\tcase Opt_quota_account:\n\t\t\targs->ar_quota = GFS2_QUOTA_ACCOUNT;\n\t\t\tbreak;\n\t\tcase Opt_quota_on:\n\t\tcase Opt_quota:\n\t\t\targs->ar_quota = GFS2_QUOTA_ON;\n\t\t\tbreak;\n\t\tcase Opt_suiddir:\n\t\t\targs->ar_suiddir = 1;\n\t\t\tbreak;\n\t\tcase Opt_nosuiddir:\n\t\t\targs->ar_suiddir = 0;\n\t\t\tbreak;\n\t\tcase Opt_data_writeback:\n\t\t\targs->ar_data = GFS2_DATA_WRITEBACK;\n\t\t\tbreak;\n\t\tcase Opt_data_ordered:\n\t\t\targs->ar_data = GFS2_DATA_ORDERED;\n\t\t\tbreak;\n\t\tcase Opt_meta:\n\t\t\targs->ar_meta = 1;\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\targs->ar_discard = 1;\n\t\t\tbreak;\n\t\tcase Opt_nodiscard:\n\t\t\targs->ar_discard = 0;\n\t\t\tbreak;\n\t\tcase Opt_commit:\n\t\t\trv = match_int(&tmp[0], &args->ar_commit);\n\t\t\tif (rv || args->ar_commit <= 0) {\n\t\t\t\tpr_warn(\"commit mount option requires a positive numeric argument\\n\");\n\t\t\t\treturn rv ? rv : -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_statfs_quantum:\n\t\t\trv = match_int(&tmp[0], &args->ar_statfs_quantum);\n\t\t\tif (rv || args->ar_statfs_quantum < 0) {\n\t\t\t\tpr_warn(\"statfs_quantum mount option requires a non-negative numeric argument\\n\");\n\t\t\t\treturn rv ? rv : -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_quota_quantum:\n\t\t\trv = match_int(&tmp[0], &args->ar_quota_quantum);\n\t\t\tif (rv || args->ar_quota_quantum <= 0) {\n\t\t\t\tpr_warn(\"quota_quantum mount option requires a positive numeric argument\\n\");\n\t\t\t\treturn rv ? rv : -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_statfs_percent:\n\t\t\trv = match_int(&tmp[0], &args->ar_statfs_percent);\n\t\t\tif (rv || args->ar_statfs_percent < 0 ||\n\t\t\t    args->ar_statfs_percent > 100) {\n\t\t\t\tpr_warn(\"statfs_percent mount option requires a numeric argument between 0 and 100\\n\");\n\t\t\t\treturn rv ? rv : -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_err_withdraw:\n\t\t\targs->ar_errors = GFS2_ERRORS_WITHDRAW;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tif (args->ar_debug) {\n\t\t\t\tpr_warn(\"-o debug and -o errors=panic are mutually exclusive\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\targs->ar_errors = GFS2_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\targs->ar_nobarrier = 0;\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\targs->ar_nobarrier = 1;\n\t\t\tbreak;\n\t\tcase Opt_rgrplvb:\n\t\t\targs->ar_rgrplvb = 1;\n\t\t\tbreak;\n\t\tcase Opt_norgrplvb:\n\t\t\targs->ar_rgrplvb = 0;\n\t\t\tbreak;\n\t\tcase Opt_error:\n\t\tdefault:\n\t\t\tpr_warn(\"invalid mount option: %s\\n\", o);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_lockproto, \"lockproto=%s\"},\n\t{Opt_locktable, \"locktable=%s\"},\n\t{Opt_hostdata, \"hostdata=%s\"},\n\t{Opt_spectator, \"spectator\"},\n\t{Opt_spectator, \"norecovery\"},\n\t{Opt_ignore_local_fs, \"ignore_local_fs\"},\n\t{Opt_localflocks, \"localflocks\"},\n\t{Opt_localcaching, \"localcaching\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_nodebug, \"nodebug\"},\n\t{Opt_upgrade, \"upgrade\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_quota_off, \"quota=off\"},\n\t{Opt_quota_account, \"quota=account\"},\n\t{Opt_quota_on, \"quota=on\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_suiddir, \"suiddir\"},\n\t{Opt_nosuiddir, \"nosuiddir\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_meta, \"meta\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_commit, \"commit=%d\"},\n\t{Opt_err_withdraw, \"errors=withdraw\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_statfs_quantum, \"statfs_quantum=%d\"},\n\t{Opt_statfs_percent, \"statfs_percent=%d\"},\n\t{Opt_quota_quantum, \"quota_quantum=%d\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_rgrplvb, \"rgrplvb\"},\n\t{Opt_norgrplvb, \"norgrplvb\"},\n\t{Opt_error, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_lockproto, \"lockproto=%s\"},\n\t{Opt_locktable, \"locktable=%s\"},\n\t{Opt_hostdata, \"hostdata=%s\"},\n\t{Opt_spectator, \"spectator\"},\n\t{Opt_spectator, \"norecovery\"},\n\t{Opt_ignore_local_fs, \"ignore_local_fs\"},\n\t{Opt_localflocks, \"localflocks\"},\n\t{Opt_localcaching, \"localcaching\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_nodebug, \"nodebug\"},\n\t{Opt_upgrade, \"upgrade\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_quota_off, \"quota=off\"},\n\t{Opt_quota_account, \"quota=account\"},\n\t{Opt_quota_on, \"quota=on\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_suiddir, \"suiddir\"},\n\t{Opt_nosuiddir, \"nosuiddir\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_meta, \"meta\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_commit, \"commit=%d\"},\n\t{Opt_err_withdraw, \"errors=withdraw\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_statfs_quantum, \"statfs_quantum=%d\"},\n\t{Opt_statfs_percent, \"statfs_percent=%d\"},\n\t{Opt_quota_quantum, \"quota_quantum=%d\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_rgrplvb, \"rgrplvb\"},\n\t{Opt_norgrplvb, \"norgrplvb\"},\n\t{Opt_error, NULL}\n};\n\nint gfs2_mount_args(struct gfs2_args *args, char *options)\n{\n\tchar *o;\n\tint token;\n\tsubstring_t tmp[MAX_OPT_ARGS];\n\tint rv;\n\n\t/* Split the options into tokens with the \",\" character and\n\t   process them */\n\n\twhile (1) {\n\t\to = strsep(&options, \",\");\n\t\tif (o == NULL)\n\t\t\tbreak;\n\t\tif (*o == '\\0')\n\t\t\tcontinue;\n\n\t\ttoken = match_token(o, tokens, tmp);\n\t\tswitch (token) {\n\t\tcase Opt_lockproto:\n\t\t\tmatch_strlcpy(args->ar_lockproto, &tmp[0],\n\t\t\t\t      GFS2_LOCKNAME_LEN);\n\t\t\tbreak;\n\t\tcase Opt_locktable:\n\t\t\tmatch_strlcpy(args->ar_locktable, &tmp[0],\n\t\t\t\t      GFS2_LOCKNAME_LEN);\n\t\t\tbreak;\n\t\tcase Opt_hostdata:\n\t\t\tmatch_strlcpy(args->ar_hostdata, &tmp[0],\n\t\t\t\t      GFS2_LOCKNAME_LEN);\n\t\t\tbreak;\n\t\tcase Opt_spectator:\n\t\t\targs->ar_spectator = 1;\n\t\t\tbreak;\n\t\tcase Opt_ignore_local_fs:\n\t\t\t/* Retained for backwards compat only */\n\t\t\tbreak;\n\t\tcase Opt_localflocks:\n\t\t\targs->ar_localflocks = 1;\n\t\t\tbreak;\n\t\tcase Opt_localcaching:\n\t\t\t/* Retained for backwards compat only */\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tif (args->ar_errors == GFS2_ERRORS_PANIC) {\n\t\t\t\tpr_warn(\"-o debug and -o errors=panic are mutually exclusive\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\targs->ar_debug = 1;\n\t\t\tbreak;\n\t\tcase Opt_nodebug:\n\t\t\targs->ar_debug = 0;\n\t\t\tbreak;\n\t\tcase Opt_upgrade:\n\t\t\t/* Retained for backwards compat only */\n\t\t\tbreak;\n\t\tcase Opt_acl:\n\t\t\targs->ar_posix_acl = 1;\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\targs->ar_posix_acl = 0;\n\t\t\tbreak;\n\t\tcase Opt_quota_off:\n\t\tcase Opt_noquota:\n\t\t\targs->ar_quota = GFS2_QUOTA_OFF;\n\t\t\tbreak;\n\t\tcase Opt_quota_account:\n\t\t\targs->ar_quota = GFS2_QUOTA_ACCOUNT;\n\t\t\tbreak;\n\t\tcase Opt_quota_on:\n\t\tcase Opt_quota:\n\t\t\targs->ar_quota = GFS2_QUOTA_ON;\n\t\t\tbreak;\n\t\tcase Opt_suiddir:\n\t\t\targs->ar_suiddir = 1;\n\t\t\tbreak;\n\t\tcase Opt_nosuiddir:\n\t\t\targs->ar_suiddir = 0;\n\t\t\tbreak;\n\t\tcase Opt_data_writeback:\n\t\t\targs->ar_data = GFS2_DATA_WRITEBACK;\n\t\t\tbreak;\n\t\tcase Opt_data_ordered:\n\t\t\targs->ar_data = GFS2_DATA_ORDERED;\n\t\t\tbreak;\n\t\tcase Opt_meta:\n\t\t\targs->ar_meta = 1;\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\targs->ar_discard = 1;\n\t\t\tbreak;\n\t\tcase Opt_nodiscard:\n\t\t\targs->ar_discard = 0;\n\t\t\tbreak;\n\t\tcase Opt_commit:\n\t\t\trv = match_int(&tmp[0], &args->ar_commit);\n\t\t\tif (rv || args->ar_commit <= 0) {\n\t\t\t\tpr_warn(\"commit mount option requires a positive numeric argument\\n\");\n\t\t\t\treturn rv ? rv : -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_statfs_quantum:\n\t\t\trv = match_int(&tmp[0], &args->ar_statfs_quantum);\n\t\t\tif (rv || args->ar_statfs_quantum < 0) {\n\t\t\t\tpr_warn(\"statfs_quantum mount option requires a non-negative numeric argument\\n\");\n\t\t\t\treturn rv ? rv : -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_quota_quantum:\n\t\t\trv = match_int(&tmp[0], &args->ar_quota_quantum);\n\t\t\tif (rv || args->ar_quota_quantum <= 0) {\n\t\t\t\tpr_warn(\"quota_quantum mount option requires a positive numeric argument\\n\");\n\t\t\t\treturn rv ? rv : -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_statfs_percent:\n\t\t\trv = match_int(&tmp[0], &args->ar_statfs_percent);\n\t\t\tif (rv || args->ar_statfs_percent < 0 ||\n\t\t\t    args->ar_statfs_percent > 100) {\n\t\t\t\tpr_warn(\"statfs_percent mount option requires a numeric argument between 0 and 100\\n\");\n\t\t\t\treturn rv ? rv : -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_err_withdraw:\n\t\t\targs->ar_errors = GFS2_ERRORS_WITHDRAW;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tif (args->ar_debug) {\n\t\t\t\tpr_warn(\"-o debug and -o errors=panic are mutually exclusive\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\targs->ar_errors = GFS2_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\targs->ar_nobarrier = 0;\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\targs->ar_nobarrier = 1;\n\t\t\tbreak;\n\t\tcase Opt_rgrplvb:\n\t\t\targs->ar_rgrplvb = 1;\n\t\t\tbreak;\n\t\tcase Opt_norgrplvb:\n\t\t\targs->ar_rgrplvb = 0;\n\t\t\tbreak;\n\t\tcase Opt_error:\n\t\tdefault:\n\t\t\tpr_warn(\"invalid mount option: %s\\n\", o);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&s->s_umount"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&s->s_umount"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "s"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "s"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sget",
          "args": [
            "fs_type",
            "test_gfs2_super",
            "set_gfs2_super",
            "flags",
            "bdev"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "bdev"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bdev"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get_by_path",
          "args": [
            "dev_name",
            "mode",
            "fs_type"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1387-1407",
          "snippet": "struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct dentry *gfs2_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data)\n{\n\tstruct block_device *bdev;\n\tstruct super_block *s;\n\tfmode_t mode = FMODE_READ | FMODE_EXCL;\n\tint error;\n\tstruct gfs2_args args;\n\tstruct gfs2_sbd *sdp;\n\n\tif (!(flags & MS_RDONLY))\n\t\tmode |= FMODE_WRITE;\n\n\tbdev = blkdev_get_by_path(dev_name, mode, fs_type);\n\tif (IS_ERR(bdev))\n\t\treturn ERR_CAST(bdev);\n\n\t/*\n\t * once the super is inserted into the list by sget, s_umount\n\t * will protect the lockfs code from trying to start a snapshot\n\t * while we are mounting\n\t */\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (bdev->bd_fsfreeze_count > 0) {\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\terror = -EBUSY;\n\t\tgoto error_bdev;\n\t}\n\ts = sget(fs_type, test_gfs2_super, set_gfs2_super, flags, bdev);\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\terror = PTR_ERR(s);\n\tif (IS_ERR(s))\n\t\tgoto error_bdev;\n\n\tif (s->s_root) {\n\t\t/*\n\t\t * s_umount nests inside bd_mutex during\n\t\t * __invalidate_device().  blkdev_put() acquires\n\t\t * bd_mutex and can't be called under s_umount.  Drop\n\t\t * s_umount temporarily.  This is safe as we're\n\t\t * holding an active reference.\n\t\t */\n\t\tup_write(&s->s_umount);\n\t\tblkdev_put(bdev, mode);\n\t\tdown_write(&s->s_umount);\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\targs.ar_quota = GFS2_QUOTA_DEFAULT;\n\targs.ar_data = GFS2_DATA_DEFAULT;\n\targs.ar_commit = 30;\n\targs.ar_statfs_quantum = 30;\n\targs.ar_quota_quantum = 60;\n\targs.ar_errors = GFS2_ERRORS_DEFAULT;\n\n\terror = gfs2_mount_args(&args, data);\n\tif (error) {\n\t\tpr_warn(\"can't parse mount arguments\\n\");\n\t\tgoto error_super;\n\t}\n\n\tif (s->s_root) {\n\t\terror = -EBUSY;\n\t\tif ((flags ^ s->s_flags) & MS_RDONLY)\n\t\t\tgoto error_super;\n\t} else {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\ts->s_mode = mode;\n\t\tstrlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));\n\t\tsb_set_blocksize(s, block_size(bdev));\n\t\terror = fill_super(s, &args, flags & MS_SILENT ? 1 : 0);\n\t\tif (error)\n\t\t\tgoto error_super;\n\t\ts->s_flags |= MS_ACTIVE;\n\t\tbdev->bd_super = s;\n\t}\n\n\tsdp = s->s_fs_info;\n\tif (args.ar_meta)\n\t\treturn dget(sdp->sd_master_dir);\n\telse\n\t\treturn dget(sdp->sd_root_dir);\n\nerror_super:\n\tdeactivate_locked_super(s);\n\treturn ERR_PTR(error);\nerror_bdev:\n\tblkdev_put(bdev, mode);\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "test_gfs2_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "1228-1232",
    "snippet": "static int test_gfs2_super(struct super_block *s, void *ptr)\n{\n\tstruct block_device *bdev = ptr;\n\treturn (bdev == s->s_bdev);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int test_gfs2_super(struct super_block *s, void *ptr)\n{\n\tstruct block_device *bdev = ptr;\n\treturn (bdev == s->s_bdev);\n}"
  },
  {
    "function_name": "set_gfs2_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "1215-1226",
    "snippet": "static int set_gfs2_super(struct super_block *s, void *data)\n{\n\ts->s_bdev = data;\n\ts->s_dev = s->s_bdev->bd_dev;\n\n\t/*\n\t * We set the bdi here to the queue backing, file systems can\n\t * overwrite this in ->fill_super()\n\t */\n\ts->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "s->s_bdev"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int set_gfs2_super(struct super_block *s, void *data)\n{\n\ts->s_bdev = data;\n\ts->s_dev = s->s_bdev->bd_dev;\n\n\t/*\n\t * We set the bdi here to the queue backing, file systems can\n\t * overwrite this in ->fill_super()\n\t */\n\ts->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;\n\treturn 0;\n}"
  },
  {
    "function_name": "fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "1047-1213",
    "snippet": "static int fill_super(struct super_block *sb, struct gfs2_args *args, int silent)\n{\n\tstruct gfs2_sbd *sdp;\n\tstruct gfs2_holder mount_gh;\n\tint error;\n\n\tsdp = init_sbd(sb);\n\tif (!sdp) {\n\t\tpr_warn(\"can't alloc struct gfs2_sbd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tsdp->sd_args = *args;\n\n\tif (sdp->sd_args.ar_spectator) {\n                sb->s_flags |= MS_RDONLY;\n\t\tset_bit(SDF_RORECOVERY, &sdp->sd_flags);\n\t}\n\tif (sdp->sd_args.ar_posix_acl)\n\t\tsb->s_flags |= MS_POSIXACL;\n\tif (sdp->sd_args.ar_nobarrier)\n\t\tset_bit(SDF_NOBARRIERS, &sdp->sd_flags);\n\n\tsb->s_flags |= MS_NOSEC;\n\tsb->s_magic = GFS2_MAGIC;\n\tsb->s_op = &gfs2_super_ops;\n\tsb->s_d_op = &gfs2_dops;\n\tsb->s_export_op = &gfs2_export_ops;\n\tsb->s_xattr = gfs2_xattr_handlers;\n\tsb->s_qcop = &gfs2_quotactl_ops;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;\n\tsb->s_time_gran = 1;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\n\t/* Set up the buffer cache and fill in some fake block size values\n\t   to allow us to read-in the on-disk superblock. */\n\tsdp->sd_sb.sb_bsize = sb_min_blocksize(sb, GFS2_BASIC_BLOCK);\n\tsdp->sd_sb.sb_bsize_shift = sb->s_blocksize_bits;\n\tsdp->sd_fsb2bb_shift = sdp->sd_sb.sb_bsize_shift -\n                               GFS2_BASIC_BLOCK_SHIFT;\n\tsdp->sd_fsb2bb = 1 << sdp->sd_fsb2bb_shift;\n\n\tsdp->sd_tune.gt_logd_secs = sdp->sd_args.ar_commit;\n\tsdp->sd_tune.gt_quota_quantum = sdp->sd_args.ar_quota_quantum;\n\tif (sdp->sd_args.ar_statfs_quantum) {\n\t\tsdp->sd_tune.gt_statfs_slow = 0;\n\t\tsdp->sd_tune.gt_statfs_quantum = sdp->sd_args.ar_statfs_quantum;\n\t} else {\n\t\tsdp->sd_tune.gt_statfs_slow = 1;\n\t\tsdp->sd_tune.gt_statfs_quantum = 30;\n\t}\n\n\terror = init_names(sdp, silent);\n\tif (error) {\n\t\t/* In this case, we haven't initialized sysfs, so we have to\n\t\t   manually free the sdp. */\n\t\tfree_percpu(sdp->sd_lkstats);\n\t\tkfree(sdp);\n\t\tsb->s_fs_info = NULL;\n\t\treturn error;\n\t}\n\n\tsnprintf(sdp->sd_fsname, GFS2_FSNAME_LEN, \"%s\", sdp->sd_table_name);\n\n\terror = gfs2_sys_fs_add(sdp);\n\t/*\n\t * If we hit an error here, gfs2_sys_fs_add will have called function\n\t * kobject_put which causes the sysfs usage count to go to zero, which\n\t * causes sysfs to call function gfs2_sbd_release, which frees sdp.\n\t * Subsequent error paths here will call gfs2_sys_fs_del, which also\n\t * kobject_put to free sdp.\n\t */\n\tif (error)\n\t\treturn error;\n\n\tgfs2_create_debugfs_file(sdp);\n\n\terror = gfs2_lm_mount(sdp, silent);\n\tif (error)\n\t\tgoto fail_debug;\n\n\terror = init_locking(sdp, &mount_gh, DO);\n\tif (error)\n\t\tgoto fail_lm;\n\n\terror = init_sb(sdp, silent);\n\tif (error)\n\t\tgoto fail_locking;\n\n\terror = wait_on_journal(sdp);\n\tif (error)\n\t\tgoto fail_sb;\n\n\t/*\n\t * If user space has failed to join the cluster or some similar\n\t * failure has occurred, then the journal id will contain a\n\t * negative (error) number. This will then be returned to the\n\t * caller (of the mount syscall). We do this even for spectator\n\t * mounts (which just write a jid of 0 to indicate \"ok\" even though\n\t * the jid is unused in the spectator case)\n\t */\n\tif (sdp->sd_lockstruct.ls_jid < 0) {\n\t\terror = sdp->sd_lockstruct.ls_jid;\n\t\tsdp->sd_lockstruct.ls_jid = 0;\n\t\tgoto fail_sb;\n\t}\n\n\tif (sdp->sd_args.ar_spectator)\n\t\tsnprintf(sdp->sd_fsname, GFS2_FSNAME_LEN, \"%s.s\",\n\t\t\t sdp->sd_table_name);\n\telse\n\t\tsnprintf(sdp->sd_fsname, GFS2_FSNAME_LEN, \"%s.%u\",\n\t\t\t sdp->sd_table_name, sdp->sd_lockstruct.ls_jid);\n\n\terror = init_inodes(sdp, DO);\n\tif (error)\n\t\tgoto fail_sb;\n\n\terror = init_per_node(sdp, DO);\n\tif (error)\n\t\tgoto fail_inodes;\n\n\terror = gfs2_statfs_init(sdp);\n\tif (error) {\n\t\tfs_err(sdp, \"can't initialize statfs subsystem: %d\\n\", error);\n\t\tgoto fail_per_node;\n\t}\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\terror = gfs2_make_fs_rw(sdp);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"can't make FS RW: %d\\n\", error);\n\t\t\tgoto fail_per_node;\n\t\t}\n\t}\n\n\tgfs2_glock_dq_uninit(&mount_gh);\n\tgfs2_online_uevent(sdp);\n\treturn 0;\n\nfail_per_node:\n\tinit_per_node(sdp, UNDO);\nfail_inodes:\n\tinit_inodes(sdp, UNDO);\nfail_sb:\n\tif (sdp->sd_root_dir)\n\t\tdput(sdp->sd_root_dir);\n\tif (sdp->sd_master_dir)\n\t\tdput(sdp->sd_master_dir);\n\tif (sb->s_root)\n\t\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfail_locking:\n\tinit_locking(sdp, &mount_gh, UNDO);\nfail_lm:\n\tcomplete_all(&sdp->sd_journal_ready);\n\tgfs2_gl_hash_clear(sdp);\n\tgfs2_lm_unmount(sdp);\nfail_debug:\n\tgfs2_delete_debugfs_file(sdp);\n\tfree_percpu(sdp->sd_lkstats);\n\t/* gfs2_sys_fs_del must be the last thing we do, since it causes\n\t * sysfs to call function gfs2_sbd_release, which frees sdp. */\n\tgfs2_sys_fs_del(sdp);\n\tsb->s_fs_info = NULL;\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UNDO 1",
      "#define DO 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_sys_fs_del",
          "args": [
            "sdp"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_sys_fs_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "671-677",
          "snippet": "void gfs2_sys_fs_del(struct gfs2_sbd *sdp)\n{\n\tsysfs_remove_link(&sdp->sd_kobj, \"device\");\n\tsysfs_remove_group(&sdp->sd_kobj, &tune_group);\n\tsysfs_remove_group(&sdp->sd_kobj, &lock_module_group);\n\tkobject_put(&sdp->sd_kobj);\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct attribute_group tune_group = {\n\t.name = \"tune\",\n\t.attrs = tune_attrs,\n};",
            "static struct attribute_group lock_module_group = {\n\t.name = \"lock_module\",\n\t.attrs = lock_module_attrs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic struct attribute_group tune_group = {\n\t.name = \"tune\",\n\t.attrs = tune_attrs,\n};\nstatic struct attribute_group lock_module_group = {\n\t.name = \"lock_module\",\n\t.attrs = lock_module_attrs,\n};\n\nvoid gfs2_sys_fs_del(struct gfs2_sbd *sdp)\n{\n\tsysfs_remove_link(&sdp->sd_kobj, \"device\");\n\tsysfs_remove_group(&sdp->sd_kobj, &tune_group);\n\tsysfs_remove_group(&sdp->sd_kobj, &lock_module_group);\n\tkobject_put(&sdp->sd_kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "sdp->sd_lkstats"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_delete_debugfs_file",
          "args": [
            "sdp"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_delete_debugfs_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "2080-2098",
          "snippet": "void gfs2_delete_debugfs_file(struct gfs2_sbd *sdp)\n{\n\tif (sdp->debugfs_dir) {\n\t\tif (sdp->debugfs_dentry_glocks) {\n\t\t\tdebugfs_remove(sdp->debugfs_dentry_glocks);\n\t\t\tsdp->debugfs_dentry_glocks = NULL;\n\t\t}\n\t\tif (sdp->debugfs_dentry_glstats) {\n\t\t\tdebugfs_remove(sdp->debugfs_dentry_glstats);\n\t\t\tsdp->debugfs_dentry_glstats = NULL;\n\t\t}\n\t\tif (sdp->debugfs_dentry_sbstats) {\n\t\t\tdebugfs_remove(sdp->debugfs_dentry_sbstats);\n\t\t\tsdp->debugfs_dentry_sbstats = NULL;\n\t\t}\n\t\tdebugfs_remove(sdp->debugfs_dir);\n\t\tsdp->debugfs_dir = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_delete_debugfs_file(struct gfs2_sbd *sdp)\n{\n\tif (sdp->debugfs_dir) {\n\t\tif (sdp->debugfs_dentry_glocks) {\n\t\t\tdebugfs_remove(sdp->debugfs_dentry_glocks);\n\t\t\tsdp->debugfs_dentry_glocks = NULL;\n\t\t}\n\t\tif (sdp->debugfs_dentry_glstats) {\n\t\t\tdebugfs_remove(sdp->debugfs_dentry_glstats);\n\t\t\tsdp->debugfs_dentry_glstats = NULL;\n\t\t}\n\t\tif (sdp->debugfs_dentry_sbstats) {\n\t\t\tdebugfs_remove(sdp->debugfs_dentry_sbstats);\n\t\t\tsdp->debugfs_dentry_sbstats = NULL;\n\t\t}\n\t\tdebugfs_remove(sdp->debugfs_dir);\n\t\tsdp->debugfs_dir = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_lm_unmount",
          "args": [
            "sdp"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lm_unmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "1010-1016",
          "snippet": "void gfs2_lm_unmount(struct gfs2_sbd *sdp)\n{\n\tconst struct lm_lockops *lm = sdp->sd_lockstruct.ls_ops;\n\tif (likely(!test_bit(SDF_SHUTDOWN, &sdp->sd_flags)) &&\n\t    lm->lm_unmount)\n\t\tlm->lm_unmount(sdp);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_lm_unmount(struct gfs2_sbd *sdp)\n{\n\tconst struct lm_lockops *lm = sdp->sd_lockstruct.ls_ops;\n\tif (likely(!test_bit(SDF_SHUTDOWN, &sdp->sd_flags)) &&\n\t    lm->lm_unmount)\n\t\tlm->lm_unmount(sdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_gl_hash_clear",
          "args": [
            "sdp"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_gl_hash_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1555-1563",
          "snippet": "void gfs2_gl_hash_clear(struct gfs2_sbd *sdp)\n{\n\tset_bit(SDF_SKIP_DLM_UNLOCK, &sdp->sd_flags);\n\tflush_workqueue(glock_workqueue);\n\tglock_hash_walk(clear_glock, sdp);\n\tflush_workqueue(glock_workqueue);\n\twait_event(sdp->sd_glock_wait, atomic_read(&sdp->sd_glock_disposal) == 0);\n\tglock_hash_walk(dump_glock_func, sdp);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *glock_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct workqueue_struct *glock_workqueue;\n\nvoid gfs2_gl_hash_clear(struct gfs2_sbd *sdp)\n{\n\tset_bit(SDF_SKIP_DLM_UNLOCK, &sdp->sd_flags);\n\tflush_workqueue(glock_workqueue);\n\tglock_hash_walk(clear_glock, sdp);\n\tflush_workqueue(glock_workqueue);\n\twait_event(sdp->sd_glock_wait, atomic_read(&sdp->sd_glock_disposal) == 0);\n\tglock_hash_walk(dump_glock_func, sdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete_all",
          "args": [
            "&sdp->sd_journal_ready"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_locking",
          "args": [
            "sdp",
            "&mount_gh",
            "UNDO"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "init_locking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "392-445",
          "snippet": "static int init_locking(struct gfs2_sbd *sdp, struct gfs2_holder *mount_gh,\n\t\t\tint undo)\n{\n\tint error = 0;\n\n\tif (undo)\n\t\tgoto fail_trans;\n\n\terror = gfs2_glock_nq_num(sdp,\n\t\t\t\t  GFS2_MOUNT_LOCK, &gfs2_nondisk_glops,\n\t\t\t\t  LM_ST_EXCLUSIVE, LM_FLAG_NOEXP | GL_NOCACHE,\n\t\t\t\t  mount_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't acquire mount glock: %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = gfs2_glock_nq_num(sdp,\n\t\t\t\t  GFS2_LIVE_LOCK, &gfs2_nondisk_glops,\n\t\t\t\t  LM_ST_SHARED,\n\t\t\t\t  LM_FLAG_NOEXP | GL_EXACT,\n\t\t\t\t  &sdp->sd_live_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't acquire live glock: %d\\n\", error);\n\t\tgoto fail_mount;\n\t}\n\n\terror = gfs2_glock_get(sdp, GFS2_RENAME_LOCK, &gfs2_nondisk_glops,\n\t\t\t       CREATE, &sdp->sd_rename_gl);\n\tif (error) {\n\t\tfs_err(sdp, \"can't create rename glock: %d\\n\", error);\n\t\tgoto fail_live;\n\t}\n\n\terror = gfs2_glock_get(sdp, GFS2_FREEZE_LOCK, &gfs2_freeze_glops,\n\t\t\t       CREATE, &sdp->sd_freeze_gl);\n\tif (error) {\n\t\tfs_err(sdp, \"can't create transaction glock: %d\\n\", error);\n\t\tgoto fail_rename;\n\t}\n\n\treturn 0;\n\nfail_trans:\n\tgfs2_glock_put(sdp->sd_freeze_gl);\nfail_rename:\n\tgfs2_glock_put(sdp->sd_rename_gl);\nfail_live:\n\tgfs2_glock_dq_uninit(&sdp->sd_live_gh);\nfail_mount:\n\tgfs2_glock_dq_uninit(mount_gh);\nfail:\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int init_locking(struct gfs2_sbd *sdp, struct gfs2_holder *mount_gh,\n\t\t\tint undo)\n{\n\tint error = 0;\n\n\tif (undo)\n\t\tgoto fail_trans;\n\n\terror = gfs2_glock_nq_num(sdp,\n\t\t\t\t  GFS2_MOUNT_LOCK, &gfs2_nondisk_glops,\n\t\t\t\t  LM_ST_EXCLUSIVE, LM_FLAG_NOEXP | GL_NOCACHE,\n\t\t\t\t  mount_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't acquire mount glock: %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = gfs2_glock_nq_num(sdp,\n\t\t\t\t  GFS2_LIVE_LOCK, &gfs2_nondisk_glops,\n\t\t\t\t  LM_ST_SHARED,\n\t\t\t\t  LM_FLAG_NOEXP | GL_EXACT,\n\t\t\t\t  &sdp->sd_live_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't acquire live glock: %d\\n\", error);\n\t\tgoto fail_mount;\n\t}\n\n\terror = gfs2_glock_get(sdp, GFS2_RENAME_LOCK, &gfs2_nondisk_glops,\n\t\t\t       CREATE, &sdp->sd_rename_gl);\n\tif (error) {\n\t\tfs_err(sdp, \"can't create rename glock: %d\\n\", error);\n\t\tgoto fail_live;\n\t}\n\n\terror = gfs2_glock_get(sdp, GFS2_FREEZE_LOCK, &gfs2_freeze_glops,\n\t\t\t       CREATE, &sdp->sd_freeze_gl);\n\tif (error) {\n\t\tfs_err(sdp, \"can't create transaction glock: %d\\n\", error);\n\t\tgoto fail_rename;\n\t}\n\n\treturn 0;\n\nfail_trans:\n\tgfs2_glock_put(sdp->sd_freeze_gl);\nfail_rename:\n\tgfs2_glock_put(sdp->sd_rename_gl);\nfail_live:\n\tgfs2_glock_dq_uninit(&sdp->sd_live_gh);\nfail_mount:\n\tgfs2_glock_dq_uninit(mount_gh);\nfail:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "sb->s_root"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodes",
          "args": [
            "sdp",
            "UNDO"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "782-843",
          "snippet": "static int init_inodes(struct gfs2_sbd *sdp, int undo)\n{\n\tint error = 0;\n\tstruct inode *master = sdp->sd_master_dir->d_inode;\n\n\tif (undo)\n\t\tgoto fail_qinode;\n\n\terror = init_journal(sdp, undo);\n\tcomplete_all(&sdp->sd_journal_ready);\n\tif (error)\n\t\tgoto fail;\n\n\t/* Read in the master statfs inode */\n\tsdp->sd_statfs_inode = gfs2_lookup_simple(master, \"statfs\");\n\tif (IS_ERR(sdp->sd_statfs_inode)) {\n\t\terror = PTR_ERR(sdp->sd_statfs_inode);\n\t\tfs_err(sdp, \"can't read in statfs inode: %d\\n\", error);\n\t\tgoto fail_journal;\n\t}\n\n\t/* Read in the resource index inode */\n\tsdp->sd_rindex = gfs2_lookup_simple(master, \"rindex\");\n\tif (IS_ERR(sdp->sd_rindex)) {\n\t\terror = PTR_ERR(sdp->sd_rindex);\n\t\tfs_err(sdp, \"can't get resource index inode: %d\\n\", error);\n\t\tgoto fail_statfs;\n\t}\n\tsdp->sd_rindex_uptodate = 0;\n\n\t/* Read in the quota inode */\n\tsdp->sd_quota_inode = gfs2_lookup_simple(master, \"quota\");\n\tif (IS_ERR(sdp->sd_quota_inode)) {\n\t\terror = PTR_ERR(sdp->sd_quota_inode);\n\t\tfs_err(sdp, \"can't get quota file inode: %d\\n\", error);\n\t\tgoto fail_rindex;\n\t}\n\t/*\n\t * i_mutex on quota files is special. Since this inode is hidden system\n\t * file, we are safe to define locking ourselves.\n\t */\n\tlockdep_set_class(&sdp->sd_quota_inode->i_mutex,\n\t\t\t  &gfs2_quota_imutex_key);\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\tgoto fail_qinode;\n\n\treturn 0;\n\nfail_qinode:\n\tiput(sdp->sd_quota_inode);\nfail_rindex:\n\tgfs2_clear_rgrpd(sdp);\n\tiput(sdp->sd_rindex);\nfail_statfs:\n\tiput(sdp->sd_statfs_inode);\nfail_journal:\n\tinit_journal(sdp, UNDO);\nfail:\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UNDO 1"
          ],
          "globals_used": [
            "static struct lock_class_key gfs2_quota_imutex_key;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define UNDO 1\n\nstatic struct lock_class_key gfs2_quota_imutex_key;\n\nstatic int init_inodes(struct gfs2_sbd *sdp, int undo)\n{\n\tint error = 0;\n\tstruct inode *master = sdp->sd_master_dir->d_inode;\n\n\tif (undo)\n\t\tgoto fail_qinode;\n\n\terror = init_journal(sdp, undo);\n\tcomplete_all(&sdp->sd_journal_ready);\n\tif (error)\n\t\tgoto fail;\n\n\t/* Read in the master statfs inode */\n\tsdp->sd_statfs_inode = gfs2_lookup_simple(master, \"statfs\");\n\tif (IS_ERR(sdp->sd_statfs_inode)) {\n\t\terror = PTR_ERR(sdp->sd_statfs_inode);\n\t\tfs_err(sdp, \"can't read in statfs inode: %d\\n\", error);\n\t\tgoto fail_journal;\n\t}\n\n\t/* Read in the resource index inode */\n\tsdp->sd_rindex = gfs2_lookup_simple(master, \"rindex\");\n\tif (IS_ERR(sdp->sd_rindex)) {\n\t\terror = PTR_ERR(sdp->sd_rindex);\n\t\tfs_err(sdp, \"can't get resource index inode: %d\\n\", error);\n\t\tgoto fail_statfs;\n\t}\n\tsdp->sd_rindex_uptodate = 0;\n\n\t/* Read in the quota inode */\n\tsdp->sd_quota_inode = gfs2_lookup_simple(master, \"quota\");\n\tif (IS_ERR(sdp->sd_quota_inode)) {\n\t\terror = PTR_ERR(sdp->sd_quota_inode);\n\t\tfs_err(sdp, \"can't get quota file inode: %d\\n\", error);\n\t\tgoto fail_rindex;\n\t}\n\t/*\n\t * i_mutex on quota files is special. Since this inode is hidden system\n\t * file, we are safe to define locking ourselves.\n\t */\n\tlockdep_set_class(&sdp->sd_quota_inode->i_mutex,\n\t\t\t  &gfs2_quota_imutex_key);\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\tgoto fail_qinode;\n\n\treturn 0;\n\nfail_qinode:\n\tiput(sdp->sd_quota_inode);\nfail_rindex:\n\tgfs2_clear_rgrpd(sdp);\n\tiput(sdp->sd_rindex);\nfail_statfs:\n\tiput(sdp->sd_statfs_inode);\nfail_journal:\n\tinit_journal(sdp, UNDO);\nfail:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_per_node",
          "args": [
            "sdp",
            "UNDO"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "init_per_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "845-915",
          "snippet": "static int init_per_node(struct gfs2_sbd *sdp, int undo)\n{\n\tstruct inode *pn = NULL;\n\tchar buf[30];\n\tint error = 0;\n\tstruct gfs2_inode *ip;\n\tstruct inode *master = sdp->sd_master_dir->d_inode;\n\n\tif (sdp->sd_args.ar_spectator)\n\t\treturn 0;\n\n\tif (undo)\n\t\tgoto fail_qc_gh;\n\n\tpn = gfs2_lookup_simple(master, \"per_node\");\n\tif (IS_ERR(pn)) {\n\t\terror = PTR_ERR(pn);\n\t\tfs_err(sdp, \"can't find per_node directory: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tsprintf(buf, \"statfs_change%u\", sdp->sd_jdesc->jd_jid);\n\tsdp->sd_sc_inode = gfs2_lookup_simple(pn, buf);\n\tif (IS_ERR(sdp->sd_sc_inode)) {\n\t\terror = PTR_ERR(sdp->sd_sc_inode);\n\t\tfs_err(sdp, \"can't find local \\\"sc\\\" file: %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\tsprintf(buf, \"quota_change%u\", sdp->sd_jdesc->jd_jid);\n\tsdp->sd_qc_inode = gfs2_lookup_simple(pn, buf);\n\tif (IS_ERR(sdp->sd_qc_inode)) {\n\t\terror = PTR_ERR(sdp->sd_qc_inode);\n\t\tfs_err(sdp, \"can't find local \\\"qc\\\" file: %d\\n\", error);\n\t\tgoto fail_ut_i;\n\t}\n\n\tiput(pn);\n\tpn = NULL;\n\n\tip = GFS2_I(sdp->sd_sc_inode);\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0,\n\t\t\t\t   &sdp->sd_sc_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't lock local \\\"sc\\\" file: %d\\n\", error);\n\t\tgoto fail_qc_i;\n\t}\n\n\tip = GFS2_I(sdp->sd_qc_inode);\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0,\n\t\t\t\t   &sdp->sd_qc_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't lock local \\\"qc\\\" file: %d\\n\", error);\n\t\tgoto fail_ut_gh;\n\t}\n\n\treturn 0;\n\nfail_qc_gh:\n\tgfs2_glock_dq_uninit(&sdp->sd_qc_gh);\nfail_ut_gh:\n\tgfs2_glock_dq_uninit(&sdp->sd_sc_gh);\nfail_qc_i:\n\tiput(sdp->sd_qc_inode);\nfail_ut_i:\n\tiput(sdp->sd_sc_inode);\nfail:\n\tif (pn)\n\t\tiput(pn);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int init_per_node(struct gfs2_sbd *sdp, int undo)\n{\n\tstruct inode *pn = NULL;\n\tchar buf[30];\n\tint error = 0;\n\tstruct gfs2_inode *ip;\n\tstruct inode *master = sdp->sd_master_dir->d_inode;\n\n\tif (sdp->sd_args.ar_spectator)\n\t\treturn 0;\n\n\tif (undo)\n\t\tgoto fail_qc_gh;\n\n\tpn = gfs2_lookup_simple(master, \"per_node\");\n\tif (IS_ERR(pn)) {\n\t\terror = PTR_ERR(pn);\n\t\tfs_err(sdp, \"can't find per_node directory: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tsprintf(buf, \"statfs_change%u\", sdp->sd_jdesc->jd_jid);\n\tsdp->sd_sc_inode = gfs2_lookup_simple(pn, buf);\n\tif (IS_ERR(sdp->sd_sc_inode)) {\n\t\terror = PTR_ERR(sdp->sd_sc_inode);\n\t\tfs_err(sdp, \"can't find local \\\"sc\\\" file: %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\tsprintf(buf, \"quota_change%u\", sdp->sd_jdesc->jd_jid);\n\tsdp->sd_qc_inode = gfs2_lookup_simple(pn, buf);\n\tif (IS_ERR(sdp->sd_qc_inode)) {\n\t\terror = PTR_ERR(sdp->sd_qc_inode);\n\t\tfs_err(sdp, \"can't find local \\\"qc\\\" file: %d\\n\", error);\n\t\tgoto fail_ut_i;\n\t}\n\n\tiput(pn);\n\tpn = NULL;\n\n\tip = GFS2_I(sdp->sd_sc_inode);\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0,\n\t\t\t\t   &sdp->sd_sc_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't lock local \\\"sc\\\" file: %d\\n\", error);\n\t\tgoto fail_qc_i;\n\t}\n\n\tip = GFS2_I(sdp->sd_qc_inode);\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0,\n\t\t\t\t   &sdp->sd_qc_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't lock local \\\"qc\\\" file: %d\\n\", error);\n\t\tgoto fail_ut_gh;\n\t}\n\n\treturn 0;\n\nfail_qc_gh:\n\tgfs2_glock_dq_uninit(&sdp->sd_qc_gh);\nfail_ut_gh:\n\tgfs2_glock_dq_uninit(&sdp->sd_sc_gh);\nfail_qc_i:\n\tiput(sdp->sd_qc_inode);\nfail_ut_i:\n\tiput(sdp->sd_sc_inode);\nfail:\n\tif (pn)\n\t\tiput(pn);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_online_uevent",
          "args": [
            "sdp"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_online_uevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "1027-1036",
          "snippet": "void gfs2_online_uevent(struct gfs2_sbd *sdp)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tchar ro[20];\n\tchar spectator[20];\n\tchar *envp[] = { ro, spectator, NULL };\n\tsprintf(ro, \"RDONLY=%d\", (sb->s_flags & MS_RDONLY) ? 1 : 0);\n\tsprintf(spectator, \"SPECTATOR=%d\", sdp->sd_args.ar_spectator ? 1 : 0);\n\tkobject_uevent_env(&sdp->sd_kobj, KOBJ_ONLINE, envp);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_online_uevent(struct gfs2_sbd *sdp)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tchar ro[20];\n\tchar spectator[20];\n\tchar *envp[] = { ro, spectator, NULL };\n\tsprintf(ro, \"RDONLY=%d\", (sb->s_flags & MS_RDONLY) ? 1 : 0);\n\tsprintf(spectator, \"SPECTATOR=%d\", sdp->sd_args.ar_spectator ? 1 : 0);\n\tkobject_uevent_env(&sdp->sd_kobj, KOBJ_ONLINE, envp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&mount_gh"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"can't make FS RW: %d\\n\"",
            "error"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_make_fs_rw",
          "args": [
            "sdp"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_make_fs_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "399-449",
          "snippet": "int gfs2_make_fs_rw(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_jdesc->jd_inode);\n\tstruct gfs2_glock *j_gl = ip->i_gl;\n\tstruct gfs2_holder freeze_gh;\n\tstruct gfs2_log_header_host head;\n\tint error;\n\n\terror = init_threads(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(sdp->sd_freeze_gl, LM_ST_SHARED, 0,\n\t\t\t\t   &freeze_gh);\n\tif (error)\n\t\tgoto fail_threads;\n\n\tj_gl->gl_ops->go_inval(j_gl, DIO_METADATA);\n\n\terror = gfs2_find_jhead(sdp->sd_jdesc, &head);\n\tif (error)\n\t\tgoto fail;\n\n\tif (!(head.lh_flags & GFS2_LOG_HEAD_UNMOUNT)) {\n\t\tgfs2_consist(sdp);\n\t\terror = -EIO;\n\t\tgoto fail;\n\t}\n\n\t/*  Initialize some head of the log stuff  */\n\tsdp->sd_log_sequence = head.lh_sequence + 1;\n\tgfs2_log_pointers_init(sdp, head.lh_blkno);\n\n\terror = gfs2_quota_init(sdp);\n\tif (error)\n\t\tgoto fail;\n\n\tset_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags);\n\n\tgfs2_glock_dq_uninit(&freeze_gh);\n\n\treturn 0;\n\nfail:\n\tfreeze_gh.gh_flags |= GL_NOCACHE;\n\tgfs2_glock_dq_uninit(&freeze_gh);\nfail_threads:\n\tkthread_stop(sdp->sd_quotad_process);\n\tkthread_stop(sdp->sd_logd_process);\n\treturn error;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nint gfs2_make_fs_rw(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_jdesc->jd_inode);\n\tstruct gfs2_glock *j_gl = ip->i_gl;\n\tstruct gfs2_holder freeze_gh;\n\tstruct gfs2_log_header_host head;\n\tint error;\n\n\terror = init_threads(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(sdp->sd_freeze_gl, LM_ST_SHARED, 0,\n\t\t\t\t   &freeze_gh);\n\tif (error)\n\t\tgoto fail_threads;\n\n\tj_gl->gl_ops->go_inval(j_gl, DIO_METADATA);\n\n\terror = gfs2_find_jhead(sdp->sd_jdesc, &head);\n\tif (error)\n\t\tgoto fail;\n\n\tif (!(head.lh_flags & GFS2_LOG_HEAD_UNMOUNT)) {\n\t\tgfs2_consist(sdp);\n\t\terror = -EIO;\n\t\tgoto fail;\n\t}\n\n\t/*  Initialize some head of the log stuff  */\n\tsdp->sd_log_sequence = head.lh_sequence + 1;\n\tgfs2_log_pointers_init(sdp, head.lh_blkno);\n\n\terror = gfs2_quota_init(sdp);\n\tif (error)\n\t\tgoto fail;\n\n\tset_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags);\n\n\tgfs2_glock_dq_uninit(&freeze_gh);\n\n\treturn 0;\n\nfail:\n\tfreeze_gh.gh_flags |= GL_NOCACHE;\n\tgfs2_glock_dq_uninit(&freeze_gh);\nfail_threads:\n\tkthread_stop(sdp->sd_quotad_process);\n\tkthread_stop(sdp->sd_logd_process);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_statfs_init",
          "args": [
            "sdp"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_statfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "469-513",
          "snippet": "int gfs2_statfs_init(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct buffer_head *m_bh, *l_bh;\n\tstruct gfs2_holder gh;\n\tint error;\n\n\terror = gfs2_glock_nq_init(m_ip->i_gl, LM_ST_EXCLUSIVE, GL_NOCACHE,\n\t\t\t\t   &gh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_meta_inode_buffer(m_ip, &m_bh);\n\tif (error)\n\t\tgoto out;\n\n\tif (sdp->sd_args.ar_spectator) {\n\t\tspin_lock(&sdp->sd_statfs_spin);\n\t\tgfs2_statfs_change_in(m_sc, m_bh->b_data +\n\t\t\t\t      sizeof(struct gfs2_dinode));\n\t\tspin_unlock(&sdp->sd_statfs_spin);\n\t} else {\n\t\terror = gfs2_meta_inode_buffer(l_ip, &l_bh);\n\t\tif (error)\n\t\t\tgoto out_m_bh;\n\n\t\tspin_lock(&sdp->sd_statfs_spin);\n\t\tgfs2_statfs_change_in(m_sc, m_bh->b_data +\n\t\t\t\t      sizeof(struct gfs2_dinode));\n\t\tgfs2_statfs_change_in(l_sc, l_bh->b_data +\n\t\t\t\t      sizeof(struct gfs2_dinode));\n\t\tspin_unlock(&sdp->sd_statfs_spin);\n\n\t\tbrelse(l_bh);\n\t}\n\nout_m_bh:\n\tbrelse(m_bh);\nout:\n\tgfs2_glock_dq_uninit(&gh);\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nint gfs2_statfs_init(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct buffer_head *m_bh, *l_bh;\n\tstruct gfs2_holder gh;\n\tint error;\n\n\terror = gfs2_glock_nq_init(m_ip->i_gl, LM_ST_EXCLUSIVE, GL_NOCACHE,\n\t\t\t\t   &gh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_meta_inode_buffer(m_ip, &m_bh);\n\tif (error)\n\t\tgoto out;\n\n\tif (sdp->sd_args.ar_spectator) {\n\t\tspin_lock(&sdp->sd_statfs_spin);\n\t\tgfs2_statfs_change_in(m_sc, m_bh->b_data +\n\t\t\t\t      sizeof(struct gfs2_dinode));\n\t\tspin_unlock(&sdp->sd_statfs_spin);\n\t} else {\n\t\terror = gfs2_meta_inode_buffer(l_ip, &l_bh);\n\t\tif (error)\n\t\t\tgoto out_m_bh;\n\n\t\tspin_lock(&sdp->sd_statfs_spin);\n\t\tgfs2_statfs_change_in(m_sc, m_bh->b_data +\n\t\t\t\t      sizeof(struct gfs2_dinode));\n\t\tgfs2_statfs_change_in(l_sc, l_bh->b_data +\n\t\t\t\t      sizeof(struct gfs2_dinode));\n\t\tspin_unlock(&sdp->sd_statfs_spin);\n\n\t\tbrelse(l_bh);\n\t}\n\nout_m_bh:\n\tbrelse(m_bh);\nout:\n\tgfs2_glock_dq_uninit(&gh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "sdp->sd_fsname",
            "GFS2_FSNAME_LEN",
            "\"%s.%u\"",
            "sdp->sd_table_name",
            "sdp->sd_lockstruct.ls_jid"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "sdp->sd_fsname",
            "GFS2_FSNAME_LEN",
            "\"%s.s\"",
            "sdp->sd_table_name"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_journal",
          "args": [
            "sdp"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "1018-1025",
          "snippet": "static int wait_on_journal(struct gfs2_sbd *sdp)\n{\n\tif (sdp->sd_lockstruct.ls_ops->lm_mount == NULL)\n\t\treturn 0;\n\n\treturn wait_on_bit(&sdp->sd_flags, SDF_NOJOURNALID, TASK_INTERRUPTIBLE)\n\t\t? -EINTR : 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int wait_on_journal(struct gfs2_sbd *sdp)\n{\n\tif (sdp->sd_lockstruct.ls_ops->lm_mount == NULL)\n\t\treturn 0;\n\n\treturn wait_on_bit(&sdp->sd_flags, SDF_NOJOURNALID, TASK_INTERRUPTIBLE)\n\t\t? -EINTR : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_sb",
          "args": [
            "sdp",
            "silent"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "init_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "468-522",
          "snippet": "static int init_sb(struct gfs2_sbd *sdp, int silent)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct gfs2_holder sb_gh;\n\tu64 no_addr;\n\tint ret;\n\n\tret = gfs2_glock_nq_num(sdp, GFS2_SB_LOCK, &gfs2_meta_glops,\n\t\t\t\tLM_ST_SHARED, 0, &sb_gh);\n\tif (ret) {\n\t\tfs_err(sdp, \"can't acquire superblock glock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = gfs2_read_sb(sdp, silent);\n\tif (ret) {\n\t\tfs_err(sdp, \"can't read superblock: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t/* Set up the buffer cache and SB for real */\n\tif (sdp->sd_sb.sb_bsize < bdev_logical_block_size(sb->s_bdev)) {\n\t\tret = -EINVAL;\n\t\tfs_err(sdp, \"FS block size (%u) is too small for device \"\n\t\t       \"block size (%u)\\n\",\n\t\t       sdp->sd_sb.sb_bsize, bdev_logical_block_size(sb->s_bdev));\n\t\tgoto out;\n\t}\n\tif (sdp->sd_sb.sb_bsize > PAGE_SIZE) {\n\t\tret = -EINVAL;\n\t\tfs_err(sdp, \"FS block size (%u) is too big for machine \"\n\t\t       \"page size (%u)\\n\",\n\t\t       sdp->sd_sb.sb_bsize, (unsigned int)PAGE_SIZE);\n\t\tgoto out;\n\t}\n\tsb_set_blocksize(sb, sdp->sd_sb.sb_bsize);\n\n\t/* Get the root inode */\n\tno_addr = sdp->sd_sb.sb_root_dir.no_addr;\n\tret = gfs2_lookup_root(sb, &sdp->sd_root_dir, no_addr, \"root\");\n\tif (ret)\n\t\tgoto out;\n\n\t/* Get the master inode */\n\tno_addr = sdp->sd_sb.sb_master_dir.no_addr;\n\tret = gfs2_lookup_root(sb, &sdp->sd_master_dir, no_addr, \"master\");\n\tif (ret) {\n\t\tdput(sdp->sd_root_dir);\n\t\tgoto out;\n\t}\n\tsb->s_root = dget(sdp->sd_args.ar_meta ? sdp->sd_master_dir : sdp->sd_root_dir);\nout:\n\tgfs2_glock_dq_uninit(&sb_gh);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int init_sb(struct gfs2_sbd *sdp, int silent)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct gfs2_holder sb_gh;\n\tu64 no_addr;\n\tint ret;\n\n\tret = gfs2_glock_nq_num(sdp, GFS2_SB_LOCK, &gfs2_meta_glops,\n\t\t\t\tLM_ST_SHARED, 0, &sb_gh);\n\tif (ret) {\n\t\tfs_err(sdp, \"can't acquire superblock glock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = gfs2_read_sb(sdp, silent);\n\tif (ret) {\n\t\tfs_err(sdp, \"can't read superblock: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t/* Set up the buffer cache and SB for real */\n\tif (sdp->sd_sb.sb_bsize < bdev_logical_block_size(sb->s_bdev)) {\n\t\tret = -EINVAL;\n\t\tfs_err(sdp, \"FS block size (%u) is too small for device \"\n\t\t       \"block size (%u)\\n\",\n\t\t       sdp->sd_sb.sb_bsize, bdev_logical_block_size(sb->s_bdev));\n\t\tgoto out;\n\t}\n\tif (sdp->sd_sb.sb_bsize > PAGE_SIZE) {\n\t\tret = -EINVAL;\n\t\tfs_err(sdp, \"FS block size (%u) is too big for machine \"\n\t\t       \"page size (%u)\\n\",\n\t\t       sdp->sd_sb.sb_bsize, (unsigned int)PAGE_SIZE);\n\t\tgoto out;\n\t}\n\tsb_set_blocksize(sb, sdp->sd_sb.sb_bsize);\n\n\t/* Get the root inode */\n\tno_addr = sdp->sd_sb.sb_root_dir.no_addr;\n\tret = gfs2_lookup_root(sb, &sdp->sd_root_dir, no_addr, \"root\");\n\tif (ret)\n\t\tgoto out;\n\n\t/* Get the master inode */\n\tno_addr = sdp->sd_sb.sb_master_dir.no_addr;\n\tret = gfs2_lookup_root(sb, &sdp->sd_master_dir, no_addr, \"master\");\n\tif (ret) {\n\t\tdput(sdp->sd_root_dir);\n\t\tgoto out;\n\t}\n\tsb->s_root = dget(sdp->sd_args.ar_meta ? sdp->sd_master_dir : sdp->sd_root_dir);\nout:\n\tgfs2_glock_dq_uninit(&sb_gh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_lm_mount",
          "args": [
            "sdp",
            "silent"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lm_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "937-1008",
          "snippet": "static int gfs2_lm_mount(struct gfs2_sbd *sdp, int silent)\n{\n\tconst struct lm_lockops *lm;\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tstruct gfs2_args *args = &sdp->sd_args;\n\tconst char *proto = sdp->sd_proto_name;\n\tconst char *table = sdp->sd_table_name;\n\tchar *o, *options;\n\tint ret;\n\n\tif (!strcmp(\"lock_nolock\", proto)) {\n\t\tlm = &nolock_ops;\n\t\tsdp->sd_args.ar_localflocks = 1;\n#ifdef CONFIG_GFS2_FS_LOCKING_DLM\n\t} else if (!strcmp(\"lock_dlm\", proto)) {\n\t\tlm = &gfs2_dlm_ops;\n#endif\n\t} else {\n\t\tpr_info(\"can't find protocol %s\\n\", proto);\n\t\treturn -ENOENT;\n\t}\n\n\tfs_info(sdp, \"Trying to join cluster \\\"%s\\\", \\\"%s\\\"\\n\", proto, table);\n\n\tls->ls_ops = lm;\n\tls->ls_first = 1;\n\n\tfor (options = args->ar_hostdata; (o = strsep(&options, \":\")); ) {\n\t\tsubstring_t tmp[MAX_OPT_ARGS];\n\t\tint token, option;\n\n\t\tif (!o || !*o)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(o, *lm->lm_tokens, tmp);\n\t\tswitch (token) {\n\t\tcase Opt_jid:\n\t\t\tret = match_int(&tmp[0], &option);\n\t\t\tif (ret || option < 0) \n\t\t\t\tgoto hostdata_error;\n\t\t\tif (test_and_clear_bit(SDF_NOJOURNALID, &sdp->sd_flags))\n\t\t\t\tls->ls_jid = option;\n\t\t\tbreak;\n\t\tcase Opt_id:\n\t\tcase Opt_nodir:\n\t\t\t/* Obsolete, but left for backward compat purposes */\n\t\t\tbreak;\n\t\tcase Opt_first:\n\t\t\tret = match_int(&tmp[0], &option);\n\t\t\tif (ret || (option != 0 && option != 1))\n\t\t\t\tgoto hostdata_error;\n\t\t\tls->ls_first = option;\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\tdefault:\nhostdata_error:\n\t\t\tfs_info(sdp, \"unknown hostdata (%s)\\n\", o);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (lm->lm_mount == NULL) {\n\t\tfs_info(sdp, \"Now mounting FS...\\n\");\n\t\tcomplete_all(&sdp->sd_locking_init);\n\t\treturn 0;\n\t}\n\tret = lm->lm_mount(sdp, table);\n\tif (ret == 0)\n\t\tfs_info(sdp, \"Joined cluster. Now mounting FS...\\n\");\n\tcomplete_all(&sdp->sd_locking_init);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct lm_lockops nolock_ops = {\n\t.lm_proto_name = \"lock_nolock\",\n\t.lm_put_lock = gfs2_glock_free,\n\t.lm_tokens = &nolock_tokens,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic const struct lm_lockops nolock_ops = {\n\t.lm_proto_name = \"lock_nolock\",\n\t.lm_put_lock = gfs2_glock_free,\n\t.lm_tokens = &nolock_tokens,\n};\n\nstatic int gfs2_lm_mount(struct gfs2_sbd *sdp, int silent)\n{\n\tconst struct lm_lockops *lm;\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tstruct gfs2_args *args = &sdp->sd_args;\n\tconst char *proto = sdp->sd_proto_name;\n\tconst char *table = sdp->sd_table_name;\n\tchar *o, *options;\n\tint ret;\n\n\tif (!strcmp(\"lock_nolock\", proto)) {\n\t\tlm = &nolock_ops;\n\t\tsdp->sd_args.ar_localflocks = 1;\n#ifdef CONFIG_GFS2_FS_LOCKING_DLM\n\t} else if (!strcmp(\"lock_dlm\", proto)) {\n\t\tlm = &gfs2_dlm_ops;\n#endif\n\t} else {\n\t\tpr_info(\"can't find protocol %s\\n\", proto);\n\t\treturn -ENOENT;\n\t}\n\n\tfs_info(sdp, \"Trying to join cluster \\\"%s\\\", \\\"%s\\\"\\n\", proto, table);\n\n\tls->ls_ops = lm;\n\tls->ls_first = 1;\n\n\tfor (options = args->ar_hostdata; (o = strsep(&options, \":\")); ) {\n\t\tsubstring_t tmp[MAX_OPT_ARGS];\n\t\tint token, option;\n\n\t\tif (!o || !*o)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(o, *lm->lm_tokens, tmp);\n\t\tswitch (token) {\n\t\tcase Opt_jid:\n\t\t\tret = match_int(&tmp[0], &option);\n\t\t\tif (ret || option < 0) \n\t\t\t\tgoto hostdata_error;\n\t\t\tif (test_and_clear_bit(SDF_NOJOURNALID, &sdp->sd_flags))\n\t\t\t\tls->ls_jid = option;\n\t\t\tbreak;\n\t\tcase Opt_id:\n\t\tcase Opt_nodir:\n\t\t\t/* Obsolete, but left for backward compat purposes */\n\t\t\tbreak;\n\t\tcase Opt_first:\n\t\t\tret = match_int(&tmp[0], &option);\n\t\t\tif (ret || (option != 0 && option != 1))\n\t\t\t\tgoto hostdata_error;\n\t\t\tls->ls_first = option;\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\tdefault:\nhostdata_error:\n\t\t\tfs_info(sdp, \"unknown hostdata (%s)\\n\", o);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (lm->lm_mount == NULL) {\n\t\tfs_info(sdp, \"Now mounting FS...\\n\");\n\t\tcomplete_all(&sdp->sd_locking_init);\n\t\treturn 0;\n\t}\n\tret = lm->lm_mount(sdp, table);\n\tif (ret == 0)\n\t\tfs_info(sdp, \"Joined cluster. Now mounting FS...\\n\");\n\tcomplete_all(&sdp->sd_locking_init);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_create_debugfs_file",
          "args": [
            "sdp"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_create_debugfs_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "2048-2078",
          "snippet": "int gfs2_create_debugfs_file(struct gfs2_sbd *sdp)\n{\n\tsdp->debugfs_dir = debugfs_create_dir(sdp->sd_table_name, gfs2_root);\n\tif (!sdp->debugfs_dir)\n\t\treturn -ENOMEM;\n\tsdp->debugfs_dentry_glocks = debugfs_create_file(\"glocks\",\n\t\t\t\t\t\t\t S_IFREG | S_IRUGO,\n\t\t\t\t\t\t\t sdp->debugfs_dir, sdp,\n\t\t\t\t\t\t\t &gfs2_glocks_fops);\n\tif (!sdp->debugfs_dentry_glocks)\n\t\tgoto fail;\n\n\tsdp->debugfs_dentry_glstats = debugfs_create_file(\"glstats\",\n\t\t\t\t\t\t\tS_IFREG | S_IRUGO,\n\t\t\t\t\t\t\tsdp->debugfs_dir, sdp,\n\t\t\t\t\t\t\t&gfs2_glstats_fops);\n\tif (!sdp->debugfs_dentry_glstats)\n\t\tgoto fail;\n\n\tsdp->debugfs_dentry_sbstats = debugfs_create_file(\"sbstats\",\n\t\t\t\t\t\t\tS_IFREG | S_IRUGO,\n\t\t\t\t\t\t\tsdp->debugfs_dir, sdp,\n\t\t\t\t\t\t\t&gfs2_sbstats_fops);\n\tif (!sdp->debugfs_dentry_sbstats)\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tgfs2_delete_debugfs_file(sdp);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *gfs2_root;",
            "static struct dentry *gfs2_root;",
            "static const struct file_operations gfs2_glocks_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = gfs2_glocks_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private,\n};",
            "static const struct file_operations gfs2_glstats_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = gfs2_glstats_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private,\n};",
            "static const struct file_operations gfs2_sbstats_fops = {\n\t.owner   = THIS_MODULE,\n\t.open\t = gfs2_sbstats_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct dentry *gfs2_root;\nstatic struct dentry *gfs2_root;\nstatic const struct file_operations gfs2_glocks_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = gfs2_glocks_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private,\n};\nstatic const struct file_operations gfs2_glstats_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = gfs2_glstats_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private,\n};\nstatic const struct file_operations gfs2_sbstats_fops = {\n\t.owner   = THIS_MODULE,\n\t.open\t = gfs2_sbstats_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private,\n};\n\nint gfs2_create_debugfs_file(struct gfs2_sbd *sdp)\n{\n\tsdp->debugfs_dir = debugfs_create_dir(sdp->sd_table_name, gfs2_root);\n\tif (!sdp->debugfs_dir)\n\t\treturn -ENOMEM;\n\tsdp->debugfs_dentry_glocks = debugfs_create_file(\"glocks\",\n\t\t\t\t\t\t\t S_IFREG | S_IRUGO,\n\t\t\t\t\t\t\t sdp->debugfs_dir, sdp,\n\t\t\t\t\t\t\t &gfs2_glocks_fops);\n\tif (!sdp->debugfs_dentry_glocks)\n\t\tgoto fail;\n\n\tsdp->debugfs_dentry_glstats = debugfs_create_file(\"glstats\",\n\t\t\t\t\t\t\tS_IFREG | S_IRUGO,\n\t\t\t\t\t\t\tsdp->debugfs_dir, sdp,\n\t\t\t\t\t\t\t&gfs2_glstats_fops);\n\tif (!sdp->debugfs_dentry_glstats)\n\t\tgoto fail;\n\n\tsdp->debugfs_dentry_sbstats = debugfs_create_file(\"sbstats\",\n\t\t\t\t\t\t\tS_IFREG | S_IRUGO,\n\t\t\t\t\t\t\tsdp->debugfs_dir, sdp,\n\t\t\t\t\t\t\t&gfs2_sbstats_fops);\n\tif (!sdp->debugfs_dentry_sbstats)\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tgfs2_delete_debugfs_file(sdp);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_sys_fs_add",
          "args": [
            "sdp"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_sys_fs_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "619-669",
          "snippet": "int gfs2_sys_fs_add(struct gfs2_sbd *sdp)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tint error;\n\tchar ro[20];\n\tchar spectator[20];\n\tchar *envp[] = { ro, spectator, NULL };\n\tint sysfs_frees_sdp = 0;\n\n\tsprintf(ro, \"RDONLY=%d\", (sb->s_flags & MS_RDONLY) ? 1 : 0);\n\tsprintf(spectator, \"SPECTATOR=%d\", sdp->sd_args.ar_spectator ? 1 : 0);\n\n\tsdp->sd_kobj.kset = gfs2_kset;\n\terror = kobject_init_and_add(&sdp->sd_kobj, &gfs2_ktype, NULL,\n\t\t\t\t     \"%s\", sdp->sd_table_name);\n\tif (error)\n\t\tgoto fail_reg;\n\n\tsysfs_frees_sdp = 1; /* Freeing sdp is now done by sysfs calling\n\t\t\t\tfunction gfs2_sbd_release. */\n\terror = sysfs_create_group(&sdp->sd_kobj, &tune_group);\n\tif (error)\n\t\tgoto fail_reg;\n\n\terror = sysfs_create_group(&sdp->sd_kobj, &lock_module_group);\n\tif (error)\n\t\tgoto fail_tune;\n\n\terror = sysfs_create_link(&sdp->sd_kobj,\n\t\t\t\t  &disk_to_dev(sb->s_bdev->bd_disk)->kobj,\n\t\t\t\t  \"device\");\n\tif (error)\n\t\tgoto fail_lock_module;\n\n\tkobject_uevent_env(&sdp->sd_kobj, KOBJ_ADD, envp);\n\treturn 0;\n\nfail_lock_module:\n\tsysfs_remove_group(&sdp->sd_kobj, &lock_module_group);\nfail_tune:\n\tsysfs_remove_group(&sdp->sd_kobj, &tune_group);\nfail_reg:\n\tfree_percpu(sdp->sd_lkstats);\n\tfs_err(sdp, \"error %d adding sysfs files\", error);\n\tif (sysfs_frees_sdp)\n\t\tkobject_put(&sdp->sd_kobj);\n\telse\n\t\tkfree(sdp);\n\tsb->s_fs_info = NULL;\n\treturn error;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kset *gfs2_kset;",
            "static struct kobj_type gfs2_ktype = {\n\t.release = gfs2_sbd_release,\n\t.default_attrs = gfs2_attrs,\n\t.sysfs_ops     = &gfs2_attr_ops,\n};",
            "static struct attribute_group tune_group = {\n\t.name = \"tune\",\n\t.attrs = tune_attrs,\n};",
            "static struct attribute_group lock_module_group = {\n\t.name = \"lock_module\",\n\t.attrs = lock_module_attrs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic struct kset *gfs2_kset;\nstatic struct kobj_type gfs2_ktype = {\n\t.release = gfs2_sbd_release,\n\t.default_attrs = gfs2_attrs,\n\t.sysfs_ops     = &gfs2_attr_ops,\n};\nstatic struct attribute_group tune_group = {\n\t.name = \"tune\",\n\t.attrs = tune_attrs,\n};\nstatic struct attribute_group lock_module_group = {\n\t.name = \"lock_module\",\n\t.attrs = lock_module_attrs,\n};\n\nint gfs2_sys_fs_add(struct gfs2_sbd *sdp)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tint error;\n\tchar ro[20];\n\tchar spectator[20];\n\tchar *envp[] = { ro, spectator, NULL };\n\tint sysfs_frees_sdp = 0;\n\n\tsprintf(ro, \"RDONLY=%d\", (sb->s_flags & MS_RDONLY) ? 1 : 0);\n\tsprintf(spectator, \"SPECTATOR=%d\", sdp->sd_args.ar_spectator ? 1 : 0);\n\n\tsdp->sd_kobj.kset = gfs2_kset;\n\terror = kobject_init_and_add(&sdp->sd_kobj, &gfs2_ktype, NULL,\n\t\t\t\t     \"%s\", sdp->sd_table_name);\n\tif (error)\n\t\tgoto fail_reg;\n\n\tsysfs_frees_sdp = 1; /* Freeing sdp is now done by sysfs calling\n\t\t\t\tfunction gfs2_sbd_release. */\n\terror = sysfs_create_group(&sdp->sd_kobj, &tune_group);\n\tif (error)\n\t\tgoto fail_reg;\n\n\terror = sysfs_create_group(&sdp->sd_kobj, &lock_module_group);\n\tif (error)\n\t\tgoto fail_tune;\n\n\terror = sysfs_create_link(&sdp->sd_kobj,\n\t\t\t\t  &disk_to_dev(sb->s_bdev->bd_disk)->kobj,\n\t\t\t\t  \"device\");\n\tif (error)\n\t\tgoto fail_lock_module;\n\n\tkobject_uevent_env(&sdp->sd_kobj, KOBJ_ADD, envp);\n\treturn 0;\n\nfail_lock_module:\n\tsysfs_remove_group(&sdp->sd_kobj, &lock_module_group);\nfail_tune:\n\tsysfs_remove_group(&sdp->sd_kobj, &tune_group);\nfail_reg:\n\tfree_percpu(sdp->sd_lkstats);\n\tfs_err(sdp, \"error %d adding sysfs files\", error);\n\tif (sysfs_frees_sdp)\n\t\tkobject_put(&sdp->sd_kobj);\n\telse\n\t\tkfree(sdp);\n\tsb->s_fs_info = NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "sdp->sd_fsname",
            "GFS2_FSNAME_LEN",
            "\"%s\"",
            "sdp->sd_table_name"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sdp"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "sdp->sd_lkstats"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_names",
          "args": [
            "sdp",
            "silent"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "init_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "358-390",
          "snippet": "static int init_names(struct gfs2_sbd *sdp, int silent)\n{\n\tchar *proto, *table;\n\tint error = 0;\n\n\tproto = sdp->sd_args.ar_lockproto;\n\ttable = sdp->sd_args.ar_locktable;\n\n\t/*  Try to autodetect  */\n\n\tif (!proto[0] || !table[0]) {\n\t\terror = gfs2_read_super(sdp, GFS2_SB_ADDR >> sdp->sd_fsb2bb_shift, silent);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (!proto[0])\n\t\t\tproto = sdp->sd_sb.sb_lockproto;\n\t\tif (!table[0])\n\t\t\ttable = sdp->sd_sb.sb_locktable;\n\t}\n\n\tif (!table[0])\n\t\ttable = sdp->sd_vfs->s_id;\n\n\tstrlcpy(sdp->sd_proto_name, proto, GFS2_FSNAME_LEN);\n\tstrlcpy(sdp->sd_table_name, table, GFS2_FSNAME_LEN);\n\n\ttable = sdp->sd_table_name;\n\twhile ((table = strchr(table, '/')))\n\t\t*table = '_';\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int init_names(struct gfs2_sbd *sdp, int silent)\n{\n\tchar *proto, *table;\n\tint error = 0;\n\n\tproto = sdp->sd_args.ar_lockproto;\n\ttable = sdp->sd_args.ar_locktable;\n\n\t/*  Try to autodetect  */\n\n\tif (!proto[0] || !table[0]) {\n\t\terror = gfs2_read_super(sdp, GFS2_SB_ADDR >> sdp->sd_fsb2bb_shift, silent);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (!proto[0])\n\t\t\tproto = sdp->sd_sb.sb_lockproto;\n\t\tif (!table[0])\n\t\t\ttable = sdp->sd_sb.sb_locktable;\n\t}\n\n\tif (!table[0])\n\t\ttable = sdp->sd_vfs->s_id;\n\n\tstrlcpy(sdp->sd_proto_name, proto, GFS2_FSNAME_LEN);\n\tstrlcpy(sdp->sd_table_name, table, GFS2_FSNAME_LEN);\n\n\ttable = sdp->sd_table_name;\n\twhile ((table = strchr(table, '/')))\n\t\t*table = '_';\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_min_blocksize",
          "args": [
            "sb",
            "GFS2_BASIC_BLOCK"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "sb_min_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "129-135",
          "snippet": "int sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "SDF_NOBARRIERS",
            "&sdp->sd_flags"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"can't alloc struct gfs2_sbd\\n\""
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sbd",
          "args": [
            "sb"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "init_sbd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "65-138",
          "snippet": "static struct gfs2_sbd *init_sbd(struct super_block *sb)\n{\n\tstruct gfs2_sbd *sdp;\n\tstruct address_space *mapping;\n\n\tsdp = kzalloc(sizeof(struct gfs2_sbd), GFP_KERNEL);\n\tif (!sdp)\n\t\treturn NULL;\n\n\tsb->s_fs_info = sdp;\n\tsdp->sd_vfs = sb;\n\tsdp->sd_lkstats = alloc_percpu(struct gfs2_pcpu_lkstats);\n\tif (!sdp->sd_lkstats) {\n\t\tkfree(sdp);\n\t\treturn NULL;\n\t}\n\n\tset_bit(SDF_NOJOURNALID, &sdp->sd_flags);\n\tgfs2_tune_init(&sdp->sd_tune);\n\n\tinit_waitqueue_head(&sdp->sd_glock_wait);\n\tatomic_set(&sdp->sd_glock_disposal, 0);\n\tinit_completion(&sdp->sd_locking_init);\n\tinit_completion(&sdp->sd_wdack);\n\tspin_lock_init(&sdp->sd_statfs_spin);\n\n\tspin_lock_init(&sdp->sd_rindex_spin);\n\tsdp->sd_rindex_tree.rb_node = NULL;\n\n\tINIT_LIST_HEAD(&sdp->sd_jindex_list);\n\tspin_lock_init(&sdp->sd_jindex_spin);\n\tmutex_init(&sdp->sd_jindex_mutex);\n\tinit_completion(&sdp->sd_journal_ready);\n\n\tINIT_LIST_HEAD(&sdp->sd_quota_list);\n\tmutex_init(&sdp->sd_quota_mutex);\n\tmutex_init(&sdp->sd_quota_sync_mutex);\n\tinit_waitqueue_head(&sdp->sd_quota_wait);\n\tINIT_LIST_HEAD(&sdp->sd_trunc_list);\n\tspin_lock_init(&sdp->sd_trunc_lock);\n\tspin_lock_init(&sdp->sd_bitmap_lock);\n\n\tmapping = &sdp->sd_aspace;\n\n\taddress_space_init_once(mapping);\n\tmapping->a_ops = &gfs2_rgrp_aops;\n\tmapping->host = sb->s_bdev->bd_inode;\n\tmapping->flags = 0;\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\n\tspin_lock_init(&sdp->sd_log_lock);\n\tatomic_set(&sdp->sd_log_pinned, 0);\n\tINIT_LIST_HEAD(&sdp->sd_log_le_revoke);\n\tINIT_LIST_HEAD(&sdp->sd_log_le_ordered);\n\tspin_lock_init(&sdp->sd_ordered_lock);\n\n\tinit_waitqueue_head(&sdp->sd_log_waitq);\n\tinit_waitqueue_head(&sdp->sd_logd_waitq);\n\tspin_lock_init(&sdp->sd_ail_lock);\n\tINIT_LIST_HEAD(&sdp->sd_ail1_list);\n\tINIT_LIST_HEAD(&sdp->sd_ail2_list);\n\n\tinit_rwsem(&sdp->sd_log_flush_lock);\n\tatomic_set(&sdp->sd_log_in_flight, 0);\n\tatomic_set(&sdp->sd_reserving_log, 0);\n\tinit_waitqueue_head(&sdp->sd_reserving_log_wait);\n\tinit_waitqueue_head(&sdp->sd_log_flush_wait);\n\tatomic_set(&sdp->sd_freeze_state, SFS_UNFROZEN);\n\tmutex_init(&sdp->sd_freeze_mutex);\n\n\treturn sdp;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct gfs2_sbd *init_sbd(struct super_block *sb)\n{\n\tstruct gfs2_sbd *sdp;\n\tstruct address_space *mapping;\n\n\tsdp = kzalloc(sizeof(struct gfs2_sbd), GFP_KERNEL);\n\tif (!sdp)\n\t\treturn NULL;\n\n\tsb->s_fs_info = sdp;\n\tsdp->sd_vfs = sb;\n\tsdp->sd_lkstats = alloc_percpu(struct gfs2_pcpu_lkstats);\n\tif (!sdp->sd_lkstats) {\n\t\tkfree(sdp);\n\t\treturn NULL;\n\t}\n\n\tset_bit(SDF_NOJOURNALID, &sdp->sd_flags);\n\tgfs2_tune_init(&sdp->sd_tune);\n\n\tinit_waitqueue_head(&sdp->sd_glock_wait);\n\tatomic_set(&sdp->sd_glock_disposal, 0);\n\tinit_completion(&sdp->sd_locking_init);\n\tinit_completion(&sdp->sd_wdack);\n\tspin_lock_init(&sdp->sd_statfs_spin);\n\n\tspin_lock_init(&sdp->sd_rindex_spin);\n\tsdp->sd_rindex_tree.rb_node = NULL;\n\n\tINIT_LIST_HEAD(&sdp->sd_jindex_list);\n\tspin_lock_init(&sdp->sd_jindex_spin);\n\tmutex_init(&sdp->sd_jindex_mutex);\n\tinit_completion(&sdp->sd_journal_ready);\n\n\tINIT_LIST_HEAD(&sdp->sd_quota_list);\n\tmutex_init(&sdp->sd_quota_mutex);\n\tmutex_init(&sdp->sd_quota_sync_mutex);\n\tinit_waitqueue_head(&sdp->sd_quota_wait);\n\tINIT_LIST_HEAD(&sdp->sd_trunc_list);\n\tspin_lock_init(&sdp->sd_trunc_lock);\n\tspin_lock_init(&sdp->sd_bitmap_lock);\n\n\tmapping = &sdp->sd_aspace;\n\n\taddress_space_init_once(mapping);\n\tmapping->a_ops = &gfs2_rgrp_aops;\n\tmapping->host = sb->s_bdev->bd_inode;\n\tmapping->flags = 0;\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\n\tspin_lock_init(&sdp->sd_log_lock);\n\tatomic_set(&sdp->sd_log_pinned, 0);\n\tINIT_LIST_HEAD(&sdp->sd_log_le_revoke);\n\tINIT_LIST_HEAD(&sdp->sd_log_le_ordered);\n\tspin_lock_init(&sdp->sd_ordered_lock);\n\n\tinit_waitqueue_head(&sdp->sd_log_waitq);\n\tinit_waitqueue_head(&sdp->sd_logd_waitq);\n\tspin_lock_init(&sdp->sd_ail_lock);\n\tINIT_LIST_HEAD(&sdp->sd_ail1_list);\n\tINIT_LIST_HEAD(&sdp->sd_ail2_list);\n\n\tinit_rwsem(&sdp->sd_log_flush_lock);\n\tatomic_set(&sdp->sd_log_in_flight, 0);\n\tatomic_set(&sdp->sd_reserving_log, 0);\n\tinit_waitqueue_head(&sdp->sd_reserving_log_wait);\n\tinit_waitqueue_head(&sdp->sd_log_flush_wait);\n\tatomic_set(&sdp->sd_freeze_state, SFS_UNFROZEN);\n\tmutex_init(&sdp->sd_freeze_mutex);\n\n\treturn sdp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define UNDO 1\n#define DO 0\n\nstatic int fill_super(struct super_block *sb, struct gfs2_args *args, int silent)\n{\n\tstruct gfs2_sbd *sdp;\n\tstruct gfs2_holder mount_gh;\n\tint error;\n\n\tsdp = init_sbd(sb);\n\tif (!sdp) {\n\t\tpr_warn(\"can't alloc struct gfs2_sbd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tsdp->sd_args = *args;\n\n\tif (sdp->sd_args.ar_spectator) {\n                sb->s_flags |= MS_RDONLY;\n\t\tset_bit(SDF_RORECOVERY, &sdp->sd_flags);\n\t}\n\tif (sdp->sd_args.ar_posix_acl)\n\t\tsb->s_flags |= MS_POSIXACL;\n\tif (sdp->sd_args.ar_nobarrier)\n\t\tset_bit(SDF_NOBARRIERS, &sdp->sd_flags);\n\n\tsb->s_flags |= MS_NOSEC;\n\tsb->s_magic = GFS2_MAGIC;\n\tsb->s_op = &gfs2_super_ops;\n\tsb->s_d_op = &gfs2_dops;\n\tsb->s_export_op = &gfs2_export_ops;\n\tsb->s_xattr = gfs2_xattr_handlers;\n\tsb->s_qcop = &gfs2_quotactl_ops;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;\n\tsb->s_time_gran = 1;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\n\t/* Set up the buffer cache and fill in some fake block size values\n\t   to allow us to read-in the on-disk superblock. */\n\tsdp->sd_sb.sb_bsize = sb_min_blocksize(sb, GFS2_BASIC_BLOCK);\n\tsdp->sd_sb.sb_bsize_shift = sb->s_blocksize_bits;\n\tsdp->sd_fsb2bb_shift = sdp->sd_sb.sb_bsize_shift -\n                               GFS2_BASIC_BLOCK_SHIFT;\n\tsdp->sd_fsb2bb = 1 << sdp->sd_fsb2bb_shift;\n\n\tsdp->sd_tune.gt_logd_secs = sdp->sd_args.ar_commit;\n\tsdp->sd_tune.gt_quota_quantum = sdp->sd_args.ar_quota_quantum;\n\tif (sdp->sd_args.ar_statfs_quantum) {\n\t\tsdp->sd_tune.gt_statfs_slow = 0;\n\t\tsdp->sd_tune.gt_statfs_quantum = sdp->sd_args.ar_statfs_quantum;\n\t} else {\n\t\tsdp->sd_tune.gt_statfs_slow = 1;\n\t\tsdp->sd_tune.gt_statfs_quantum = 30;\n\t}\n\n\terror = init_names(sdp, silent);\n\tif (error) {\n\t\t/* In this case, we haven't initialized sysfs, so we have to\n\t\t   manually free the sdp. */\n\t\tfree_percpu(sdp->sd_lkstats);\n\t\tkfree(sdp);\n\t\tsb->s_fs_info = NULL;\n\t\treturn error;\n\t}\n\n\tsnprintf(sdp->sd_fsname, GFS2_FSNAME_LEN, \"%s\", sdp->sd_table_name);\n\n\terror = gfs2_sys_fs_add(sdp);\n\t/*\n\t * If we hit an error here, gfs2_sys_fs_add will have called function\n\t * kobject_put which causes the sysfs usage count to go to zero, which\n\t * causes sysfs to call function gfs2_sbd_release, which frees sdp.\n\t * Subsequent error paths here will call gfs2_sys_fs_del, which also\n\t * kobject_put to free sdp.\n\t */\n\tif (error)\n\t\treturn error;\n\n\tgfs2_create_debugfs_file(sdp);\n\n\terror = gfs2_lm_mount(sdp, silent);\n\tif (error)\n\t\tgoto fail_debug;\n\n\terror = init_locking(sdp, &mount_gh, DO);\n\tif (error)\n\t\tgoto fail_lm;\n\n\terror = init_sb(sdp, silent);\n\tif (error)\n\t\tgoto fail_locking;\n\n\terror = wait_on_journal(sdp);\n\tif (error)\n\t\tgoto fail_sb;\n\n\t/*\n\t * If user space has failed to join the cluster or some similar\n\t * failure has occurred, then the journal id will contain a\n\t * negative (error) number. This will then be returned to the\n\t * caller (of the mount syscall). We do this even for spectator\n\t * mounts (which just write a jid of 0 to indicate \"ok\" even though\n\t * the jid is unused in the spectator case)\n\t */\n\tif (sdp->sd_lockstruct.ls_jid < 0) {\n\t\terror = sdp->sd_lockstruct.ls_jid;\n\t\tsdp->sd_lockstruct.ls_jid = 0;\n\t\tgoto fail_sb;\n\t}\n\n\tif (sdp->sd_args.ar_spectator)\n\t\tsnprintf(sdp->sd_fsname, GFS2_FSNAME_LEN, \"%s.s\",\n\t\t\t sdp->sd_table_name);\n\telse\n\t\tsnprintf(sdp->sd_fsname, GFS2_FSNAME_LEN, \"%s.%u\",\n\t\t\t sdp->sd_table_name, sdp->sd_lockstruct.ls_jid);\n\n\terror = init_inodes(sdp, DO);\n\tif (error)\n\t\tgoto fail_sb;\n\n\terror = init_per_node(sdp, DO);\n\tif (error)\n\t\tgoto fail_inodes;\n\n\terror = gfs2_statfs_init(sdp);\n\tif (error) {\n\t\tfs_err(sdp, \"can't initialize statfs subsystem: %d\\n\", error);\n\t\tgoto fail_per_node;\n\t}\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\terror = gfs2_make_fs_rw(sdp);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"can't make FS RW: %d\\n\", error);\n\t\t\tgoto fail_per_node;\n\t\t}\n\t}\n\n\tgfs2_glock_dq_uninit(&mount_gh);\n\tgfs2_online_uevent(sdp);\n\treturn 0;\n\nfail_per_node:\n\tinit_per_node(sdp, UNDO);\nfail_inodes:\n\tinit_inodes(sdp, UNDO);\nfail_sb:\n\tif (sdp->sd_root_dir)\n\t\tdput(sdp->sd_root_dir);\n\tif (sdp->sd_master_dir)\n\t\tdput(sdp->sd_master_dir);\n\tif (sb->s_root)\n\t\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfail_locking:\n\tinit_locking(sdp, &mount_gh, UNDO);\nfail_lm:\n\tcomplete_all(&sdp->sd_journal_ready);\n\tgfs2_gl_hash_clear(sdp);\n\tgfs2_lm_unmount(sdp);\nfail_debug:\n\tgfs2_delete_debugfs_file(sdp);\n\tfree_percpu(sdp->sd_lkstats);\n\t/* gfs2_sys_fs_del must be the last thing we do, since it causes\n\t * sysfs to call function gfs2_sbd_release, which frees sdp. */\n\tgfs2_sys_fs_del(sdp);\n\tsb->s_fs_info = NULL;\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_online_uevent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "1027-1036",
    "snippet": "void gfs2_online_uevent(struct gfs2_sbd *sdp)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tchar ro[20];\n\tchar spectator[20];\n\tchar *envp[] = { ro, spectator, NULL };\n\tsprintf(ro, \"RDONLY=%d\", (sb->s_flags & MS_RDONLY) ? 1 : 0);\n\tsprintf(spectator, \"SPECTATOR=%d\", sdp->sd_args.ar_spectator ? 1 : 0);\n\tkobject_uevent_env(&sdp->sd_kobj, KOBJ_ONLINE, envp);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_uevent_env",
          "args": [
            "&sdp->sd_kobj",
            "KOBJ_ONLINE",
            "envp"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "spectator",
            "\"SPECTATOR=%d\"",
            "sdp->sd_args.ar_spectator ? 1 : 0"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ro",
            "\"RDONLY=%d\"",
            "(sb->s_flags & MS_RDONLY) ? 1 : 0"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_online_uevent(struct gfs2_sbd *sdp)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tchar ro[20];\n\tchar spectator[20];\n\tchar *envp[] = { ro, spectator, NULL };\n\tsprintf(ro, \"RDONLY=%d\", (sb->s_flags & MS_RDONLY) ? 1 : 0);\n\tsprintf(spectator, \"SPECTATOR=%d\", sdp->sd_args.ar_spectator ? 1 : 0);\n\tkobject_uevent_env(&sdp->sd_kobj, KOBJ_ONLINE, envp);\n}"
  },
  {
    "function_name": "wait_on_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "1018-1025",
    "snippet": "static int wait_on_journal(struct gfs2_sbd *sdp)\n{\n\tif (sdp->sd_lockstruct.ls_ops->lm_mount == NULL)\n\t\treturn 0;\n\n\treturn wait_on_bit(&sdp->sd_flags, SDF_NOJOURNALID, TASK_INTERRUPTIBLE)\n\t\t? -EINTR : 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_bit",
          "args": [
            "&sdp->sd_flags",
            "SDF_NOJOURNALID",
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int wait_on_journal(struct gfs2_sbd *sdp)\n{\n\tif (sdp->sd_lockstruct.ls_ops->lm_mount == NULL)\n\t\treturn 0;\n\n\treturn wait_on_bit(&sdp->sd_flags, SDF_NOJOURNALID, TASK_INTERRUPTIBLE)\n\t\t? -EINTR : 0;\n}"
  },
  {
    "function_name": "gfs2_lm_unmount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "1010-1016",
    "snippet": "void gfs2_lm_unmount(struct gfs2_sbd *sdp)\n{\n\tconst struct lm_lockops *lm = sdp->sd_lockstruct.ls_ops;\n\tif (likely(!test_bit(SDF_SHUTDOWN, &sdp->sd_flags)) &&\n\t    lm->lm_unmount)\n\t\tlm->lm_unmount(sdp);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lm->lm_unmount",
          "args": [
            "sdp"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!test_bit(SDF_SHUTDOWN, &sdp->sd_flags)"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "SDF_SHUTDOWN",
            "&sdp->sd_flags"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_lm_unmount(struct gfs2_sbd *sdp)\n{\n\tconst struct lm_lockops *lm = sdp->sd_lockstruct.ls_ops;\n\tif (likely(!test_bit(SDF_SHUTDOWN, &sdp->sd_flags)) &&\n\t    lm->lm_unmount)\n\t\tlm->lm_unmount(sdp);\n}"
  },
  {
    "function_name": "gfs2_lm_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "937-1008",
    "snippet": "static int gfs2_lm_mount(struct gfs2_sbd *sdp, int silent)\n{\n\tconst struct lm_lockops *lm;\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tstruct gfs2_args *args = &sdp->sd_args;\n\tconst char *proto = sdp->sd_proto_name;\n\tconst char *table = sdp->sd_table_name;\n\tchar *o, *options;\n\tint ret;\n\n\tif (!strcmp(\"lock_nolock\", proto)) {\n\t\tlm = &nolock_ops;\n\t\tsdp->sd_args.ar_localflocks = 1;\n#ifdef CONFIG_GFS2_FS_LOCKING_DLM\n\t} else if (!strcmp(\"lock_dlm\", proto)) {\n\t\tlm = &gfs2_dlm_ops;\n#endif\n\t} else {\n\t\tpr_info(\"can't find protocol %s\\n\", proto);\n\t\treturn -ENOENT;\n\t}\n\n\tfs_info(sdp, \"Trying to join cluster \\\"%s\\\", \\\"%s\\\"\\n\", proto, table);\n\n\tls->ls_ops = lm;\n\tls->ls_first = 1;\n\n\tfor (options = args->ar_hostdata; (o = strsep(&options, \":\")); ) {\n\t\tsubstring_t tmp[MAX_OPT_ARGS];\n\t\tint token, option;\n\n\t\tif (!o || !*o)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(o, *lm->lm_tokens, tmp);\n\t\tswitch (token) {\n\t\tcase Opt_jid:\n\t\t\tret = match_int(&tmp[0], &option);\n\t\t\tif (ret || option < 0) \n\t\t\t\tgoto hostdata_error;\n\t\t\tif (test_and_clear_bit(SDF_NOJOURNALID, &sdp->sd_flags))\n\t\t\t\tls->ls_jid = option;\n\t\t\tbreak;\n\t\tcase Opt_id:\n\t\tcase Opt_nodir:\n\t\t\t/* Obsolete, but left for backward compat purposes */\n\t\t\tbreak;\n\t\tcase Opt_first:\n\t\t\tret = match_int(&tmp[0], &option);\n\t\t\tif (ret || (option != 0 && option != 1))\n\t\t\t\tgoto hostdata_error;\n\t\t\tls->ls_first = option;\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\tdefault:\nhostdata_error:\n\t\t\tfs_info(sdp, \"unknown hostdata (%s)\\n\", o);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (lm->lm_mount == NULL) {\n\t\tfs_info(sdp, \"Now mounting FS...\\n\");\n\t\tcomplete_all(&sdp->sd_locking_init);\n\t\treturn 0;\n\t}\n\tret = lm->lm_mount(sdp, table);\n\tif (ret == 0)\n\t\tfs_info(sdp, \"Joined cluster. Now mounting FS...\\n\");\n\tcomplete_all(&sdp->sd_locking_init);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct lm_lockops nolock_ops = {\n\t.lm_proto_name = \"lock_nolock\",\n\t.lm_put_lock = gfs2_glock_free,\n\t.lm_tokens = &nolock_tokens,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete_all",
          "args": [
            "&sdp->sd_locking_init"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_info",
          "args": [
            "sdp",
            "\"Joined cluster. Now mounting FS...\\n\""
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fs_info_to_kstatfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2426-2436",
          "snippet": "static void\ncopy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\n\t\t\tstruct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\n\t\t\t  le32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\n\tkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\n\tkst->f_bfree  = le64_to_cpu(pfs_inf->ActualAvailableAllocationUnits);\n\tkst->f_bavail = le64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\n\treturn;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void\ncopy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\n\t\t\tstruct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\n\t\t\t  le32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\n\tkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\n\tkst->f_bfree  = le64_to_cpu(pfs_inf->ActualAvailableAllocationUnits);\n\tkst->f_bavail = le64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lm->lm_mount",
          "args": [
            "sdp",
            "table"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete_all",
          "args": [
            "&sdp->sd_locking_init"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_info",
          "args": [
            "sdp",
            "\"unknown hostdata (%s)\\n\"",
            "o"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&tmp[0]",
            "&option"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "SDF_NOJOURNALID",
            "&sdp->sd_flags"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&tmp[0]",
            "&option"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "o",
            "*lm->lm_tokens",
            "tmp"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\":\""
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"can't find protocol %s\\n\"",
            "proto"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"lock_dlm\"",
            "proto"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic const struct lm_lockops nolock_ops = {\n\t.lm_proto_name = \"lock_nolock\",\n\t.lm_put_lock = gfs2_glock_free,\n\t.lm_tokens = &nolock_tokens,\n};\n\nstatic int gfs2_lm_mount(struct gfs2_sbd *sdp, int silent)\n{\n\tconst struct lm_lockops *lm;\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tstruct gfs2_args *args = &sdp->sd_args;\n\tconst char *proto = sdp->sd_proto_name;\n\tconst char *table = sdp->sd_table_name;\n\tchar *o, *options;\n\tint ret;\n\n\tif (!strcmp(\"lock_nolock\", proto)) {\n\t\tlm = &nolock_ops;\n\t\tsdp->sd_args.ar_localflocks = 1;\n#ifdef CONFIG_GFS2_FS_LOCKING_DLM\n\t} else if (!strcmp(\"lock_dlm\", proto)) {\n\t\tlm = &gfs2_dlm_ops;\n#endif\n\t} else {\n\t\tpr_info(\"can't find protocol %s\\n\", proto);\n\t\treturn -ENOENT;\n\t}\n\n\tfs_info(sdp, \"Trying to join cluster \\\"%s\\\", \\\"%s\\\"\\n\", proto, table);\n\n\tls->ls_ops = lm;\n\tls->ls_first = 1;\n\n\tfor (options = args->ar_hostdata; (o = strsep(&options, \":\")); ) {\n\t\tsubstring_t tmp[MAX_OPT_ARGS];\n\t\tint token, option;\n\n\t\tif (!o || !*o)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(o, *lm->lm_tokens, tmp);\n\t\tswitch (token) {\n\t\tcase Opt_jid:\n\t\t\tret = match_int(&tmp[0], &option);\n\t\t\tif (ret || option < 0) \n\t\t\t\tgoto hostdata_error;\n\t\t\tif (test_and_clear_bit(SDF_NOJOURNALID, &sdp->sd_flags))\n\t\t\t\tls->ls_jid = option;\n\t\t\tbreak;\n\t\tcase Opt_id:\n\t\tcase Opt_nodir:\n\t\t\t/* Obsolete, but left for backward compat purposes */\n\t\t\tbreak;\n\t\tcase Opt_first:\n\t\t\tret = match_int(&tmp[0], &option);\n\t\t\tif (ret || (option != 0 && option != 1))\n\t\t\t\tgoto hostdata_error;\n\t\t\tls->ls_first = option;\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\tdefault:\nhostdata_error:\n\t\t\tfs_info(sdp, \"unknown hostdata (%s)\\n\", o);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (lm->lm_mount == NULL) {\n\t\tfs_info(sdp, \"Now mounting FS...\\n\");\n\t\tcomplete_all(&sdp->sd_locking_init);\n\t\treturn 0;\n\t}\n\tret = lm->lm_mount(sdp, table);\n\tif (ret == 0)\n\t\tfs_info(sdp, \"Joined cluster. Now mounting FS...\\n\");\n\tcomplete_all(&sdp->sd_locking_init);\n\treturn ret;\n}"
  },
  {
    "function_name": "init_per_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "845-915",
    "snippet": "static int init_per_node(struct gfs2_sbd *sdp, int undo)\n{\n\tstruct inode *pn = NULL;\n\tchar buf[30];\n\tint error = 0;\n\tstruct gfs2_inode *ip;\n\tstruct inode *master = sdp->sd_master_dir->d_inode;\n\n\tif (sdp->sd_args.ar_spectator)\n\t\treturn 0;\n\n\tif (undo)\n\t\tgoto fail_qc_gh;\n\n\tpn = gfs2_lookup_simple(master, \"per_node\");\n\tif (IS_ERR(pn)) {\n\t\terror = PTR_ERR(pn);\n\t\tfs_err(sdp, \"can't find per_node directory: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tsprintf(buf, \"statfs_change%u\", sdp->sd_jdesc->jd_jid);\n\tsdp->sd_sc_inode = gfs2_lookup_simple(pn, buf);\n\tif (IS_ERR(sdp->sd_sc_inode)) {\n\t\terror = PTR_ERR(sdp->sd_sc_inode);\n\t\tfs_err(sdp, \"can't find local \\\"sc\\\" file: %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\tsprintf(buf, \"quota_change%u\", sdp->sd_jdesc->jd_jid);\n\tsdp->sd_qc_inode = gfs2_lookup_simple(pn, buf);\n\tif (IS_ERR(sdp->sd_qc_inode)) {\n\t\terror = PTR_ERR(sdp->sd_qc_inode);\n\t\tfs_err(sdp, \"can't find local \\\"qc\\\" file: %d\\n\", error);\n\t\tgoto fail_ut_i;\n\t}\n\n\tiput(pn);\n\tpn = NULL;\n\n\tip = GFS2_I(sdp->sd_sc_inode);\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0,\n\t\t\t\t   &sdp->sd_sc_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't lock local \\\"sc\\\" file: %d\\n\", error);\n\t\tgoto fail_qc_i;\n\t}\n\n\tip = GFS2_I(sdp->sd_qc_inode);\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0,\n\t\t\t\t   &sdp->sd_qc_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't lock local \\\"qc\\\" file: %d\\n\", error);\n\t\tgoto fail_ut_gh;\n\t}\n\n\treturn 0;\n\nfail_qc_gh:\n\tgfs2_glock_dq_uninit(&sdp->sd_qc_gh);\nfail_ut_gh:\n\tgfs2_glock_dq_uninit(&sdp->sd_sc_gh);\nfail_qc_i:\n\tiput(sdp->sd_qc_inode);\nfail_ut_i:\n\tiput(sdp->sd_sc_inode);\nfail:\n\tif (pn)\n\t\tiput(pn);\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "pn"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&sdp->sd_sc_gh"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"can't lock local \\\"qc\\\" file: %d\\n\"",
            "error"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "ip->i_gl",
            "LM_ST_EXCLUSIVE",
            "0",
            "&sdp->sd_qc_gh"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "sdp->sd_qc_inode"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sdp->sd_qc_inode"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sdp->sd_qc_inode"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_lookup_simple",
          "args": [
            "pn",
            "buf"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lookup_simple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "250-265",
          "snippet": "struct inode *gfs2_lookup_simple(struct inode *dip, const char *name)\n{\n\tstruct qstr qstr;\n\tstruct inode *inode;\n\tgfs2_str2qstr(&qstr, name);\n\tinode = gfs2_lookupi(dip, &qstr, 1);\n\t/* gfs2_lookupi has inconsistent callers: vfs\n\t * related routines expect NULL for no entry found,\n\t * gfs2_lookup_simple callers expect ENOENT\n\t * and do not check for NULL.\n\t */\n\tif (inode == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\telse\n\t\treturn inode;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct inode *gfs2_lookup_simple(struct inode *dip, const char *name)\n{\n\tstruct qstr qstr;\n\tstruct inode *inode;\n\tgfs2_str2qstr(&qstr, name);\n\tinode = gfs2_lookupi(dip, &qstr, 1);\n\t/* gfs2_lookupi has inconsistent callers: vfs\n\t * related routines expect NULL for no entry found,\n\t * gfs2_lookup_simple callers expect ENOENT\n\t * and do not check for NULL.\n\t */\n\tif (inode == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\telse\n\t\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"quota_change%u\"",
            "sdp->sd_jdesc->jd_jid"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sdp->sd_sc_inode"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sdp->sd_sc_inode"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"statfs_change%u\"",
            "sdp->sd_jdesc->jd_jid"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pn"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pn"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int init_per_node(struct gfs2_sbd *sdp, int undo)\n{\n\tstruct inode *pn = NULL;\n\tchar buf[30];\n\tint error = 0;\n\tstruct gfs2_inode *ip;\n\tstruct inode *master = sdp->sd_master_dir->d_inode;\n\n\tif (sdp->sd_args.ar_spectator)\n\t\treturn 0;\n\n\tif (undo)\n\t\tgoto fail_qc_gh;\n\n\tpn = gfs2_lookup_simple(master, \"per_node\");\n\tif (IS_ERR(pn)) {\n\t\terror = PTR_ERR(pn);\n\t\tfs_err(sdp, \"can't find per_node directory: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tsprintf(buf, \"statfs_change%u\", sdp->sd_jdesc->jd_jid);\n\tsdp->sd_sc_inode = gfs2_lookup_simple(pn, buf);\n\tif (IS_ERR(sdp->sd_sc_inode)) {\n\t\terror = PTR_ERR(sdp->sd_sc_inode);\n\t\tfs_err(sdp, \"can't find local \\\"sc\\\" file: %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\tsprintf(buf, \"quota_change%u\", sdp->sd_jdesc->jd_jid);\n\tsdp->sd_qc_inode = gfs2_lookup_simple(pn, buf);\n\tif (IS_ERR(sdp->sd_qc_inode)) {\n\t\terror = PTR_ERR(sdp->sd_qc_inode);\n\t\tfs_err(sdp, \"can't find local \\\"qc\\\" file: %d\\n\", error);\n\t\tgoto fail_ut_i;\n\t}\n\n\tiput(pn);\n\tpn = NULL;\n\n\tip = GFS2_I(sdp->sd_sc_inode);\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0,\n\t\t\t\t   &sdp->sd_sc_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't lock local \\\"sc\\\" file: %d\\n\", error);\n\t\tgoto fail_qc_i;\n\t}\n\n\tip = GFS2_I(sdp->sd_qc_inode);\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0,\n\t\t\t\t   &sdp->sd_qc_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't lock local \\\"qc\\\" file: %d\\n\", error);\n\t\tgoto fail_ut_gh;\n\t}\n\n\treturn 0;\n\nfail_qc_gh:\n\tgfs2_glock_dq_uninit(&sdp->sd_qc_gh);\nfail_ut_gh:\n\tgfs2_glock_dq_uninit(&sdp->sd_sc_gh);\nfail_qc_i:\n\tiput(sdp->sd_qc_inode);\nfail_ut_i:\n\tiput(sdp->sd_sc_inode);\nfail:\n\tif (pn)\n\t\tiput(pn);\n\treturn error;\n}"
  },
  {
    "function_name": "init_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "782-843",
    "snippet": "static int init_inodes(struct gfs2_sbd *sdp, int undo)\n{\n\tint error = 0;\n\tstruct inode *master = sdp->sd_master_dir->d_inode;\n\n\tif (undo)\n\t\tgoto fail_qinode;\n\n\terror = init_journal(sdp, undo);\n\tcomplete_all(&sdp->sd_journal_ready);\n\tif (error)\n\t\tgoto fail;\n\n\t/* Read in the master statfs inode */\n\tsdp->sd_statfs_inode = gfs2_lookup_simple(master, \"statfs\");\n\tif (IS_ERR(sdp->sd_statfs_inode)) {\n\t\terror = PTR_ERR(sdp->sd_statfs_inode);\n\t\tfs_err(sdp, \"can't read in statfs inode: %d\\n\", error);\n\t\tgoto fail_journal;\n\t}\n\n\t/* Read in the resource index inode */\n\tsdp->sd_rindex = gfs2_lookup_simple(master, \"rindex\");\n\tif (IS_ERR(sdp->sd_rindex)) {\n\t\terror = PTR_ERR(sdp->sd_rindex);\n\t\tfs_err(sdp, \"can't get resource index inode: %d\\n\", error);\n\t\tgoto fail_statfs;\n\t}\n\tsdp->sd_rindex_uptodate = 0;\n\n\t/* Read in the quota inode */\n\tsdp->sd_quota_inode = gfs2_lookup_simple(master, \"quota\");\n\tif (IS_ERR(sdp->sd_quota_inode)) {\n\t\terror = PTR_ERR(sdp->sd_quota_inode);\n\t\tfs_err(sdp, \"can't get quota file inode: %d\\n\", error);\n\t\tgoto fail_rindex;\n\t}\n\t/*\n\t * i_mutex on quota files is special. Since this inode is hidden system\n\t * file, we are safe to define locking ourselves.\n\t */\n\tlockdep_set_class(&sdp->sd_quota_inode->i_mutex,\n\t\t\t  &gfs2_quota_imutex_key);\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\tgoto fail_qinode;\n\n\treturn 0;\n\nfail_qinode:\n\tiput(sdp->sd_quota_inode);\nfail_rindex:\n\tgfs2_clear_rgrpd(sdp);\n\tiput(sdp->sd_rindex);\nfail_statfs:\n\tiput(sdp->sd_statfs_inode);\nfail_journal:\n\tinit_journal(sdp, UNDO);\nfail:\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UNDO 1"
    ],
    "globals_used": [
      "static struct lock_class_key gfs2_quota_imutex_key;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_journal",
          "args": [
            "sdp",
            "UNDO"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "init_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "648-778",
          "snippet": "static int init_journal(struct gfs2_sbd *sdp, int undo)\n{\n\tstruct inode *master = sdp->sd_master_dir->d_inode;\n\tstruct gfs2_holder ji_gh;\n\tstruct gfs2_inode *ip;\n\tint jindex = 1;\n\tint error = 0;\n\n\tif (undo) {\n\t\tjindex = 0;\n\t\tgoto fail_jinode_gh;\n\t}\n\n\tsdp->sd_jindex = gfs2_lookup_simple(master, \"jindex\");\n\tif (IS_ERR(sdp->sd_jindex)) {\n\t\tfs_err(sdp, \"can't lookup journal index: %d\\n\", error);\n\t\treturn PTR_ERR(sdp->sd_jindex);\n\t}\n\n\t/* Load in the journal index special file */\n\n\terror = gfs2_jindex_hold(sdp, &ji_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't read journal index: %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = -EUSERS;\n\tif (!gfs2_jindex_size(sdp)) {\n\t\tfs_err(sdp, \"no journals!\\n\");\n\t\tgoto fail_jindex;\n\t}\n\n\tif (sdp->sd_args.ar_spectator) {\n\t\tsdp->sd_jdesc = gfs2_jdesc_find(sdp, 0);\n\t\tatomic_set(&sdp->sd_log_blks_free, sdp->sd_jdesc->jd_blocks);\n\t\tatomic_set(&sdp->sd_log_thresh1, 2*sdp->sd_jdesc->jd_blocks/5);\n\t\tatomic_set(&sdp->sd_log_thresh2, 4*sdp->sd_jdesc->jd_blocks/5);\n\t} else {\n\t\tif (sdp->sd_lockstruct.ls_jid >= gfs2_jindex_size(sdp)) {\n\t\t\tfs_err(sdp, \"can't mount journal #%u\\n\",\n\t\t\t       sdp->sd_lockstruct.ls_jid);\n\t\t\tfs_err(sdp, \"there are only %u journals (0 - %u)\\n\",\n\t\t\t       gfs2_jindex_size(sdp),\n\t\t\t       gfs2_jindex_size(sdp) - 1);\n\t\t\tgoto fail_jindex;\n\t\t}\n\t\tsdp->sd_jdesc = gfs2_jdesc_find(sdp, sdp->sd_lockstruct.ls_jid);\n\n\t\terror = gfs2_glock_nq_num(sdp, sdp->sd_lockstruct.ls_jid,\n\t\t\t\t\t  &gfs2_journal_glops,\n\t\t\t\t\t  LM_ST_EXCLUSIVE, LM_FLAG_NOEXP,\n\t\t\t\t\t  &sdp->sd_journal_gh);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"can't acquire journal glock: %d\\n\", error);\n\t\t\tgoto fail_jindex;\n\t\t}\n\n\t\tip = GFS2_I(sdp->sd_jdesc->jd_inode);\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED,\n\t\t\t\t\t   LM_FLAG_NOEXP | GL_EXACT | GL_NOCACHE,\n\t\t\t\t\t   &sdp->sd_jinode_gh);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"can't acquire journal inode glock: %d\\n\",\n\t\t\t       error);\n\t\t\tgoto fail_journal_gh;\n\t\t}\n\n\t\terror = gfs2_jdesc_check(sdp->sd_jdesc);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"my journal (%u) is bad: %d\\n\",\n\t\t\t       sdp->sd_jdesc->jd_jid, error);\n\t\t\tgoto fail_jinode_gh;\n\t\t}\n\t\tatomic_set(&sdp->sd_log_blks_free, sdp->sd_jdesc->jd_blocks);\n\t\tatomic_set(&sdp->sd_log_thresh1, 2*sdp->sd_jdesc->jd_blocks/5);\n\t\tatomic_set(&sdp->sd_log_thresh2, 4*sdp->sd_jdesc->jd_blocks/5);\n\n\t\t/* Map the extents for this journal's blocks */\n\t\tgfs2_map_journal_extents(sdp, sdp->sd_jdesc);\n\t}\n\ttrace_gfs2_log_blocks(sdp, atomic_read(&sdp->sd_log_blks_free));\n\n\tif (sdp->sd_lockstruct.ls_first) {\n\t\tunsigned int x;\n\t\tfor (x = 0; x < sdp->sd_journals; x++) {\n\t\t\tstruct gfs2_jdesc *jd = gfs2_jdesc_find(sdp, x);\n\n\t\t\tif (sdp->sd_args.ar_spectator) {\n\t\t\t\terror = check_journal_clean(sdp, jd);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto fail_jinode_gh;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terror = gfs2_recover_journal(jd, true);\n\t\t\tif (error) {\n\t\t\t\tfs_err(sdp, \"error recovering journal %u: %d\\n\",\n\t\t\t\t       x, error);\n\t\t\t\tgoto fail_jinode_gh;\n\t\t\t}\n\t\t}\n\n\t\tgfs2_others_may_mount(sdp);\n\t} else if (!sdp->sd_args.ar_spectator) {\n\t\terror = gfs2_recover_journal(sdp->sd_jdesc, true);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"error recovering my journal: %d\\n\", error);\n\t\t\tgoto fail_jinode_gh;\n\t\t}\n\t}\n\n\tset_bit(SDF_JOURNAL_CHECKED, &sdp->sd_flags);\n\tgfs2_glock_dq_uninit(&ji_gh);\n\tjindex = 0;\n\tINIT_WORK(&sdp->sd_freeze_work, gfs2_freeze_func);\n\treturn 0;\n\nfail_jinode_gh:\n\tif (!sdp->sd_args.ar_spectator)\n\t\tgfs2_glock_dq_uninit(&sdp->sd_jinode_gh);\nfail_journal_gh:\n\tif (!sdp->sd_args.ar_spectator)\n\t\tgfs2_glock_dq_uninit(&sdp->sd_journal_gh);\nfail_jindex:\n\tgfs2_jindex_free(sdp);\n\tif (jindex)\n\t\tgfs2_glock_dq_uninit(&ji_gh);\nfail:\n\tiput(sdp->sd_jindex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int init_journal(struct gfs2_sbd *sdp, int undo)\n{\n\tstruct inode *master = sdp->sd_master_dir->d_inode;\n\tstruct gfs2_holder ji_gh;\n\tstruct gfs2_inode *ip;\n\tint jindex = 1;\n\tint error = 0;\n\n\tif (undo) {\n\t\tjindex = 0;\n\t\tgoto fail_jinode_gh;\n\t}\n\n\tsdp->sd_jindex = gfs2_lookup_simple(master, \"jindex\");\n\tif (IS_ERR(sdp->sd_jindex)) {\n\t\tfs_err(sdp, \"can't lookup journal index: %d\\n\", error);\n\t\treturn PTR_ERR(sdp->sd_jindex);\n\t}\n\n\t/* Load in the journal index special file */\n\n\terror = gfs2_jindex_hold(sdp, &ji_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't read journal index: %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = -EUSERS;\n\tif (!gfs2_jindex_size(sdp)) {\n\t\tfs_err(sdp, \"no journals!\\n\");\n\t\tgoto fail_jindex;\n\t}\n\n\tif (sdp->sd_args.ar_spectator) {\n\t\tsdp->sd_jdesc = gfs2_jdesc_find(sdp, 0);\n\t\tatomic_set(&sdp->sd_log_blks_free, sdp->sd_jdesc->jd_blocks);\n\t\tatomic_set(&sdp->sd_log_thresh1, 2*sdp->sd_jdesc->jd_blocks/5);\n\t\tatomic_set(&sdp->sd_log_thresh2, 4*sdp->sd_jdesc->jd_blocks/5);\n\t} else {\n\t\tif (sdp->sd_lockstruct.ls_jid >= gfs2_jindex_size(sdp)) {\n\t\t\tfs_err(sdp, \"can't mount journal #%u\\n\",\n\t\t\t       sdp->sd_lockstruct.ls_jid);\n\t\t\tfs_err(sdp, \"there are only %u journals (0 - %u)\\n\",\n\t\t\t       gfs2_jindex_size(sdp),\n\t\t\t       gfs2_jindex_size(sdp) - 1);\n\t\t\tgoto fail_jindex;\n\t\t}\n\t\tsdp->sd_jdesc = gfs2_jdesc_find(sdp, sdp->sd_lockstruct.ls_jid);\n\n\t\terror = gfs2_glock_nq_num(sdp, sdp->sd_lockstruct.ls_jid,\n\t\t\t\t\t  &gfs2_journal_glops,\n\t\t\t\t\t  LM_ST_EXCLUSIVE, LM_FLAG_NOEXP,\n\t\t\t\t\t  &sdp->sd_journal_gh);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"can't acquire journal glock: %d\\n\", error);\n\t\t\tgoto fail_jindex;\n\t\t}\n\n\t\tip = GFS2_I(sdp->sd_jdesc->jd_inode);\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED,\n\t\t\t\t\t   LM_FLAG_NOEXP | GL_EXACT | GL_NOCACHE,\n\t\t\t\t\t   &sdp->sd_jinode_gh);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"can't acquire journal inode glock: %d\\n\",\n\t\t\t       error);\n\t\t\tgoto fail_journal_gh;\n\t\t}\n\n\t\terror = gfs2_jdesc_check(sdp->sd_jdesc);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"my journal (%u) is bad: %d\\n\",\n\t\t\t       sdp->sd_jdesc->jd_jid, error);\n\t\t\tgoto fail_jinode_gh;\n\t\t}\n\t\tatomic_set(&sdp->sd_log_blks_free, sdp->sd_jdesc->jd_blocks);\n\t\tatomic_set(&sdp->sd_log_thresh1, 2*sdp->sd_jdesc->jd_blocks/5);\n\t\tatomic_set(&sdp->sd_log_thresh2, 4*sdp->sd_jdesc->jd_blocks/5);\n\n\t\t/* Map the extents for this journal's blocks */\n\t\tgfs2_map_journal_extents(sdp, sdp->sd_jdesc);\n\t}\n\ttrace_gfs2_log_blocks(sdp, atomic_read(&sdp->sd_log_blks_free));\n\n\tif (sdp->sd_lockstruct.ls_first) {\n\t\tunsigned int x;\n\t\tfor (x = 0; x < sdp->sd_journals; x++) {\n\t\t\tstruct gfs2_jdesc *jd = gfs2_jdesc_find(sdp, x);\n\n\t\t\tif (sdp->sd_args.ar_spectator) {\n\t\t\t\terror = check_journal_clean(sdp, jd);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto fail_jinode_gh;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terror = gfs2_recover_journal(jd, true);\n\t\t\tif (error) {\n\t\t\t\tfs_err(sdp, \"error recovering journal %u: %d\\n\",\n\t\t\t\t       x, error);\n\t\t\t\tgoto fail_jinode_gh;\n\t\t\t}\n\t\t}\n\n\t\tgfs2_others_may_mount(sdp);\n\t} else if (!sdp->sd_args.ar_spectator) {\n\t\terror = gfs2_recover_journal(sdp->sd_jdesc, true);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"error recovering my journal: %d\\n\", error);\n\t\t\tgoto fail_jinode_gh;\n\t\t}\n\t}\n\n\tset_bit(SDF_JOURNAL_CHECKED, &sdp->sd_flags);\n\tgfs2_glock_dq_uninit(&ji_gh);\n\tjindex = 0;\n\tINIT_WORK(&sdp->sd_freeze_work, gfs2_freeze_func);\n\treturn 0;\n\nfail_jinode_gh:\n\tif (!sdp->sd_args.ar_spectator)\n\t\tgfs2_glock_dq_uninit(&sdp->sd_jinode_gh);\nfail_journal_gh:\n\tif (!sdp->sd_args.ar_spectator)\n\t\tgfs2_glock_dq_uninit(&sdp->sd_journal_gh);\nfail_jindex:\n\tgfs2_jindex_free(sdp);\n\tif (jindex)\n\t\tgfs2_glock_dq_uninit(&ji_gh);\nfail:\n\tiput(sdp->sd_jindex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "sdp->sd_statfs_inode"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_clear_rgrpd",
          "args": [
            "sdp"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_clear_rgrpd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "719-744",
          "snippet": "void gfs2_clear_rgrpd(struct gfs2_sbd *sdp)\n{\n\tstruct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_glock *gl;\n\n\twhile ((n = rb_first(&sdp->sd_rindex_tree))) {\n\t\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tgl = rgd->rd_gl;\n\n\t\trb_erase(n, &sdp->sd_rindex_tree);\n\n\t\tif (gl) {\n\t\t\tspin_lock(&gl->gl_spin);\n\t\t\tgl->gl_object = NULL;\n\t\t\tspin_unlock(&gl->gl_spin);\n\t\t\tgfs2_glock_add_to_lru(gl);\n\t\t\tgfs2_glock_put(gl);\n\t\t}\n\n\t\tgfs2_free_clones(rgd);\n\t\tkfree(rgd->rd_bits);\n\t\treturn_all_reservations(rgd);\n\t\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_clear_rgrpd(struct gfs2_sbd *sdp)\n{\n\tstruct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_glock *gl;\n\n\twhile ((n = rb_first(&sdp->sd_rindex_tree))) {\n\t\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tgl = rgd->rd_gl;\n\n\t\trb_erase(n, &sdp->sd_rindex_tree);\n\n\t\tif (gl) {\n\t\t\tspin_lock(&gl->gl_spin);\n\t\t\tgl->gl_object = NULL;\n\t\t\tspin_unlock(&gl->gl_spin);\n\t\t\tgfs2_glock_add_to_lru(gl);\n\t\t\tgfs2_glock_put(gl);\n\t\t}\n\n\t\tgfs2_free_clones(rgd);\n\t\tkfree(rgd->rd_bits);\n\t\treturn_all_reservations(rgd);\n\t\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rindex_update",
          "args": [
            "sdp"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rindex_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1029-1052",
          "snippet": "int gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&sdp->sd_quota_inode->i_mutex",
            "&gfs2_quota_imutex_key"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"can't get quota file inode: %d\\n\"",
            "error"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sdp->sd_quota_inode"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sdp->sd_quota_inode"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_lookup_simple",
          "args": [
            "master",
            "\"quota\""
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lookup_simple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "250-265",
          "snippet": "struct inode *gfs2_lookup_simple(struct inode *dip, const char *name)\n{\n\tstruct qstr qstr;\n\tstruct inode *inode;\n\tgfs2_str2qstr(&qstr, name);\n\tinode = gfs2_lookupi(dip, &qstr, 1);\n\t/* gfs2_lookupi has inconsistent callers: vfs\n\t * related routines expect NULL for no entry found,\n\t * gfs2_lookup_simple callers expect ENOENT\n\t * and do not check for NULL.\n\t */\n\tif (inode == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\telse\n\t\treturn inode;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct inode *gfs2_lookup_simple(struct inode *dip, const char *name)\n{\n\tstruct qstr qstr;\n\tstruct inode *inode;\n\tgfs2_str2qstr(&qstr, name);\n\tinode = gfs2_lookupi(dip, &qstr, 1);\n\t/* gfs2_lookupi has inconsistent callers: vfs\n\t * related routines expect NULL for no entry found,\n\t * gfs2_lookup_simple callers expect ENOENT\n\t * and do not check for NULL.\n\t */\n\tif (inode == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\telse\n\t\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sdp->sd_rindex"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sdp->sd_rindex"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sdp->sd_statfs_inode"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sdp->sd_statfs_inode"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete_all",
          "args": [
            "&sdp->sd_journal_ready"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define UNDO 1\n\nstatic struct lock_class_key gfs2_quota_imutex_key;\n\nstatic int init_inodes(struct gfs2_sbd *sdp, int undo)\n{\n\tint error = 0;\n\tstruct inode *master = sdp->sd_master_dir->d_inode;\n\n\tif (undo)\n\t\tgoto fail_qinode;\n\n\terror = init_journal(sdp, undo);\n\tcomplete_all(&sdp->sd_journal_ready);\n\tif (error)\n\t\tgoto fail;\n\n\t/* Read in the master statfs inode */\n\tsdp->sd_statfs_inode = gfs2_lookup_simple(master, \"statfs\");\n\tif (IS_ERR(sdp->sd_statfs_inode)) {\n\t\terror = PTR_ERR(sdp->sd_statfs_inode);\n\t\tfs_err(sdp, \"can't read in statfs inode: %d\\n\", error);\n\t\tgoto fail_journal;\n\t}\n\n\t/* Read in the resource index inode */\n\tsdp->sd_rindex = gfs2_lookup_simple(master, \"rindex\");\n\tif (IS_ERR(sdp->sd_rindex)) {\n\t\terror = PTR_ERR(sdp->sd_rindex);\n\t\tfs_err(sdp, \"can't get resource index inode: %d\\n\", error);\n\t\tgoto fail_statfs;\n\t}\n\tsdp->sd_rindex_uptodate = 0;\n\n\t/* Read in the quota inode */\n\tsdp->sd_quota_inode = gfs2_lookup_simple(master, \"quota\");\n\tif (IS_ERR(sdp->sd_quota_inode)) {\n\t\terror = PTR_ERR(sdp->sd_quota_inode);\n\t\tfs_err(sdp, \"can't get quota file inode: %d\\n\", error);\n\t\tgoto fail_rindex;\n\t}\n\t/*\n\t * i_mutex on quota files is special. Since this inode is hidden system\n\t * file, we are safe to define locking ourselves.\n\t */\n\tlockdep_set_class(&sdp->sd_quota_inode->i_mutex,\n\t\t\t  &gfs2_quota_imutex_key);\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\tgoto fail_qinode;\n\n\treturn 0;\n\nfail_qinode:\n\tiput(sdp->sd_quota_inode);\nfail_rindex:\n\tgfs2_clear_rgrpd(sdp);\n\tiput(sdp->sd_rindex);\nfail_statfs:\n\tiput(sdp->sd_statfs_inode);\nfail_journal:\n\tinit_journal(sdp, UNDO);\nfail:\n\treturn error;\n}"
  },
  {
    "function_name": "init_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "648-778",
    "snippet": "static int init_journal(struct gfs2_sbd *sdp, int undo)\n{\n\tstruct inode *master = sdp->sd_master_dir->d_inode;\n\tstruct gfs2_holder ji_gh;\n\tstruct gfs2_inode *ip;\n\tint jindex = 1;\n\tint error = 0;\n\n\tif (undo) {\n\t\tjindex = 0;\n\t\tgoto fail_jinode_gh;\n\t}\n\n\tsdp->sd_jindex = gfs2_lookup_simple(master, \"jindex\");\n\tif (IS_ERR(sdp->sd_jindex)) {\n\t\tfs_err(sdp, \"can't lookup journal index: %d\\n\", error);\n\t\treturn PTR_ERR(sdp->sd_jindex);\n\t}\n\n\t/* Load in the journal index special file */\n\n\terror = gfs2_jindex_hold(sdp, &ji_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't read journal index: %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = -EUSERS;\n\tif (!gfs2_jindex_size(sdp)) {\n\t\tfs_err(sdp, \"no journals!\\n\");\n\t\tgoto fail_jindex;\n\t}\n\n\tif (sdp->sd_args.ar_spectator) {\n\t\tsdp->sd_jdesc = gfs2_jdesc_find(sdp, 0);\n\t\tatomic_set(&sdp->sd_log_blks_free, sdp->sd_jdesc->jd_blocks);\n\t\tatomic_set(&sdp->sd_log_thresh1, 2*sdp->sd_jdesc->jd_blocks/5);\n\t\tatomic_set(&sdp->sd_log_thresh2, 4*sdp->sd_jdesc->jd_blocks/5);\n\t} else {\n\t\tif (sdp->sd_lockstruct.ls_jid >= gfs2_jindex_size(sdp)) {\n\t\t\tfs_err(sdp, \"can't mount journal #%u\\n\",\n\t\t\t       sdp->sd_lockstruct.ls_jid);\n\t\t\tfs_err(sdp, \"there are only %u journals (0 - %u)\\n\",\n\t\t\t       gfs2_jindex_size(sdp),\n\t\t\t       gfs2_jindex_size(sdp) - 1);\n\t\t\tgoto fail_jindex;\n\t\t}\n\t\tsdp->sd_jdesc = gfs2_jdesc_find(sdp, sdp->sd_lockstruct.ls_jid);\n\n\t\terror = gfs2_glock_nq_num(sdp, sdp->sd_lockstruct.ls_jid,\n\t\t\t\t\t  &gfs2_journal_glops,\n\t\t\t\t\t  LM_ST_EXCLUSIVE, LM_FLAG_NOEXP,\n\t\t\t\t\t  &sdp->sd_journal_gh);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"can't acquire journal glock: %d\\n\", error);\n\t\t\tgoto fail_jindex;\n\t\t}\n\n\t\tip = GFS2_I(sdp->sd_jdesc->jd_inode);\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED,\n\t\t\t\t\t   LM_FLAG_NOEXP | GL_EXACT | GL_NOCACHE,\n\t\t\t\t\t   &sdp->sd_jinode_gh);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"can't acquire journal inode glock: %d\\n\",\n\t\t\t       error);\n\t\t\tgoto fail_journal_gh;\n\t\t}\n\n\t\terror = gfs2_jdesc_check(sdp->sd_jdesc);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"my journal (%u) is bad: %d\\n\",\n\t\t\t       sdp->sd_jdesc->jd_jid, error);\n\t\t\tgoto fail_jinode_gh;\n\t\t}\n\t\tatomic_set(&sdp->sd_log_blks_free, sdp->sd_jdesc->jd_blocks);\n\t\tatomic_set(&sdp->sd_log_thresh1, 2*sdp->sd_jdesc->jd_blocks/5);\n\t\tatomic_set(&sdp->sd_log_thresh2, 4*sdp->sd_jdesc->jd_blocks/5);\n\n\t\t/* Map the extents for this journal's blocks */\n\t\tgfs2_map_journal_extents(sdp, sdp->sd_jdesc);\n\t}\n\ttrace_gfs2_log_blocks(sdp, atomic_read(&sdp->sd_log_blks_free));\n\n\tif (sdp->sd_lockstruct.ls_first) {\n\t\tunsigned int x;\n\t\tfor (x = 0; x < sdp->sd_journals; x++) {\n\t\t\tstruct gfs2_jdesc *jd = gfs2_jdesc_find(sdp, x);\n\n\t\t\tif (sdp->sd_args.ar_spectator) {\n\t\t\t\terror = check_journal_clean(sdp, jd);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto fail_jinode_gh;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terror = gfs2_recover_journal(jd, true);\n\t\t\tif (error) {\n\t\t\t\tfs_err(sdp, \"error recovering journal %u: %d\\n\",\n\t\t\t\t       x, error);\n\t\t\t\tgoto fail_jinode_gh;\n\t\t\t}\n\t\t}\n\n\t\tgfs2_others_may_mount(sdp);\n\t} else if (!sdp->sd_args.ar_spectator) {\n\t\terror = gfs2_recover_journal(sdp->sd_jdesc, true);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"error recovering my journal: %d\\n\", error);\n\t\t\tgoto fail_jinode_gh;\n\t\t}\n\t}\n\n\tset_bit(SDF_JOURNAL_CHECKED, &sdp->sd_flags);\n\tgfs2_glock_dq_uninit(&ji_gh);\n\tjindex = 0;\n\tINIT_WORK(&sdp->sd_freeze_work, gfs2_freeze_func);\n\treturn 0;\n\nfail_jinode_gh:\n\tif (!sdp->sd_args.ar_spectator)\n\t\tgfs2_glock_dq_uninit(&sdp->sd_jinode_gh);\nfail_journal_gh:\n\tif (!sdp->sd_args.ar_spectator)\n\t\tgfs2_glock_dq_uninit(&sdp->sd_journal_gh);\nfail_jindex:\n\tgfs2_jindex_free(sdp);\n\tif (jindex)\n\t\tgfs2_glock_dq_uninit(&ji_gh);\nfail:\n\tiput(sdp->sd_jindex);\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "sdp->sd_jindex"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&ji_gh"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_jindex_free",
          "args": [
            "sdp"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_jindex_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "297-315",
          "snippet": "void gfs2_jindex_free(struct gfs2_sbd *sdp)\n{\n\tstruct list_head list;\n\tstruct gfs2_jdesc *jd;\n\n\tspin_lock(&sdp->sd_jindex_spin);\n\tlist_add(&list, &sdp->sd_jindex_list);\n\tlist_del_init(&sdp->sd_jindex_list);\n\tsdp->sd_journals = 0;\n\tspin_unlock(&sdp->sd_jindex_spin);\n\n\twhile (!list_empty(&list)) {\n\t\tjd = list_entry(list.next, struct gfs2_jdesc, jd_list);\n\t\tgfs2_free_journal_extents(jd);\n\t\tlist_del(&jd->jd_list);\n\t\tiput(jd->jd_inode);\n\t\tkfree(jd);\n\t}\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_jindex_free(struct gfs2_sbd *sdp)\n{\n\tstruct list_head list;\n\tstruct gfs2_jdesc *jd;\n\n\tspin_lock(&sdp->sd_jindex_spin);\n\tlist_add(&list, &sdp->sd_jindex_list);\n\tlist_del_init(&sdp->sd_jindex_list);\n\tsdp->sd_journals = 0;\n\tspin_unlock(&sdp->sd_jindex_spin);\n\n\twhile (!list_empty(&list)) {\n\t\tjd = list_entry(list.next, struct gfs2_jdesc, jd_list);\n\t\tgfs2_free_journal_extents(jd);\n\t\tlist_del(&jd->jd_list);\n\t\tiput(jd->jd_inode);\n\t\tkfree(jd);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&sdp->sd_freeze_work",
            "gfs2_freeze_func"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "SDF_JOURNAL_CHECKED",
            "&sdp->sd_flags"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"error recovering my journal: %d\\n\"",
            "error"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_recover_journal",
          "args": [
            "sdp->sd_jdesc",
            "true"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_recover_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
          "lines": "594-610",
          "snippet": "int gfs2_recover_journal(struct gfs2_jdesc *jd, bool wait)\n{\n\tint rv;\n\n\tif (test_and_set_bit(JDF_RECOVERY, &jd->jd_flags))\n\t\treturn -EBUSY;\n\n\t/* we have JDF_RECOVERY, queue should always succeed */\n\trv = queue_work(gfs_recovery_wq, &jd->jd_work);\n\tBUG_ON(!rv);\n\n\tif (wait)\n\t\twait_on_bit(&jd->jd_flags, JDF_RECOVERY,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\n\treturn wait ? jd->jd_recover_error : 0;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct workqueue_struct *gfs_recovery_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct workqueue_struct *gfs_recovery_wq;\n\nint gfs2_recover_journal(struct gfs2_jdesc *jd, bool wait)\n{\n\tint rv;\n\n\tif (test_and_set_bit(JDF_RECOVERY, &jd->jd_flags))\n\t\treturn -EBUSY;\n\n\t/* we have JDF_RECOVERY, queue should always succeed */\n\trv = queue_work(gfs_recovery_wq, &jd->jd_work);\n\tBUG_ON(!rv);\n\n\tif (wait)\n\t\twait_on_bit(&jd->jd_flags, JDF_RECOVERY,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\n\treturn wait ? jd->jd_recover_error : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_others_may_mount",
          "args": [
            "sdp"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_others_may_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "524-535",
          "snippet": "static void gfs2_others_may_mount(struct gfs2_sbd *sdp)\n{\n\tchar *message = \"FIRSTMOUNT=Done\";\n\tchar *envp[] = { message, NULL };\n\n\tfs_info(sdp, \"first mount done, others may mount\\n\");\n\n\tif (sdp->sd_lockstruct.ls_ops->lm_first_done)\n\t\tsdp->sd_lockstruct.ls_ops->lm_first_done(sdp);\n\n\tkobject_uevent_env(&sdp->sd_kobj, KOBJ_CHANGE, envp);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void gfs2_others_may_mount(struct gfs2_sbd *sdp)\n{\n\tchar *message = \"FIRSTMOUNT=Done\";\n\tchar *envp[] = { message, NULL };\n\n\tfs_info(sdp, \"first mount done, others may mount\\n\");\n\n\tif (sdp->sd_lockstruct.ls_ops->lm_first_done)\n\t\tsdp->sd_lockstruct.ls_ops->lm_first_done(sdp);\n\n\tkobject_uevent_env(&sdp->sd_kobj, KOBJ_CHANGE, envp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_journal_clean",
          "args": [
            "sdp",
            "jd"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "check_journal_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "613-646",
          "snippet": "static int check_journal_clean(struct gfs2_sbd *sdp, struct gfs2_jdesc *jd)\n{\n\tint error;\n\tstruct gfs2_holder j_gh;\n\tstruct gfs2_log_header_host head;\n\tstruct gfs2_inode *ip;\n\n\tip = GFS2_I(jd->jd_inode);\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_NOEXP |\n\t\t\t\t   GL_EXACT | GL_NOCACHE, &j_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"Error locking journal for spectator mount.\\n\");\n\t\treturn -EPERM;\n\t}\n\terror = gfs2_jdesc_check(jd);\n\tif (error) {\n\t\tfs_err(sdp, \"Error checking journal for spectator mount.\\n\");\n\t\tgoto out_unlock;\n\t}\n\terror = gfs2_find_jhead(jd, &head);\n\tif (error) {\n\t\tfs_err(sdp, \"Error parsing journal for spectator mount.\\n\");\n\t\tgoto out_unlock;\n\t}\n\tif (!(head.lh_flags & GFS2_LOG_HEAD_UNMOUNT)) {\n\t\terror = -EPERM;\n\t\tfs_err(sdp, \"jid=%u: Journal is dirty, so the first mounter \"\n\t\t       \"must not be a spectator.\\n\", jd->jd_jid);\n\t}\n\nout_unlock:\n\tgfs2_glock_dq_uninit(&j_gh);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int check_journal_clean(struct gfs2_sbd *sdp, struct gfs2_jdesc *jd)\n{\n\tint error;\n\tstruct gfs2_holder j_gh;\n\tstruct gfs2_log_header_host head;\n\tstruct gfs2_inode *ip;\n\n\tip = GFS2_I(jd->jd_inode);\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_NOEXP |\n\t\t\t\t   GL_EXACT | GL_NOCACHE, &j_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"Error locking journal for spectator mount.\\n\");\n\t\treturn -EPERM;\n\t}\n\terror = gfs2_jdesc_check(jd);\n\tif (error) {\n\t\tfs_err(sdp, \"Error checking journal for spectator mount.\\n\");\n\t\tgoto out_unlock;\n\t}\n\terror = gfs2_find_jhead(jd, &head);\n\tif (error) {\n\t\tfs_err(sdp, \"Error parsing journal for spectator mount.\\n\");\n\t\tgoto out_unlock;\n\t}\n\tif (!(head.lh_flags & GFS2_LOG_HEAD_UNMOUNT)) {\n\t\terror = -EPERM;\n\t\tfs_err(sdp, \"jid=%u: Journal is dirty, so the first mounter \"\n\t\t       \"must not be a spectator.\\n\", jd->jd_jid);\n\t}\n\nout_unlock:\n\tgfs2_glock_dq_uninit(&j_gh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_jdesc_find",
          "args": [
            "sdp",
            "x"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_jdesc_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "335-344",
          "snippet": "struct gfs2_jdesc *gfs2_jdesc_find(struct gfs2_sbd *sdp, unsigned int jid)\n{\n\tstruct gfs2_jdesc *jd;\n\n\tspin_lock(&sdp->sd_jindex_spin);\n\tjd = jdesc_find_i(&sdp->sd_jindex_list, jid);\n\tspin_unlock(&sdp->sd_jindex_spin);\n\n\treturn jd;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nstruct gfs2_jdesc *gfs2_jdesc_find(struct gfs2_sbd *sdp, unsigned int jid)\n{\n\tstruct gfs2_jdesc *jd;\n\n\tspin_lock(&sdp->sd_jindex_spin);\n\tjd = jdesc_find_i(&sdp->sd_jindex_list, jid);\n\tspin_unlock(&sdp->sd_jindex_spin);\n\n\treturn jd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_gfs2_log_blocks",
          "args": [
            "sdp",
            "atomic_read(&sdp->sd_log_blks_free)"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sdp->sd_log_blks_free"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_map_journal_extents",
          "args": [
            "sdp",
            "sdp->sd_jdesc"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_map_journal_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1401-1444",
          "snippet": "int gfs2_map_journal_extents(struct gfs2_sbd *sdp, struct gfs2_jdesc *jd)\n{\n\tu64 lblock = 0;\n\tu64 lblock_stop;\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct buffer_head bh;\n\tunsigned int shift = sdp->sd_sb.sb_bsize_shift;\n\tu64 size;\n\tint rc;\n\n\tlblock_stop = i_size_read(jd->jd_inode) >> shift;\n\tsize = (lblock_stop - lblock) << shift;\n\tjd->nr_extents = 0;\n\tWARN_ON(!list_empty(&jd->extent_list));\n\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_blocknr = 0;\n\t\tbh.b_size = size;\n\t\trc = gfs2_block_map(jd->jd_inode, lblock, &bh, 0);\n\t\tif (rc || !buffer_mapped(&bh))\n\t\t\tgoto fail;\n\t\trc = gfs2_add_jextent(jd, lblock, bh.b_blocknr, bh.b_size >> shift);\n\t\tif (rc)\n\t\t\tgoto fail;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> ip->i_inode.i_blkbits);\n\t} while(size > 0);\n\n\tfs_info(sdp, \"journal %d mapped with %u extents\\n\", jd->jd_jid,\n\t\tjd->nr_extents);\n\treturn 0;\n\nfail:\n\tfs_warn(sdp, \"error %d mapping journal %u at offset %llu (extent %u)\\n\",\n\t\trc, jd->jd_jid,\n\t\t(unsigned long long)(i_size_read(jd->jd_inode) - size),\n\t\tjd->nr_extents);\n\tfs_warn(sdp, \"bmap=%d lblock=%llu block=%llu, state=0x%08lx, size=%llu\\n\",\n\t\trc, (unsigned long long)lblock, (unsigned long long)bh.b_blocknr,\n\t\tbh.b_state, (unsigned long long)bh.b_size);\n\tgfs2_free_journal_extents(jd);\n\treturn rc;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_map_journal_extents(struct gfs2_sbd *sdp, struct gfs2_jdesc *jd)\n{\n\tu64 lblock = 0;\n\tu64 lblock_stop;\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct buffer_head bh;\n\tunsigned int shift = sdp->sd_sb.sb_bsize_shift;\n\tu64 size;\n\tint rc;\n\n\tlblock_stop = i_size_read(jd->jd_inode) >> shift;\n\tsize = (lblock_stop - lblock) << shift;\n\tjd->nr_extents = 0;\n\tWARN_ON(!list_empty(&jd->extent_list));\n\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_blocknr = 0;\n\t\tbh.b_size = size;\n\t\trc = gfs2_block_map(jd->jd_inode, lblock, &bh, 0);\n\t\tif (rc || !buffer_mapped(&bh))\n\t\t\tgoto fail;\n\t\trc = gfs2_add_jextent(jd, lblock, bh.b_blocknr, bh.b_size >> shift);\n\t\tif (rc)\n\t\t\tgoto fail;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> ip->i_inode.i_blkbits);\n\t} while(size > 0);\n\n\tfs_info(sdp, \"journal %d mapped with %u extents\\n\", jd->jd_jid,\n\t\tjd->nr_extents);\n\treturn 0;\n\nfail:\n\tfs_warn(sdp, \"error %d mapping journal %u at offset %llu (extent %u)\\n\",\n\t\trc, jd->jd_jid,\n\t\t(unsigned long long)(i_size_read(jd->jd_inode) - size),\n\t\tjd->nr_extents);\n\tfs_warn(sdp, \"bmap=%d lblock=%llu block=%llu, state=0x%08lx, size=%llu\\n\",\n\t\trc, (unsigned long long)lblock, (unsigned long long)bh.b_blocknr,\n\t\tbh.b_state, (unsigned long long)bh.b_size);\n\tgfs2_free_journal_extents(jd);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sdp->sd_log_thresh2",
            "4*sdp->sd_jdesc->jd_blocks/5"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sdp->sd_log_thresh1",
            "2*sdp->sd_jdesc->jd_blocks/5"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sdp->sd_log_blks_free",
            "sdp->sd_jdesc->jd_blocks"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_jdesc_check",
          "args": [
            "sdp->sd_jdesc"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_jdesc_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "346-363",
          "snippet": "int gfs2_jdesc_check(struct gfs2_jdesc *jd)\n{\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tu64 size = i_size_read(jd->jd_inode);\n\n\tif (gfs2_check_internal_file_size(jd->jd_inode, 8 << 20, 1 << 30))\n\t\treturn -EIO;\n\n\tjd->jd_blocks = size >> sdp->sd_sb.sb_bsize_shift;\n\n\tif (gfs2_write_alloc_required(ip, 0, size)) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nint gfs2_jdesc_check(struct gfs2_jdesc *jd)\n{\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tu64 size = i_size_read(jd->jd_inode);\n\n\tif (gfs2_check_internal_file_size(jd->jd_inode, 8 << 20, 1 << 30))\n\t\treturn -EIO;\n\n\tjd->jd_blocks = size >> sdp->sd_sb.sb_bsize_shift;\n\n\tif (gfs2_write_alloc_required(ip, 0, size)) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "ip->i_gl",
            "LM_ST_SHARED",
            "LM_FLAG_NOEXP | GL_EXACT | GL_NOCACHE",
            "&sdp->sd_jinode_gh"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "sdp->sd_jdesc->jd_inode"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_num",
          "args": [
            "sdp",
            "sdp->sd_lockstruct.ls_jid",
            "&gfs2_journal_glops",
            "LM_ST_EXCLUSIVE",
            "LM_FLAG_NOEXP",
            "&sdp->sd_journal_gh"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1128-1142",
          "snippet": "int gfs2_glock_nq_num(struct gfs2_sbd *sdp, u64 number,\n\t\t      const struct gfs2_glock_operations *glops,\n\t\t      unsigned int state, int flags, struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\terror = gfs2_glock_get(sdp, number, glops, CREATE, &gl);\n\tif (!error) {\n\t\terror = gfs2_glock_nq_init(gl, state, flags, gh);\n\t\tgfs2_glock_put(gl);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_glock_nq_num(struct gfs2_sbd *sdp, u64 number,\n\t\t      const struct gfs2_glock_operations *glops,\n\t\t      unsigned int state, int flags, struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\terror = gfs2_glock_get(sdp, number, glops, CREATE, &gl);\n\tif (!error) {\n\t\terror = gfs2_glock_nq_init(gl, state, flags, gh);\n\t\tgfs2_glock_put(gl);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_jindex_size",
          "args": [
            "sdp"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_jindex_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.h",
          "lines": "19-26",
          "snippet": "static inline unsigned int gfs2_jindex_size(struct gfs2_sbd *sdp)\n{\n\tunsigned int x;\n\tspin_lock(&sdp->sd_jindex_spin);\n\tx = sdp->sd_journals;\n\tspin_unlock(&sdp->sd_jindex_spin);\n\treturn x;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/dcache.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int gfs2_jindex_size(struct gfs2_sbd *sdp)\n{\n\tunsigned int x;\n\tspin_lock(&sdp->sd_jindex_spin);\n\tx = sdp->sd_journals;\n\tspin_unlock(&sdp->sd_jindex_spin);\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sdp->sd_log_thresh2",
            "4*sdp->sd_jdesc->jd_blocks/5"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sdp->sd_log_thresh1",
            "2*sdp->sd_jdesc->jd_blocks/5"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sdp->sd_log_blks_free",
            "sdp->sd_jdesc->jd_blocks"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_jindex_hold",
          "args": [
            "sdp",
            "&ji_gh"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_jindex_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "545-604",
          "snippet": "static int gfs2_jindex_hold(struct gfs2_sbd *sdp, struct gfs2_holder *ji_gh)\n{\n\tstruct gfs2_inode *dip = GFS2_I(sdp->sd_jindex);\n\tstruct qstr name;\n\tchar buf[20];\n\tstruct gfs2_jdesc *jd;\n\tint error;\n\n\tname.name = buf;\n\n\tmutex_lock(&sdp->sd_jindex_mutex);\n\n\tfor (;;) {\n\t\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, ji_gh);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tname.len = sprintf(buf, \"journal%u\", sdp->sd_journals);\n\t\tname.hash = gfs2_disk_hash(name.name, name.len);\n\n\t\terror = gfs2_dir_check(sdp->sd_jindex, &name, NULL);\n\t\tif (error == -ENOENT) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tgfs2_glock_dq_uninit(ji_gh);\n\n\t\tif (error)\n\t\t\tbreak;\n\n\t\terror = -ENOMEM;\n\t\tjd = kzalloc(sizeof(struct gfs2_jdesc), GFP_KERNEL);\n\t\tif (!jd)\n\t\t\tbreak;\n\n\t\tINIT_LIST_HEAD(&jd->extent_list);\n\t\tINIT_LIST_HEAD(&jd->jd_revoke_list);\n\n\t\tINIT_WORK(&jd->jd_work, gfs2_recover_func);\n\t\tjd->jd_inode = gfs2_lookupi(sdp->sd_jindex, &name, 1);\n\t\tif (!jd->jd_inode || IS_ERR(jd->jd_inode)) {\n\t\t\tif (!jd->jd_inode)\n\t\t\t\terror = -ENOENT;\n\t\t\telse\n\t\t\t\terror = PTR_ERR(jd->jd_inode);\n\t\t\tkfree(jd);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock(&sdp->sd_jindex_spin);\n\t\tjd->jd_jid = sdp->sd_journals++;\n\t\tlist_add_tail(&jd->jd_list, &sdp->sd_jindex_list);\n\t\tspin_unlock(&sdp->sd_jindex_spin);\n\t}\n\n\tmutex_unlock(&sdp->sd_jindex_mutex);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_jindex_hold(struct gfs2_sbd *sdp, struct gfs2_holder *ji_gh)\n{\n\tstruct gfs2_inode *dip = GFS2_I(sdp->sd_jindex);\n\tstruct qstr name;\n\tchar buf[20];\n\tstruct gfs2_jdesc *jd;\n\tint error;\n\n\tname.name = buf;\n\n\tmutex_lock(&sdp->sd_jindex_mutex);\n\n\tfor (;;) {\n\t\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, ji_gh);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tname.len = sprintf(buf, \"journal%u\", sdp->sd_journals);\n\t\tname.hash = gfs2_disk_hash(name.name, name.len);\n\n\t\terror = gfs2_dir_check(sdp->sd_jindex, &name, NULL);\n\t\tif (error == -ENOENT) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tgfs2_glock_dq_uninit(ji_gh);\n\n\t\tif (error)\n\t\t\tbreak;\n\n\t\terror = -ENOMEM;\n\t\tjd = kzalloc(sizeof(struct gfs2_jdesc), GFP_KERNEL);\n\t\tif (!jd)\n\t\t\tbreak;\n\n\t\tINIT_LIST_HEAD(&jd->extent_list);\n\t\tINIT_LIST_HEAD(&jd->jd_revoke_list);\n\n\t\tINIT_WORK(&jd->jd_work, gfs2_recover_func);\n\t\tjd->jd_inode = gfs2_lookupi(sdp->sd_jindex, &name, 1);\n\t\tif (!jd->jd_inode || IS_ERR(jd->jd_inode)) {\n\t\t\tif (!jd->jd_inode)\n\t\t\t\terror = -ENOENT;\n\t\t\telse\n\t\t\t\terror = PTR_ERR(jd->jd_inode);\n\t\t\tkfree(jd);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock(&sdp->sd_jindex_spin);\n\t\tjd->jd_jid = sdp->sd_journals++;\n\t\tlist_add_tail(&jd->jd_list, &sdp->sd_jindex_list);\n\t\tspin_unlock(&sdp->sd_jindex_spin);\n\t}\n\n\tmutex_unlock(&sdp->sd_jindex_mutex);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sdp->sd_jindex"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sdp->sd_jindex"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_lookup_simple",
          "args": [
            "master",
            "\"jindex\""
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lookup_simple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "250-265",
          "snippet": "struct inode *gfs2_lookup_simple(struct inode *dip, const char *name)\n{\n\tstruct qstr qstr;\n\tstruct inode *inode;\n\tgfs2_str2qstr(&qstr, name);\n\tinode = gfs2_lookupi(dip, &qstr, 1);\n\t/* gfs2_lookupi has inconsistent callers: vfs\n\t * related routines expect NULL for no entry found,\n\t * gfs2_lookup_simple callers expect ENOENT\n\t * and do not check for NULL.\n\t */\n\tif (inode == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\telse\n\t\treturn inode;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct inode *gfs2_lookup_simple(struct inode *dip, const char *name)\n{\n\tstruct qstr qstr;\n\tstruct inode *inode;\n\tgfs2_str2qstr(&qstr, name);\n\tinode = gfs2_lookupi(dip, &qstr, 1);\n\t/* gfs2_lookupi has inconsistent callers: vfs\n\t * related routines expect NULL for no entry found,\n\t * gfs2_lookup_simple callers expect ENOENT\n\t * and do not check for NULL.\n\t */\n\tif (inode == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\telse\n\t\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int init_journal(struct gfs2_sbd *sdp, int undo)\n{\n\tstruct inode *master = sdp->sd_master_dir->d_inode;\n\tstruct gfs2_holder ji_gh;\n\tstruct gfs2_inode *ip;\n\tint jindex = 1;\n\tint error = 0;\n\n\tif (undo) {\n\t\tjindex = 0;\n\t\tgoto fail_jinode_gh;\n\t}\n\n\tsdp->sd_jindex = gfs2_lookup_simple(master, \"jindex\");\n\tif (IS_ERR(sdp->sd_jindex)) {\n\t\tfs_err(sdp, \"can't lookup journal index: %d\\n\", error);\n\t\treturn PTR_ERR(sdp->sd_jindex);\n\t}\n\n\t/* Load in the journal index special file */\n\n\terror = gfs2_jindex_hold(sdp, &ji_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't read journal index: %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = -EUSERS;\n\tif (!gfs2_jindex_size(sdp)) {\n\t\tfs_err(sdp, \"no journals!\\n\");\n\t\tgoto fail_jindex;\n\t}\n\n\tif (sdp->sd_args.ar_spectator) {\n\t\tsdp->sd_jdesc = gfs2_jdesc_find(sdp, 0);\n\t\tatomic_set(&sdp->sd_log_blks_free, sdp->sd_jdesc->jd_blocks);\n\t\tatomic_set(&sdp->sd_log_thresh1, 2*sdp->sd_jdesc->jd_blocks/5);\n\t\tatomic_set(&sdp->sd_log_thresh2, 4*sdp->sd_jdesc->jd_blocks/5);\n\t} else {\n\t\tif (sdp->sd_lockstruct.ls_jid >= gfs2_jindex_size(sdp)) {\n\t\t\tfs_err(sdp, \"can't mount journal #%u\\n\",\n\t\t\t       sdp->sd_lockstruct.ls_jid);\n\t\t\tfs_err(sdp, \"there are only %u journals (0 - %u)\\n\",\n\t\t\t       gfs2_jindex_size(sdp),\n\t\t\t       gfs2_jindex_size(sdp) - 1);\n\t\t\tgoto fail_jindex;\n\t\t}\n\t\tsdp->sd_jdesc = gfs2_jdesc_find(sdp, sdp->sd_lockstruct.ls_jid);\n\n\t\terror = gfs2_glock_nq_num(sdp, sdp->sd_lockstruct.ls_jid,\n\t\t\t\t\t  &gfs2_journal_glops,\n\t\t\t\t\t  LM_ST_EXCLUSIVE, LM_FLAG_NOEXP,\n\t\t\t\t\t  &sdp->sd_journal_gh);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"can't acquire journal glock: %d\\n\", error);\n\t\t\tgoto fail_jindex;\n\t\t}\n\n\t\tip = GFS2_I(sdp->sd_jdesc->jd_inode);\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED,\n\t\t\t\t\t   LM_FLAG_NOEXP | GL_EXACT | GL_NOCACHE,\n\t\t\t\t\t   &sdp->sd_jinode_gh);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"can't acquire journal inode glock: %d\\n\",\n\t\t\t       error);\n\t\t\tgoto fail_journal_gh;\n\t\t}\n\n\t\terror = gfs2_jdesc_check(sdp->sd_jdesc);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"my journal (%u) is bad: %d\\n\",\n\t\t\t       sdp->sd_jdesc->jd_jid, error);\n\t\t\tgoto fail_jinode_gh;\n\t\t}\n\t\tatomic_set(&sdp->sd_log_blks_free, sdp->sd_jdesc->jd_blocks);\n\t\tatomic_set(&sdp->sd_log_thresh1, 2*sdp->sd_jdesc->jd_blocks/5);\n\t\tatomic_set(&sdp->sd_log_thresh2, 4*sdp->sd_jdesc->jd_blocks/5);\n\n\t\t/* Map the extents for this journal's blocks */\n\t\tgfs2_map_journal_extents(sdp, sdp->sd_jdesc);\n\t}\n\ttrace_gfs2_log_blocks(sdp, atomic_read(&sdp->sd_log_blks_free));\n\n\tif (sdp->sd_lockstruct.ls_first) {\n\t\tunsigned int x;\n\t\tfor (x = 0; x < sdp->sd_journals; x++) {\n\t\t\tstruct gfs2_jdesc *jd = gfs2_jdesc_find(sdp, x);\n\n\t\t\tif (sdp->sd_args.ar_spectator) {\n\t\t\t\terror = check_journal_clean(sdp, jd);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto fail_jinode_gh;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terror = gfs2_recover_journal(jd, true);\n\t\t\tif (error) {\n\t\t\t\tfs_err(sdp, \"error recovering journal %u: %d\\n\",\n\t\t\t\t       x, error);\n\t\t\t\tgoto fail_jinode_gh;\n\t\t\t}\n\t\t}\n\n\t\tgfs2_others_may_mount(sdp);\n\t} else if (!sdp->sd_args.ar_spectator) {\n\t\terror = gfs2_recover_journal(sdp->sd_jdesc, true);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"error recovering my journal: %d\\n\", error);\n\t\t\tgoto fail_jinode_gh;\n\t\t}\n\t}\n\n\tset_bit(SDF_JOURNAL_CHECKED, &sdp->sd_flags);\n\tgfs2_glock_dq_uninit(&ji_gh);\n\tjindex = 0;\n\tINIT_WORK(&sdp->sd_freeze_work, gfs2_freeze_func);\n\treturn 0;\n\nfail_jinode_gh:\n\tif (!sdp->sd_args.ar_spectator)\n\t\tgfs2_glock_dq_uninit(&sdp->sd_jinode_gh);\nfail_journal_gh:\n\tif (!sdp->sd_args.ar_spectator)\n\t\tgfs2_glock_dq_uninit(&sdp->sd_journal_gh);\nfail_jindex:\n\tgfs2_jindex_free(sdp);\n\tif (jindex)\n\t\tgfs2_glock_dq_uninit(&ji_gh);\nfail:\n\tiput(sdp->sd_jindex);\n\treturn error;\n}"
  },
  {
    "function_name": "check_journal_clean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "613-646",
    "snippet": "static int check_journal_clean(struct gfs2_sbd *sdp, struct gfs2_jdesc *jd)\n{\n\tint error;\n\tstruct gfs2_holder j_gh;\n\tstruct gfs2_log_header_host head;\n\tstruct gfs2_inode *ip;\n\n\tip = GFS2_I(jd->jd_inode);\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_NOEXP |\n\t\t\t\t   GL_EXACT | GL_NOCACHE, &j_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"Error locking journal for spectator mount.\\n\");\n\t\treturn -EPERM;\n\t}\n\terror = gfs2_jdesc_check(jd);\n\tif (error) {\n\t\tfs_err(sdp, \"Error checking journal for spectator mount.\\n\");\n\t\tgoto out_unlock;\n\t}\n\terror = gfs2_find_jhead(jd, &head);\n\tif (error) {\n\t\tfs_err(sdp, \"Error parsing journal for spectator mount.\\n\");\n\t\tgoto out_unlock;\n\t}\n\tif (!(head.lh_flags & GFS2_LOG_HEAD_UNMOUNT)) {\n\t\terror = -EPERM;\n\t\tfs_err(sdp, \"jid=%u: Journal is dirty, so the first mounter \"\n\t\t       \"must not be a spectator.\\n\", jd->jd_jid);\n\t}\n\nout_unlock:\n\tgfs2_glock_dq_uninit(&j_gh);\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&j_gh"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"jid=%u: Journal is dirty, so the first mounter \"\n\t\t       \"must not be a spectator.\\n\"",
            "jd->jd_jid"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_find_jhead",
          "args": [
            "jd",
            "&head"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_find_jhead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
          "lines": "263-299",
          "snippet": "int gfs2_find_jhead(struct gfs2_jdesc *jd, struct gfs2_log_header_host *head)\n{\n\tstruct gfs2_log_header_host lh_1, lh_m;\n\tu32 blk_1, blk_2, blk_m;\n\tint error;\n\n\tblk_1 = 0;\n\tblk_2 = jd->jd_blocks - 1;\n\n\tfor (;;) {\n\t\tblk_m = (blk_1 + blk_2) / 2;\n\n\t\terror = find_good_lh(jd, &blk_1, &lh_1);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = find_good_lh(jd, &blk_m, &lh_m);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (blk_1 == blk_m || blk_m == blk_2)\n\t\t\tbreak;\n\n\t\tif (lh_1.lh_sequence <= lh_m.lh_sequence)\n\t\t\tblk_1 = blk_m;\n\t\telse\n\t\t\tblk_2 = blk_m;\n\t}\n\n\terror = jhead_scan(jd, &lh_1);\n\tif (error)\n\t\treturn error;\n\n\t*head = lh_1;\n\n\treturn error;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint gfs2_find_jhead(struct gfs2_jdesc *jd, struct gfs2_log_header_host *head)\n{\n\tstruct gfs2_log_header_host lh_1, lh_m;\n\tu32 blk_1, blk_2, blk_m;\n\tint error;\n\n\tblk_1 = 0;\n\tblk_2 = jd->jd_blocks - 1;\n\n\tfor (;;) {\n\t\tblk_m = (blk_1 + blk_2) / 2;\n\n\t\terror = find_good_lh(jd, &blk_1, &lh_1);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = find_good_lh(jd, &blk_m, &lh_m);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (blk_1 == blk_m || blk_m == blk_2)\n\t\t\tbreak;\n\n\t\tif (lh_1.lh_sequence <= lh_m.lh_sequence)\n\t\t\tblk_1 = blk_m;\n\t\telse\n\t\t\tblk_2 = blk_m;\n\t}\n\n\terror = jhead_scan(jd, &lh_1);\n\tif (error)\n\t\treturn error;\n\n\t*head = lh_1;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_jdesc_check",
          "args": [
            "jd"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_jdesc_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "346-363",
          "snippet": "int gfs2_jdesc_check(struct gfs2_jdesc *jd)\n{\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tu64 size = i_size_read(jd->jd_inode);\n\n\tif (gfs2_check_internal_file_size(jd->jd_inode, 8 << 20, 1 << 30))\n\t\treturn -EIO;\n\n\tjd->jd_blocks = size >> sdp->sd_sb.sb_bsize_shift;\n\n\tif (gfs2_write_alloc_required(ip, 0, size)) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nint gfs2_jdesc_check(struct gfs2_jdesc *jd)\n{\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tu64 size = i_size_read(jd->jd_inode);\n\n\tif (gfs2_check_internal_file_size(jd->jd_inode, 8 << 20, 1 << 30))\n\t\treturn -EIO;\n\n\tjd->jd_blocks = size >> sdp->sd_sb.sb_bsize_shift;\n\n\tif (gfs2_write_alloc_required(ip, 0, size)) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "ip->i_gl",
            "LM_ST_SHARED",
            "LM_FLAG_NOEXP |\n\t\t\t\t   GL_EXACT | GL_NOCACHE",
            "&j_gh"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "jd->jd_inode"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int check_journal_clean(struct gfs2_sbd *sdp, struct gfs2_jdesc *jd)\n{\n\tint error;\n\tstruct gfs2_holder j_gh;\n\tstruct gfs2_log_header_host head;\n\tstruct gfs2_inode *ip;\n\n\tip = GFS2_I(jd->jd_inode);\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_NOEXP |\n\t\t\t\t   GL_EXACT | GL_NOCACHE, &j_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"Error locking journal for spectator mount.\\n\");\n\t\treturn -EPERM;\n\t}\n\terror = gfs2_jdesc_check(jd);\n\tif (error) {\n\t\tfs_err(sdp, \"Error checking journal for spectator mount.\\n\");\n\t\tgoto out_unlock;\n\t}\n\terror = gfs2_find_jhead(jd, &head);\n\tif (error) {\n\t\tfs_err(sdp, \"Error parsing journal for spectator mount.\\n\");\n\t\tgoto out_unlock;\n\t}\n\tif (!(head.lh_flags & GFS2_LOG_HEAD_UNMOUNT)) {\n\t\terror = -EPERM;\n\t\tfs_err(sdp, \"jid=%u: Journal is dirty, so the first mounter \"\n\t\t       \"must not be a spectator.\\n\", jd->jd_jid);\n\t}\n\nout_unlock:\n\tgfs2_glock_dq_uninit(&j_gh);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_jindex_hold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "545-604",
    "snippet": "static int gfs2_jindex_hold(struct gfs2_sbd *sdp, struct gfs2_holder *ji_gh)\n{\n\tstruct gfs2_inode *dip = GFS2_I(sdp->sd_jindex);\n\tstruct qstr name;\n\tchar buf[20];\n\tstruct gfs2_jdesc *jd;\n\tint error;\n\n\tname.name = buf;\n\n\tmutex_lock(&sdp->sd_jindex_mutex);\n\n\tfor (;;) {\n\t\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, ji_gh);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tname.len = sprintf(buf, \"journal%u\", sdp->sd_journals);\n\t\tname.hash = gfs2_disk_hash(name.name, name.len);\n\n\t\terror = gfs2_dir_check(sdp->sd_jindex, &name, NULL);\n\t\tif (error == -ENOENT) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tgfs2_glock_dq_uninit(ji_gh);\n\n\t\tif (error)\n\t\t\tbreak;\n\n\t\terror = -ENOMEM;\n\t\tjd = kzalloc(sizeof(struct gfs2_jdesc), GFP_KERNEL);\n\t\tif (!jd)\n\t\t\tbreak;\n\n\t\tINIT_LIST_HEAD(&jd->extent_list);\n\t\tINIT_LIST_HEAD(&jd->jd_revoke_list);\n\n\t\tINIT_WORK(&jd->jd_work, gfs2_recover_func);\n\t\tjd->jd_inode = gfs2_lookupi(sdp->sd_jindex, &name, 1);\n\t\tif (!jd->jd_inode || IS_ERR(jd->jd_inode)) {\n\t\t\tif (!jd->jd_inode)\n\t\t\t\terror = -ENOENT;\n\t\t\telse\n\t\t\t\terror = PTR_ERR(jd->jd_inode);\n\t\t\tkfree(jd);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock(&sdp->sd_jindex_spin);\n\t\tjd->jd_jid = sdp->sd_journals++;\n\t\tlist_add_tail(&jd->jd_list, &sdp->sd_jindex_list);\n\t\tspin_unlock(&sdp->sd_jindex_spin);\n\t}\n\n\tmutex_unlock(&sdp->sd_jindex_mutex);\n\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sdp->sd_jindex_mutex"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sdp->sd_jindex_spin"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&jd->jd_list",
            "&sdp->sd_jindex_list"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sdp->sd_jindex_spin"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "jd"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "jd->jd_inode"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "jd->jd_inode"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_lookupi",
          "args": [
            "sdp->sd_jindex",
            "&name",
            "1"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lookupi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "283-325",
          "snippet": "struct inode *gfs2_lookupi(struct inode *dir, const struct qstr *name,\n\t\t\t   int is_root)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_holder d_gh;\n\tint error = 0;\n\tstruct inode *inode = NULL;\n\tint unlock = 0;\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tif ((name->len == 1 && memcmp(name->name, \".\", 1) == 0) ||\n\t    (name->len == 2 && memcmp(name->name, \"..\", 2) == 0 &&\n\t     dir == sb->s_root->d_inode)) {\n\t\tigrab(dir);\n\t\treturn dir;\n\t}\n\n\tif (gfs2_glock_is_locked_by_me(dip->i_gl) == NULL) {\n\t\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, &d_gh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tunlock = 1;\n\t}\n\n\tif (!is_root) {\n\t\terror = gfs2_permission(dir, MAY_EXEC);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tinode = gfs2_dir_search(dir, name, false);\n\tif (IS_ERR(inode))\n\t\terror = PTR_ERR(inode);\nout:\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&d_gh);\n\tif (error == -ENOENT)\n\t\treturn NULL;\n\treturn inode ? inode : ERR_PTR(error);\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct inode *gfs2_lookupi(struct inode *dir, const struct qstr *name,\n\t\t\t   int is_root)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_holder d_gh;\n\tint error = 0;\n\tstruct inode *inode = NULL;\n\tint unlock = 0;\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tif ((name->len == 1 && memcmp(name->name, \".\", 1) == 0) ||\n\t    (name->len == 2 && memcmp(name->name, \"..\", 2) == 0 &&\n\t     dir == sb->s_root->d_inode)) {\n\t\tigrab(dir);\n\t\treturn dir;\n\t}\n\n\tif (gfs2_glock_is_locked_by_me(dip->i_gl) == NULL) {\n\t\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, &d_gh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tunlock = 1;\n\t}\n\n\tif (!is_root) {\n\t\terror = gfs2_permission(dir, MAY_EXEC);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tinode = gfs2_dir_search(dir, name, false);\n\tif (IS_ERR(inode))\n\t\terror = PTR_ERR(inode);\nout:\n\tif (unlock)\n\t\tgfs2_glock_dq_uninit(&d_gh);\n\tif (error == -ENOENT)\n\t\treturn NULL;\n\treturn inode ? inode : ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&jd->jd_work",
            "gfs2_recover_func"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&jd->jd_revoke_list"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&jd->extent_list"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct gfs2_jdesc)",
            "GFP_KERNEL"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "ji_gh"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_check",
          "args": [
            "sdp->sd_jindex",
            "&name",
            "NULL"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "1571-1600",
          "snippet": "int gfs2_dir_check(struct inode *dir, const struct qstr *name,\n\t\t   const struct gfs2_inode *ip)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tint ret = -ENOENT;\n\n\tdent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);\n\tif (dent) {\n\t\tif (IS_ERR(dent))\n\t\t\treturn PTR_ERR(dent);\n\t\tif (ip) {\n\t\t\tif (be64_to_cpu(dent->de_inum.no_addr) != ip->i_no_addr)\n\t\t\t\tgoto out;\n\t\t\tif (be64_to_cpu(dent->de_inum.no_formal_ino) !=\n\t\t\t    ip->i_no_formal_ino)\n\t\t\t\tgoto out;\n\t\t\tif (unlikely(IF2DT(ip->i_inode.i_mode) !=\n\t\t\t    be16_to_cpu(dent->de_type))) {\n\t\t\t\tgfs2_consist_inode(GFS2_I(dir));\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = 0;\nout:\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_dir_check(struct inode *dir, const struct qstr *name,\n\t\t   const struct gfs2_inode *ip)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tint ret = -ENOENT;\n\n\tdent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);\n\tif (dent) {\n\t\tif (IS_ERR(dent))\n\t\t\treturn PTR_ERR(dent);\n\t\tif (ip) {\n\t\t\tif (be64_to_cpu(dent->de_inum.no_addr) != ip->i_no_addr)\n\t\t\t\tgoto out;\n\t\t\tif (be64_to_cpu(dent->de_inum.no_formal_ino) !=\n\t\t\t    ip->i_no_formal_ino)\n\t\t\t\tgoto out;\n\t\t\tif (unlikely(IF2DT(ip->i_inode.i_mode) !=\n\t\t\t    be16_to_cpu(dent->de_type))) {\n\t\t\t\tgfs2_consist_inode(GFS2_I(dir));\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = 0;\nout:\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_disk_hash",
          "args": [
            "name.name",
            "name.len"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_disk_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.h",
          "lines": "57-60",
          "snippet": "static inline u32 gfs2_disk_hash(const char *data, int len)\n{\n        return crc32_le((u32)~0, data, len) ^ (u32)~0;\n}",
          "includes": [
            "#include <linux/crc32.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crc32.h>\n#include <linux/dcache.h>\n\nstatic inline u32 gfs2_disk_hash(const char *data, int len)\n{\n        return crc32_le((u32)~0, data, len) ^ (u32)~0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"journal%u\"",
            "sdp->sd_journals"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "dip->i_gl",
            "LM_ST_SHARED",
            "0",
            "ji_gh"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sdp->sd_jindex_mutex"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "sdp->sd_jindex"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_jindex_hold(struct gfs2_sbd *sdp, struct gfs2_holder *ji_gh)\n{\n\tstruct gfs2_inode *dip = GFS2_I(sdp->sd_jindex);\n\tstruct qstr name;\n\tchar buf[20];\n\tstruct gfs2_jdesc *jd;\n\tint error;\n\n\tname.name = buf;\n\n\tmutex_lock(&sdp->sd_jindex_mutex);\n\n\tfor (;;) {\n\t\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, ji_gh);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tname.len = sprintf(buf, \"journal%u\", sdp->sd_journals);\n\t\tname.hash = gfs2_disk_hash(name.name, name.len);\n\n\t\terror = gfs2_dir_check(sdp->sd_jindex, &name, NULL);\n\t\tif (error == -ENOENT) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tgfs2_glock_dq_uninit(ji_gh);\n\n\t\tif (error)\n\t\t\tbreak;\n\n\t\terror = -ENOMEM;\n\t\tjd = kzalloc(sizeof(struct gfs2_jdesc), GFP_KERNEL);\n\t\tif (!jd)\n\t\t\tbreak;\n\n\t\tINIT_LIST_HEAD(&jd->extent_list);\n\t\tINIT_LIST_HEAD(&jd->jd_revoke_list);\n\n\t\tINIT_WORK(&jd->jd_work, gfs2_recover_func);\n\t\tjd->jd_inode = gfs2_lookupi(sdp->sd_jindex, &name, 1);\n\t\tif (!jd->jd_inode || IS_ERR(jd->jd_inode)) {\n\t\t\tif (!jd->jd_inode)\n\t\t\t\terror = -ENOENT;\n\t\t\telse\n\t\t\t\terror = PTR_ERR(jd->jd_inode);\n\t\t\tkfree(jd);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock(&sdp->sd_jindex_spin);\n\t\tjd->jd_jid = sdp->sd_journals++;\n\t\tlist_add_tail(&jd->jd_list, &sdp->sd_jindex_list);\n\t\tspin_unlock(&sdp->sd_jindex_spin);\n\t}\n\n\tmutex_unlock(&sdp->sd_jindex_mutex);\n\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_others_may_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "524-535",
    "snippet": "static void gfs2_others_may_mount(struct gfs2_sbd *sdp)\n{\n\tchar *message = \"FIRSTMOUNT=Done\";\n\tchar *envp[] = { message, NULL };\n\n\tfs_info(sdp, \"first mount done, others may mount\\n\");\n\n\tif (sdp->sd_lockstruct.ls_ops->lm_first_done)\n\t\tsdp->sd_lockstruct.ls_ops->lm_first_done(sdp);\n\n\tkobject_uevent_env(&sdp->sd_kobj, KOBJ_CHANGE, envp);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_uevent_env",
          "args": [
            "&sdp->sd_kobj",
            "KOBJ_CHANGE",
            "envp"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp->sd_lockstruct.ls_ops->lm_first_done",
          "args": [
            "sdp"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_info",
          "args": [
            "sdp",
            "\"first mount done, others may mount\\n\""
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fs_info_to_kstatfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2426-2436",
          "snippet": "static void\ncopy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\n\t\t\tstruct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\n\t\t\t  le32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\n\tkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\n\tkst->f_bfree  = le64_to_cpu(pfs_inf->ActualAvailableAllocationUnits);\n\tkst->f_bavail = le64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\n\treturn;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void\ncopy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\n\t\t\tstruct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\n\t\t\t  le32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\n\tkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\n\tkst->f_bfree  = le64_to_cpu(pfs_inf->ActualAvailableAllocationUnits);\n\tkst->f_bavail = le64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void gfs2_others_may_mount(struct gfs2_sbd *sdp)\n{\n\tchar *message = \"FIRSTMOUNT=Done\";\n\tchar *envp[] = { message, NULL };\n\n\tfs_info(sdp, \"first mount done, others may mount\\n\");\n\n\tif (sdp->sd_lockstruct.ls_ops->lm_first_done)\n\t\tsdp->sd_lockstruct.ls_ops->lm_first_done(sdp);\n\n\tkobject_uevent_env(&sdp->sd_kobj, KOBJ_CHANGE, envp);\n}"
  },
  {
    "function_name": "init_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "468-522",
    "snippet": "static int init_sb(struct gfs2_sbd *sdp, int silent)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct gfs2_holder sb_gh;\n\tu64 no_addr;\n\tint ret;\n\n\tret = gfs2_glock_nq_num(sdp, GFS2_SB_LOCK, &gfs2_meta_glops,\n\t\t\t\tLM_ST_SHARED, 0, &sb_gh);\n\tif (ret) {\n\t\tfs_err(sdp, \"can't acquire superblock glock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = gfs2_read_sb(sdp, silent);\n\tif (ret) {\n\t\tfs_err(sdp, \"can't read superblock: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t/* Set up the buffer cache and SB for real */\n\tif (sdp->sd_sb.sb_bsize < bdev_logical_block_size(sb->s_bdev)) {\n\t\tret = -EINVAL;\n\t\tfs_err(sdp, \"FS block size (%u) is too small for device \"\n\t\t       \"block size (%u)\\n\",\n\t\t       sdp->sd_sb.sb_bsize, bdev_logical_block_size(sb->s_bdev));\n\t\tgoto out;\n\t}\n\tif (sdp->sd_sb.sb_bsize > PAGE_SIZE) {\n\t\tret = -EINVAL;\n\t\tfs_err(sdp, \"FS block size (%u) is too big for machine \"\n\t\t       \"page size (%u)\\n\",\n\t\t       sdp->sd_sb.sb_bsize, (unsigned int)PAGE_SIZE);\n\t\tgoto out;\n\t}\n\tsb_set_blocksize(sb, sdp->sd_sb.sb_bsize);\n\n\t/* Get the root inode */\n\tno_addr = sdp->sd_sb.sb_root_dir.no_addr;\n\tret = gfs2_lookup_root(sb, &sdp->sd_root_dir, no_addr, \"root\");\n\tif (ret)\n\t\tgoto out;\n\n\t/* Get the master inode */\n\tno_addr = sdp->sd_sb.sb_master_dir.no_addr;\n\tret = gfs2_lookup_root(sb, &sdp->sd_master_dir, no_addr, \"master\");\n\tif (ret) {\n\t\tdput(sdp->sd_root_dir);\n\t\tgoto out;\n\t}\n\tsb->s_root = dget(sdp->sd_args.ar_meta ? sdp->sd_master_dir : sdp->sd_root_dir);\nout:\n\tgfs2_glock_dq_uninit(&sb_gh);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&sb_gh"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "sdp->sd_args.ar_meta ? sdp->sd_master_dir : sdp->sd_root_dir"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "sdp->sd_root_dir"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_lookup_root",
          "args": [
            "sb",
            "&sdp->sd_master_dir",
            "no_addr",
            "\"master\""
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lookup_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "447-466",
          "snippet": "static int gfs2_lookup_root(struct super_block *sb, struct dentry **dptr,\n\t\t\t    u64 no_addr, const char *name)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tinode = gfs2_inode_lookup(sb, DT_DIR, no_addr, 0, 0);\n\tif (IS_ERR(inode)) {\n\t\tfs_err(sdp, \"can't read in %s inode: %ld\\n\", name, PTR_ERR(inode));\n\t\treturn PTR_ERR(inode);\n\t}\n\tdentry = d_make_root(inode);\n\tif (!dentry) {\n\t\tfs_err(sdp, \"can't alloc %s dentry\\n\", name);\n\t\treturn -ENOMEM;\n\t}\n\t*dptr = dentry;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_lookup_root(struct super_block *sb, struct dentry **dptr,\n\t\t\t    u64 no_addr, const char *name)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tinode = gfs2_inode_lookup(sb, DT_DIR, no_addr, 0, 0);\n\tif (IS_ERR(inode)) {\n\t\tfs_err(sdp, \"can't read in %s inode: %ld\\n\", name, PTR_ERR(inode));\n\t\treturn PTR_ERR(inode);\n\t}\n\tdentry = d_make_root(inode);\n\tif (!dentry) {\n\t\tfs_err(sdp, \"can't alloc %s dentry\\n\", name);\n\t\treturn -ENOMEM;\n\t}\n\t*dptr = dentry;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "sdp->sd_sb.sb_bsize"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"FS block size (%u) is too big for machine \"\n\t\t       \"page size (%u)\\n\"",
            "sdp->sd_sb.sb_bsize",
            "(unsigned int)PAGE_SIZE"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "sb->s_bdev"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "sb->s_bdev"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_read_sb",
          "args": [
            "sdp",
            "silent"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_read_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "270-356",
          "snippet": "static int gfs2_read_sb(struct gfs2_sbd *sdp, int silent)\n{\n\tu32 hash_blocks, ind_blocks, leaf_blocks;\n\tu32 tmp_blocks;\n\tunsigned int x;\n\tint error;\n\n\terror = gfs2_read_super(sdp, GFS2_SB_ADDR >> sdp->sd_fsb2bb_shift, silent);\n\tif (error) {\n\t\tif (!silent)\n\t\t\tfs_err(sdp, \"can't read superblock\\n\");\n\t\treturn error;\n\t}\n\n\tsdp->sd_fsb2bb_shift = sdp->sd_sb.sb_bsize_shift -\n\t\t\t       GFS2_BASIC_BLOCK_SHIFT;\n\tsdp->sd_fsb2bb = 1 << sdp->sd_fsb2bb_shift;\n\tsdp->sd_diptrs = (sdp->sd_sb.sb_bsize -\n\t\t\t  sizeof(struct gfs2_dinode)) / sizeof(u64);\n\tsdp->sd_inptrs = (sdp->sd_sb.sb_bsize -\n\t\t\t  sizeof(struct gfs2_meta_header)) / sizeof(u64);\n\tsdp->sd_jbsize = sdp->sd_sb.sb_bsize - sizeof(struct gfs2_meta_header);\n\tsdp->sd_hash_bsize = sdp->sd_sb.sb_bsize / 2;\n\tsdp->sd_hash_bsize_shift = sdp->sd_sb.sb_bsize_shift - 1;\n\tsdp->sd_hash_ptrs = sdp->sd_hash_bsize / sizeof(u64);\n\tsdp->sd_qc_per_block = (sdp->sd_sb.sb_bsize -\n\t\t\t\tsizeof(struct gfs2_meta_header)) /\n\t\t\t        sizeof(struct gfs2_quota_change);\n\tsdp->sd_blocks_per_bitmap = (sdp->sd_sb.sb_bsize -\n\t\t\t\t     sizeof(struct gfs2_meta_header))\n\t\t* GFS2_NBBY; /* not the rgrp bitmap, subsequent bitmaps only */\n\n\t/* Compute maximum reservation required to add a entry to a directory */\n\n\thash_blocks = DIV_ROUND_UP(sizeof(u64) * (1 << GFS2_DIR_MAX_DEPTH),\n\t\t\t     sdp->sd_jbsize);\n\n\tind_blocks = 0;\n\tfor (tmp_blocks = hash_blocks; tmp_blocks > sdp->sd_diptrs;) {\n\t\ttmp_blocks = DIV_ROUND_UP(tmp_blocks, sdp->sd_inptrs);\n\t\tind_blocks += tmp_blocks;\n\t}\n\n\tleaf_blocks = 2 + GFS2_DIR_MAX_DEPTH;\n\n\tsdp->sd_max_dirres = hash_blocks + ind_blocks + leaf_blocks;\n\n\tsdp->sd_heightsize[0] = sdp->sd_sb.sb_bsize -\n\t\t\t\tsizeof(struct gfs2_dinode);\n\tsdp->sd_heightsize[1] = sdp->sd_sb.sb_bsize * sdp->sd_diptrs;\n\tfor (x = 2;; x++) {\n\t\tu64 space, d;\n\t\tu32 m;\n\n\t\tspace = sdp->sd_heightsize[x - 1] * sdp->sd_inptrs;\n\t\td = space;\n\t\tm = do_div(d, sdp->sd_inptrs);\n\n\t\tif (d != sdp->sd_heightsize[x - 1] || m)\n\t\t\tbreak;\n\t\tsdp->sd_heightsize[x] = space;\n\t}\n\tsdp->sd_max_height = x;\n\tsdp->sd_heightsize[x] = ~0;\n\tgfs2_assert(sdp, sdp->sd_max_height <= GFS2_MAX_META_HEIGHT);\n\n\tsdp->sd_jheightsize[0] = sdp->sd_sb.sb_bsize -\n\t\t\t\t sizeof(struct gfs2_dinode);\n\tsdp->sd_jheightsize[1] = sdp->sd_jbsize * sdp->sd_diptrs;\n\tfor (x = 2;; x++) {\n\t\tu64 space, d;\n\t\tu32 m;\n\n\t\tspace = sdp->sd_jheightsize[x - 1] * sdp->sd_inptrs;\n\t\td = space;\n\t\tm = do_div(d, sdp->sd_inptrs);\n\n\t\tif (d != sdp->sd_jheightsize[x - 1] || m)\n\t\t\tbreak;\n\t\tsdp->sd_jheightsize[x] = space;\n\t}\n\tsdp->sd_max_jheight = x;\n\tsdp->sd_jheightsize[x] = ~0;\n\tgfs2_assert(sdp, sdp->sd_max_jheight <= GFS2_MAX_META_HEIGHT);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_read_sb(struct gfs2_sbd *sdp, int silent)\n{\n\tu32 hash_blocks, ind_blocks, leaf_blocks;\n\tu32 tmp_blocks;\n\tunsigned int x;\n\tint error;\n\n\terror = gfs2_read_super(sdp, GFS2_SB_ADDR >> sdp->sd_fsb2bb_shift, silent);\n\tif (error) {\n\t\tif (!silent)\n\t\t\tfs_err(sdp, \"can't read superblock\\n\");\n\t\treturn error;\n\t}\n\n\tsdp->sd_fsb2bb_shift = sdp->sd_sb.sb_bsize_shift -\n\t\t\t       GFS2_BASIC_BLOCK_SHIFT;\n\tsdp->sd_fsb2bb = 1 << sdp->sd_fsb2bb_shift;\n\tsdp->sd_diptrs = (sdp->sd_sb.sb_bsize -\n\t\t\t  sizeof(struct gfs2_dinode)) / sizeof(u64);\n\tsdp->sd_inptrs = (sdp->sd_sb.sb_bsize -\n\t\t\t  sizeof(struct gfs2_meta_header)) / sizeof(u64);\n\tsdp->sd_jbsize = sdp->sd_sb.sb_bsize - sizeof(struct gfs2_meta_header);\n\tsdp->sd_hash_bsize = sdp->sd_sb.sb_bsize / 2;\n\tsdp->sd_hash_bsize_shift = sdp->sd_sb.sb_bsize_shift - 1;\n\tsdp->sd_hash_ptrs = sdp->sd_hash_bsize / sizeof(u64);\n\tsdp->sd_qc_per_block = (sdp->sd_sb.sb_bsize -\n\t\t\t\tsizeof(struct gfs2_meta_header)) /\n\t\t\t        sizeof(struct gfs2_quota_change);\n\tsdp->sd_blocks_per_bitmap = (sdp->sd_sb.sb_bsize -\n\t\t\t\t     sizeof(struct gfs2_meta_header))\n\t\t* GFS2_NBBY; /* not the rgrp bitmap, subsequent bitmaps only */\n\n\t/* Compute maximum reservation required to add a entry to a directory */\n\n\thash_blocks = DIV_ROUND_UP(sizeof(u64) * (1 << GFS2_DIR_MAX_DEPTH),\n\t\t\t     sdp->sd_jbsize);\n\n\tind_blocks = 0;\n\tfor (tmp_blocks = hash_blocks; tmp_blocks > sdp->sd_diptrs;) {\n\t\ttmp_blocks = DIV_ROUND_UP(tmp_blocks, sdp->sd_inptrs);\n\t\tind_blocks += tmp_blocks;\n\t}\n\n\tleaf_blocks = 2 + GFS2_DIR_MAX_DEPTH;\n\n\tsdp->sd_max_dirres = hash_blocks + ind_blocks + leaf_blocks;\n\n\tsdp->sd_heightsize[0] = sdp->sd_sb.sb_bsize -\n\t\t\t\tsizeof(struct gfs2_dinode);\n\tsdp->sd_heightsize[1] = sdp->sd_sb.sb_bsize * sdp->sd_diptrs;\n\tfor (x = 2;; x++) {\n\t\tu64 space, d;\n\t\tu32 m;\n\n\t\tspace = sdp->sd_heightsize[x - 1] * sdp->sd_inptrs;\n\t\td = space;\n\t\tm = do_div(d, sdp->sd_inptrs);\n\n\t\tif (d != sdp->sd_heightsize[x - 1] || m)\n\t\t\tbreak;\n\t\tsdp->sd_heightsize[x] = space;\n\t}\n\tsdp->sd_max_height = x;\n\tsdp->sd_heightsize[x] = ~0;\n\tgfs2_assert(sdp, sdp->sd_max_height <= GFS2_MAX_META_HEIGHT);\n\n\tsdp->sd_jheightsize[0] = sdp->sd_sb.sb_bsize -\n\t\t\t\t sizeof(struct gfs2_dinode);\n\tsdp->sd_jheightsize[1] = sdp->sd_jbsize * sdp->sd_diptrs;\n\tfor (x = 2;; x++) {\n\t\tu64 space, d;\n\t\tu32 m;\n\n\t\tspace = sdp->sd_jheightsize[x - 1] * sdp->sd_inptrs;\n\t\td = space;\n\t\tm = do_div(d, sdp->sd_inptrs);\n\n\t\tif (d != sdp->sd_jheightsize[x - 1] || m)\n\t\t\tbreak;\n\t\tsdp->sd_jheightsize[x] = space;\n\t}\n\tsdp->sd_max_jheight = x;\n\tsdp->sd_jheightsize[x] = ~0;\n\tgfs2_assert(sdp, sdp->sd_max_jheight <= GFS2_MAX_META_HEIGHT);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_num",
          "args": [
            "sdp",
            "GFS2_SB_LOCK",
            "&gfs2_meta_glops",
            "LM_ST_SHARED",
            "0",
            "&sb_gh"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1128-1142",
          "snippet": "int gfs2_glock_nq_num(struct gfs2_sbd *sdp, u64 number,\n\t\t      const struct gfs2_glock_operations *glops,\n\t\t      unsigned int state, int flags, struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\terror = gfs2_glock_get(sdp, number, glops, CREATE, &gl);\n\tif (!error) {\n\t\terror = gfs2_glock_nq_init(gl, state, flags, gh);\n\t\tgfs2_glock_put(gl);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_glock_nq_num(struct gfs2_sbd *sdp, u64 number,\n\t\t      const struct gfs2_glock_operations *glops,\n\t\t      unsigned int state, int flags, struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\terror = gfs2_glock_get(sdp, number, glops, CREATE, &gl);\n\tif (!error) {\n\t\terror = gfs2_glock_nq_init(gl, state, flags, gh);\n\t\tgfs2_glock_put(gl);\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int init_sb(struct gfs2_sbd *sdp, int silent)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct gfs2_holder sb_gh;\n\tu64 no_addr;\n\tint ret;\n\n\tret = gfs2_glock_nq_num(sdp, GFS2_SB_LOCK, &gfs2_meta_glops,\n\t\t\t\tLM_ST_SHARED, 0, &sb_gh);\n\tif (ret) {\n\t\tfs_err(sdp, \"can't acquire superblock glock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = gfs2_read_sb(sdp, silent);\n\tif (ret) {\n\t\tfs_err(sdp, \"can't read superblock: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t/* Set up the buffer cache and SB for real */\n\tif (sdp->sd_sb.sb_bsize < bdev_logical_block_size(sb->s_bdev)) {\n\t\tret = -EINVAL;\n\t\tfs_err(sdp, \"FS block size (%u) is too small for device \"\n\t\t       \"block size (%u)\\n\",\n\t\t       sdp->sd_sb.sb_bsize, bdev_logical_block_size(sb->s_bdev));\n\t\tgoto out;\n\t}\n\tif (sdp->sd_sb.sb_bsize > PAGE_SIZE) {\n\t\tret = -EINVAL;\n\t\tfs_err(sdp, \"FS block size (%u) is too big for machine \"\n\t\t       \"page size (%u)\\n\",\n\t\t       sdp->sd_sb.sb_bsize, (unsigned int)PAGE_SIZE);\n\t\tgoto out;\n\t}\n\tsb_set_blocksize(sb, sdp->sd_sb.sb_bsize);\n\n\t/* Get the root inode */\n\tno_addr = sdp->sd_sb.sb_root_dir.no_addr;\n\tret = gfs2_lookup_root(sb, &sdp->sd_root_dir, no_addr, \"root\");\n\tif (ret)\n\t\tgoto out;\n\n\t/* Get the master inode */\n\tno_addr = sdp->sd_sb.sb_master_dir.no_addr;\n\tret = gfs2_lookup_root(sb, &sdp->sd_master_dir, no_addr, \"master\");\n\tif (ret) {\n\t\tdput(sdp->sd_root_dir);\n\t\tgoto out;\n\t}\n\tsb->s_root = dget(sdp->sd_args.ar_meta ? sdp->sd_master_dir : sdp->sd_root_dir);\nout:\n\tgfs2_glock_dq_uninit(&sb_gh);\n\treturn ret;\n}"
  },
  {
    "function_name": "gfs2_lookup_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "447-466",
    "snippet": "static int gfs2_lookup_root(struct super_block *sb, struct dentry **dptr,\n\t\t\t    u64 no_addr, const char *name)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tinode = gfs2_inode_lookup(sb, DT_DIR, no_addr, 0, 0);\n\tif (IS_ERR(inode)) {\n\t\tfs_err(sdp, \"can't read in %s inode: %ld\\n\", name, PTR_ERR(inode));\n\t\treturn PTR_ERR(inode);\n\t}\n\tdentry = d_make_root(inode);\n\tif (!dentry) {\n\t\tfs_err(sdp, \"can't alloc %s dentry\\n\", name);\n\t\treturn -ENOMEM;\n\t}\n\t*dptr = dentry;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"can't alloc %s dentry\\n\"",
            "name"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_inode_lookup",
          "args": [
            "sb",
            "DT_DIR",
            "no_addr",
            "0",
            "0"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inode_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "140-204",
          "snippet": "struct inode *gfs2_inode_lookup(struct super_block *sb, unsigned int type,\n\t\t\t\tu64 no_addr, u64 no_formal_ino, int non_block)\n{\n\tstruct inode *inode;\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_glock *io_gl = NULL;\n\tint error;\n\n\tinode = gfs2_iget(sb, no_addr, non_block);\n\tip = GFS2_I(inode);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\t\tip->i_no_formal_ino = no_formal_ino;\n\n\t\terror = gfs2_glock_get(sdp, no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail;\n\t\tip->i_gl->gl_object = ip;\n\n\t\terror = gfs2_glock_get(sdp, no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail_put;\n\n\t\tset_bit(GIF_INVALID, &ip->i_flags);\n\t\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\t\tif (unlikely(error))\n\t\t\tgoto fail_iopen;\n\n\t\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\t\tgfs2_glock_put(io_gl);\n\t\tio_gl = NULL;\n\n\t\tif (type == DT_UNKNOWN) {\n\t\t\t/* Inode glock must be locked already */\n\t\t\terror = gfs2_inode_refresh(GFS2_I(inode));\n\t\t\tif (error)\n\t\t\t\tgoto fail_refresh;\n\t\t} else {\n\t\t\tinode->i_mode = DT2IF(type);\n\t\t}\n\n\t\tgfs2_set_iop(inode);\n\t\tunlock_new_inode(inode);\n\t}\n\n\treturn inode;\n\nfail_refresh:\n\tip->i_iopen_gh.gh_flags |= GL_NOCACHE;\n\tip->i_iopen_gh.gh_gl->gl_object = NULL;\n\tgfs2_glock_dq_uninit(&ip->i_iopen_gh);\nfail_iopen:\n\tif (io_gl)\n\t\tgfs2_glock_put(io_gl);\nfail_put:\n\tip->i_gl->gl_object = NULL;\n\tgfs2_glock_put(ip->i_gl);\nfail:\n\tiget_failed(inode);\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct inode *gfs2_inode_lookup(struct super_block *sb, unsigned int type,\n\t\t\t\tu64 no_addr, u64 no_formal_ino, int non_block)\n{\n\tstruct inode *inode;\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_glock *io_gl = NULL;\n\tint error;\n\n\tinode = gfs2_iget(sb, no_addr, non_block);\n\tip = GFS2_I(inode);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\t\tip->i_no_formal_ino = no_formal_ino;\n\n\t\terror = gfs2_glock_get(sdp, no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail;\n\t\tip->i_gl->gl_object = ip;\n\n\t\terror = gfs2_glock_get(sdp, no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail_put;\n\n\t\tset_bit(GIF_INVALID, &ip->i_flags);\n\t\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);\n\t\tif (unlikely(error))\n\t\t\tgoto fail_iopen;\n\n\t\tip->i_iopen_gh.gh_gl->gl_object = ip;\n\t\tgfs2_glock_put(io_gl);\n\t\tio_gl = NULL;\n\n\t\tif (type == DT_UNKNOWN) {\n\t\t\t/* Inode glock must be locked already */\n\t\t\terror = gfs2_inode_refresh(GFS2_I(inode));\n\t\t\tif (error)\n\t\t\t\tgoto fail_refresh;\n\t\t} else {\n\t\t\tinode->i_mode = DT2IF(type);\n\t\t}\n\n\t\tgfs2_set_iop(inode);\n\t\tunlock_new_inode(inode);\n\t}\n\n\treturn inode;\n\nfail_refresh:\n\tip->i_iopen_gh.gh_flags |= GL_NOCACHE;\n\tip->i_iopen_gh.gh_gl->gl_object = NULL;\n\tgfs2_glock_dq_uninit(&ip->i_iopen_gh);\nfail_iopen:\n\tif (io_gl)\n\t\tgfs2_glock_put(io_gl);\nfail_put:\n\tip->i_gl->gl_object = NULL;\n\tgfs2_glock_put(ip->i_gl);\nfail:\n\tiget_failed(inode);\n\treturn ERR_PTR(error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_lookup_root(struct super_block *sb, struct dentry **dptr,\n\t\t\t    u64 no_addr, const char *name)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tinode = gfs2_inode_lookup(sb, DT_DIR, no_addr, 0, 0);\n\tif (IS_ERR(inode)) {\n\t\tfs_err(sdp, \"can't read in %s inode: %ld\\n\", name, PTR_ERR(inode));\n\t\treturn PTR_ERR(inode);\n\t}\n\tdentry = d_make_root(inode);\n\tif (!dentry) {\n\t\tfs_err(sdp, \"can't alloc %s dentry\\n\", name);\n\t\treturn -ENOMEM;\n\t}\n\t*dptr = dentry;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_locking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "392-445",
    "snippet": "static int init_locking(struct gfs2_sbd *sdp, struct gfs2_holder *mount_gh,\n\t\t\tint undo)\n{\n\tint error = 0;\n\n\tif (undo)\n\t\tgoto fail_trans;\n\n\terror = gfs2_glock_nq_num(sdp,\n\t\t\t\t  GFS2_MOUNT_LOCK, &gfs2_nondisk_glops,\n\t\t\t\t  LM_ST_EXCLUSIVE, LM_FLAG_NOEXP | GL_NOCACHE,\n\t\t\t\t  mount_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't acquire mount glock: %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = gfs2_glock_nq_num(sdp,\n\t\t\t\t  GFS2_LIVE_LOCK, &gfs2_nondisk_glops,\n\t\t\t\t  LM_ST_SHARED,\n\t\t\t\t  LM_FLAG_NOEXP | GL_EXACT,\n\t\t\t\t  &sdp->sd_live_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't acquire live glock: %d\\n\", error);\n\t\tgoto fail_mount;\n\t}\n\n\terror = gfs2_glock_get(sdp, GFS2_RENAME_LOCK, &gfs2_nondisk_glops,\n\t\t\t       CREATE, &sdp->sd_rename_gl);\n\tif (error) {\n\t\tfs_err(sdp, \"can't create rename glock: %d\\n\", error);\n\t\tgoto fail_live;\n\t}\n\n\terror = gfs2_glock_get(sdp, GFS2_FREEZE_LOCK, &gfs2_freeze_glops,\n\t\t\t       CREATE, &sdp->sd_freeze_gl);\n\tif (error) {\n\t\tfs_err(sdp, \"can't create transaction glock: %d\\n\", error);\n\t\tgoto fail_rename;\n\t}\n\n\treturn 0;\n\nfail_trans:\n\tgfs2_glock_put(sdp->sd_freeze_gl);\nfail_rename:\n\tgfs2_glock_put(sdp->sd_rename_gl);\nfail_live:\n\tgfs2_glock_dq_uninit(&sdp->sd_live_gh);\nfail_mount:\n\tgfs2_glock_dq_uninit(mount_gh);\nfail:\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "mount_gh"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_put",
          "args": [
            "sdp->sd_rename_gl"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "193-212",
          "snippet": "void gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"can't create transaction glock: %d\\n\"",
            "error"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_get",
          "args": [
            "sdp",
            "GFS2_FREEZE_LOCK",
            "&gfs2_freeze_glops",
            "CREATE",
            "&sdp->sd_freeze_gl"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "702-790",
          "snippet": "int gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,\n\t\t   const struct gfs2_glock_operations *glops, int create,\n\t\t   struct gfs2_glock **glp)\n{\n\tstruct super_block *s = sdp->sd_vfs;\n\tstruct lm_lockname name = { .ln_number = number, .ln_type = glops->go_type };\n\tstruct gfs2_glock *gl, *tmp;\n\tunsigned int hash = gl_hash(sdp, &name);\n\tstruct address_space *mapping;\n\tstruct kmem_cache *cachep;\n\n\trcu_read_lock();\n\tgl = search_bucket(hash, sdp, &name);\n\trcu_read_unlock();\n\n\t*glp = gl;\n\tif (gl)\n\t\treturn 0;\n\tif (!create)\n\t\treturn -ENOENT;\n\n\tif (glops->go_flags & GLOF_ASPACE)\n\t\tcachep = gfs2_glock_aspace_cachep;\n\telse\n\t\tcachep = gfs2_glock_cachep;\n\tgl = kmem_cache_alloc(cachep, GFP_NOFS);\n\tif (!gl)\n\t\treturn -ENOMEM;\n\n\tmemset(&gl->gl_lksb, 0, sizeof(struct dlm_lksb));\n\n\tif (glops->go_flags & GLOF_LVB) {\n\t\tgl->gl_lksb.sb_lvbptr = kzalloc(GFS2_MIN_LVB_SIZE, GFP_NOFS);\n\t\tif (!gl->gl_lksb.sb_lvbptr) {\n\t\t\tkmem_cache_free(cachep, gl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tatomic_inc(&sdp->sd_glock_disposal);\n\tgl->gl_sbd = sdp;\n\tgl->gl_flags = 0;\n\tgl->gl_name = name;\n\tgl->gl_lockref.count = 1;\n\tgl->gl_state = LM_ST_UNLOCKED;\n\tgl->gl_target = LM_ST_UNLOCKED;\n\tgl->gl_demote_state = LM_ST_EXCLUSIVE;\n\tgl->gl_hash = hash;\n\tgl->gl_ops = glops;\n\tgl->gl_dstamp = ktime_set(0, 0);\n\tpreempt_disable();\n\t/* We use the global stats to estimate the initial per-glock stats */\n\tgl->gl_stats = this_cpu_ptr(sdp->sd_lkstats)->lkstats[glops->go_type];\n\tpreempt_enable();\n\tgl->gl_stats.stats[GFS2_LKS_DCOUNT] = 0;\n\tgl->gl_stats.stats[GFS2_LKS_QCOUNT] = 0;\n\tgl->gl_tchange = jiffies;\n\tgl->gl_object = NULL;\n\tgl->gl_hold_time = GL_GLOCK_DFT_HOLD;\n\tINIT_DELAYED_WORK(&gl->gl_work, glock_work_func);\n\tINIT_WORK(&gl->gl_delete, delete_work_func);\n\n\tmapping = gfs2_glock2aspace(gl);\n\tif (mapping) {\n                mapping->a_ops = &gfs2_meta_aops;\n\t\tmapping->host = s->s_bdev->bd_inode;\n\t\tmapping->flags = 0;\n\t\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\t\tmapping->private_data = NULL;\n\t\tmapping->writeback_index = 0;\n\t}\n\n\tspin_lock_bucket(hash);\n\ttmp = search_bucket(hash, sdp, &name);\n\tif (tmp) {\n\t\tspin_unlock_bucket(hash);\n\t\tkfree(gl->gl_lksb.sb_lvbptr);\n\t\tkmem_cache_free(cachep, gl);\n\t\tatomic_dec(&sdp->sd_glock_disposal);\n\t\tgl = tmp;\n\t} else {\n\t\thlist_bl_add_head_rcu(&gl->gl_list, &gl_hash_table[hash]);\n\t\tspin_unlock_bucket(hash);\n\t}\n\n\t*glp = gl;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head gl_hash_table[GFS2_GL_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head gl_hash_table[GFS2_GL_HASH_SIZE];\n\nint gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,\n\t\t   const struct gfs2_glock_operations *glops, int create,\n\t\t   struct gfs2_glock **glp)\n{\n\tstruct super_block *s = sdp->sd_vfs;\n\tstruct lm_lockname name = { .ln_number = number, .ln_type = glops->go_type };\n\tstruct gfs2_glock *gl, *tmp;\n\tunsigned int hash = gl_hash(sdp, &name);\n\tstruct address_space *mapping;\n\tstruct kmem_cache *cachep;\n\n\trcu_read_lock();\n\tgl = search_bucket(hash, sdp, &name);\n\trcu_read_unlock();\n\n\t*glp = gl;\n\tif (gl)\n\t\treturn 0;\n\tif (!create)\n\t\treturn -ENOENT;\n\n\tif (glops->go_flags & GLOF_ASPACE)\n\t\tcachep = gfs2_glock_aspace_cachep;\n\telse\n\t\tcachep = gfs2_glock_cachep;\n\tgl = kmem_cache_alloc(cachep, GFP_NOFS);\n\tif (!gl)\n\t\treturn -ENOMEM;\n\n\tmemset(&gl->gl_lksb, 0, sizeof(struct dlm_lksb));\n\n\tif (glops->go_flags & GLOF_LVB) {\n\t\tgl->gl_lksb.sb_lvbptr = kzalloc(GFS2_MIN_LVB_SIZE, GFP_NOFS);\n\t\tif (!gl->gl_lksb.sb_lvbptr) {\n\t\t\tkmem_cache_free(cachep, gl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tatomic_inc(&sdp->sd_glock_disposal);\n\tgl->gl_sbd = sdp;\n\tgl->gl_flags = 0;\n\tgl->gl_name = name;\n\tgl->gl_lockref.count = 1;\n\tgl->gl_state = LM_ST_UNLOCKED;\n\tgl->gl_target = LM_ST_UNLOCKED;\n\tgl->gl_demote_state = LM_ST_EXCLUSIVE;\n\tgl->gl_hash = hash;\n\tgl->gl_ops = glops;\n\tgl->gl_dstamp = ktime_set(0, 0);\n\tpreempt_disable();\n\t/* We use the global stats to estimate the initial per-glock stats */\n\tgl->gl_stats = this_cpu_ptr(sdp->sd_lkstats)->lkstats[glops->go_type];\n\tpreempt_enable();\n\tgl->gl_stats.stats[GFS2_LKS_DCOUNT] = 0;\n\tgl->gl_stats.stats[GFS2_LKS_QCOUNT] = 0;\n\tgl->gl_tchange = jiffies;\n\tgl->gl_object = NULL;\n\tgl->gl_hold_time = GL_GLOCK_DFT_HOLD;\n\tINIT_DELAYED_WORK(&gl->gl_work, glock_work_func);\n\tINIT_WORK(&gl->gl_delete, delete_work_func);\n\n\tmapping = gfs2_glock2aspace(gl);\n\tif (mapping) {\n                mapping->a_ops = &gfs2_meta_aops;\n\t\tmapping->host = s->s_bdev->bd_inode;\n\t\tmapping->flags = 0;\n\t\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\t\tmapping->private_data = NULL;\n\t\tmapping->writeback_index = 0;\n\t}\n\n\tspin_lock_bucket(hash);\n\ttmp = search_bucket(hash, sdp, &name);\n\tif (tmp) {\n\t\tspin_unlock_bucket(hash);\n\t\tkfree(gl->gl_lksb.sb_lvbptr);\n\t\tkmem_cache_free(cachep, gl);\n\t\tatomic_dec(&sdp->sd_glock_disposal);\n\t\tgl = tmp;\n\t} else {\n\t\thlist_bl_add_head_rcu(&gl->gl_list, &gl_hash_table[hash]);\n\t\tspin_unlock_bucket(hash);\n\t}\n\n\t*glp = gl;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_num",
          "args": [
            "sdp",
            "GFS2_LIVE_LOCK",
            "&gfs2_nondisk_glops",
            "LM_ST_SHARED",
            "LM_FLAG_NOEXP | GL_EXACT",
            "&sdp->sd_live_gh"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1128-1142",
          "snippet": "int gfs2_glock_nq_num(struct gfs2_sbd *sdp, u64 number,\n\t\t      const struct gfs2_glock_operations *glops,\n\t\t      unsigned int state, int flags, struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\terror = gfs2_glock_get(sdp, number, glops, CREATE, &gl);\n\tif (!error) {\n\t\terror = gfs2_glock_nq_init(gl, state, flags, gh);\n\t\tgfs2_glock_put(gl);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_glock_nq_num(struct gfs2_sbd *sdp, u64 number,\n\t\t      const struct gfs2_glock_operations *glops,\n\t\t      unsigned int state, int flags, struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\terror = gfs2_glock_get(sdp, number, glops, CREATE, &gl);\n\tif (!error) {\n\t\terror = gfs2_glock_nq_init(gl, state, flags, gh);\n\t\tgfs2_glock_put(gl);\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int init_locking(struct gfs2_sbd *sdp, struct gfs2_holder *mount_gh,\n\t\t\tint undo)\n{\n\tint error = 0;\n\n\tif (undo)\n\t\tgoto fail_trans;\n\n\terror = gfs2_glock_nq_num(sdp,\n\t\t\t\t  GFS2_MOUNT_LOCK, &gfs2_nondisk_glops,\n\t\t\t\t  LM_ST_EXCLUSIVE, LM_FLAG_NOEXP | GL_NOCACHE,\n\t\t\t\t  mount_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't acquire mount glock: %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = gfs2_glock_nq_num(sdp,\n\t\t\t\t  GFS2_LIVE_LOCK, &gfs2_nondisk_glops,\n\t\t\t\t  LM_ST_SHARED,\n\t\t\t\t  LM_FLAG_NOEXP | GL_EXACT,\n\t\t\t\t  &sdp->sd_live_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't acquire live glock: %d\\n\", error);\n\t\tgoto fail_mount;\n\t}\n\n\terror = gfs2_glock_get(sdp, GFS2_RENAME_LOCK, &gfs2_nondisk_glops,\n\t\t\t       CREATE, &sdp->sd_rename_gl);\n\tif (error) {\n\t\tfs_err(sdp, \"can't create rename glock: %d\\n\", error);\n\t\tgoto fail_live;\n\t}\n\n\terror = gfs2_glock_get(sdp, GFS2_FREEZE_LOCK, &gfs2_freeze_glops,\n\t\t\t       CREATE, &sdp->sd_freeze_gl);\n\tif (error) {\n\t\tfs_err(sdp, \"can't create transaction glock: %d\\n\", error);\n\t\tgoto fail_rename;\n\t}\n\n\treturn 0;\n\nfail_trans:\n\tgfs2_glock_put(sdp->sd_freeze_gl);\nfail_rename:\n\tgfs2_glock_put(sdp->sd_rename_gl);\nfail_live:\n\tgfs2_glock_dq_uninit(&sdp->sd_live_gh);\nfail_mount:\n\tgfs2_glock_dq_uninit(mount_gh);\nfail:\n\treturn error;\n}"
  },
  {
    "function_name": "init_names",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "358-390",
    "snippet": "static int init_names(struct gfs2_sbd *sdp, int silent)\n{\n\tchar *proto, *table;\n\tint error = 0;\n\n\tproto = sdp->sd_args.ar_lockproto;\n\ttable = sdp->sd_args.ar_locktable;\n\n\t/*  Try to autodetect  */\n\n\tif (!proto[0] || !table[0]) {\n\t\terror = gfs2_read_super(sdp, GFS2_SB_ADDR >> sdp->sd_fsb2bb_shift, silent);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (!proto[0])\n\t\t\tproto = sdp->sd_sb.sb_lockproto;\n\t\tif (!table[0])\n\t\t\ttable = sdp->sd_sb.sb_locktable;\n\t}\n\n\tif (!table[0])\n\t\ttable = sdp->sd_vfs->s_id;\n\n\tstrlcpy(sdp->sd_proto_name, proto, GFS2_FSNAME_LEN);\n\tstrlcpy(sdp->sd_table_name, table, GFS2_FSNAME_LEN);\n\n\ttable = sdp->sd_table_name;\n\twhile ((table = strchr(table, '/')))\n\t\t*table = '_';\n\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "table",
            "'/'"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "sdp->sd_table_name",
            "table",
            "GFS2_FSNAME_LEN"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "sdp->sd_proto_name",
            "proto",
            "GFS2_FSNAME_LEN"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_read_super",
          "args": [
            "sdp",
            "GFS2_SB_ADDR >> sdp->sd_fsb2bb_shift",
            "silent"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_read_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "227-261",
          "snippet": "static int gfs2_read_super(struct gfs2_sbd *sdp, sector_t sector, int silent)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct gfs2_sb *p;\n\tstruct page *page;\n\tstruct bio *bio;\n\n\tpage = alloc_page(GFP_NOFS);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\tClearPageUptodate(page);\n\tClearPageDirty(page);\n\tlock_page(page);\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\tbio->bi_iter.bi_sector = sector * (sb->s_blocksize >> 9);\n\tbio->bi_bdev = sb->s_bdev;\n\tbio_add_page(bio, page, PAGE_SIZE, 0);\n\n\tbio->bi_end_io = end_bio_io_page;\n\tbio->bi_private = page;\n\tsubmit_bio(READ_SYNC | REQ_META, bio);\n\twait_on_page_locked(page);\n\tbio_put(bio);\n\tif (!PageUptodate(page)) {\n\t\t__free_page(page);\n\t\treturn -EIO;\n\t}\n\tp = kmap(page);\n\tgfs2_sb_in(sdp, p);\n\tkunmap(page);\n\t__free_page(page);\n\treturn gfs2_check_sb(sdp, silent);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_read_super(struct gfs2_sbd *sdp, sector_t sector, int silent)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct gfs2_sb *p;\n\tstruct page *page;\n\tstruct bio *bio;\n\n\tpage = alloc_page(GFP_NOFS);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\tClearPageUptodate(page);\n\tClearPageDirty(page);\n\tlock_page(page);\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\tbio->bi_iter.bi_sector = sector * (sb->s_blocksize >> 9);\n\tbio->bi_bdev = sb->s_bdev;\n\tbio_add_page(bio, page, PAGE_SIZE, 0);\n\n\tbio->bi_end_io = end_bio_io_page;\n\tbio->bi_private = page;\n\tsubmit_bio(READ_SYNC | REQ_META, bio);\n\twait_on_page_locked(page);\n\tbio_put(bio);\n\tif (!PageUptodate(page)) {\n\t\t__free_page(page);\n\t\treturn -EIO;\n\t}\n\tp = kmap(page);\n\tgfs2_sb_in(sdp, p);\n\tkunmap(page);\n\t__free_page(page);\n\treturn gfs2_check_sb(sdp, silent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int init_names(struct gfs2_sbd *sdp, int silent)\n{\n\tchar *proto, *table;\n\tint error = 0;\n\n\tproto = sdp->sd_args.ar_lockproto;\n\ttable = sdp->sd_args.ar_locktable;\n\n\t/*  Try to autodetect  */\n\n\tif (!proto[0] || !table[0]) {\n\t\terror = gfs2_read_super(sdp, GFS2_SB_ADDR >> sdp->sd_fsb2bb_shift, silent);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (!proto[0])\n\t\t\tproto = sdp->sd_sb.sb_lockproto;\n\t\tif (!table[0])\n\t\t\ttable = sdp->sd_sb.sb_locktable;\n\t}\n\n\tif (!table[0])\n\t\ttable = sdp->sd_vfs->s_id;\n\n\tstrlcpy(sdp->sd_proto_name, proto, GFS2_FSNAME_LEN);\n\tstrlcpy(sdp->sd_table_name, table, GFS2_FSNAME_LEN);\n\n\ttable = sdp->sd_table_name;\n\twhile ((table = strchr(table, '/')))\n\t\t*table = '_';\n\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_read_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "270-356",
    "snippet": "static int gfs2_read_sb(struct gfs2_sbd *sdp, int silent)\n{\n\tu32 hash_blocks, ind_blocks, leaf_blocks;\n\tu32 tmp_blocks;\n\tunsigned int x;\n\tint error;\n\n\terror = gfs2_read_super(sdp, GFS2_SB_ADDR >> sdp->sd_fsb2bb_shift, silent);\n\tif (error) {\n\t\tif (!silent)\n\t\t\tfs_err(sdp, \"can't read superblock\\n\");\n\t\treturn error;\n\t}\n\n\tsdp->sd_fsb2bb_shift = sdp->sd_sb.sb_bsize_shift -\n\t\t\t       GFS2_BASIC_BLOCK_SHIFT;\n\tsdp->sd_fsb2bb = 1 << sdp->sd_fsb2bb_shift;\n\tsdp->sd_diptrs = (sdp->sd_sb.sb_bsize -\n\t\t\t  sizeof(struct gfs2_dinode)) / sizeof(u64);\n\tsdp->sd_inptrs = (sdp->sd_sb.sb_bsize -\n\t\t\t  sizeof(struct gfs2_meta_header)) / sizeof(u64);\n\tsdp->sd_jbsize = sdp->sd_sb.sb_bsize - sizeof(struct gfs2_meta_header);\n\tsdp->sd_hash_bsize = sdp->sd_sb.sb_bsize / 2;\n\tsdp->sd_hash_bsize_shift = sdp->sd_sb.sb_bsize_shift - 1;\n\tsdp->sd_hash_ptrs = sdp->sd_hash_bsize / sizeof(u64);\n\tsdp->sd_qc_per_block = (sdp->sd_sb.sb_bsize -\n\t\t\t\tsizeof(struct gfs2_meta_header)) /\n\t\t\t        sizeof(struct gfs2_quota_change);\n\tsdp->sd_blocks_per_bitmap = (sdp->sd_sb.sb_bsize -\n\t\t\t\t     sizeof(struct gfs2_meta_header))\n\t\t* GFS2_NBBY; /* not the rgrp bitmap, subsequent bitmaps only */\n\n\t/* Compute maximum reservation required to add a entry to a directory */\n\n\thash_blocks = DIV_ROUND_UP(sizeof(u64) * (1 << GFS2_DIR_MAX_DEPTH),\n\t\t\t     sdp->sd_jbsize);\n\n\tind_blocks = 0;\n\tfor (tmp_blocks = hash_blocks; tmp_blocks > sdp->sd_diptrs;) {\n\t\ttmp_blocks = DIV_ROUND_UP(tmp_blocks, sdp->sd_inptrs);\n\t\tind_blocks += tmp_blocks;\n\t}\n\n\tleaf_blocks = 2 + GFS2_DIR_MAX_DEPTH;\n\n\tsdp->sd_max_dirres = hash_blocks + ind_blocks + leaf_blocks;\n\n\tsdp->sd_heightsize[0] = sdp->sd_sb.sb_bsize -\n\t\t\t\tsizeof(struct gfs2_dinode);\n\tsdp->sd_heightsize[1] = sdp->sd_sb.sb_bsize * sdp->sd_diptrs;\n\tfor (x = 2;; x++) {\n\t\tu64 space, d;\n\t\tu32 m;\n\n\t\tspace = sdp->sd_heightsize[x - 1] * sdp->sd_inptrs;\n\t\td = space;\n\t\tm = do_div(d, sdp->sd_inptrs);\n\n\t\tif (d != sdp->sd_heightsize[x - 1] || m)\n\t\t\tbreak;\n\t\tsdp->sd_heightsize[x] = space;\n\t}\n\tsdp->sd_max_height = x;\n\tsdp->sd_heightsize[x] = ~0;\n\tgfs2_assert(sdp, sdp->sd_max_height <= GFS2_MAX_META_HEIGHT);\n\n\tsdp->sd_jheightsize[0] = sdp->sd_sb.sb_bsize -\n\t\t\t\t sizeof(struct gfs2_dinode);\n\tsdp->sd_jheightsize[1] = sdp->sd_jbsize * sdp->sd_diptrs;\n\tfor (x = 2;; x++) {\n\t\tu64 space, d;\n\t\tu32 m;\n\n\t\tspace = sdp->sd_jheightsize[x - 1] * sdp->sd_inptrs;\n\t\td = space;\n\t\tm = do_div(d, sdp->sd_inptrs);\n\n\t\tif (d != sdp->sd_jheightsize[x - 1] || m)\n\t\t\tbreak;\n\t\tsdp->sd_jheightsize[x] = space;\n\t}\n\tsdp->sd_max_jheight = x;\n\tsdp->sd_jheightsize[x] = ~0;\n\tgfs2_assert(sdp, sdp->sd_max_jheight <= GFS2_MAX_META_HEIGHT);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_assert",
          "args": [
            "sdp",
            "sdp->sd_max_jheight <= GFS2_MAX_META_HEIGHT"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "d",
            "sdp->sd_inptrs"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_assert",
          "args": [
            "sdp",
            "sdp->sd_max_height <= GFS2_MAX_META_HEIGHT"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "d",
            "sdp->sd_inptrs"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "tmp_blocks",
            "sdp->sd_inptrs"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "sizeof(u64) * (1 << GFS2_DIR_MAX_DEPTH)",
            "sdp->sd_jbsize"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"can't read superblock\\n\""
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_read_super",
          "args": [
            "sdp",
            "GFS2_SB_ADDR >> sdp->sd_fsb2bb_shift",
            "silent"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_read_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "227-261",
          "snippet": "static int gfs2_read_super(struct gfs2_sbd *sdp, sector_t sector, int silent)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct gfs2_sb *p;\n\tstruct page *page;\n\tstruct bio *bio;\n\n\tpage = alloc_page(GFP_NOFS);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\tClearPageUptodate(page);\n\tClearPageDirty(page);\n\tlock_page(page);\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\tbio->bi_iter.bi_sector = sector * (sb->s_blocksize >> 9);\n\tbio->bi_bdev = sb->s_bdev;\n\tbio_add_page(bio, page, PAGE_SIZE, 0);\n\n\tbio->bi_end_io = end_bio_io_page;\n\tbio->bi_private = page;\n\tsubmit_bio(READ_SYNC | REQ_META, bio);\n\twait_on_page_locked(page);\n\tbio_put(bio);\n\tif (!PageUptodate(page)) {\n\t\t__free_page(page);\n\t\treturn -EIO;\n\t}\n\tp = kmap(page);\n\tgfs2_sb_in(sdp, p);\n\tkunmap(page);\n\t__free_page(page);\n\treturn gfs2_check_sb(sdp, silent);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_read_super(struct gfs2_sbd *sdp, sector_t sector, int silent)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct gfs2_sb *p;\n\tstruct page *page;\n\tstruct bio *bio;\n\n\tpage = alloc_page(GFP_NOFS);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\tClearPageUptodate(page);\n\tClearPageDirty(page);\n\tlock_page(page);\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\tbio->bi_iter.bi_sector = sector * (sb->s_blocksize >> 9);\n\tbio->bi_bdev = sb->s_bdev;\n\tbio_add_page(bio, page, PAGE_SIZE, 0);\n\n\tbio->bi_end_io = end_bio_io_page;\n\tbio->bi_private = page;\n\tsubmit_bio(READ_SYNC | REQ_META, bio);\n\twait_on_page_locked(page);\n\tbio_put(bio);\n\tif (!PageUptodate(page)) {\n\t\t__free_page(page);\n\t\treturn -EIO;\n\t}\n\tp = kmap(page);\n\tgfs2_sb_in(sdp, p);\n\tkunmap(page);\n\t__free_page(page);\n\treturn gfs2_check_sb(sdp, silent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_read_sb(struct gfs2_sbd *sdp, int silent)\n{\n\tu32 hash_blocks, ind_blocks, leaf_blocks;\n\tu32 tmp_blocks;\n\tunsigned int x;\n\tint error;\n\n\terror = gfs2_read_super(sdp, GFS2_SB_ADDR >> sdp->sd_fsb2bb_shift, silent);\n\tif (error) {\n\t\tif (!silent)\n\t\t\tfs_err(sdp, \"can't read superblock\\n\");\n\t\treturn error;\n\t}\n\n\tsdp->sd_fsb2bb_shift = sdp->sd_sb.sb_bsize_shift -\n\t\t\t       GFS2_BASIC_BLOCK_SHIFT;\n\tsdp->sd_fsb2bb = 1 << sdp->sd_fsb2bb_shift;\n\tsdp->sd_diptrs = (sdp->sd_sb.sb_bsize -\n\t\t\t  sizeof(struct gfs2_dinode)) / sizeof(u64);\n\tsdp->sd_inptrs = (sdp->sd_sb.sb_bsize -\n\t\t\t  sizeof(struct gfs2_meta_header)) / sizeof(u64);\n\tsdp->sd_jbsize = sdp->sd_sb.sb_bsize - sizeof(struct gfs2_meta_header);\n\tsdp->sd_hash_bsize = sdp->sd_sb.sb_bsize / 2;\n\tsdp->sd_hash_bsize_shift = sdp->sd_sb.sb_bsize_shift - 1;\n\tsdp->sd_hash_ptrs = sdp->sd_hash_bsize / sizeof(u64);\n\tsdp->sd_qc_per_block = (sdp->sd_sb.sb_bsize -\n\t\t\t\tsizeof(struct gfs2_meta_header)) /\n\t\t\t        sizeof(struct gfs2_quota_change);\n\tsdp->sd_blocks_per_bitmap = (sdp->sd_sb.sb_bsize -\n\t\t\t\t     sizeof(struct gfs2_meta_header))\n\t\t* GFS2_NBBY; /* not the rgrp bitmap, subsequent bitmaps only */\n\n\t/* Compute maximum reservation required to add a entry to a directory */\n\n\thash_blocks = DIV_ROUND_UP(sizeof(u64) * (1 << GFS2_DIR_MAX_DEPTH),\n\t\t\t     sdp->sd_jbsize);\n\n\tind_blocks = 0;\n\tfor (tmp_blocks = hash_blocks; tmp_blocks > sdp->sd_diptrs;) {\n\t\ttmp_blocks = DIV_ROUND_UP(tmp_blocks, sdp->sd_inptrs);\n\t\tind_blocks += tmp_blocks;\n\t}\n\n\tleaf_blocks = 2 + GFS2_DIR_MAX_DEPTH;\n\n\tsdp->sd_max_dirres = hash_blocks + ind_blocks + leaf_blocks;\n\n\tsdp->sd_heightsize[0] = sdp->sd_sb.sb_bsize -\n\t\t\t\tsizeof(struct gfs2_dinode);\n\tsdp->sd_heightsize[1] = sdp->sd_sb.sb_bsize * sdp->sd_diptrs;\n\tfor (x = 2;; x++) {\n\t\tu64 space, d;\n\t\tu32 m;\n\n\t\tspace = sdp->sd_heightsize[x - 1] * sdp->sd_inptrs;\n\t\td = space;\n\t\tm = do_div(d, sdp->sd_inptrs);\n\n\t\tif (d != sdp->sd_heightsize[x - 1] || m)\n\t\t\tbreak;\n\t\tsdp->sd_heightsize[x] = space;\n\t}\n\tsdp->sd_max_height = x;\n\tsdp->sd_heightsize[x] = ~0;\n\tgfs2_assert(sdp, sdp->sd_max_height <= GFS2_MAX_META_HEIGHT);\n\n\tsdp->sd_jheightsize[0] = sdp->sd_sb.sb_bsize -\n\t\t\t\t sizeof(struct gfs2_dinode);\n\tsdp->sd_jheightsize[1] = sdp->sd_jbsize * sdp->sd_diptrs;\n\tfor (x = 2;; x++) {\n\t\tu64 space, d;\n\t\tu32 m;\n\n\t\tspace = sdp->sd_jheightsize[x - 1] * sdp->sd_inptrs;\n\t\td = space;\n\t\tm = do_div(d, sdp->sd_inptrs);\n\n\t\tif (d != sdp->sd_jheightsize[x - 1] || m)\n\t\t\tbreak;\n\t\tsdp->sd_jheightsize[x] = space;\n\t}\n\tsdp->sd_max_jheight = x;\n\tsdp->sd_jheightsize[x] = ~0;\n\tgfs2_assert(sdp, sdp->sd_max_jheight <= GFS2_MAX_META_HEIGHT);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_read_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "227-261",
    "snippet": "static int gfs2_read_super(struct gfs2_sbd *sdp, sector_t sector, int silent)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct gfs2_sb *p;\n\tstruct page *page;\n\tstruct bio *bio;\n\n\tpage = alloc_page(GFP_NOFS);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\tClearPageUptodate(page);\n\tClearPageDirty(page);\n\tlock_page(page);\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\tbio->bi_iter.bi_sector = sector * (sb->s_blocksize >> 9);\n\tbio->bi_bdev = sb->s_bdev;\n\tbio_add_page(bio, page, PAGE_SIZE, 0);\n\n\tbio->bi_end_io = end_bio_io_page;\n\tbio->bi_private = page;\n\tsubmit_bio(READ_SYNC | REQ_META, bio);\n\twait_on_page_locked(page);\n\tbio_put(bio);\n\tif (!PageUptodate(page)) {\n\t\t__free_page(page);\n\t\treturn -EIO;\n\t}\n\tp = kmap(page);\n\tgfs2_sb_in(sdp, p);\n\tkunmap(page);\n\t__free_page(page);\n\treturn gfs2_check_sb(sdp, silent);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_check_sb",
          "args": [
            "sdp",
            "silent"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_check_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "152-172",
          "snippet": "static int gfs2_check_sb(struct gfs2_sbd *sdp, int silent)\n{\n\tstruct gfs2_sb_host *sb = &sdp->sd_sb;\n\n\tif (sb->sb_magic != GFS2_MAGIC ||\n\t    sb->sb_type != GFS2_METATYPE_SB) {\n\t\tif (!silent)\n\t\t\tpr_warn(\"not a GFS2 filesystem\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*  If format numbers match exactly, we're done.  */\n\n\tif (sb->sb_fs_format == GFS2_FORMAT_FS &&\n\t    sb->sb_multihost_format == GFS2_FORMAT_MULTI)\n\t\treturn 0;\n\n\tfs_warn(sdp, \"Unknown on-disk format, unable to mount\\n\");\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_check_sb(struct gfs2_sbd *sdp, int silent)\n{\n\tstruct gfs2_sb_host *sb = &sdp->sd_sb;\n\n\tif (sb->sb_magic != GFS2_MAGIC ||\n\t    sb->sb_type != GFS2_METATYPE_SB) {\n\t\tif (!silent)\n\t\t\tpr_warn(\"not a GFS2 filesystem\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*  If format numbers match exactly, we're done.  */\n\n\tif (sb->sb_fs_format == GFS2_FORMAT_FS &&\n\t    sb->sb_multihost_format == GFS2_FORMAT_MULTI)\n\t\treturn 0;\n\n\tfs_warn(sdp, \"Unknown on-disk format, unable to mount\\n\");\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_sb_in",
          "args": [
            "sdp",
            "p"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_sb_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "185-206",
          "snippet": "static void gfs2_sb_in(struct gfs2_sbd *sdp, const void *buf)\n{\n\tstruct gfs2_sb_host *sb = &sdp->sd_sb;\n\tstruct super_block *s = sdp->sd_vfs;\n\tconst struct gfs2_sb *str = buf;\n\n\tsb->sb_magic = be32_to_cpu(str->sb_header.mh_magic);\n\tsb->sb_type = be32_to_cpu(str->sb_header.mh_type);\n\tsb->sb_format = be32_to_cpu(str->sb_header.mh_format);\n\tsb->sb_fs_format = be32_to_cpu(str->sb_fs_format);\n\tsb->sb_multihost_format = be32_to_cpu(str->sb_multihost_format);\n\tsb->sb_bsize = be32_to_cpu(str->sb_bsize);\n\tsb->sb_bsize_shift = be32_to_cpu(str->sb_bsize_shift);\n\tsb->sb_master_dir.no_addr = be64_to_cpu(str->sb_master_dir.no_addr);\n\tsb->sb_master_dir.no_formal_ino = be64_to_cpu(str->sb_master_dir.no_formal_ino);\n\tsb->sb_root_dir.no_addr = be64_to_cpu(str->sb_root_dir.no_addr);\n\tsb->sb_root_dir.no_formal_ino = be64_to_cpu(str->sb_root_dir.no_formal_ino);\n\n\tmemcpy(sb->sb_lockproto, str->sb_lockproto, GFS2_LOCKNAME_LEN);\n\tmemcpy(sb->sb_locktable, str->sb_locktable, GFS2_LOCKNAME_LEN);\n\tmemcpy(s->s_uuid, str->sb_uuid, 16);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void gfs2_sb_in(struct gfs2_sbd *sdp, const void *buf)\n{\n\tstruct gfs2_sb_host *sb = &sdp->sd_sb;\n\tstruct super_block *s = sdp->sd_vfs;\n\tconst struct gfs2_sb *str = buf;\n\n\tsb->sb_magic = be32_to_cpu(str->sb_header.mh_magic);\n\tsb->sb_type = be32_to_cpu(str->sb_header.mh_type);\n\tsb->sb_format = be32_to_cpu(str->sb_header.mh_format);\n\tsb->sb_fs_format = be32_to_cpu(str->sb_fs_format);\n\tsb->sb_multihost_format = be32_to_cpu(str->sb_multihost_format);\n\tsb->sb_bsize = be32_to_cpu(str->sb_bsize);\n\tsb->sb_bsize_shift = be32_to_cpu(str->sb_bsize_shift);\n\tsb->sb_master_dir.no_addr = be64_to_cpu(str->sb_master_dir.no_addr);\n\tsb->sb_master_dir.no_formal_ino = be64_to_cpu(str->sb_master_dir.no_formal_ino);\n\tsb->sb_root_dir.no_addr = be64_to_cpu(str->sb_root_dir.no_addr);\n\tsb->sb_root_dir.no_formal_ino = be64_to_cpu(str->sb_root_dir.no_formal_ino);\n\n\tmemcpy(sb->sb_lockproto, str->sb_lockproto, GFS2_LOCKNAME_LEN);\n\tmemcpy(sb->sb_locktable, str->sb_locktable, GFS2_LOCKNAME_LEN);\n\tmemcpy(s->s_uuid, str->sb_uuid, 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_locked",
          "args": [
            "page"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "READ_SYNC | REQ_META",
            "bio"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-115",
          "snippet": "static struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "PAGE_SIZE",
            "0"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_NOFS",
            "1"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageDirty",
          "args": [
            "page"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_NOFS"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_read_super(struct gfs2_sbd *sdp, sector_t sector, int silent)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct gfs2_sb *p;\n\tstruct page *page;\n\tstruct bio *bio;\n\n\tpage = alloc_page(GFP_NOFS);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\tClearPageUptodate(page);\n\tClearPageDirty(page);\n\tlock_page(page);\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\tbio->bi_iter.bi_sector = sector * (sb->s_blocksize >> 9);\n\tbio->bi_bdev = sb->s_bdev;\n\tbio_add_page(bio, page, PAGE_SIZE, 0);\n\n\tbio->bi_end_io = end_bio_io_page;\n\tbio->bi_private = page;\n\tsubmit_bio(READ_SYNC | REQ_META, bio);\n\twait_on_page_locked(page);\n\tbio_put(bio);\n\tif (!PageUptodate(page)) {\n\t\t__free_page(page);\n\t\treturn -EIO;\n\t}\n\tp = kmap(page);\n\tgfs2_sb_in(sdp, p);\n\tkunmap(page);\n\t__free_page(page);\n\treturn gfs2_check_sb(sdp, silent);\n}"
  },
  {
    "function_name": "gfs2_sb_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "185-206",
    "snippet": "static void gfs2_sb_in(struct gfs2_sbd *sdp, const void *buf)\n{\n\tstruct gfs2_sb_host *sb = &sdp->sd_sb;\n\tstruct super_block *s = sdp->sd_vfs;\n\tconst struct gfs2_sb *str = buf;\n\n\tsb->sb_magic = be32_to_cpu(str->sb_header.mh_magic);\n\tsb->sb_type = be32_to_cpu(str->sb_header.mh_type);\n\tsb->sb_format = be32_to_cpu(str->sb_header.mh_format);\n\tsb->sb_fs_format = be32_to_cpu(str->sb_fs_format);\n\tsb->sb_multihost_format = be32_to_cpu(str->sb_multihost_format);\n\tsb->sb_bsize = be32_to_cpu(str->sb_bsize);\n\tsb->sb_bsize_shift = be32_to_cpu(str->sb_bsize_shift);\n\tsb->sb_master_dir.no_addr = be64_to_cpu(str->sb_master_dir.no_addr);\n\tsb->sb_master_dir.no_formal_ino = be64_to_cpu(str->sb_master_dir.no_formal_ino);\n\tsb->sb_root_dir.no_addr = be64_to_cpu(str->sb_root_dir.no_addr);\n\tsb->sb_root_dir.no_formal_ino = be64_to_cpu(str->sb_root_dir.no_formal_ino);\n\n\tmemcpy(sb->sb_lockproto, str->sb_lockproto, GFS2_LOCKNAME_LEN);\n\tmemcpy(sb->sb_locktable, str->sb_locktable, GFS2_LOCKNAME_LEN);\n\tmemcpy(s->s_uuid, str->sb_uuid, 16);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s->s_uuid",
            "str->sb_uuid",
            "16"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sb->sb_locktable",
            "str->sb_locktable",
            "GFS2_LOCKNAME_LEN"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sb->sb_lockproto",
            "str->sb_lockproto",
            "GFS2_LOCKNAME_LEN"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "str->sb_root_dir.no_formal_ino"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "str->sb_root_dir.no_addr"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "str->sb_master_dir.no_formal_ino"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "str->sb_master_dir.no_addr"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->sb_bsize_shift"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->sb_bsize"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->sb_multihost_format"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->sb_fs_format"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->sb_header.mh_format"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->sb_header.mh_type"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->sb_header.mh_magic"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void gfs2_sb_in(struct gfs2_sbd *sdp, const void *buf)\n{\n\tstruct gfs2_sb_host *sb = &sdp->sd_sb;\n\tstruct super_block *s = sdp->sd_vfs;\n\tconst struct gfs2_sb *str = buf;\n\n\tsb->sb_magic = be32_to_cpu(str->sb_header.mh_magic);\n\tsb->sb_type = be32_to_cpu(str->sb_header.mh_type);\n\tsb->sb_format = be32_to_cpu(str->sb_header.mh_format);\n\tsb->sb_fs_format = be32_to_cpu(str->sb_fs_format);\n\tsb->sb_multihost_format = be32_to_cpu(str->sb_multihost_format);\n\tsb->sb_bsize = be32_to_cpu(str->sb_bsize);\n\tsb->sb_bsize_shift = be32_to_cpu(str->sb_bsize_shift);\n\tsb->sb_master_dir.no_addr = be64_to_cpu(str->sb_master_dir.no_addr);\n\tsb->sb_master_dir.no_formal_ino = be64_to_cpu(str->sb_master_dir.no_formal_ino);\n\tsb->sb_root_dir.no_addr = be64_to_cpu(str->sb_root_dir.no_addr);\n\tsb->sb_root_dir.no_formal_ino = be64_to_cpu(str->sb_root_dir.no_formal_ino);\n\n\tmemcpy(sb->sb_lockproto, str->sb_lockproto, GFS2_LOCKNAME_LEN);\n\tmemcpy(sb->sb_locktable, str->sb_locktable, GFS2_LOCKNAME_LEN);\n\tmemcpy(s->s_uuid, str->sb_uuid, 16);\n}"
  },
  {
    "function_name": "end_bio_io_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "174-183",
    "snippet": "static void end_bio_io_page(struct bio *bio, int error)\n{\n\tstruct page *page = bio->bi_private;\n\n\tif (!error)\n\t\tSetPageUptodate(page);\n\telse\n\t\tpr_warn(\"error %d reading superblock\\n\", error);\n\tunlock_page(page);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error %d reading superblock\\n\"",
            "error"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void end_bio_io_page(struct bio *bio, int error)\n{\n\tstruct page *page = bio->bi_private;\n\n\tif (!error)\n\t\tSetPageUptodate(page);\n\telse\n\t\tpr_warn(\"error %d reading superblock\\n\", error);\n\tunlock_page(page);\n}"
  },
  {
    "function_name": "gfs2_check_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "152-172",
    "snippet": "static int gfs2_check_sb(struct gfs2_sbd *sdp, int silent)\n{\n\tstruct gfs2_sb_host *sb = &sdp->sd_sb;\n\n\tif (sb->sb_magic != GFS2_MAGIC ||\n\t    sb->sb_type != GFS2_METATYPE_SB) {\n\t\tif (!silent)\n\t\t\tpr_warn(\"not a GFS2 filesystem\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*  If format numbers match exactly, we're done.  */\n\n\tif (sb->sb_fs_format == GFS2_FORMAT_FS &&\n\t    sb->sb_multihost_format == GFS2_FORMAT_MULTI)\n\t\treturn 0;\n\n\tfs_warn(sdp, \"Unknown on-disk format, unable to mount\\n\");\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_warn",
          "args": [
            "sdp",
            "\"Unknown on-disk format, unable to mount\\n\""
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "befs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "40-51",
          "snippet": "void\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"not a GFS2 filesystem\\n\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_check_sb(struct gfs2_sbd *sdp, int silent)\n{\n\tstruct gfs2_sb_host *sb = &sdp->sd_sb;\n\n\tif (sb->sb_magic != GFS2_MAGIC ||\n\t    sb->sb_type != GFS2_METATYPE_SB) {\n\t\tif (!silent)\n\t\t\tpr_warn(\"not a GFS2 filesystem\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*  If format numbers match exactly, we're done.  */\n\n\tif (sb->sb_fs_format == GFS2_FORMAT_FS &&\n\t    sb->sb_multihost_format == GFS2_FORMAT_MULTI)\n\t\treturn 0;\n\n\tfs_warn(sdp, \"Unknown on-disk format, unable to mount\\n\");\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "init_sbd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "65-138",
    "snippet": "static struct gfs2_sbd *init_sbd(struct super_block *sb)\n{\n\tstruct gfs2_sbd *sdp;\n\tstruct address_space *mapping;\n\n\tsdp = kzalloc(sizeof(struct gfs2_sbd), GFP_KERNEL);\n\tif (!sdp)\n\t\treturn NULL;\n\n\tsb->s_fs_info = sdp;\n\tsdp->sd_vfs = sb;\n\tsdp->sd_lkstats = alloc_percpu(struct gfs2_pcpu_lkstats);\n\tif (!sdp->sd_lkstats) {\n\t\tkfree(sdp);\n\t\treturn NULL;\n\t}\n\n\tset_bit(SDF_NOJOURNALID, &sdp->sd_flags);\n\tgfs2_tune_init(&sdp->sd_tune);\n\n\tinit_waitqueue_head(&sdp->sd_glock_wait);\n\tatomic_set(&sdp->sd_glock_disposal, 0);\n\tinit_completion(&sdp->sd_locking_init);\n\tinit_completion(&sdp->sd_wdack);\n\tspin_lock_init(&sdp->sd_statfs_spin);\n\n\tspin_lock_init(&sdp->sd_rindex_spin);\n\tsdp->sd_rindex_tree.rb_node = NULL;\n\n\tINIT_LIST_HEAD(&sdp->sd_jindex_list);\n\tspin_lock_init(&sdp->sd_jindex_spin);\n\tmutex_init(&sdp->sd_jindex_mutex);\n\tinit_completion(&sdp->sd_journal_ready);\n\n\tINIT_LIST_HEAD(&sdp->sd_quota_list);\n\tmutex_init(&sdp->sd_quota_mutex);\n\tmutex_init(&sdp->sd_quota_sync_mutex);\n\tinit_waitqueue_head(&sdp->sd_quota_wait);\n\tINIT_LIST_HEAD(&sdp->sd_trunc_list);\n\tspin_lock_init(&sdp->sd_trunc_lock);\n\tspin_lock_init(&sdp->sd_bitmap_lock);\n\n\tmapping = &sdp->sd_aspace;\n\n\taddress_space_init_once(mapping);\n\tmapping->a_ops = &gfs2_rgrp_aops;\n\tmapping->host = sb->s_bdev->bd_inode;\n\tmapping->flags = 0;\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\n\tspin_lock_init(&sdp->sd_log_lock);\n\tatomic_set(&sdp->sd_log_pinned, 0);\n\tINIT_LIST_HEAD(&sdp->sd_log_le_revoke);\n\tINIT_LIST_HEAD(&sdp->sd_log_le_ordered);\n\tspin_lock_init(&sdp->sd_ordered_lock);\n\n\tinit_waitqueue_head(&sdp->sd_log_waitq);\n\tinit_waitqueue_head(&sdp->sd_logd_waitq);\n\tspin_lock_init(&sdp->sd_ail_lock);\n\tINIT_LIST_HEAD(&sdp->sd_ail1_list);\n\tINIT_LIST_HEAD(&sdp->sd_ail2_list);\n\n\tinit_rwsem(&sdp->sd_log_flush_lock);\n\tatomic_set(&sdp->sd_log_in_flight, 0);\n\tatomic_set(&sdp->sd_reserving_log, 0);\n\tinit_waitqueue_head(&sdp->sd_reserving_log_wait);\n\tinit_waitqueue_head(&sdp->sd_log_flush_wait);\n\tatomic_set(&sdp->sd_freeze_state, SFS_UNFROZEN);\n\tmutex_init(&sdp->sd_freeze_mutex);\n\n\treturn sdp;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sdp->sd_freeze_mutex"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sdp->sd_freeze_state",
            "SFS_UNFROZEN"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&sdp->sd_log_flush_wait"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&sdp->sd_reserving_log_wait"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sdp->sd_reserving_log",
            "0"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sdp->sd_log_in_flight",
            "0"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&sdp->sd_log_flush_lock"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sdp->sd_ail2_list"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sdp->sd_ail1_list"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sdp->sd_ail_lock"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&sdp->sd_logd_waitq"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&sdp->sd_log_waitq"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sdp->sd_ordered_lock"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sdp->sd_log_le_ordered"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sdp->sd_log_le_revoke"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sdp->sd_log_pinned",
            "0"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sdp->sd_log_lock"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "mapping",
            "GFP_NOFS"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "address_space_init_once",
          "args": [
            "mapping"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "address_space_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "338-347",
          "snippet": "void address_space_init_once(struct address_space *mapping)\n{\n\tmemset(mapping, 0, sizeof(*mapping));\n\tINIT_RADIX_TREE(&mapping->page_tree, GFP_ATOMIC);\n\tspin_lock_init(&mapping->tree_lock);\n\tinit_rwsem(&mapping->i_mmap_rwsem);\n\tINIT_LIST_HEAD(&mapping->private_list);\n\tspin_lock_init(&mapping->private_lock);\n\tmapping->i_mmap = RB_ROOT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid address_space_init_once(struct address_space *mapping)\n{\n\tmemset(mapping, 0, sizeof(*mapping));\n\tINIT_RADIX_TREE(&mapping->page_tree, GFP_ATOMIC);\n\tspin_lock_init(&mapping->tree_lock);\n\tinit_rwsem(&mapping->i_mmap_rwsem);\n\tINIT_LIST_HEAD(&mapping->private_list);\n\tspin_lock_init(&mapping->private_lock);\n\tmapping->i_mmap = RB_ROOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sdp->sd_bitmap_lock"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sdp->sd_trunc_lock"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sdp->sd_trunc_list"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&sdp->sd_quota_wait"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sdp->sd_quota_sync_mutex"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sdp->sd_quota_mutex"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sdp->sd_quota_list"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&sdp->sd_journal_ready"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sdp->sd_jindex_mutex"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sdp->sd_jindex_spin"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sdp->sd_jindex_list"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sdp->sd_rindex_spin"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sdp->sd_statfs_spin"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&sdp->sd_wdack"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&sdp->sd_locking_init"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sdp->sd_glock_disposal",
            "0"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&sdp->sd_glock_wait"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_tune_init",
          "args": [
            "&sdp->sd_tune"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_tune_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
          "lines": "53-63",
          "snippet": "static void gfs2_tune_init(struct gfs2_tune *gt)\n{\n\tspin_lock_init(&gt->gt_spin);\n\n\tgt->gt_quota_warn_period = 10;\n\tgt->gt_quota_scale_num = 1;\n\tgt->gt_quota_scale_den = 1;\n\tgt->gt_new_files_jdata = 0;\n\tgt->gt_max_readahead = 1 << 18;\n\tgt->gt_complain_secs = 10;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"meta_io.h\"",
            "#include \"dir.h\"",
            "#include \"quota.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"sys.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/module.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void gfs2_tune_init(struct gfs2_tune *gt)\n{\n\tspin_lock_init(&gt->gt_spin);\n\n\tgt->gt_quota_warn_period = 10;\n\tgt->gt_quota_scale_num = 1;\n\tgt->gt_quota_scale_den = 1;\n\tgt->gt_new_files_jdata = 0;\n\tgt->gt_max_readahead = 1 << 18;\n\tgt->gt_complain_secs = 10;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "SDF_NOJOURNALID",
            "&sdp->sd_flags"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sdp"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structgfs2_pcpu_lkstats"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct gfs2_sbd)",
            "GFP_KERNEL"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct gfs2_sbd *init_sbd(struct super_block *sb)\n{\n\tstruct gfs2_sbd *sdp;\n\tstruct address_space *mapping;\n\n\tsdp = kzalloc(sizeof(struct gfs2_sbd), GFP_KERNEL);\n\tif (!sdp)\n\t\treturn NULL;\n\n\tsb->s_fs_info = sdp;\n\tsdp->sd_vfs = sb;\n\tsdp->sd_lkstats = alloc_percpu(struct gfs2_pcpu_lkstats);\n\tif (!sdp->sd_lkstats) {\n\t\tkfree(sdp);\n\t\treturn NULL;\n\t}\n\n\tset_bit(SDF_NOJOURNALID, &sdp->sd_flags);\n\tgfs2_tune_init(&sdp->sd_tune);\n\n\tinit_waitqueue_head(&sdp->sd_glock_wait);\n\tatomic_set(&sdp->sd_glock_disposal, 0);\n\tinit_completion(&sdp->sd_locking_init);\n\tinit_completion(&sdp->sd_wdack);\n\tspin_lock_init(&sdp->sd_statfs_spin);\n\n\tspin_lock_init(&sdp->sd_rindex_spin);\n\tsdp->sd_rindex_tree.rb_node = NULL;\n\n\tINIT_LIST_HEAD(&sdp->sd_jindex_list);\n\tspin_lock_init(&sdp->sd_jindex_spin);\n\tmutex_init(&sdp->sd_jindex_mutex);\n\tinit_completion(&sdp->sd_journal_ready);\n\n\tINIT_LIST_HEAD(&sdp->sd_quota_list);\n\tmutex_init(&sdp->sd_quota_mutex);\n\tmutex_init(&sdp->sd_quota_sync_mutex);\n\tinit_waitqueue_head(&sdp->sd_quota_wait);\n\tINIT_LIST_HEAD(&sdp->sd_trunc_list);\n\tspin_lock_init(&sdp->sd_trunc_lock);\n\tspin_lock_init(&sdp->sd_bitmap_lock);\n\n\tmapping = &sdp->sd_aspace;\n\n\taddress_space_init_once(mapping);\n\tmapping->a_ops = &gfs2_rgrp_aops;\n\tmapping->host = sb->s_bdev->bd_inode;\n\tmapping->flags = 0;\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\n\tspin_lock_init(&sdp->sd_log_lock);\n\tatomic_set(&sdp->sd_log_pinned, 0);\n\tINIT_LIST_HEAD(&sdp->sd_log_le_revoke);\n\tINIT_LIST_HEAD(&sdp->sd_log_le_ordered);\n\tspin_lock_init(&sdp->sd_ordered_lock);\n\n\tinit_waitqueue_head(&sdp->sd_log_waitq);\n\tinit_waitqueue_head(&sdp->sd_logd_waitq);\n\tspin_lock_init(&sdp->sd_ail_lock);\n\tINIT_LIST_HEAD(&sdp->sd_ail1_list);\n\tINIT_LIST_HEAD(&sdp->sd_ail2_list);\n\n\tinit_rwsem(&sdp->sd_log_flush_lock);\n\tatomic_set(&sdp->sd_log_in_flight, 0);\n\tatomic_set(&sdp->sd_reserving_log, 0);\n\tinit_waitqueue_head(&sdp->sd_reserving_log_wait);\n\tinit_waitqueue_head(&sdp->sd_log_flush_wait);\n\tatomic_set(&sdp->sd_freeze_state, SFS_UNFROZEN);\n\tmutex_init(&sdp->sd_freeze_mutex);\n\n\treturn sdp;\n}"
  },
  {
    "function_name": "gfs2_tune_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/ops_fstype.c",
    "lines": "53-63",
    "snippet": "static void gfs2_tune_init(struct gfs2_tune *gt)\n{\n\tspin_lock_init(&gt->gt_spin);\n\n\tgt->gt_quota_warn_period = 10;\n\tgt->gt_quota_scale_num = 1;\n\tgt->gt_quota_scale_den = 1;\n\tgt->gt_new_files_jdata = 0;\n\tgt->gt_max_readahead = 1 << 18;\n\tgt->gt_complain_secs = 10;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"meta_io.h\"",
      "#include \"dir.h\"",
      "#include \"quota.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"sys.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/module.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&gt->gt_spin"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"meta_io.h\"\n#include \"dir.h\"\n#include \"quota.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/module.h>\n#include <linux/lockdep.h>\n#include <linux/quotaops.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void gfs2_tune_init(struct gfs2_tune *gt)\n{\n\tspin_lock_init(&gt->gt_spin);\n\n\tgt->gt_quota_warn_period = 10;\n\tgt->gt_quota_scale_num = 1;\n\tgt->gt_quota_scale_den = 1;\n\tgt->gt_new_files_jdata = 0;\n\tgt->gt_max_readahead = 1 << 18;\n\tgt->gt_complain_secs = 10;\n}"
  }
]