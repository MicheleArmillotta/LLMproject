[
  {
    "function_name": "afs_volume_release_fileserver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
    "lines": "306-401",
    "snippet": "int afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" [try next server]\""
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "server"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&volume->server_sem"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&server->fs_lock"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"kAFS: SERVER DEAD state=%d\\n\"",
            "result"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&server->fs_lock"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&volume->server_sem"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&volume->servers[loop]",
            "&volume->servers[loop + 1]",
            "sizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&volume->server_sem"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s,%08x,%d\"",
            "volume->vlocation->vldb.name",
            "ntohl(server->addr.s_addr)",
            "result"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "server->addr.s_addr"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_volume_release_fileserver(struct afs_vnode *vnode,\n\t\t\t\t  struct afs_server *server,\n\t\t\t\t  int result)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tunsigned loop;\n\n\t_enter(\"%s,%08x,%d\",\n\t       volume->vlocation->vldb.name, ntohl(server->addr.s_addr),\n\t       result);\n\n\tswitch (result) {\n\t\t/* success */\n\tcase 0:\n\t\tserver->fs_act_jif = jiffies;\n\t\tserver->fs_state = 0;\n\t\t_leave(\"\");\n\t\treturn 1;\n\n\t\t/* the fileserver denied all knowledge of the volume */\n\tcase -ENOMEDIUM:\n\t\tserver->fs_act_jif = jiffies;\n\t\tdown_write(&volume->server_sem);\n\n\t\t/* firstly, find where the server is in the active list (if it\n\t\t * is) */\n\t\tfor (loop = 0; loop < volume->nservers; loop++)\n\t\t\tif (volume->servers[loop] == server)\n\t\t\t\tgoto present;\n\n\t\t/* no longer there - may have been discarded by another op */\n\t\tgoto try_next_server_upw;\n\n\tpresent:\n\t\tvolume->nservers--;\n\t\tmemmove(&volume->servers[loop],\n\t\t\t&volume->servers[loop + 1],\n\t\t\tsizeof(volume->servers[loop]) *\n\t\t\t(volume->nservers - loop));\n\t\tvolume->servers[volume->nservers] = NULL;\n\t\tafs_put_server(server);\n\t\tvolume->rjservers++;\n\n\t\tif (volume->nservers > 0)\n\t\t\t/* another server might acknowledge its existence */\n\t\t\tgoto try_next_server_upw;\n\n\t\t/* handle the case where all the fileservers have rejected the\n\t\t * volume\n\t\t * - TODO: try asking the fileservers for volume information\n\t\t * - TODO: contact the VL server again to see if the volume is\n\t\t *         no longer registered\n\t\t */\n\t\tup_write(&volume->server_sem);\n\t\tafs_put_server(server);\n\t\t_leave(\" [completely rejected]\");\n\t\treturn 1;\n\n\t\t/* problem reaching the server */\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -ECONNREFUSED:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\tcase -EREMOTEIO:\n\t\t/* mark the server as dead\n\t\t * TODO: vary dead timeout depending on error\n\t\t */\n\t\tspin_lock(&server->fs_lock);\n\t\tif (!server->fs_state) {\n\t\t\tserver->fs_dead_jif = jiffies + HZ * 10;\n\t\t\tserver->fs_state = result;\n\t\t\tprintk(\"kAFS: SERVER DEAD state=%d\\n\", result);\n\t\t}\n\t\tspin_unlock(&server->fs_lock);\n\t\tgoto try_next_server;\n\n\t\t/* miscellaneous error */\n\tdefault:\n\t\tserver->fs_act_jif = jiffies;\n\tcase -ENOMEM:\n\tcase -ENONET:\n\t\t/* tell the caller to accept the result */\n\t\tafs_put_server(server);\n\t\t_leave(\" [local failure]\");\n\t\treturn 1;\n\t}\n\n\t/* tell the caller to loop around and try the next server */\ntry_next_server_upw:\n\tup_write(&volume->server_sem);\ntry_next_server:\n\tafs_put_server(server);\n\t_leave(\" [try next server]\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_volume_pick_fileserver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
    "lines": "219-297",
    "snippet": "struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&volume->server_sem"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %p (picked %08x)\"",
            "server",
            "ntohl(server->addr.s_addr)"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "are_leaves_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "698-757",
          "snippet": "static int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "server->addr.s_addr"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&volume->server_sem"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_get_server",
          "args": [
            "server"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"consider %d [%d]\"",
            "loop",
            "state"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&volume->server_sem"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&volume->server_sem"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_get_server",
          "args": [
            "vnode->server"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%s\"",
            "volume->vlocation->vldb.name"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct afs_server *afs_volume_pick_fileserver(struct afs_vnode *vnode)\n{\n\tstruct afs_volume *volume = vnode->volume;\n\tstruct afs_server *server;\n\tint ret, state, loop;\n\n\t_enter(\"%s\", volume->vlocation->vldb.name);\n\n\t/* stick with the server we're already using if we can */\n\tif (vnode->server && vnode->server->fs_state == 0) {\n\t\tafs_get_server(vnode->server);\n\t\t_leave(\" = %p [current]\", vnode->server);\n\t\treturn vnode->server;\n\t}\n\n\tdown_read(&volume->server_sem);\n\n\t/* handle the no-server case */\n\tif (volume->nservers == 0) {\n\t\tret = volume->rjservers ? -ENOMEDIUM : -ESTALE;\n\t\tup_read(&volume->server_sem);\n\t\t_leave(\" = %d [no servers]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* basically, just search the list for the first live server and use\n\t * that */\n\tret = 0;\n\tfor (loop = 0; loop < volume->nservers; loop++) {\n\t\tserver = volume->servers[loop];\n\t\tstate = server->fs_state;\n\n\t\t_debug(\"consider %d [%d]\", loop, state);\n\n\t\tswitch (state) {\n\t\t\t/* found an apparently healthy server */\n\t\tcase 0:\n\t\t\tafs_get_server(server);\n\t\t\tup_read(&volume->server_sem);\n\t\t\t_leave(\" = %p (picked %08x)\",\n\t\t\t       server, ntohl(server->addr.s_addr));\n\t\t\treturn server;\n\n\t\tcase -ENETUNREACH:\n\t\t\tif (ret == 0)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -EHOSTUNREACH:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tcase -ECONNREFUSED:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase -EREMOTEIO:\n\t\t\tif (ret == 0 ||\n\t\t\t    ret == -ENETUNREACH ||\n\t\t\t    ret == -EHOSTUNREACH ||\n\t\t\t    ret == -ECONNREFUSED)\n\t\t\t\tret = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no available servers\n\t * - TODO: handle the no active servers case better\n\t */\n\tup_read(&volume->server_sem);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "afs_put_volume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
    "lines": "172-213",
    "snippet": "void afs_put_volume(struct afs_volume *volume)\n{\n\tstruct afs_vlocation *vlocation;\n\tint loop;\n\n\tif (!volume)\n\t\treturn;\n\n\t_enter(\"%p\", volume);\n\n\tASSERTCMP(atomic_read(&volume->usage), >, 0);\n\n\tvlocation = volume->vlocation;\n\n\t/* to prevent a race, the decrement and the dequeue must be effectively\n\t * atomic */\n\tdown_write(&vlocation->cell->vl_sem);\n\n\tif (likely(!atomic_dec_and_test(&volume->usage))) {\n\t\tup_write(&vlocation->cell->vl_sem);\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tvlocation->vols[volume->type] = NULL;\n\n\tup_write(&vlocation->cell->vl_sem);\n\n\t/* finish cleaning up the volume */\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(volume->cache, 0);\n#endif\n\tafs_put_vlocation(vlocation);\n\n\tfor (loop = volume->nservers - 1; loop >= 0; loop--)\n\t\tafs_put_server(volume->servers[loop]);\n\n\tbdi_destroy(&volume->bdi);\n\tkfree(volume);\n\n\t_leave(\" [destroyed]\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" [destroyed]\""
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "volume"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_destroy",
          "args": [
            "&volume->bdi"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bdi_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "372-376",
          "snippet": "static void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "volume->servers[loop]"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_vlocation",
          "args": [
            "vlocation"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_vlocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
          "lines": "491-522",
          "snippet": "void afs_put_vlocation(struct afs_vlocation *vl)\n{\n\tif (!vl)\n\t\treturn;\n\n\t_enter(\"%s\", vl->vldb.name);\n\n\tASSERTCMP(atomic_read(&vl->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&vl->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tspin_lock(&afs_vlocation_graveyard_lock);\n\tif (atomic_read(&vl->usage) == 0) {\n\t\t_debug(\"buried\");\n\t\tlist_move_tail(&vl->grave, &afs_vlocation_graveyard);\n\t\tvl->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_vlocation_reap,\n\t\t\t\t   afs_vlocation_timeout * HZ);\n\n\t\t/* suspend updates on this record */\n\t\tif (!list_empty(&vl->update)) {\n\t\t\tspin_lock(&afs_vlocation_updates_lock);\n\t\t\tlist_del_init(&vl->update);\n\t\t\tspin_unlock(&afs_vlocation_updates_lock);\n\t\t}\n\t}\n\tspin_unlock(&afs_vlocation_graveyard_lock);\n\t_leave(\" [killed?]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_vlocation_timeout = 10;",
            "static LIST_HEAD(afs_vlocation_graveyard);",
            "static DEFINE_SPINLOCK(afs_vlocation_updates_lock);",
            "static DEFINE_SPINLOCK(afs_vlocation_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic unsigned afs_vlocation_timeout = 10;\nstatic LIST_HEAD(afs_vlocation_graveyard);\nstatic DEFINE_SPINLOCK(afs_vlocation_updates_lock);\nstatic DEFINE_SPINLOCK(afs_vlocation_graveyard_lock);\n\nvoid afs_put_vlocation(struct afs_vlocation *vl)\n{\n\tif (!vl)\n\t\treturn;\n\n\t_enter(\"%s\", vl->vldb.name);\n\n\tASSERTCMP(atomic_read(&vl->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&vl->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tspin_lock(&afs_vlocation_graveyard_lock);\n\tif (atomic_read(&vl->usage) == 0) {\n\t\t_debug(\"buried\");\n\t\tlist_move_tail(&vl->grave, &afs_vlocation_graveyard);\n\t\tvl->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_vlocation_reap,\n\t\t\t\t   afs_vlocation_timeout * HZ);\n\n\t\t/* suspend updates on this record */\n\t\tif (!list_empty(&vl->update)) {\n\t\t\tspin_lock(&afs_vlocation_updates_lock);\n\t\t\tlist_del_init(&vl->update);\n\t\t\tspin_unlock(&afs_vlocation_updates_lock);\n\t\t}\n\t}\n\tspin_unlock(&afs_vlocation_graveyard_lock);\n\t_leave(\" [killed?]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_relinquish_cookie",
          "args": [
            "volume->cache",
            "0"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_relinquish_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "581-618",
          "snippet": "void __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vlocation->cell->vl_sem"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vlocation->cell->vl_sem"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!atomic_dec_and_test(&volume->usage)"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&volume->usage"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&vlocation->cell->vl_sem"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "atomic_read(&volume->usage)",
            ">,0"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&volume->usage"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p\"",
            "volume"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_put_volume(struct afs_volume *volume)\n{\n\tstruct afs_vlocation *vlocation;\n\tint loop;\n\n\tif (!volume)\n\t\treturn;\n\n\t_enter(\"%p\", volume);\n\n\tASSERTCMP(atomic_read(&volume->usage), >, 0);\n\n\tvlocation = volume->vlocation;\n\n\t/* to prevent a race, the decrement and the dequeue must be effectively\n\t * atomic */\n\tdown_write(&vlocation->cell->vl_sem);\n\n\tif (likely(!atomic_dec_and_test(&volume->usage))) {\n\t\tup_write(&vlocation->cell->vl_sem);\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tvlocation->vols[volume->type] = NULL;\n\n\tup_write(&vlocation->cell->vl_sem);\n\n\t/* finish cleaning up the volume */\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(volume->cache, 0);\n#endif\n\tafs_put_vlocation(vlocation);\n\n\tfor (loop = volume->nservers - 1; loop >= 0; loop--)\n\t\tafs_put_server(volume->servers[loop]);\n\n\tbdi_destroy(&volume->bdi);\n\tkfree(volume);\n\n\t_leave(\" [destroyed]\");\n}"
  },
  {
    "function_name": "afs_volume_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/volume.c",
    "lines": "45-167",
    "snippet": "struct afs_volume *afs_volume_lookup(struct afs_mount_params *params)\n{\n\tstruct afs_vlocation *vlocation = NULL;\n\tstruct afs_volume *volume = NULL;\n\tstruct afs_server *server = NULL;\n\tchar srvtmask;\n\tint ret, loop;\n\n\t_enter(\"{%*.*s,%d}\",\n\t       params->volnamesz, params->volnamesz, params->volname, params->rwpath);\n\n\t/* lookup the volume location record */\n\tvlocation = afs_vlocation_lookup(params->cell, params->key,\n\t\t\t\t\t params->volname, params->volnamesz);\n\tif (IS_ERR(vlocation)) {\n\t\tret = PTR_ERR(vlocation);\n\t\tvlocation = NULL;\n\t\tgoto error;\n\t}\n\n\t/* make the final decision on the type we want */\n\tret = -ENOMEDIUM;\n\tif (params->force && !(vlocation->vldb.vidmask & (1 << params->type)))\n\t\tgoto error;\n\n\tsrvtmask = 0;\n\tfor (loop = 0; loop < vlocation->vldb.nservers; loop++)\n\t\tsrvtmask |= vlocation->vldb.srvtmask[loop];\n\n\tif (params->force) {\n\t\tif (!(srvtmask & (1 << params->type)))\n\t\t\tgoto error;\n\t} else if (srvtmask & AFS_VOL_VTM_RO) {\n\t\tparams->type = AFSVL_ROVOL;\n\t} else if (srvtmask & AFS_VOL_VTM_RW) {\n\t\tparams->type = AFSVL_RWVOL;\n\t} else {\n\t\tgoto error;\n\t}\n\n\tdown_write(&params->cell->vl_sem);\n\n\t/* is the volume already active? */\n\tif (vlocation->vols[params->type]) {\n\t\t/* yes - re-use it */\n\t\tvolume = vlocation->vols[params->type];\n\t\tafs_get_volume(volume);\n\t\tgoto success;\n\t}\n\n\t/* create a new volume record */\n\t_debug(\"creating new volume record\");\n\n\tret = -ENOMEM;\n\tvolume = kzalloc(sizeof(struct afs_volume), GFP_KERNEL);\n\tif (!volume)\n\t\tgoto error_up;\n\n\tatomic_set(&volume->usage, 1);\n\tvolume->type\t\t= params->type;\n\tvolume->type_force\t= params->force;\n\tvolume->cell\t\t= params->cell;\n\tvolume->vid\t\t= vlocation->vldb.vid[params->type];\n\n\tret = bdi_setup_and_register(&volume->bdi, \"afs\");\n\tif (ret)\n\t\tgoto error_bdi;\n\n\tinit_rwsem(&volume->server_sem);\n\n\t/* look up all the applicable server records */\n\tfor (loop = 0; loop < 8; loop++) {\n\t\tif (vlocation->vldb.srvtmask[loop] & (1 << volume->type)) {\n\t\t\tserver = afs_lookup_server(\n\t\t\t       volume->cell, &vlocation->vldb.servers[loop]);\n\t\t\tif (IS_ERR(server)) {\n\t\t\t\tret = PTR_ERR(server);\n\t\t\t\tgoto error_discard;\n\t\t\t}\n\n\t\t\tvolume->servers[volume->nservers] = server;\n\t\t\tvolume->nservers++;\n\t\t}\n\t}\n\n\t/* attach the cache and volume location */\n#ifdef CONFIG_AFS_FSCACHE\n\tvolume->cache = fscache_acquire_cookie(vlocation->cache,\n\t\t\t\t\t       &afs_volume_cache_index_def,\n\t\t\t\t\t       volume, true);\n#endif\n\tafs_get_vlocation(vlocation);\n\tvolume->vlocation = vlocation;\n\n\tvlocation->vols[volume->type] = volume;\n\nsuccess:\n\t_debug(\"kAFS selected %s volume %08x\",\n\t       afs_voltypes[volume->type], volume->vid);\n\tup_write(&params->cell->vl_sem);\n\tafs_put_vlocation(vlocation);\n\t_leave(\" = %p\", volume);\n\treturn volume;\n\n\t/* clean up */\nerror_up:\n\tup_write(&params->cell->vl_sem);\nerror:\n\tafs_put_vlocation(vlocation);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n\nerror_discard:\n\tbdi_destroy(&volume->bdi);\nerror_bdi:\n\tup_write(&params->cell->vl_sem);\n\n\tfor (loop = volume->nservers - 1; loop >= 0; loop--)\n\t\tafs_put_server(volume->servers[loop]);\n\n\tkfree(volume);\n\tgoto error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *afs_voltypes[] = { \"R/W\", \"R/O\", \"BAK\" };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "volume"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "volume->servers[loop]"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&params->cell->vl_sem"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_destroy",
          "args": [
            "&volume->bdi"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bdi_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "372-376",
          "snippet": "static void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_vlocation",
          "args": [
            "vlocation"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_vlocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
          "lines": "491-522",
          "snippet": "void afs_put_vlocation(struct afs_vlocation *vl)\n{\n\tif (!vl)\n\t\treturn;\n\n\t_enter(\"%s\", vl->vldb.name);\n\n\tASSERTCMP(atomic_read(&vl->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&vl->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tspin_lock(&afs_vlocation_graveyard_lock);\n\tif (atomic_read(&vl->usage) == 0) {\n\t\t_debug(\"buried\");\n\t\tlist_move_tail(&vl->grave, &afs_vlocation_graveyard);\n\t\tvl->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_vlocation_reap,\n\t\t\t\t   afs_vlocation_timeout * HZ);\n\n\t\t/* suspend updates on this record */\n\t\tif (!list_empty(&vl->update)) {\n\t\t\tspin_lock(&afs_vlocation_updates_lock);\n\t\t\tlist_del_init(&vl->update);\n\t\t\tspin_unlock(&afs_vlocation_updates_lock);\n\t\t}\n\t}\n\tspin_unlock(&afs_vlocation_graveyard_lock);\n\t_leave(\" [killed?]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_vlocation_timeout = 10;",
            "static LIST_HEAD(afs_vlocation_graveyard);",
            "static DEFINE_SPINLOCK(afs_vlocation_updates_lock);",
            "static DEFINE_SPINLOCK(afs_vlocation_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic unsigned afs_vlocation_timeout = 10;\nstatic LIST_HEAD(afs_vlocation_graveyard);\nstatic DEFINE_SPINLOCK(afs_vlocation_updates_lock);\nstatic DEFINE_SPINLOCK(afs_vlocation_graveyard_lock);\n\nvoid afs_put_vlocation(struct afs_vlocation *vl)\n{\n\tif (!vl)\n\t\treturn;\n\n\t_enter(\"%s\", vl->vldb.name);\n\n\tASSERTCMP(atomic_read(&vl->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&vl->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tspin_lock(&afs_vlocation_graveyard_lock);\n\tif (atomic_read(&vl->usage) == 0) {\n\t\t_debug(\"buried\");\n\t\tlist_move_tail(&vl->grave, &afs_vlocation_graveyard);\n\t\tvl->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_vlocation_reap,\n\t\t\t\t   afs_vlocation_timeout * HZ);\n\n\t\t/* suspend updates on this record */\n\t\tif (!list_empty(&vl->update)) {\n\t\t\tspin_lock(&afs_vlocation_updates_lock);\n\t\t\tlist_del_init(&vl->update);\n\t\t\tspin_unlock(&afs_vlocation_updates_lock);\n\t\t}\n\t}\n\tspin_unlock(&afs_vlocation_graveyard_lock);\n\t_leave(\" [killed?]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&params->cell->vl_sem"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&params->cell->vl_sem"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"kAFS selected %s volume %08x\"",
            "afs_voltypes[volume->type]",
            "volume->vid"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_get_vlocation",
          "args": [
            "vlocation"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_acquire_cookie",
          "args": [
            "vlocation->cache",
            "&afs_volume_cache_index_def",
            "volume",
            "true"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_acquire_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "58-150",
          "snippet": "struct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *fscache_cookie_jar;",
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct kmem_cache *fscache_cookie_jar;\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstruct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "server"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_lookup_server",
          "args": [
            "volume->cell",
            "&vlocation->vldb.servers[loop]"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "afs_lookup_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "104-176",
          "snippet": "struct afs_server *afs_lookup_server(struct afs_cell *cell,\n\t\t\t\t     const struct in_addr *addr)\n{\n\tstruct afs_server *server, *candidate;\n\n\t_enter(\"%p,%pI4\", cell, &addr->s_addr);\n\n\t/* quick scan of the list to see if we already have the server */\n\tread_lock(&cell->servers_lock);\n\n\tlist_for_each_entry(server, &cell->servers, link) {\n\t\tif (server->addr.s_addr == addr->s_addr)\n\t\t\tgoto found_server_quickly;\n\t}\n\tread_unlock(&cell->servers_lock);\n\n\tcandidate = afs_alloc_server(cell, addr);\n\tif (!candidate) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\twrite_lock(&cell->servers_lock);\n\n\t/* check the cell's server list again */\n\tlist_for_each_entry(server, &cell->servers, link) {\n\t\tif (server->addr.s_addr == addr->s_addr)\n\t\t\tgoto found_server;\n\t}\n\n\t_debug(\"new\");\n\tserver = candidate;\n\tif (afs_install_server(server) < 0)\n\t\tgoto server_in_two_cells;\n\n\tafs_get_cell(cell);\n\tlist_add_tail(&server->link, &cell->servers);\n\n\twrite_unlock(&cell->servers_lock);\n\t_leave(\" = %p{%d}\", server, atomic_read(&server->usage));\n\treturn server;\n\n\t/* found a matching server quickly */\nfound_server_quickly:\n\t_debug(\"found quickly\");\n\tafs_get_server(server);\n\tread_unlock(&cell->servers_lock);\nno_longer_unused:\n\tif (!list_empty(&server->grave)) {\n\t\tspin_lock(&afs_server_graveyard_lock);\n\t\tlist_del_init(&server->grave);\n\t\tspin_unlock(&afs_server_graveyard_lock);\n\t}\n\t_leave(\" = %p{%d}\", server, atomic_read(&server->usage));\n\treturn server;\n\n\t/* found a matching server on the second pass */\nfound_server:\n\t_debug(\"found\");\n\tafs_get_server(server);\n\twrite_unlock(&cell->servers_lock);\n\tkfree(candidate);\n\tgoto no_longer_unused;\n\n\t/* found a server that seems to be in two cells */\nserver_in_two_cells:\n\twrite_unlock(&cell->servers_lock);\n\tkfree(candidate);\n\tprintk(KERN_NOTICE \"kAFS: Server %pI4 appears to be in two cells\\n\",\n\t       addr);\n\t_leave(\" = -EEXIST\");\n\treturn ERR_PTR(-EEXIST);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nstruct afs_server *afs_lookup_server(struct afs_cell *cell,\n\t\t\t\t     const struct in_addr *addr)\n{\n\tstruct afs_server *server, *candidate;\n\n\t_enter(\"%p,%pI4\", cell, &addr->s_addr);\n\n\t/* quick scan of the list to see if we already have the server */\n\tread_lock(&cell->servers_lock);\n\n\tlist_for_each_entry(server, &cell->servers, link) {\n\t\tif (server->addr.s_addr == addr->s_addr)\n\t\t\tgoto found_server_quickly;\n\t}\n\tread_unlock(&cell->servers_lock);\n\n\tcandidate = afs_alloc_server(cell, addr);\n\tif (!candidate) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\twrite_lock(&cell->servers_lock);\n\n\t/* check the cell's server list again */\n\tlist_for_each_entry(server, &cell->servers, link) {\n\t\tif (server->addr.s_addr == addr->s_addr)\n\t\t\tgoto found_server;\n\t}\n\n\t_debug(\"new\");\n\tserver = candidate;\n\tif (afs_install_server(server) < 0)\n\t\tgoto server_in_two_cells;\n\n\tafs_get_cell(cell);\n\tlist_add_tail(&server->link, &cell->servers);\n\n\twrite_unlock(&cell->servers_lock);\n\t_leave(\" = %p{%d}\", server, atomic_read(&server->usage));\n\treturn server;\n\n\t/* found a matching server quickly */\nfound_server_quickly:\n\t_debug(\"found quickly\");\n\tafs_get_server(server);\n\tread_unlock(&cell->servers_lock);\nno_longer_unused:\n\tif (!list_empty(&server->grave)) {\n\t\tspin_lock(&afs_server_graveyard_lock);\n\t\tlist_del_init(&server->grave);\n\t\tspin_unlock(&afs_server_graveyard_lock);\n\t}\n\t_leave(\" = %p{%d}\", server, atomic_read(&server->usage));\n\treturn server;\n\n\t/* found a matching server on the second pass */\nfound_server:\n\t_debug(\"found\");\n\tafs_get_server(server);\n\twrite_unlock(&cell->servers_lock);\n\tkfree(candidate);\n\tgoto no_longer_unused;\n\n\t/* found a server that seems to be in two cells */\nserver_in_two_cells:\n\twrite_unlock(&cell->servers_lock);\n\tkfree(candidate);\n\tprintk(KERN_NOTICE \"kAFS: Server %pI4 appears to be in two cells\\n\",\n\t       addr);\n\t_leave(\" = -EEXIST\");\n\treturn ERR_PTR(-EEXIST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&volume->server_sem"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_setup_and_register",
          "args": [
            "&volume->bdi",
            "\"afs\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&volume->usage",
            "1"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct afs_volume)",
            "GFP_KERNEL"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"creating new volume record\""
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_get_volume",
          "args": [
            "volume"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "afs_get_volume_status_call_destructor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "1703-1708",
          "snippet": "static void afs_get_volume_status_call_destructor(struct afs_call *call)\n{\n\tkfree(call->reply3);\n\tcall->reply3 = NULL;\n\tafs_flat_call_destructor(call);\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void afs_get_volume_status_call_destructor(struct afs_call *call)\n{\n\tkfree(call->reply3);\n\tcall->reply3 = NULL;\n\tafs_flat_call_destructor(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&params->cell->vl_sem"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "vlocation"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "vlocation"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_vlocation_lookup",
          "args": [
            "params->cell",
            "params->key",
            "params->volname",
            "params->volnamesz"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vlocation_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
          "lines": "373-486",
          "snippet": "struct afs_vlocation *afs_vlocation_lookup(struct afs_cell *cell,\n\t\t\t\t\t   struct key *key,\n\t\t\t\t\t   const char *name,\n\t\t\t\t\t   size_t namesz)\n{\n\tstruct afs_vlocation *vl;\n\tint ret;\n\n\t_enter(\"{%s},{%x},%*.*s,%zu\",\n\t       cell->name, key_serial(key),\n\t       (int) namesz, (int) namesz, name, namesz);\n\n\tif (namesz >= sizeof(vl->vldb.name)) {\n\t\t_leave(\" = -ENAMETOOLONG\");\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\n\t/* see if we have an in-memory copy first */\n\tdown_write(&cell->vl_sem);\n\tspin_lock(&cell->vl_lock);\n\tlist_for_each_entry(vl, &cell->vl_list, link) {\n\t\tif (vl->vldb.name[namesz] != '\\0')\n\t\t\tcontinue;\n\t\tif (memcmp(vl->vldb.name, name, namesz) == 0)\n\t\t\tgoto found_in_memory;\n\t}\n\tspin_unlock(&cell->vl_lock);\n\n\t/* not in the cell's in-memory lists - create a new record */\n\tvl = afs_vlocation_alloc(cell, name, namesz);\n\tif (!vl) {\n\t\tup_write(&cell->vl_sem);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tafs_get_cell(cell);\n\n\tlist_add_tail(&vl->link, &cell->vl_list);\n\tvl->state = AFS_VL_CREATING;\n\tup_write(&cell->vl_sem);\n\nfill_in_record:\n\tret = afs_vlocation_fill_in_record(vl, key);\n\tif (ret < 0)\n\t\tgoto error_abandon;\n\tspin_lock(&vl->lock);\n\tvl->state = AFS_VL_VALID;\n\tspin_unlock(&vl->lock);\n\twake_up(&vl->waitq);\n\n\t/* update volume entry in local cache */\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_update_cookie(vl->cache);\n#endif\n\n\t/* schedule for regular updates */\n\tafs_vlocation_queue_for_updates(vl);\n\tgoto success;\n\nfound_in_memory:\n\t/* found in memory */\n\t_debug(\"found in memory\");\n\tatomic_inc(&vl->usage);\n\tspin_unlock(&cell->vl_lock);\n\tif (!list_empty(&vl->grave)) {\n\t\tspin_lock(&afs_vlocation_graveyard_lock);\n\t\tlist_del_init(&vl->grave);\n\t\tspin_unlock(&afs_vlocation_graveyard_lock);\n\t}\n\tup_write(&cell->vl_sem);\n\n\t/* see if it was an abandoned record that we might try filling in */\n\tspin_lock(&vl->lock);\n\twhile (vl->state != AFS_VL_VALID) {\n\t\tafs_vlocation_state_t state = vl->state;\n\n\t\t_debug(\"invalid [state %d]\", state);\n\n\t\tif (state == AFS_VL_NEW || state == AFS_VL_NO_VOLUME) {\n\t\t\tvl->state = AFS_VL_CREATING;\n\t\t\tspin_unlock(&vl->lock);\n\t\t\tgoto fill_in_record;\n\t\t}\n\n\t\t/* must now wait for creation or update by someone else to\n\t\t * complete */\n\t\t_debug(\"wait\");\n\n\t\tspin_unlock(&vl->lock);\n\t\tret = wait_event_interruptible(vl->waitq,\n\t\t\t\t\t       vl->state == AFS_VL_NEW ||\n\t\t\t\t\t       vl->state == AFS_VL_VALID ||\n\t\t\t\t\t       vl->state == AFS_VL_NO_VOLUME);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tspin_lock(&vl->lock);\n\t}\n\tspin_unlock(&vl->lock);\n\nsuccess:\n\t_leave(\" = %p\", vl);\n\treturn vl;\n\nerror_abandon:\n\tspin_lock(&vl->lock);\n\tvl->state = AFS_VL_NEW;\n\tspin_unlock(&vl->lock);\n\twake_up(&vl->waitq);\nerror:\n\tASSERT(vl != NULL);\n\tafs_put_vlocation(vl);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(afs_vlocation_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(afs_vlocation_graveyard_lock);\n\nstruct afs_vlocation *afs_vlocation_lookup(struct afs_cell *cell,\n\t\t\t\t\t   struct key *key,\n\t\t\t\t\t   const char *name,\n\t\t\t\t\t   size_t namesz)\n{\n\tstruct afs_vlocation *vl;\n\tint ret;\n\n\t_enter(\"{%s},{%x},%*.*s,%zu\",\n\t       cell->name, key_serial(key),\n\t       (int) namesz, (int) namesz, name, namesz);\n\n\tif (namesz >= sizeof(vl->vldb.name)) {\n\t\t_leave(\" = -ENAMETOOLONG\");\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\n\t/* see if we have an in-memory copy first */\n\tdown_write(&cell->vl_sem);\n\tspin_lock(&cell->vl_lock);\n\tlist_for_each_entry(vl, &cell->vl_list, link) {\n\t\tif (vl->vldb.name[namesz] != '\\0')\n\t\t\tcontinue;\n\t\tif (memcmp(vl->vldb.name, name, namesz) == 0)\n\t\t\tgoto found_in_memory;\n\t}\n\tspin_unlock(&cell->vl_lock);\n\n\t/* not in the cell's in-memory lists - create a new record */\n\tvl = afs_vlocation_alloc(cell, name, namesz);\n\tif (!vl) {\n\t\tup_write(&cell->vl_sem);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tafs_get_cell(cell);\n\n\tlist_add_tail(&vl->link, &cell->vl_list);\n\tvl->state = AFS_VL_CREATING;\n\tup_write(&cell->vl_sem);\n\nfill_in_record:\n\tret = afs_vlocation_fill_in_record(vl, key);\n\tif (ret < 0)\n\t\tgoto error_abandon;\n\tspin_lock(&vl->lock);\n\tvl->state = AFS_VL_VALID;\n\tspin_unlock(&vl->lock);\n\twake_up(&vl->waitq);\n\n\t/* update volume entry in local cache */\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_update_cookie(vl->cache);\n#endif\n\n\t/* schedule for regular updates */\n\tafs_vlocation_queue_for_updates(vl);\n\tgoto success;\n\nfound_in_memory:\n\t/* found in memory */\n\t_debug(\"found in memory\");\n\tatomic_inc(&vl->usage);\n\tspin_unlock(&cell->vl_lock);\n\tif (!list_empty(&vl->grave)) {\n\t\tspin_lock(&afs_vlocation_graveyard_lock);\n\t\tlist_del_init(&vl->grave);\n\t\tspin_unlock(&afs_vlocation_graveyard_lock);\n\t}\n\tup_write(&cell->vl_sem);\n\n\t/* see if it was an abandoned record that we might try filling in */\n\tspin_lock(&vl->lock);\n\twhile (vl->state != AFS_VL_VALID) {\n\t\tafs_vlocation_state_t state = vl->state;\n\n\t\t_debug(\"invalid [state %d]\", state);\n\n\t\tif (state == AFS_VL_NEW || state == AFS_VL_NO_VOLUME) {\n\t\t\tvl->state = AFS_VL_CREATING;\n\t\t\tspin_unlock(&vl->lock);\n\t\t\tgoto fill_in_record;\n\t\t}\n\n\t\t/* must now wait for creation or update by someone else to\n\t\t * complete */\n\t\t_debug(\"wait\");\n\n\t\tspin_unlock(&vl->lock);\n\t\tret = wait_event_interruptible(vl->waitq,\n\t\t\t\t\t       vl->state == AFS_VL_NEW ||\n\t\t\t\t\t       vl->state == AFS_VL_VALID ||\n\t\t\t\t\t       vl->state == AFS_VL_NO_VOLUME);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tspin_lock(&vl->lock);\n\t}\n\tspin_unlock(&vl->lock);\n\nsuccess:\n\t_leave(\" = %p\", vl);\n\treturn vl;\n\nerror_abandon:\n\tspin_lock(&vl->lock);\n\tvl->state = AFS_VL_NEW;\n\tspin_unlock(&vl->lock);\n\twake_up(&vl->waitq);\nerror:\n\tASSERT(vl != NULL);\n\tafs_put_vlocation(vl);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%*.*s,%d}\"",
            "params->volnamesz",
            "params->volnamesz",
            "params->volname",
            "params->rwpath"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic const char *afs_voltypes[] = { \"R/W\", \"R/O\", \"BAK\" };\n\nstruct afs_volume *afs_volume_lookup(struct afs_mount_params *params)\n{\n\tstruct afs_vlocation *vlocation = NULL;\n\tstruct afs_volume *volume = NULL;\n\tstruct afs_server *server = NULL;\n\tchar srvtmask;\n\tint ret, loop;\n\n\t_enter(\"{%*.*s,%d}\",\n\t       params->volnamesz, params->volnamesz, params->volname, params->rwpath);\n\n\t/* lookup the volume location record */\n\tvlocation = afs_vlocation_lookup(params->cell, params->key,\n\t\t\t\t\t params->volname, params->volnamesz);\n\tif (IS_ERR(vlocation)) {\n\t\tret = PTR_ERR(vlocation);\n\t\tvlocation = NULL;\n\t\tgoto error;\n\t}\n\n\t/* make the final decision on the type we want */\n\tret = -ENOMEDIUM;\n\tif (params->force && !(vlocation->vldb.vidmask & (1 << params->type)))\n\t\tgoto error;\n\n\tsrvtmask = 0;\n\tfor (loop = 0; loop < vlocation->vldb.nservers; loop++)\n\t\tsrvtmask |= vlocation->vldb.srvtmask[loop];\n\n\tif (params->force) {\n\t\tif (!(srvtmask & (1 << params->type)))\n\t\t\tgoto error;\n\t} else if (srvtmask & AFS_VOL_VTM_RO) {\n\t\tparams->type = AFSVL_ROVOL;\n\t} else if (srvtmask & AFS_VOL_VTM_RW) {\n\t\tparams->type = AFSVL_RWVOL;\n\t} else {\n\t\tgoto error;\n\t}\n\n\tdown_write(&params->cell->vl_sem);\n\n\t/* is the volume already active? */\n\tif (vlocation->vols[params->type]) {\n\t\t/* yes - re-use it */\n\t\tvolume = vlocation->vols[params->type];\n\t\tafs_get_volume(volume);\n\t\tgoto success;\n\t}\n\n\t/* create a new volume record */\n\t_debug(\"creating new volume record\");\n\n\tret = -ENOMEM;\n\tvolume = kzalloc(sizeof(struct afs_volume), GFP_KERNEL);\n\tif (!volume)\n\t\tgoto error_up;\n\n\tatomic_set(&volume->usage, 1);\n\tvolume->type\t\t= params->type;\n\tvolume->type_force\t= params->force;\n\tvolume->cell\t\t= params->cell;\n\tvolume->vid\t\t= vlocation->vldb.vid[params->type];\n\n\tret = bdi_setup_and_register(&volume->bdi, \"afs\");\n\tif (ret)\n\t\tgoto error_bdi;\n\n\tinit_rwsem(&volume->server_sem);\n\n\t/* look up all the applicable server records */\n\tfor (loop = 0; loop < 8; loop++) {\n\t\tif (vlocation->vldb.srvtmask[loop] & (1 << volume->type)) {\n\t\t\tserver = afs_lookup_server(\n\t\t\t       volume->cell, &vlocation->vldb.servers[loop]);\n\t\t\tif (IS_ERR(server)) {\n\t\t\t\tret = PTR_ERR(server);\n\t\t\t\tgoto error_discard;\n\t\t\t}\n\n\t\t\tvolume->servers[volume->nservers] = server;\n\t\t\tvolume->nservers++;\n\t\t}\n\t}\n\n\t/* attach the cache and volume location */\n#ifdef CONFIG_AFS_FSCACHE\n\tvolume->cache = fscache_acquire_cookie(vlocation->cache,\n\t\t\t\t\t       &afs_volume_cache_index_def,\n\t\t\t\t\t       volume, true);\n#endif\n\tafs_get_vlocation(vlocation);\n\tvolume->vlocation = vlocation;\n\n\tvlocation->vols[volume->type] = volume;\n\nsuccess:\n\t_debug(\"kAFS selected %s volume %08x\",\n\t       afs_voltypes[volume->type], volume->vid);\n\tup_write(&params->cell->vl_sem);\n\tafs_put_vlocation(vlocation);\n\t_leave(\" = %p\", volume);\n\treturn volume;\n\n\t/* clean up */\nerror_up:\n\tup_write(&params->cell->vl_sem);\nerror:\n\tafs_put_vlocation(vlocation);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n\nerror_discard:\n\tbdi_destroy(&volume->bdi);\nerror_bdi:\n\tup_write(&params->cell->vl_sem);\n\n\tfor (loop = volume->nservers - 1; loop >= 0; loop--)\n\t\tafs_put_server(volume->servers[loop]);\n\n\tkfree(volume);\n\tgoto error;\n}"
  }
]