[
  {
    "function_name": "cifs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "767-873",
    "snippet": "int cifs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tint i;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsFileInfo *cifsFile = NULL;\n\tchar *current_entry;\n\tint num_to_fill = 0;\n\tchar *tmp_buf = NULL;\n\tchar *end_of_smb;\n\tunsigned int max_len;\n\n\txid = get_xid();\n\n\t/*\n\t * Ensure FindFirst doesn't fail before doing filldir() for '.' and\n\t * '..'. Otherwise we won't be able to notify VFS in case of failure.\n\t */\n\tif (file->private_data == NULL) {\n\t\trc = initiate_cifs_search(xid, file);\n\t\tcifs_dbg(FYI, \"initiate cifs search rc %d\\n\", rc);\n\t\tif (rc)\n\t\t\tgoto rddir2_exit;\n\t}\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto rddir2_exit;\n\n\t/* 1) If search is active,\n\t\tis in current search buffer?\n\t\tif it before then restart search\n\t\tif after then keep searching till find it */\n\n\tcifsFile = file->private_data;\n\tif (cifsFile->srch_inf.endOfSearch) {\n\t\tif (cifsFile->srch_inf.emptyDir) {\n\t\t\tcifs_dbg(FYI, \"End of search, empty dir\\n\");\n\t\t\trc = 0;\n\t\t\tgoto rddir2_exit;\n\t\t}\n\t} /* else {\n\t\tcifsFile->invalidHandle = true;\n\t\ttcon->ses->server->close(xid, tcon, &cifsFile->fid);\n\t} */\n\n\ttcon = tlink_tcon(cifsFile->tlink);\n\trc = find_cifs_entry(xid, tcon, ctx->pos, file, &current_entry,\n\t\t\t     &num_to_fill);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"fce error %d\\n\", rc);\n\t\tgoto rddir2_exit;\n\t} else if (current_entry != NULL) {\n\t\tcifs_dbg(FYI, \"entry %lld found\\n\", ctx->pos);\n\t} else {\n\t\tcifs_dbg(FYI, \"could not find entry\\n\");\n\t\tgoto rddir2_exit;\n\t}\n\tcifs_dbg(FYI, \"loop through %d times filling dir for net buf %p\\n\",\n\t\t num_to_fill, cifsFile->srch_inf.ntwrk_buf_start);\n\tmax_len = tcon->ses->server->ops->calc_smb_size(\n\t\t\tcifsFile->srch_inf.ntwrk_buf_start);\n\tend_of_smb = cifsFile->srch_inf.ntwrk_buf_start + max_len;\n\n\ttmp_buf = kmalloc(UNICODE_NAME_MAX, GFP_KERNEL);\n\tif (tmp_buf == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto rddir2_exit;\n\t}\n\n\tfor (i = 0; i < num_to_fill; i++) {\n\t\tif (current_entry == NULL) {\n\t\t\t/* evaluate whether this case is an error */\n\t\t\tcifs_dbg(VFS, \"past SMB end,  num to fill %d i %d\\n\",\n\t\t\t\t num_to_fill, i);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * if buggy server returns . and .. late do we want to\n\t\t * check for that here?\n\t\t */\n\t\trc = cifs_filldir(current_entry, file, ctx,\n\t\t\t\t  tmp_buf, max_len);\n\t\tif (rc) {\n\t\t\tif (rc > 0)\n\t\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tctx->pos++;\n\t\tif (ctx->pos ==\n\t\t\tcifsFile->srch_inf.index_of_last_entry) {\n\t\t\tcifs_dbg(FYI, \"last entry in buf at pos %lld %s\\n\",\n\t\t\t\t ctx->pos, tmp_buf);\n\t\t\tcifs_save_resume_key(current_entry, cifsFile);\n\t\t\tbreak;\n\t\t} else\n\t\t\tcurrent_entry =\n\t\t\t\tnxt_dir_entry(current_entry, end_of_smb,\n\t\t\t\t\tcifsFile->srch_inf.info_level);\n\t}\n\tkfree(tmp_buf);\n\nrddir2_exit:\n\tfree_xid(xid);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define UNICODE_NAME_MAX ((4 * NAME_MAX) + 2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp_buf"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nxt_dir_entry",
          "args": [
            "current_entry",
            "end_of_smb",
            "cifsFile->srch_inf.info_level"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "nxt_dir_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "362-391",
          "snippet": "static char *nxt_dir_entry(char *old_entry, char *end_of_smb, int level)\n{\n\tchar *new_entry;\n\tFILE_DIRECTORY_INFO *pDirInfo = (FILE_DIRECTORY_INFO *)old_entry;\n\n\tif (level == SMB_FIND_FILE_INFO_STANDARD) {\n\t\tFIND_FILE_STANDARD_INFO *pfData;\n\t\tpfData = (FIND_FILE_STANDARD_INFO *)pDirInfo;\n\n\t\tnew_entry = old_entry + sizeof(FIND_FILE_STANDARD_INFO) +\n\t\t\t\tpfData->FileNameLength;\n\t} else\n\t\tnew_entry = old_entry + le32_to_cpu(pDirInfo->NextEntryOffset);\n\tcifs_dbg(FYI, \"new entry %p old entry %p\\n\", new_entry, old_entry);\n\t/* validate that new_entry is not past end of SMB */\n\tif (new_entry >= end_of_smb) {\n\t\tcifs_dbg(VFS, \"search entry %p began after end of SMB %p old entry %p\\n\",\n\t\t\t new_entry, end_of_smb, old_entry);\n\t\treturn NULL;\n\t} else if (((level == SMB_FIND_FILE_INFO_STANDARD) &&\n\t\t    (new_entry + sizeof(FIND_FILE_STANDARD_INFO) > end_of_smb))\n\t\t  || ((level != SMB_FIND_FILE_INFO_STANDARD) &&\n\t\t   (new_entry + sizeof(FILE_DIRECTORY_INFO) > end_of_smb)))  {\n\t\tcifs_dbg(VFS, \"search entry %p extends after end of SMB %p\\n\",\n\t\t\t new_entry, end_of_smb);\n\t\treturn NULL;\n\t} else\n\t\treturn new_entry;\n\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic char *nxt_dir_entry(char *old_entry, char *end_of_smb, int level)\n{\n\tchar *new_entry;\n\tFILE_DIRECTORY_INFO *pDirInfo = (FILE_DIRECTORY_INFO *)old_entry;\n\n\tif (level == SMB_FIND_FILE_INFO_STANDARD) {\n\t\tFIND_FILE_STANDARD_INFO *pfData;\n\t\tpfData = (FIND_FILE_STANDARD_INFO *)pDirInfo;\n\n\t\tnew_entry = old_entry + sizeof(FIND_FILE_STANDARD_INFO) +\n\t\t\t\tpfData->FileNameLength;\n\t} else\n\t\tnew_entry = old_entry + le32_to_cpu(pDirInfo->NextEntryOffset);\n\tcifs_dbg(FYI, \"new entry %p old entry %p\\n\", new_entry, old_entry);\n\t/* validate that new_entry is not past end of SMB */\n\tif (new_entry >= end_of_smb) {\n\t\tcifs_dbg(VFS, \"search entry %p began after end of SMB %p old entry %p\\n\",\n\t\t\t new_entry, end_of_smb, old_entry);\n\t\treturn NULL;\n\t} else if (((level == SMB_FIND_FILE_INFO_STANDARD) &&\n\t\t    (new_entry + sizeof(FIND_FILE_STANDARD_INFO) > end_of_smb))\n\t\t  || ((level != SMB_FIND_FILE_INFO_STANDARD) &&\n\t\t   (new_entry + sizeof(FILE_DIRECTORY_INFO) > end_of_smb)))  {\n\t\tcifs_dbg(VFS, \"search entry %p extends after end of SMB %p\\n\",\n\t\t\t new_entry, end_of_smb);\n\t\treturn NULL;\n\t} else\n\t\treturn new_entry;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_save_resume_key",
          "args": [
            "current_entry",
            "cifsFile"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_save_resume_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "535-549",
          "snippet": "static int cifs_save_resume_key(const char *current_entry,\n\tstruct cifsFileInfo *file_info)\n{\n\tstruct cifs_dirent de;\n\tint rc;\n\n\trc = cifs_fill_dirent(&de, current_entry, file_info->srch_inf.info_level,\n\t\t\t      file_info->srch_inf.unicode);\n\tif (!rc) {\n\t\tfile_info->srch_inf.presume_name = de.name;\n\t\tfile_info->srch_inf.resume_name_len = de.namelen;\n\t\tfile_info->srch_inf.resume_key = de.resume_key;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int cifs_save_resume_key(const char *current_entry,\n\tstruct cifsFileInfo *file_info)\n{\n\tstruct cifs_dirent de;\n\tint rc;\n\n\trc = cifs_fill_dirent(&de, current_entry, file_info->srch_inf.info_level,\n\t\t\t      file_info->srch_inf.unicode);\n\tif (!rc) {\n\t\tfile_info->srch_inf.presume_name = de.name;\n\t\tfile_info->srch_inf.resume_name_len = de.namelen;\n\t\tfile_info->srch_inf.resume_key = de.resume_key;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"last entry in buf at pos %lld %s\\n\"",
            "ctx->pos",
            "tmp_buf"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_filldir",
          "args": [
            "current_entry",
            "file",
            "ctx",
            "tmp_buf",
            "max_len"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_filldir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "681-764",
          "snippet": "static int cifs_filldir(char *find_entry, struct file *file,\n\t\tstruct dir_context *ctx,\n\t\tchar *scratch_buf, unsigned int max_len)\n{\n\tstruct cifsFileInfo *file_info = file->private_data;\n\tstruct super_block *sb = file_inode(file)->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_dirent de = { NULL, };\n\tstruct cifs_fattr fattr;\n\tstruct qstr name;\n\tint rc = 0;\n\tino_t ino;\n\n\trc = cifs_fill_dirent(&de, find_entry, file_info->srch_inf.info_level,\n\t\t\t      file_info->srch_inf.unicode);\n\tif (rc)\n\t\treturn rc;\n\n\tif (de.namelen > max_len) {\n\t\tcifs_dbg(VFS, \"bad search response length %zd past smb end\\n\",\n\t\t\t de.namelen);\n\t\treturn -EINVAL;\n\t}\n\n\t/* skip . and .. since we added them first */\n\tif (cifs_entry_is_dot(&de, file_info->srch_inf.unicode))\n\t\treturn 0;\n\n\tif (file_info->srch_inf.unicode) {\n\t\tstruct nls_table *nlt = cifs_sb->local_nls;\n\t\tint map_type;\n\n\t\tmap_type = cifs_remap(cifs_sb);\n\t\tname.name = scratch_buf;\n\t\tname.len =\n\t\t\tcifs_from_utf16((char *)name.name, (__le16 *)de.name,\n\t\t\t\t\tUNICODE_NAME_MAX,\n\t\t\t\t\tmin_t(size_t, de.namelen,\n\t\t\t\t\t      (size_t)max_len), nlt, map_type);\n\t\tname.len -= nls_nullsize(nlt);\n\t} else {\n\t\tname.name = de.name;\n\t\tname.len = de.namelen;\n\t}\n\n\tswitch (file_info->srch_inf.info_level) {\n\tcase SMB_FIND_FILE_UNIX:\n\t\tcifs_unix_basic_to_fattr(&fattr,\n\t\t\t\t\t &((FILE_UNIX_INFO *)find_entry)->basic,\n\t\t\t\t\t cifs_sb);\n\t\tbreak;\n\tcase SMB_FIND_FILE_INFO_STANDARD:\n\t\tcifs_std_info_to_fattr(&fattr,\n\t\t\t\t       (FIND_FILE_STANDARD_INFO *)find_entry,\n\t\t\t\t       cifs_sb);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dir_info_to_fattr(&fattr,\n\t\t\t\t       (FILE_DIRECTORY_INFO *)find_entry,\n\t\t\t\t       cifs_sb);\n\t\tbreak;\n\t}\n\n\tif (de.ino && (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)) {\n\t\tfattr.cf_uniqueid = de.ino;\n\t} else {\n\t\tfattr.cf_uniqueid = iunique(sb, ROOT_I);\n\t\tcifs_autodisable_serverino(cifs_sb);\n\t}\n\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS) &&\n\t    couldbe_mf_symlink(&fattr))\n\t\t/*\n\t\t * trying to get the type and mode can be slow,\n\t\t * so just call those regular files for now, and mark\n\t\t * for reval\n\t\t */\n\t\tfattr.cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\tcifs_prime_dcache(file->f_path.dentry, &name, &fattr);\n\n\tino = cifs_uniqueid_to_ino_t(fattr.cf_uniqueid);\n\treturn !dir_emit(ctx, name.name, name.len, ino, fattr.cf_dtype);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define UNICODE_NAME_MAX ((4 * NAME_MAX) + 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define UNICODE_NAME_MAX ((4 * NAME_MAX) + 2)\n\nstatic int cifs_filldir(char *find_entry, struct file *file,\n\t\tstruct dir_context *ctx,\n\t\tchar *scratch_buf, unsigned int max_len)\n{\n\tstruct cifsFileInfo *file_info = file->private_data;\n\tstruct super_block *sb = file_inode(file)->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_dirent de = { NULL, };\n\tstruct cifs_fattr fattr;\n\tstruct qstr name;\n\tint rc = 0;\n\tino_t ino;\n\n\trc = cifs_fill_dirent(&de, find_entry, file_info->srch_inf.info_level,\n\t\t\t      file_info->srch_inf.unicode);\n\tif (rc)\n\t\treturn rc;\n\n\tif (de.namelen > max_len) {\n\t\tcifs_dbg(VFS, \"bad search response length %zd past smb end\\n\",\n\t\t\t de.namelen);\n\t\treturn -EINVAL;\n\t}\n\n\t/* skip . and .. since we added them first */\n\tif (cifs_entry_is_dot(&de, file_info->srch_inf.unicode))\n\t\treturn 0;\n\n\tif (file_info->srch_inf.unicode) {\n\t\tstruct nls_table *nlt = cifs_sb->local_nls;\n\t\tint map_type;\n\n\t\tmap_type = cifs_remap(cifs_sb);\n\t\tname.name = scratch_buf;\n\t\tname.len =\n\t\t\tcifs_from_utf16((char *)name.name, (__le16 *)de.name,\n\t\t\t\t\tUNICODE_NAME_MAX,\n\t\t\t\t\tmin_t(size_t, de.namelen,\n\t\t\t\t\t      (size_t)max_len), nlt, map_type);\n\t\tname.len -= nls_nullsize(nlt);\n\t} else {\n\t\tname.name = de.name;\n\t\tname.len = de.namelen;\n\t}\n\n\tswitch (file_info->srch_inf.info_level) {\n\tcase SMB_FIND_FILE_UNIX:\n\t\tcifs_unix_basic_to_fattr(&fattr,\n\t\t\t\t\t &((FILE_UNIX_INFO *)find_entry)->basic,\n\t\t\t\t\t cifs_sb);\n\t\tbreak;\n\tcase SMB_FIND_FILE_INFO_STANDARD:\n\t\tcifs_std_info_to_fattr(&fattr,\n\t\t\t\t       (FIND_FILE_STANDARD_INFO *)find_entry,\n\t\t\t\t       cifs_sb);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dir_info_to_fattr(&fattr,\n\t\t\t\t       (FILE_DIRECTORY_INFO *)find_entry,\n\t\t\t\t       cifs_sb);\n\t\tbreak;\n\t}\n\n\tif (de.ino && (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)) {\n\t\tfattr.cf_uniqueid = de.ino;\n\t} else {\n\t\tfattr.cf_uniqueid = iunique(sb, ROOT_I);\n\t\tcifs_autodisable_serverino(cifs_sb);\n\t}\n\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS) &&\n\t    couldbe_mf_symlink(&fattr))\n\t\t/*\n\t\t * trying to get the type and mode can be slow,\n\t\t * so just call those regular files for now, and mark\n\t\t * for reval\n\t\t */\n\t\tfattr.cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\tcifs_prime_dcache(file->f_path.dentry, &name, &fattr);\n\n\tino = cifs_uniqueid_to_ino_t(fattr.cf_uniqueid);\n\treturn !dir_emit(ctx, name.name, name.len, ino, fattr.cf_dtype);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"past SMB end,  num to fill %d i %d\\n\"",
            "num_to_fill",
            "i"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "UNICODE_NAME_MAX",
            "GFP_KERNEL"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->calc_smb_size",
          "args": [
            "cifsFile->srch_inf.ntwrk_buf_start"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"loop through %d times filling dir for net buf %p\\n\"",
            "num_to_fill",
            "cifsFile->srch_inf.ntwrk_buf_start"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"could not find entry\\n\""
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"entry %lld found\\n\"",
            "ctx->pos"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"fce error %d\\n\"",
            "rc"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_cifs_entry",
          "args": [
            "xid",
            "tcon",
            "ctx->pos",
            "file",
            "&current_entry",
            "&num_to_fill"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "find_cifs_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "558-679",
          "snippet": "static int\nfind_cifs_entry(const unsigned int xid, struct cifs_tcon *tcon, loff_t pos,\n\t\tstruct file *file, char **current_entry, int *num_to_ret)\n{\n\t__u16 search_flags;\n\tint rc = 0;\n\tint pos_in_buf = 0;\n\tloff_t first_entry_in_buffer;\n\tloff_t index_to_find = pos;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t/* check if index in the buffer */\n\n\tif (!server->ops->query_dir_first || !server->ops->query_dir_next)\n\t\treturn -ENOSYS;\n\n\tif ((cfile == NULL) || (current_entry == NULL) || (num_to_ret == NULL))\n\t\treturn -ENOENT;\n\n\t*current_entry = NULL;\n\tfirst_entry_in_buffer = cfile->srch_inf.index_of_last_entry -\n\t\t\t\t\tcfile->srch_inf.entries_in_buffer;\n\n\t/*\n\t * If first entry in buf is zero then is first buffer\n\t * in search response data which means it is likely . and ..\n\t * will be in this buffer, although some servers do not return\n\t * . and .. for the root of a drive and for those we need\n\t * to start two entries earlier.\n\t */\n\n\tdump_cifs_file_struct(file, \"In fce \");\n\tif (((index_to_find < cfile->srch_inf.index_of_last_entry) &&\n\t     is_dir_changed(file)) || (index_to_find < first_entry_in_buffer)) {\n\t\t/* close and restart search */\n\t\tcifs_dbg(FYI, \"search backing up - close and restart search\\n\");\n\t\tspin_lock(&cifs_file_list_lock);\n\t\tif (server->ops->dir_needs_close(cfile)) {\n\t\t\tcfile->invalidHandle = true;\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tif (server->ops->close_dir)\n\t\t\t\tserver->ops->close_dir(xid, tcon, &cfile->fid);\n\t\t} else\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\tif (cfile->srch_inf.ntwrk_buf_start) {\n\t\t\tcifs_dbg(FYI, \"freeing SMB ff cache buf on search rewind\\n\");\n\t\t\tif (cfile->srch_inf.smallBuf)\n\t\t\t\tcifs_small_buf_release(cfile->srch_inf.\n\t\t\t\t\t\tntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(cfile->srch_inf.\n\t\t\t\t\t\tntwrk_buf_start);\n\t\t\tcfile->srch_inf.ntwrk_buf_start = NULL;\n\t\t}\n\t\trc = initiate_cifs_search(xid, file);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"error %d reinitiating a search on rewind\\n\",\n\t\t\t\t rc);\n\t\t\treturn rc;\n\t\t}\n\t\t/* FindFirst/Next set last_entry to NULL on malformed reply */\n\t\tif (cfile->srch_inf.last_entry)\n\t\t\tcifs_save_resume_key(cfile->srch_inf.last_entry, cfile);\n\t}\n\n\tsearch_flags = CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME;\n\tif (backup_cred(cifs_sb))\n\t\tsearch_flags |= CIFS_SEARCH_BACKUP_SEARCH;\n\n\twhile ((index_to_find >= cfile->srch_inf.index_of_last_entry) &&\n\t       (rc == 0) && !cfile->srch_inf.endOfSearch) {\n\t\tcifs_dbg(FYI, \"calling findnext2\\n\");\n\t\trc = server->ops->query_dir_next(xid, tcon, &cfile->fid,\n\t\t\t\t\t\t search_flags,\n\t\t\t\t\t\t &cfile->srch_inf);\n\t\t/* FindFirst/Next set last_entry to NULL on malformed reply */\n\t\tif (cfile->srch_inf.last_entry)\n\t\t\tcifs_save_resume_key(cfile->srch_inf.last_entry, cfile);\n\t\tif (rc)\n\t\t\treturn -ENOENT;\n\t}\n\tif (index_to_find < cfile->srch_inf.index_of_last_entry) {\n\t\t/* we found the buffer that contains the entry */\n\t\t/* scan and find it */\n\t\tint i;\n\t\tchar *cur_ent;\n\t\tchar *end_of_smb = cfile->srch_inf.ntwrk_buf_start +\n\t\t\tserver->ops->calc_smb_size(\n\t\t\t\t\tcfile->srch_inf.ntwrk_buf_start);\n\n\t\tcur_ent = cfile->srch_inf.srch_entries_start;\n\t\tfirst_entry_in_buffer = cfile->srch_inf.index_of_last_entry\n\t\t\t\t\t- cfile->srch_inf.entries_in_buffer;\n\t\tpos_in_buf = index_to_find - first_entry_in_buffer;\n\t\tcifs_dbg(FYI, \"found entry - pos_in_buf %d\\n\", pos_in_buf);\n\n\t\tfor (i = 0; (i < (pos_in_buf)) && (cur_ent != NULL); i++) {\n\t\t\t/* go entry by entry figuring out which is first */\n\t\t\tcur_ent = nxt_dir_entry(cur_ent, end_of_smb,\n\t\t\t\t\t\tcfile->srch_inf.info_level);\n\t\t}\n\t\tif ((cur_ent == NULL) && (i < pos_in_buf)) {\n\t\t\t/* BB fixme - check if we should flag this error */\n\t\t\tcifs_dbg(VFS, \"reached end of buf searching for pos in buf %d index to find %lld rc %d\\n\",\n\t\t\t\t pos_in_buf, index_to_find, rc);\n\t\t}\n\t\trc = 0;\n\t\t*current_entry = cur_ent;\n\t} else {\n\t\tcifs_dbg(FYI, \"index not in buffer - could not findnext into it\\n\");\n\t\treturn 0;\n\t}\n\n\tif (pos_in_buf >= cfile->srch_inf.entries_in_buffer) {\n\t\tcifs_dbg(FYI, \"can not return entries pos_in_buf beyond last\\n\");\n\t\t*num_to_ret = 0;\n\t} else\n\t\t*num_to_ret = cfile->srch_inf.entries_in_buffer - pos_in_buf;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int\nfind_cifs_entry(const unsigned int xid, struct cifs_tcon *tcon, loff_t pos,\n\t\tstruct file *file, char **current_entry, int *num_to_ret)\n{\n\t__u16 search_flags;\n\tint rc = 0;\n\tint pos_in_buf = 0;\n\tloff_t first_entry_in_buffer;\n\tloff_t index_to_find = pos;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t/* check if index in the buffer */\n\n\tif (!server->ops->query_dir_first || !server->ops->query_dir_next)\n\t\treturn -ENOSYS;\n\n\tif ((cfile == NULL) || (current_entry == NULL) || (num_to_ret == NULL))\n\t\treturn -ENOENT;\n\n\t*current_entry = NULL;\n\tfirst_entry_in_buffer = cfile->srch_inf.index_of_last_entry -\n\t\t\t\t\tcfile->srch_inf.entries_in_buffer;\n\n\t/*\n\t * If first entry in buf is zero then is first buffer\n\t * in search response data which means it is likely . and ..\n\t * will be in this buffer, although some servers do not return\n\t * . and .. for the root of a drive and for those we need\n\t * to start two entries earlier.\n\t */\n\n\tdump_cifs_file_struct(file, \"In fce \");\n\tif (((index_to_find < cfile->srch_inf.index_of_last_entry) &&\n\t     is_dir_changed(file)) || (index_to_find < first_entry_in_buffer)) {\n\t\t/* close and restart search */\n\t\tcifs_dbg(FYI, \"search backing up - close and restart search\\n\");\n\t\tspin_lock(&cifs_file_list_lock);\n\t\tif (server->ops->dir_needs_close(cfile)) {\n\t\t\tcfile->invalidHandle = true;\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tif (server->ops->close_dir)\n\t\t\t\tserver->ops->close_dir(xid, tcon, &cfile->fid);\n\t\t} else\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\tif (cfile->srch_inf.ntwrk_buf_start) {\n\t\t\tcifs_dbg(FYI, \"freeing SMB ff cache buf on search rewind\\n\");\n\t\t\tif (cfile->srch_inf.smallBuf)\n\t\t\t\tcifs_small_buf_release(cfile->srch_inf.\n\t\t\t\t\t\tntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(cfile->srch_inf.\n\t\t\t\t\t\tntwrk_buf_start);\n\t\t\tcfile->srch_inf.ntwrk_buf_start = NULL;\n\t\t}\n\t\trc = initiate_cifs_search(xid, file);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"error %d reinitiating a search on rewind\\n\",\n\t\t\t\t rc);\n\t\t\treturn rc;\n\t\t}\n\t\t/* FindFirst/Next set last_entry to NULL on malformed reply */\n\t\tif (cfile->srch_inf.last_entry)\n\t\t\tcifs_save_resume_key(cfile->srch_inf.last_entry, cfile);\n\t}\n\n\tsearch_flags = CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME;\n\tif (backup_cred(cifs_sb))\n\t\tsearch_flags |= CIFS_SEARCH_BACKUP_SEARCH;\n\n\twhile ((index_to_find >= cfile->srch_inf.index_of_last_entry) &&\n\t       (rc == 0) && !cfile->srch_inf.endOfSearch) {\n\t\tcifs_dbg(FYI, \"calling findnext2\\n\");\n\t\trc = server->ops->query_dir_next(xid, tcon, &cfile->fid,\n\t\t\t\t\t\t search_flags,\n\t\t\t\t\t\t &cfile->srch_inf);\n\t\t/* FindFirst/Next set last_entry to NULL on malformed reply */\n\t\tif (cfile->srch_inf.last_entry)\n\t\t\tcifs_save_resume_key(cfile->srch_inf.last_entry, cfile);\n\t\tif (rc)\n\t\t\treturn -ENOENT;\n\t}\n\tif (index_to_find < cfile->srch_inf.index_of_last_entry) {\n\t\t/* we found the buffer that contains the entry */\n\t\t/* scan and find it */\n\t\tint i;\n\t\tchar *cur_ent;\n\t\tchar *end_of_smb = cfile->srch_inf.ntwrk_buf_start +\n\t\t\tserver->ops->calc_smb_size(\n\t\t\t\t\tcfile->srch_inf.ntwrk_buf_start);\n\n\t\tcur_ent = cfile->srch_inf.srch_entries_start;\n\t\tfirst_entry_in_buffer = cfile->srch_inf.index_of_last_entry\n\t\t\t\t\t- cfile->srch_inf.entries_in_buffer;\n\t\tpos_in_buf = index_to_find - first_entry_in_buffer;\n\t\tcifs_dbg(FYI, \"found entry - pos_in_buf %d\\n\", pos_in_buf);\n\n\t\tfor (i = 0; (i < (pos_in_buf)) && (cur_ent != NULL); i++) {\n\t\t\t/* go entry by entry figuring out which is first */\n\t\t\tcur_ent = nxt_dir_entry(cur_ent, end_of_smb,\n\t\t\t\t\t\tcfile->srch_inf.info_level);\n\t\t}\n\t\tif ((cur_ent == NULL) && (i < pos_in_buf)) {\n\t\t\t/* BB fixme - check if we should flag this error */\n\t\t\tcifs_dbg(VFS, \"reached end of buf searching for pos in buf %d index to find %lld rc %d\\n\",\n\t\t\t\t pos_in_buf, index_to_find, rc);\n\t\t}\n\t\trc = 0;\n\t\t*current_entry = cur_ent;\n\t} else {\n\t\tcifs_dbg(FYI, \"index not in buffer - could not findnext into it\\n\");\n\t\treturn 0;\n\t}\n\n\tif (pos_in_buf >= cfile->srch_inf.entries_in_buffer) {\n\t\tcifs_dbg(FYI, \"can not return entries pos_in_buf beyond last\\n\");\n\t\t*num_to_ret = 0;\n\t} else\n\t\t*num_to_ret = cfile->srch_inf.entries_in_buffer - pos_in_buf;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cifsFile->tlink"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"End of search, empty dir\\n\""
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit_dots",
          "args": [
            "file",
            "ctx"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"initiate cifs search rc %d\\n\"",
            "rc"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initiate_cifs_search",
          "args": [
            "xid",
            "file"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "initiate_cifs_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "261-346",
          "snippet": "static int\ninitiate_cifs_search(const unsigned int xid, struct file *file)\n{\n\t__u16 search_flags;\n\tint rc = 0;\n\tchar *full_path = NULL;\n\tstruct cifsFileInfo *cifsFile;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct tcon_link *tlink = NULL;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\n\tif (file->private_data == NULL) {\n\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\tif (IS_ERR(tlink))\n\t\t\treturn PTR_ERR(tlink);\n\n\t\tcifsFile = kzalloc(sizeof(struct cifsFileInfo), GFP_KERNEL);\n\t\tif (cifsFile == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto error_exit;\n\t\t}\n\t\tfile->private_data = cifsFile;\n\t\tcifsFile->tlink = cifs_get_tlink(tlink);\n\t\ttcon = tlink_tcon(tlink);\n\t} else {\n\t\tcifsFile = file->private_data;\n\t\ttcon = tlink_tcon(cifsFile->tlink);\n\t}\n\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->query_dir_first) {\n\t\trc = -ENOSYS;\n\t\tgoto error_exit;\n\t}\n\n\tcifsFile->invalidHandle = true;\n\tcifsFile->srch_inf.endOfSearch = false;\n\n\tfull_path = build_path_from_dentry(file->f_path.dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto error_exit;\n\t}\n\n\tcifs_dbg(FYI, \"Full path: %s start at: %lld\\n\", full_path, file->f_pos);\n\nffirst_retry:\n\t/* test for Unix extensions */\n\t/* but now check for them on the share/mount not on the SMB session */\n\t/* if (cap_unix(tcon->ses) { */\n\tif (tcon->unix_ext)\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_UNIX;\n\telse if ((tcon->ses->capabilities &\n\t\t  tcon->ses->server->vals->cap_nt_find) == 0) {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_INFO_STANDARD;\n\t} else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_ID_FULL_DIR_INFO;\n\t} else /* not srvinos - BB fixme add check for backlevel? */ {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_DIRECTORY_INFO;\n\t}\n\n\tsearch_flags = CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME;\n\tif (backup_cred(cifs_sb))\n\t\tsearch_flags |= CIFS_SEARCH_BACKUP_SEARCH;\n\n\trc = server->ops->query_dir_first(xid, tcon, full_path, cifs_sb,\n\t\t\t\t\t  &cifsFile->fid, search_flags,\n\t\t\t\t\t  &cifsFile->srch_inf);\n\n\tif (rc == 0)\n\t\tcifsFile->invalidHandle = false;\n\t/* BB add following call to handle readdir on new NTFS symlink errors\n\telse if STATUS_STOPPED_ON_SYMLINK\n\t\tcall get_symlink_reparse_path and retry with new path */\n\telse if ((rc == -EOPNOTSUPP) &&\n\t\t(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)) {\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\n\t\tgoto ffirst_retry;\n\t}\nerror_exit:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int\ninitiate_cifs_search(const unsigned int xid, struct file *file)\n{\n\t__u16 search_flags;\n\tint rc = 0;\n\tchar *full_path = NULL;\n\tstruct cifsFileInfo *cifsFile;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct tcon_link *tlink = NULL;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\n\tif (file->private_data == NULL) {\n\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\tif (IS_ERR(tlink))\n\t\t\treturn PTR_ERR(tlink);\n\n\t\tcifsFile = kzalloc(sizeof(struct cifsFileInfo), GFP_KERNEL);\n\t\tif (cifsFile == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto error_exit;\n\t\t}\n\t\tfile->private_data = cifsFile;\n\t\tcifsFile->tlink = cifs_get_tlink(tlink);\n\t\ttcon = tlink_tcon(tlink);\n\t} else {\n\t\tcifsFile = file->private_data;\n\t\ttcon = tlink_tcon(cifsFile->tlink);\n\t}\n\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->query_dir_first) {\n\t\trc = -ENOSYS;\n\t\tgoto error_exit;\n\t}\n\n\tcifsFile->invalidHandle = true;\n\tcifsFile->srch_inf.endOfSearch = false;\n\n\tfull_path = build_path_from_dentry(file->f_path.dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto error_exit;\n\t}\n\n\tcifs_dbg(FYI, \"Full path: %s start at: %lld\\n\", full_path, file->f_pos);\n\nffirst_retry:\n\t/* test for Unix extensions */\n\t/* but now check for them on the share/mount not on the SMB session */\n\t/* if (cap_unix(tcon->ses) { */\n\tif (tcon->unix_ext)\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_UNIX;\n\telse if ((tcon->ses->capabilities &\n\t\t  tcon->ses->server->vals->cap_nt_find) == 0) {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_INFO_STANDARD;\n\t} else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_ID_FULL_DIR_INFO;\n\t} else /* not srvinos - BB fixme add check for backlevel? */ {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_DIRECTORY_INFO;\n\t}\n\n\tsearch_flags = CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME;\n\tif (backup_cred(cifs_sb))\n\t\tsearch_flags |= CIFS_SEARCH_BACKUP_SEARCH;\n\n\trc = server->ops->query_dir_first(xid, tcon, full_path, cifs_sb,\n\t\t\t\t\t  &cifsFile->fid, search_flags,\n\t\t\t\t\t  &cifsFile->srch_inf);\n\n\tif (rc == 0)\n\t\tcifsFile->invalidHandle = false;\n\t/* BB add following call to handle readdir on new NTFS symlink errors\n\telse if STATUS_STOPPED_ON_SYMLINK\n\t\tcall get_symlink_reparse_path and retry with new path */\n\telse if ((rc == -EOPNOTSUPP) &&\n\t\t(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)) {\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\n\t\tgoto ffirst_retry;\n\t}\nerror_exit:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define UNICODE_NAME_MAX ((4 * NAME_MAX) + 2)\n\nint cifs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tint i;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsFileInfo *cifsFile = NULL;\n\tchar *current_entry;\n\tint num_to_fill = 0;\n\tchar *tmp_buf = NULL;\n\tchar *end_of_smb;\n\tunsigned int max_len;\n\n\txid = get_xid();\n\n\t/*\n\t * Ensure FindFirst doesn't fail before doing filldir() for '.' and\n\t * '..'. Otherwise we won't be able to notify VFS in case of failure.\n\t */\n\tif (file->private_data == NULL) {\n\t\trc = initiate_cifs_search(xid, file);\n\t\tcifs_dbg(FYI, \"initiate cifs search rc %d\\n\", rc);\n\t\tif (rc)\n\t\t\tgoto rddir2_exit;\n\t}\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto rddir2_exit;\n\n\t/* 1) If search is active,\n\t\tis in current search buffer?\n\t\tif it before then restart search\n\t\tif after then keep searching till find it */\n\n\tcifsFile = file->private_data;\n\tif (cifsFile->srch_inf.endOfSearch) {\n\t\tif (cifsFile->srch_inf.emptyDir) {\n\t\t\tcifs_dbg(FYI, \"End of search, empty dir\\n\");\n\t\t\trc = 0;\n\t\t\tgoto rddir2_exit;\n\t\t}\n\t} /* else {\n\t\tcifsFile->invalidHandle = true;\n\t\ttcon->ses->server->close(xid, tcon, &cifsFile->fid);\n\t} */\n\n\ttcon = tlink_tcon(cifsFile->tlink);\n\trc = find_cifs_entry(xid, tcon, ctx->pos, file, &current_entry,\n\t\t\t     &num_to_fill);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"fce error %d\\n\", rc);\n\t\tgoto rddir2_exit;\n\t} else if (current_entry != NULL) {\n\t\tcifs_dbg(FYI, \"entry %lld found\\n\", ctx->pos);\n\t} else {\n\t\tcifs_dbg(FYI, \"could not find entry\\n\");\n\t\tgoto rddir2_exit;\n\t}\n\tcifs_dbg(FYI, \"loop through %d times filling dir for net buf %p\\n\",\n\t\t num_to_fill, cifsFile->srch_inf.ntwrk_buf_start);\n\tmax_len = tcon->ses->server->ops->calc_smb_size(\n\t\t\tcifsFile->srch_inf.ntwrk_buf_start);\n\tend_of_smb = cifsFile->srch_inf.ntwrk_buf_start + max_len;\n\n\ttmp_buf = kmalloc(UNICODE_NAME_MAX, GFP_KERNEL);\n\tif (tmp_buf == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto rddir2_exit;\n\t}\n\n\tfor (i = 0; i < num_to_fill; i++) {\n\t\tif (current_entry == NULL) {\n\t\t\t/* evaluate whether this case is an error */\n\t\t\tcifs_dbg(VFS, \"past SMB end,  num to fill %d i %d\\n\",\n\t\t\t\t num_to_fill, i);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * if buggy server returns . and .. late do we want to\n\t\t * check for that here?\n\t\t */\n\t\trc = cifs_filldir(current_entry, file, ctx,\n\t\t\t\t  tmp_buf, max_len);\n\t\tif (rc) {\n\t\t\tif (rc > 0)\n\t\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tctx->pos++;\n\t\tif (ctx->pos ==\n\t\t\tcifsFile->srch_inf.index_of_last_entry) {\n\t\t\tcifs_dbg(FYI, \"last entry in buf at pos %lld %s\\n\",\n\t\t\t\t ctx->pos, tmp_buf);\n\t\t\tcifs_save_resume_key(current_entry, cifsFile);\n\t\t\tbreak;\n\t\t} else\n\t\t\tcurrent_entry =\n\t\t\t\tnxt_dir_entry(current_entry, end_of_smb,\n\t\t\t\t\tcifsFile->srch_inf.info_level);\n\t}\n\tkfree(tmp_buf);\n\nrddir2_exit:\n\tfree_xid(xid);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_filldir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "681-764",
    "snippet": "static int cifs_filldir(char *find_entry, struct file *file,\n\t\tstruct dir_context *ctx,\n\t\tchar *scratch_buf, unsigned int max_len)\n{\n\tstruct cifsFileInfo *file_info = file->private_data;\n\tstruct super_block *sb = file_inode(file)->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_dirent de = { NULL, };\n\tstruct cifs_fattr fattr;\n\tstruct qstr name;\n\tint rc = 0;\n\tino_t ino;\n\n\trc = cifs_fill_dirent(&de, find_entry, file_info->srch_inf.info_level,\n\t\t\t      file_info->srch_inf.unicode);\n\tif (rc)\n\t\treturn rc;\n\n\tif (de.namelen > max_len) {\n\t\tcifs_dbg(VFS, \"bad search response length %zd past smb end\\n\",\n\t\t\t de.namelen);\n\t\treturn -EINVAL;\n\t}\n\n\t/* skip . and .. since we added them first */\n\tif (cifs_entry_is_dot(&de, file_info->srch_inf.unicode))\n\t\treturn 0;\n\n\tif (file_info->srch_inf.unicode) {\n\t\tstruct nls_table *nlt = cifs_sb->local_nls;\n\t\tint map_type;\n\n\t\tmap_type = cifs_remap(cifs_sb);\n\t\tname.name = scratch_buf;\n\t\tname.len =\n\t\t\tcifs_from_utf16((char *)name.name, (__le16 *)de.name,\n\t\t\t\t\tUNICODE_NAME_MAX,\n\t\t\t\t\tmin_t(size_t, de.namelen,\n\t\t\t\t\t      (size_t)max_len), nlt, map_type);\n\t\tname.len -= nls_nullsize(nlt);\n\t} else {\n\t\tname.name = de.name;\n\t\tname.len = de.namelen;\n\t}\n\n\tswitch (file_info->srch_inf.info_level) {\n\tcase SMB_FIND_FILE_UNIX:\n\t\tcifs_unix_basic_to_fattr(&fattr,\n\t\t\t\t\t &((FILE_UNIX_INFO *)find_entry)->basic,\n\t\t\t\t\t cifs_sb);\n\t\tbreak;\n\tcase SMB_FIND_FILE_INFO_STANDARD:\n\t\tcifs_std_info_to_fattr(&fattr,\n\t\t\t\t       (FIND_FILE_STANDARD_INFO *)find_entry,\n\t\t\t\t       cifs_sb);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dir_info_to_fattr(&fattr,\n\t\t\t\t       (FILE_DIRECTORY_INFO *)find_entry,\n\t\t\t\t       cifs_sb);\n\t\tbreak;\n\t}\n\n\tif (de.ino && (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)) {\n\t\tfattr.cf_uniqueid = de.ino;\n\t} else {\n\t\tfattr.cf_uniqueid = iunique(sb, ROOT_I);\n\t\tcifs_autodisable_serverino(cifs_sb);\n\t}\n\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS) &&\n\t    couldbe_mf_symlink(&fattr))\n\t\t/*\n\t\t * trying to get the type and mode can be slow,\n\t\t * so just call those regular files for now, and mark\n\t\t * for reval\n\t\t */\n\t\tfattr.cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\tcifs_prime_dcache(file->f_path.dentry, &name, &fattr);\n\n\tino = cifs_uniqueid_to_ino_t(fattr.cf_uniqueid);\n\treturn !dir_emit(ctx, name.name, name.len, ino, fattr.cf_dtype);\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define UNICODE_NAME_MAX ((4 * NAME_MAX) + 2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "name.name",
            "name.len",
            "ino",
            "fattr.cf_dtype"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_uniqueid_to_ino_t",
          "args": [
            "fattr.cf_uniqueid"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_uniqueid_to_ino_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.h",
          "lines": "41-45",
          "snippet": "static inline ino_t\ncifs_uniqueid_to_ino_t(u64 fileid)\n{\n\treturn (ino_t)hash_64(fileid, (sizeof(ino_t) * 8) - 1) + 1;\n}",
          "includes": [
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n\nstatic inline ino_t\ncifs_uniqueid_to_ino_t(u64 fileid)\n{\n\treturn (ino_t)hash_64(fileid, (sizeof(ino_t) * 8) - 1) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_prime_dcache",
          "args": [
            "file->f_path.dentry",
            "&name",
            "&fattr"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_prime_dcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "75-135",
          "snippet": "static void\ncifs_prime_dcache(struct dentry *parent, struct qstr *name,\n\t\t    struct cifs_fattr *fattr)\n{\n\tstruct dentry *dentry, *alias;\n\tstruct inode *inode;\n\tstruct super_block *sb = parent->d_inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\n\tcifs_dbg(FYI, \"%s: for %s\\n\", __func__, name->name);\n\n\tdentry = d_hash_and_lookup(parent, name);\n\tif (unlikely(IS_ERR(dentry)))\n\t\treturn;\n\n\tif (dentry) {\n\t\tinode = dentry->d_inode;\n\t\tif (inode) {\n\t\t\t/*\n\t\t\t * If we're generating inode numbers, then we don't\n\t\t\t * want to clobber the existing one with the one that\n\t\t\t * the readdir code created.\n\t\t\t */\n\t\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM))\n\t\t\t\tfattr->cf_uniqueid = CIFS_I(inode)->uniqueid;\n\n\t\t\t/* update inode in place\n\t\t\t * if both i_ino and i_mode didn't change */\n\t\t\tif (CIFS_I(inode)->uniqueid == fattr->cf_uniqueid &&\n\t\t\t    (inode->i_mode & S_IFMT) ==\n\t\t\t    (fattr->cf_mode & S_IFMT)) {\n\t\t\t\tcifs_fattr_to_inode(inode, fattr);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t}\n\n\t/*\n\t * If we know that the inode will need to be revalidated immediately,\n\t * then don't create a new dentry for it. We'll end up doing an on\n\t * the wire call either way and this spares us an invalidation.\n\t */\n\tif (fattr->cf_flags & CIFS_FATTR_NEED_REVAL)\n\t\treturn;\n\n\tdentry = d_alloc(parent, name);\n\tif (!dentry)\n\t\treturn;\n\n\tinode = cifs_iget(sb, fattr);\n\tif (!inode)\n\t\tgoto out;\n\n\talias = d_splice_alias(inode, dentry);\n\tif (alias && !IS_ERR(alias))\n\t\tdput(alias);\nout:\n\tdput(dentry);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_prime_dcache(struct dentry *parent, struct qstr *name,\n\t\t    struct cifs_fattr *fattr)\n{\n\tstruct dentry *dentry, *alias;\n\tstruct inode *inode;\n\tstruct super_block *sb = parent->d_inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\n\tcifs_dbg(FYI, \"%s: for %s\\n\", __func__, name->name);\n\n\tdentry = d_hash_and_lookup(parent, name);\n\tif (unlikely(IS_ERR(dentry)))\n\t\treturn;\n\n\tif (dentry) {\n\t\tinode = dentry->d_inode;\n\t\tif (inode) {\n\t\t\t/*\n\t\t\t * If we're generating inode numbers, then we don't\n\t\t\t * want to clobber the existing one with the one that\n\t\t\t * the readdir code created.\n\t\t\t */\n\t\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM))\n\t\t\t\tfattr->cf_uniqueid = CIFS_I(inode)->uniqueid;\n\n\t\t\t/* update inode in place\n\t\t\t * if both i_ino and i_mode didn't change */\n\t\t\tif (CIFS_I(inode)->uniqueid == fattr->cf_uniqueid &&\n\t\t\t    (inode->i_mode & S_IFMT) ==\n\t\t\t    (fattr->cf_mode & S_IFMT)) {\n\t\t\t\tcifs_fattr_to_inode(inode, fattr);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t}\n\n\t/*\n\t * If we know that the inode will need to be revalidated immediately,\n\t * then don't create a new dentry for it. We'll end up doing an on\n\t * the wire call either way and this spares us an invalidation.\n\t */\n\tif (fattr->cf_flags & CIFS_FATTR_NEED_REVAL)\n\t\treturn;\n\n\tdentry = d_alloc(parent, name);\n\tif (!dentry)\n\t\treturn;\n\n\tinode = cifs_iget(sb, fattr);\n\tif (!inode)\n\t\tgoto out;\n\n\talias = d_splice_alias(inode, dentry);\n\tif (alias && !IS_ERR(alias))\n\t\tdput(alias);\nout:\n\tdput(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "couldbe_mf_symlink",
          "args": [
            "&fattr"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "couldbe_mf_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/link.c",
          "lines": "189-201",
          "snippet": "bool\ncouldbe_mf_symlink(const struct cifs_fattr *fattr)\n{\n\tif (!S_ISREG(fattr->cf_mode))\n\t\t/* it's not a symlink */\n\t\treturn false;\n\n\tif (fattr->cf_eof != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\t/* it's not a symlink */\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define CIFS_MF_SYMLINK_FILE_SIZE \\\n\t(CIFS_MF_SYMLINK_LINK_OFFSET + CIFS_MF_SYMLINK_LINK_MAXLEN)\n\nbool\ncouldbe_mf_symlink(const struct cifs_fattr *fattr)\n{\n\tif (!S_ISREG(fattr->cf_mode))\n\t\t/* it's not a symlink */\n\t\treturn false;\n\n\tif (fattr->cf_eof != CIFS_MF_SYMLINK_FILE_SIZE)\n\t\t/* it's not a symlink */\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_autodisable_serverino",
          "args": [
            "cifs_sb"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_autodisable_serverino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "523-531",
          "snippet": "void\ncifs_autodisable_serverino(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\n\t\tcifs_dbg(VFS, \"Autodisabling the use of server inode numbers on %s. This server doesn't seem to support them properly. Hardlinks will not be recognized on this mount. Consider mounting with the \\\"noserverino\\\" option to silence this message.\\n\",\n\t\t\t cifs_sb_master_tcon(cifs_sb)->treeName);\n\t}\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ncifs_autodisable_serverino(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\n\t\tcifs_dbg(VFS, \"Autodisabling the use of server inode numbers on %s. This server doesn't seem to support them properly. Hardlinks will not be recognized on this mount. Consider mounting with the \\\"noserverino\\\" option to silence this message.\\n\",\n\t\t\t cifs_sb_master_tcon(cifs_sb)->treeName);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iunique",
          "args": [
            "sb",
            "ROOT_I"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "iunique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1150-1170",
          "snippet": "ino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dir_info_to_fattr",
          "args": [
            "&fattr",
            "(FILE_DIRECTORY_INFO *)find_entry",
            "cifs_sb"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_dir_info_to_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "192-206",
          "snippet": "void\ncifs_dir_info_to_fattr(struct cifs_fattr *fattr, FILE_DIRECTORY_INFO *info,\n\t\t       struct cifs_sb_info *cifs_sb)\n{\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_cifsattrs = le32_to_cpu(info->ExtFileAttributes);\n\tfattr->cf_eof = le64_to_cpu(info->EndOfFile);\n\tfattr->cf_bytes = le64_to_cpu(info->AllocationSize);\n\tfattr->cf_createtime = le64_to_cpu(info->CreationTime);\n\tfattr->cf_atime = cifs_NTtimeToUnix(info->LastAccessTime);\n\tfattr->cf_ctime = cifs_NTtimeToUnix(info->ChangeTime);\n\tfattr->cf_mtime = cifs_NTtimeToUnix(info->LastWriteTime);\n\n\tcifs_fill_common_info(fattr, cifs_sb);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nvoid\ncifs_dir_info_to_fattr(struct cifs_fattr *fattr, FILE_DIRECTORY_INFO *info,\n\t\t       struct cifs_sb_info *cifs_sb)\n{\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_cifsattrs = le32_to_cpu(info->ExtFileAttributes);\n\tfattr->cf_eof = le64_to_cpu(info->EndOfFile);\n\tfattr->cf_bytes = le64_to_cpu(info->AllocationSize);\n\tfattr->cf_createtime = le64_to_cpu(info->CreationTime);\n\tfattr->cf_atime = cifs_NTtimeToUnix(info->LastAccessTime);\n\tfattr->cf_ctime = cifs_NTtimeToUnix(info->ChangeTime);\n\tfattr->cf_mtime = cifs_NTtimeToUnix(info->LastWriteTime);\n\n\tcifs_fill_common_info(fattr, cifs_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_std_info_to_fattr",
          "args": [
            "&fattr",
            "(FIND_FILE_STANDARD_INFO *)find_entry",
            "cifs_sb"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_std_info_to_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "208-227",
          "snippet": "static void\ncifs_std_info_to_fattr(struct cifs_fattr *fattr, FIND_FILE_STANDARD_INFO *info,\n\t\t       struct cifs_sb_info *cifs_sb)\n{\n\tint offset = cifs_sb_master_tcon(cifs_sb)->ses->server->timeAdj;\n\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_atime = cnvrtDosUnixTm(info->LastAccessDate,\n\t\t\t\t\t    info->LastAccessTime, offset);\n\tfattr->cf_ctime = cnvrtDosUnixTm(info->LastWriteDate,\n\t\t\t\t\t    info->LastWriteTime, offset);\n\tfattr->cf_mtime = cnvrtDosUnixTm(info->LastWriteDate,\n\t\t\t\t\t    info->LastWriteTime, offset);\n\n\tfattr->cf_cifsattrs = le16_to_cpu(info->Attributes);\n\tfattr->cf_bytes = le32_to_cpu(info->AllocationSize);\n\tfattr->cf_eof = le32_to_cpu(info->DataSize);\n\n\tcifs_fill_common_info(fattr, cifs_sb);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_std_info_to_fattr(struct cifs_fattr *fattr, FIND_FILE_STANDARD_INFO *info,\n\t\t       struct cifs_sb_info *cifs_sb)\n{\n\tint offset = cifs_sb_master_tcon(cifs_sb)->ses->server->timeAdj;\n\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_atime = cnvrtDosUnixTm(info->LastAccessDate,\n\t\t\t\t\t    info->LastAccessTime, offset);\n\tfattr->cf_ctime = cnvrtDosUnixTm(info->LastWriteDate,\n\t\t\t\t\t    info->LastWriteTime, offset);\n\tfattr->cf_mtime = cnvrtDosUnixTm(info->LastWriteDate,\n\t\t\t\t\t    info->LastWriteTime, offset);\n\n\tfattr->cf_cifsattrs = le16_to_cpu(info->Attributes);\n\tfattr->cf_bytes = le32_to_cpu(info->AllocationSize);\n\tfattr->cf_eof = le32_to_cpu(info->DataSize);\n\n\tcifs_fill_common_info(fattr, cifs_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_unix_basic_to_fattr",
          "args": [
            "&fattr",
            "&((FILE_UNIX_INFO *)find_entry)->basic",
            "cifs_sb"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nls_nullsize",
          "args": [
            "nlt"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_from_utf16",
          "args": [
            "(char *)name.name",
            "(__le16 *)de.name",
            "UNICODE_NAME_MAX",
            "min_t(size_t, de.namelen,\n\t\t\t\t\t      (size_t)max_len)",
            "nlt",
            "map_type"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_from_utf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "200-244",
          "snippet": "int\ncifs_from_utf16(char *to, const __le16 *from, int tolen, int fromlen,\n\t\tconst struct nls_table *codepage, int map_type)\n{\n\tint i, charlen, safelen;\n\tint outlen = 0;\n\tint nullsize = nls_nullsize(codepage);\n\tint fromwords = fromlen / 2;\n\tchar tmp[NLS_MAX_CHARSET_SIZE];\n\t__u16 ftmp;\n\n\t/*\n\t * because the chars can be of varying widths, we need to take care\n\t * not to overflow the destination buffer when we get close to the\n\t * end of it. Until we get to this offset, we don't need to check\n\t * for overflow however.\n\t */\n\tsafelen = tolen - (NLS_MAX_CHARSET_SIZE + nullsize);\n\n\tfor (i = 0; i < fromwords; i++) {\n\t\tftmp = get_unaligned_le16(&from[i]);\n\t\tif (ftmp == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * check to see if converting this character might make the\n\t\t * conversion bleed into the null terminator\n\t\t */\n\t\tif (outlen >= safelen) {\n\t\t\tcharlen = cifs_mapchar(tmp, ftmp, codepage, map_type);\n\t\t\tif ((outlen + charlen) > (tolen - nullsize))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* put converted char into 'to' buffer */\n\t\tcharlen = cifs_mapchar(&to[outlen], ftmp, codepage, map_type);\n\t\toutlen += charlen;\n\t}\n\n\t/* properly null-terminate string */\n\tfor (i = 0; i < nullsize; i++)\n\t\tto[outlen++] = 0;\n\n\treturn outlen;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_from_utf16(char *to, const __le16 *from, int tolen, int fromlen,\n\t\tconst struct nls_table *codepage, int map_type)\n{\n\tint i, charlen, safelen;\n\tint outlen = 0;\n\tint nullsize = nls_nullsize(codepage);\n\tint fromwords = fromlen / 2;\n\tchar tmp[NLS_MAX_CHARSET_SIZE];\n\t__u16 ftmp;\n\n\t/*\n\t * because the chars can be of varying widths, we need to take care\n\t * not to overflow the destination buffer when we get close to the\n\t * end of it. Until we get to this offset, we don't need to check\n\t * for overflow however.\n\t */\n\tsafelen = tolen - (NLS_MAX_CHARSET_SIZE + nullsize);\n\n\tfor (i = 0; i < fromwords; i++) {\n\t\tftmp = get_unaligned_le16(&from[i]);\n\t\tif (ftmp == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * check to see if converting this character might make the\n\t\t * conversion bleed into the null terminator\n\t\t */\n\t\tif (outlen >= safelen) {\n\t\t\tcharlen = cifs_mapchar(tmp, ftmp, codepage, map_type);\n\t\t\tif ((outlen + charlen) > (tolen - nullsize))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* put converted char into 'to' buffer */\n\t\tcharlen = cifs_mapchar(&to[outlen], ftmp, codepage, map_type);\n\t\toutlen += charlen;\n\t}\n\n\t/* properly null-terminate string */\n\tfor (i = 0; i < nullsize; i++)\n\t\tto[outlen++] = 0;\n\n\treturn outlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "de.namelen",
            "(size_t)max_len"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_remap",
          "args": [
            "cifs_sb"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "65-77",
          "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_entry_is_dot",
          "args": [
            "&de",
            "file_info->srch_inf.unicode"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_entry_is_dot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "489-519",
          "snippet": "static int cifs_entry_is_dot(struct cifs_dirent *de, bool is_unicode)\n{\n\tint rc = 0;\n\n\tif (!de->name)\n\t\treturn 0;\n\n\tif (is_unicode) {\n\t\t__le16 *ufilename = (__le16 *)de->name;\n\t\tif (de->namelen == 2) {\n\t\t\t/* check for . */\n\t\t\tif (ufilename[0] == UNICODE_DOT)\n\t\t\t\trc = 1;\n\t\t} else if (de->namelen == 4) {\n\t\t\t/* check for .. */\n\t\t\tif (ufilename[0] == UNICODE_DOT &&\n\t\t\t    ufilename[1] == UNICODE_DOT)\n\t\t\t\trc = 2;\n\t\t}\n\t} else /* ASCII */ {\n\t\tif (de->namelen == 1) {\n\t\t\tif (de->name[0] == '.')\n\t\t\t\trc = 1;\n\t\t} else if (de->namelen == 2) {\n\t\t\tif (de->name[0] == '.' && de->name[1] == '.')\n\t\t\t\trc = 2;\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define UNICODE_DOT cpu_to_le16(0x2e)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define UNICODE_DOT cpu_to_le16(0x2e)\n\nstatic int cifs_entry_is_dot(struct cifs_dirent *de, bool is_unicode)\n{\n\tint rc = 0;\n\n\tif (!de->name)\n\t\treturn 0;\n\n\tif (is_unicode) {\n\t\t__le16 *ufilename = (__le16 *)de->name;\n\t\tif (de->namelen == 2) {\n\t\t\t/* check for . */\n\t\t\tif (ufilename[0] == UNICODE_DOT)\n\t\t\t\trc = 1;\n\t\t} else if (de->namelen == 4) {\n\t\t\t/* check for .. */\n\t\t\tif (ufilename[0] == UNICODE_DOT &&\n\t\t\t    ufilename[1] == UNICODE_DOT)\n\t\t\t\trc = 2;\n\t\t}\n\t} else /* ASCII */ {\n\t\tif (de->namelen == 1) {\n\t\t\tif (de->name[0] == '.')\n\t\t\t\trc = 1;\n\t\t} else if (de->namelen == 2) {\n\t\t\tif (de->name[0] == '.' && de->name[1] == '.')\n\t\t\t\trc = 2;\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"bad search response length %zd past smb end\\n\"",
            "de.namelen"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_fill_dirent",
          "args": [
            "&de",
            "find_entry",
            "file_info->srch_inf.info_level",
            "file_info->srch_inf.unicode"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fill_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "454-484",
          "snippet": "static int cifs_fill_dirent(struct cifs_dirent *de, const void *info,\n\t\tu16 level, bool is_unicode)\n{\n\tmemset(de, 0, sizeof(*de));\n\n\tswitch (level) {\n\tcase SMB_FIND_FILE_UNIX:\n\t\tcifs_fill_dirent_unix(de, info, is_unicode);\n\t\tbreak;\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_dir(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_FULL_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_full(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\tcifs_fill_dirent_search(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_BOTH_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_both(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_INFO_STANDARD:\n\t\tcifs_fill_dirent_std(de, info);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(FYI, \"Unknown findfirst level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int cifs_fill_dirent(struct cifs_dirent *de, const void *info,\n\t\tu16 level, bool is_unicode)\n{\n\tmemset(de, 0, sizeof(*de));\n\n\tswitch (level) {\n\tcase SMB_FIND_FILE_UNIX:\n\t\tcifs_fill_dirent_unix(de, info, is_unicode);\n\t\tbreak;\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_dir(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_FULL_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_full(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\tcifs_fill_dirent_search(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_BOTH_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_both(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_INFO_STANDARD:\n\t\tcifs_fill_dirent_std(de, info);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(FYI, \"Unknown findfirst level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "sb"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define UNICODE_NAME_MAX ((4 * NAME_MAX) + 2)\n\nstatic int cifs_filldir(char *find_entry, struct file *file,\n\t\tstruct dir_context *ctx,\n\t\tchar *scratch_buf, unsigned int max_len)\n{\n\tstruct cifsFileInfo *file_info = file->private_data;\n\tstruct super_block *sb = file_inode(file)->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_dirent de = { NULL, };\n\tstruct cifs_fattr fattr;\n\tstruct qstr name;\n\tint rc = 0;\n\tino_t ino;\n\n\trc = cifs_fill_dirent(&de, find_entry, file_info->srch_inf.info_level,\n\t\t\t      file_info->srch_inf.unicode);\n\tif (rc)\n\t\treturn rc;\n\n\tif (de.namelen > max_len) {\n\t\tcifs_dbg(VFS, \"bad search response length %zd past smb end\\n\",\n\t\t\t de.namelen);\n\t\treturn -EINVAL;\n\t}\n\n\t/* skip . and .. since we added them first */\n\tif (cifs_entry_is_dot(&de, file_info->srch_inf.unicode))\n\t\treturn 0;\n\n\tif (file_info->srch_inf.unicode) {\n\t\tstruct nls_table *nlt = cifs_sb->local_nls;\n\t\tint map_type;\n\n\t\tmap_type = cifs_remap(cifs_sb);\n\t\tname.name = scratch_buf;\n\t\tname.len =\n\t\t\tcifs_from_utf16((char *)name.name, (__le16 *)de.name,\n\t\t\t\t\tUNICODE_NAME_MAX,\n\t\t\t\t\tmin_t(size_t, de.namelen,\n\t\t\t\t\t      (size_t)max_len), nlt, map_type);\n\t\tname.len -= nls_nullsize(nlt);\n\t} else {\n\t\tname.name = de.name;\n\t\tname.len = de.namelen;\n\t}\n\n\tswitch (file_info->srch_inf.info_level) {\n\tcase SMB_FIND_FILE_UNIX:\n\t\tcifs_unix_basic_to_fattr(&fattr,\n\t\t\t\t\t &((FILE_UNIX_INFO *)find_entry)->basic,\n\t\t\t\t\t cifs_sb);\n\t\tbreak;\n\tcase SMB_FIND_FILE_INFO_STANDARD:\n\t\tcifs_std_info_to_fattr(&fattr,\n\t\t\t\t       (FIND_FILE_STANDARD_INFO *)find_entry,\n\t\t\t\t       cifs_sb);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dir_info_to_fattr(&fattr,\n\t\t\t\t       (FILE_DIRECTORY_INFO *)find_entry,\n\t\t\t\t       cifs_sb);\n\t\tbreak;\n\t}\n\n\tif (de.ino && (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)) {\n\t\tfattr.cf_uniqueid = de.ino;\n\t} else {\n\t\tfattr.cf_uniqueid = iunique(sb, ROOT_I);\n\t\tcifs_autodisable_serverino(cifs_sb);\n\t}\n\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS) &&\n\t    couldbe_mf_symlink(&fattr))\n\t\t/*\n\t\t * trying to get the type and mode can be slow,\n\t\t * so just call those regular files for now, and mark\n\t\t * for reval\n\t\t */\n\t\tfattr.cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\tcifs_prime_dcache(file->f_path.dentry, &name, &fattr);\n\n\tino = cifs_uniqueid_to_ino_t(fattr.cf_uniqueid);\n\treturn !dir_emit(ctx, name.name, name.len, ino, fattr.cf_dtype);\n}"
  },
  {
    "function_name": "find_cifs_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "558-679",
    "snippet": "static int\nfind_cifs_entry(const unsigned int xid, struct cifs_tcon *tcon, loff_t pos,\n\t\tstruct file *file, char **current_entry, int *num_to_ret)\n{\n\t__u16 search_flags;\n\tint rc = 0;\n\tint pos_in_buf = 0;\n\tloff_t first_entry_in_buffer;\n\tloff_t index_to_find = pos;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t/* check if index in the buffer */\n\n\tif (!server->ops->query_dir_first || !server->ops->query_dir_next)\n\t\treturn -ENOSYS;\n\n\tif ((cfile == NULL) || (current_entry == NULL) || (num_to_ret == NULL))\n\t\treturn -ENOENT;\n\n\t*current_entry = NULL;\n\tfirst_entry_in_buffer = cfile->srch_inf.index_of_last_entry -\n\t\t\t\t\tcfile->srch_inf.entries_in_buffer;\n\n\t/*\n\t * If first entry in buf is zero then is first buffer\n\t * in search response data which means it is likely . and ..\n\t * will be in this buffer, although some servers do not return\n\t * . and .. for the root of a drive and for those we need\n\t * to start two entries earlier.\n\t */\n\n\tdump_cifs_file_struct(file, \"In fce \");\n\tif (((index_to_find < cfile->srch_inf.index_of_last_entry) &&\n\t     is_dir_changed(file)) || (index_to_find < first_entry_in_buffer)) {\n\t\t/* close and restart search */\n\t\tcifs_dbg(FYI, \"search backing up - close and restart search\\n\");\n\t\tspin_lock(&cifs_file_list_lock);\n\t\tif (server->ops->dir_needs_close(cfile)) {\n\t\t\tcfile->invalidHandle = true;\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tif (server->ops->close_dir)\n\t\t\t\tserver->ops->close_dir(xid, tcon, &cfile->fid);\n\t\t} else\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\tif (cfile->srch_inf.ntwrk_buf_start) {\n\t\t\tcifs_dbg(FYI, \"freeing SMB ff cache buf on search rewind\\n\");\n\t\t\tif (cfile->srch_inf.smallBuf)\n\t\t\t\tcifs_small_buf_release(cfile->srch_inf.\n\t\t\t\t\t\tntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(cfile->srch_inf.\n\t\t\t\t\t\tntwrk_buf_start);\n\t\t\tcfile->srch_inf.ntwrk_buf_start = NULL;\n\t\t}\n\t\trc = initiate_cifs_search(xid, file);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"error %d reinitiating a search on rewind\\n\",\n\t\t\t\t rc);\n\t\t\treturn rc;\n\t\t}\n\t\t/* FindFirst/Next set last_entry to NULL on malformed reply */\n\t\tif (cfile->srch_inf.last_entry)\n\t\t\tcifs_save_resume_key(cfile->srch_inf.last_entry, cfile);\n\t}\n\n\tsearch_flags = CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME;\n\tif (backup_cred(cifs_sb))\n\t\tsearch_flags |= CIFS_SEARCH_BACKUP_SEARCH;\n\n\twhile ((index_to_find >= cfile->srch_inf.index_of_last_entry) &&\n\t       (rc == 0) && !cfile->srch_inf.endOfSearch) {\n\t\tcifs_dbg(FYI, \"calling findnext2\\n\");\n\t\trc = server->ops->query_dir_next(xid, tcon, &cfile->fid,\n\t\t\t\t\t\t search_flags,\n\t\t\t\t\t\t &cfile->srch_inf);\n\t\t/* FindFirst/Next set last_entry to NULL on malformed reply */\n\t\tif (cfile->srch_inf.last_entry)\n\t\t\tcifs_save_resume_key(cfile->srch_inf.last_entry, cfile);\n\t\tif (rc)\n\t\t\treturn -ENOENT;\n\t}\n\tif (index_to_find < cfile->srch_inf.index_of_last_entry) {\n\t\t/* we found the buffer that contains the entry */\n\t\t/* scan and find it */\n\t\tint i;\n\t\tchar *cur_ent;\n\t\tchar *end_of_smb = cfile->srch_inf.ntwrk_buf_start +\n\t\t\tserver->ops->calc_smb_size(\n\t\t\t\t\tcfile->srch_inf.ntwrk_buf_start);\n\n\t\tcur_ent = cfile->srch_inf.srch_entries_start;\n\t\tfirst_entry_in_buffer = cfile->srch_inf.index_of_last_entry\n\t\t\t\t\t- cfile->srch_inf.entries_in_buffer;\n\t\tpos_in_buf = index_to_find - first_entry_in_buffer;\n\t\tcifs_dbg(FYI, \"found entry - pos_in_buf %d\\n\", pos_in_buf);\n\n\t\tfor (i = 0; (i < (pos_in_buf)) && (cur_ent != NULL); i++) {\n\t\t\t/* go entry by entry figuring out which is first */\n\t\t\tcur_ent = nxt_dir_entry(cur_ent, end_of_smb,\n\t\t\t\t\t\tcfile->srch_inf.info_level);\n\t\t}\n\t\tif ((cur_ent == NULL) && (i < pos_in_buf)) {\n\t\t\t/* BB fixme - check if we should flag this error */\n\t\t\tcifs_dbg(VFS, \"reached end of buf searching for pos in buf %d index to find %lld rc %d\\n\",\n\t\t\t\t pos_in_buf, index_to_find, rc);\n\t\t}\n\t\trc = 0;\n\t\t*current_entry = cur_ent;\n\t} else {\n\t\tcifs_dbg(FYI, \"index not in buffer - could not findnext into it\\n\");\n\t\treturn 0;\n\t}\n\n\tif (pos_in_buf >= cfile->srch_inf.entries_in_buffer) {\n\t\tcifs_dbg(FYI, \"can not return entries pos_in_buf beyond last\\n\");\n\t\t*num_to_ret = 0;\n\t} else\n\t\t*num_to_ret = cfile->srch_inf.entries_in_buffer - pos_in_buf;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"can not return entries pos_in_buf beyond last\\n\""
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"index not in buffer - could not findnext into it\\n\""
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"reached end of buf searching for pos in buf %d index to find %lld rc %d\\n\"",
            "pos_in_buf",
            "index_to_find",
            "rc"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nxt_dir_entry",
          "args": [
            "cur_ent",
            "end_of_smb",
            "cfile->srch_inf.info_level"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "nxt_dir_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "362-391",
          "snippet": "static char *nxt_dir_entry(char *old_entry, char *end_of_smb, int level)\n{\n\tchar *new_entry;\n\tFILE_DIRECTORY_INFO *pDirInfo = (FILE_DIRECTORY_INFO *)old_entry;\n\n\tif (level == SMB_FIND_FILE_INFO_STANDARD) {\n\t\tFIND_FILE_STANDARD_INFO *pfData;\n\t\tpfData = (FIND_FILE_STANDARD_INFO *)pDirInfo;\n\n\t\tnew_entry = old_entry + sizeof(FIND_FILE_STANDARD_INFO) +\n\t\t\t\tpfData->FileNameLength;\n\t} else\n\t\tnew_entry = old_entry + le32_to_cpu(pDirInfo->NextEntryOffset);\n\tcifs_dbg(FYI, \"new entry %p old entry %p\\n\", new_entry, old_entry);\n\t/* validate that new_entry is not past end of SMB */\n\tif (new_entry >= end_of_smb) {\n\t\tcifs_dbg(VFS, \"search entry %p began after end of SMB %p old entry %p\\n\",\n\t\t\t new_entry, end_of_smb, old_entry);\n\t\treturn NULL;\n\t} else if (((level == SMB_FIND_FILE_INFO_STANDARD) &&\n\t\t    (new_entry + sizeof(FIND_FILE_STANDARD_INFO) > end_of_smb))\n\t\t  || ((level != SMB_FIND_FILE_INFO_STANDARD) &&\n\t\t   (new_entry + sizeof(FILE_DIRECTORY_INFO) > end_of_smb)))  {\n\t\tcifs_dbg(VFS, \"search entry %p extends after end of SMB %p\\n\",\n\t\t\t new_entry, end_of_smb);\n\t\treturn NULL;\n\t} else\n\t\treturn new_entry;\n\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic char *nxt_dir_entry(char *old_entry, char *end_of_smb, int level)\n{\n\tchar *new_entry;\n\tFILE_DIRECTORY_INFO *pDirInfo = (FILE_DIRECTORY_INFO *)old_entry;\n\n\tif (level == SMB_FIND_FILE_INFO_STANDARD) {\n\t\tFIND_FILE_STANDARD_INFO *pfData;\n\t\tpfData = (FIND_FILE_STANDARD_INFO *)pDirInfo;\n\n\t\tnew_entry = old_entry + sizeof(FIND_FILE_STANDARD_INFO) +\n\t\t\t\tpfData->FileNameLength;\n\t} else\n\t\tnew_entry = old_entry + le32_to_cpu(pDirInfo->NextEntryOffset);\n\tcifs_dbg(FYI, \"new entry %p old entry %p\\n\", new_entry, old_entry);\n\t/* validate that new_entry is not past end of SMB */\n\tif (new_entry >= end_of_smb) {\n\t\tcifs_dbg(VFS, \"search entry %p began after end of SMB %p old entry %p\\n\",\n\t\t\t new_entry, end_of_smb, old_entry);\n\t\treturn NULL;\n\t} else if (((level == SMB_FIND_FILE_INFO_STANDARD) &&\n\t\t    (new_entry + sizeof(FIND_FILE_STANDARD_INFO) > end_of_smb))\n\t\t  || ((level != SMB_FIND_FILE_INFO_STANDARD) &&\n\t\t   (new_entry + sizeof(FILE_DIRECTORY_INFO) > end_of_smb)))  {\n\t\tcifs_dbg(VFS, \"search entry %p extends after end of SMB %p\\n\",\n\t\t\t new_entry, end_of_smb);\n\t\treturn NULL;\n\t} else\n\t\treturn new_entry;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"found entry - pos_in_buf %d\\n\"",
            "pos_in_buf"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->calc_smb_size",
          "args": [
            "cfile->srch_inf.ntwrk_buf_start"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_save_resume_key",
          "args": [
            "cfile->srch_inf.last_entry",
            "cfile"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_save_resume_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "535-549",
          "snippet": "static int cifs_save_resume_key(const char *current_entry,\n\tstruct cifsFileInfo *file_info)\n{\n\tstruct cifs_dirent de;\n\tint rc;\n\n\trc = cifs_fill_dirent(&de, current_entry, file_info->srch_inf.info_level,\n\t\t\t      file_info->srch_inf.unicode);\n\tif (!rc) {\n\t\tfile_info->srch_inf.presume_name = de.name;\n\t\tfile_info->srch_inf.resume_name_len = de.namelen;\n\t\tfile_info->srch_inf.resume_key = de.resume_key;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int cifs_save_resume_key(const char *current_entry,\n\tstruct cifsFileInfo *file_info)\n{\n\tstruct cifs_dirent de;\n\tint rc;\n\n\trc = cifs_fill_dirent(&de, current_entry, file_info->srch_inf.info_level,\n\t\t\t      file_info->srch_inf.unicode);\n\tif (!rc) {\n\t\tfile_info->srch_inf.presume_name = de.name;\n\t\tfile_info->srch_inf.resume_name_len = de.namelen;\n\t\tfile_info->srch_inf.resume_key = de.resume_key;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->query_dir_next",
          "args": [
            "xid",
            "tcon",
            "&cfile->fid",
            "search_flags",
            "&cfile->srch_inf"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"calling findnext2\\n\""
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backup_cred",
          "args": [
            "cifs_sb"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "backup_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "598-611",
          "snippet": "bool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nbool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"error %d reinitiating a search on rewind\\n\"",
            "rc"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initiate_cifs_search",
          "args": [
            "xid",
            "file"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "initiate_cifs_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "261-346",
          "snippet": "static int\ninitiate_cifs_search(const unsigned int xid, struct file *file)\n{\n\t__u16 search_flags;\n\tint rc = 0;\n\tchar *full_path = NULL;\n\tstruct cifsFileInfo *cifsFile;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct tcon_link *tlink = NULL;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\n\tif (file->private_data == NULL) {\n\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\tif (IS_ERR(tlink))\n\t\t\treturn PTR_ERR(tlink);\n\n\t\tcifsFile = kzalloc(sizeof(struct cifsFileInfo), GFP_KERNEL);\n\t\tif (cifsFile == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto error_exit;\n\t\t}\n\t\tfile->private_data = cifsFile;\n\t\tcifsFile->tlink = cifs_get_tlink(tlink);\n\t\ttcon = tlink_tcon(tlink);\n\t} else {\n\t\tcifsFile = file->private_data;\n\t\ttcon = tlink_tcon(cifsFile->tlink);\n\t}\n\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->query_dir_first) {\n\t\trc = -ENOSYS;\n\t\tgoto error_exit;\n\t}\n\n\tcifsFile->invalidHandle = true;\n\tcifsFile->srch_inf.endOfSearch = false;\n\n\tfull_path = build_path_from_dentry(file->f_path.dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto error_exit;\n\t}\n\n\tcifs_dbg(FYI, \"Full path: %s start at: %lld\\n\", full_path, file->f_pos);\n\nffirst_retry:\n\t/* test for Unix extensions */\n\t/* but now check for them on the share/mount not on the SMB session */\n\t/* if (cap_unix(tcon->ses) { */\n\tif (tcon->unix_ext)\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_UNIX;\n\telse if ((tcon->ses->capabilities &\n\t\t  tcon->ses->server->vals->cap_nt_find) == 0) {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_INFO_STANDARD;\n\t} else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_ID_FULL_DIR_INFO;\n\t} else /* not srvinos - BB fixme add check for backlevel? */ {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_DIRECTORY_INFO;\n\t}\n\n\tsearch_flags = CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME;\n\tif (backup_cred(cifs_sb))\n\t\tsearch_flags |= CIFS_SEARCH_BACKUP_SEARCH;\n\n\trc = server->ops->query_dir_first(xid, tcon, full_path, cifs_sb,\n\t\t\t\t\t  &cifsFile->fid, search_flags,\n\t\t\t\t\t  &cifsFile->srch_inf);\n\n\tif (rc == 0)\n\t\tcifsFile->invalidHandle = false;\n\t/* BB add following call to handle readdir on new NTFS symlink errors\n\telse if STATUS_STOPPED_ON_SYMLINK\n\t\tcall get_symlink_reparse_path and retry with new path */\n\telse if ((rc == -EOPNOTSUPP) &&\n\t\t(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)) {\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\n\t\tgoto ffirst_retry;\n\t}\nerror_exit:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int\ninitiate_cifs_search(const unsigned int xid, struct file *file)\n{\n\t__u16 search_flags;\n\tint rc = 0;\n\tchar *full_path = NULL;\n\tstruct cifsFileInfo *cifsFile;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct tcon_link *tlink = NULL;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\n\tif (file->private_data == NULL) {\n\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\tif (IS_ERR(tlink))\n\t\t\treturn PTR_ERR(tlink);\n\n\t\tcifsFile = kzalloc(sizeof(struct cifsFileInfo), GFP_KERNEL);\n\t\tif (cifsFile == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto error_exit;\n\t\t}\n\t\tfile->private_data = cifsFile;\n\t\tcifsFile->tlink = cifs_get_tlink(tlink);\n\t\ttcon = tlink_tcon(tlink);\n\t} else {\n\t\tcifsFile = file->private_data;\n\t\ttcon = tlink_tcon(cifsFile->tlink);\n\t}\n\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->query_dir_first) {\n\t\trc = -ENOSYS;\n\t\tgoto error_exit;\n\t}\n\n\tcifsFile->invalidHandle = true;\n\tcifsFile->srch_inf.endOfSearch = false;\n\n\tfull_path = build_path_from_dentry(file->f_path.dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto error_exit;\n\t}\n\n\tcifs_dbg(FYI, \"Full path: %s start at: %lld\\n\", full_path, file->f_pos);\n\nffirst_retry:\n\t/* test for Unix extensions */\n\t/* but now check for them on the share/mount not on the SMB session */\n\t/* if (cap_unix(tcon->ses) { */\n\tif (tcon->unix_ext)\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_UNIX;\n\telse if ((tcon->ses->capabilities &\n\t\t  tcon->ses->server->vals->cap_nt_find) == 0) {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_INFO_STANDARD;\n\t} else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_ID_FULL_DIR_INFO;\n\t} else /* not srvinos - BB fixme add check for backlevel? */ {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_DIRECTORY_INFO;\n\t}\n\n\tsearch_flags = CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME;\n\tif (backup_cred(cifs_sb))\n\t\tsearch_flags |= CIFS_SEARCH_BACKUP_SEARCH;\n\n\trc = server->ops->query_dir_first(xid, tcon, full_path, cifs_sb,\n\t\t\t\t\t  &cifsFile->fid, search_flags,\n\t\t\t\t\t  &cifsFile->srch_inf);\n\n\tif (rc == 0)\n\t\tcifsFile->invalidHandle = false;\n\t/* BB add following call to handle readdir on new NTFS symlink errors\n\telse if STATUS_STOPPED_ON_SYMLINK\n\t\tcall get_symlink_reparse_path and retry with new path */\n\telse if ((rc == -EOPNOTSUPP) &&\n\t\t(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)) {\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\n\t\tgoto ffirst_retry;\n\t}\nerror_exit:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "cfile->srch_inf.\n\t\t\t\t\t\tntwrk_buf_start"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_small_buf_release",
          "args": [
            "cfile->srch_inf.\n\t\t\t\t\t\tntwrk_buf_start"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "215-227",
          "snippet": "void\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"freeing SMB ff cache buf on search rewind\\n\""
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->close_dir",
          "args": [
            "xid",
            "tcon",
            "&cfile->fid"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->dir_needs_close",
          "args": [
            "cfile"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"search backing up - close and restart search\\n\""
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_dir_changed",
          "args": [
            "file"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "is_dir_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "523-533",
          "snippet": "static int is_dir_changed(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct cifsInodeInfo *cifsInfo = CIFS_I(inode);\n\n\tif (cifsInfo->time == 0)\n\t\treturn 1; /* directory was changed, perhaps due to unlink */\n\telse\n\t\treturn 0;\n\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int is_dir_changed(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct cifsInodeInfo *cifsInfo = CIFS_I(inode);\n\n\tif (cifsInfo->time == 0)\n\t\treturn 1; /* directory was changed, perhaps due to unlink */\n\telse\n\t\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_cifs_file_struct",
          "args": [
            "file",
            "\"In fce \""
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "dump_cifs_file_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "63-65",
          "snippet": "static inline void dump_cifs_file_struct(struct file *file, char *label)\n{\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline void dump_cifs_file_struct(struct file *file, char *label)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_FILE_SB",
          "args": [
            "file"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_FILE_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1171-1175",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int\nfind_cifs_entry(const unsigned int xid, struct cifs_tcon *tcon, loff_t pos,\n\t\tstruct file *file, char **current_entry, int *num_to_ret)\n{\n\t__u16 search_flags;\n\tint rc = 0;\n\tint pos_in_buf = 0;\n\tloff_t first_entry_in_buffer;\n\tloff_t index_to_find = pos;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t/* check if index in the buffer */\n\n\tif (!server->ops->query_dir_first || !server->ops->query_dir_next)\n\t\treturn -ENOSYS;\n\n\tif ((cfile == NULL) || (current_entry == NULL) || (num_to_ret == NULL))\n\t\treturn -ENOENT;\n\n\t*current_entry = NULL;\n\tfirst_entry_in_buffer = cfile->srch_inf.index_of_last_entry -\n\t\t\t\t\tcfile->srch_inf.entries_in_buffer;\n\n\t/*\n\t * If first entry in buf is zero then is first buffer\n\t * in search response data which means it is likely . and ..\n\t * will be in this buffer, although some servers do not return\n\t * . and .. for the root of a drive and for those we need\n\t * to start two entries earlier.\n\t */\n\n\tdump_cifs_file_struct(file, \"In fce \");\n\tif (((index_to_find < cfile->srch_inf.index_of_last_entry) &&\n\t     is_dir_changed(file)) || (index_to_find < first_entry_in_buffer)) {\n\t\t/* close and restart search */\n\t\tcifs_dbg(FYI, \"search backing up - close and restart search\\n\");\n\t\tspin_lock(&cifs_file_list_lock);\n\t\tif (server->ops->dir_needs_close(cfile)) {\n\t\t\tcfile->invalidHandle = true;\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tif (server->ops->close_dir)\n\t\t\t\tserver->ops->close_dir(xid, tcon, &cfile->fid);\n\t\t} else\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\tif (cfile->srch_inf.ntwrk_buf_start) {\n\t\t\tcifs_dbg(FYI, \"freeing SMB ff cache buf on search rewind\\n\");\n\t\t\tif (cfile->srch_inf.smallBuf)\n\t\t\t\tcifs_small_buf_release(cfile->srch_inf.\n\t\t\t\t\t\tntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(cfile->srch_inf.\n\t\t\t\t\t\tntwrk_buf_start);\n\t\t\tcfile->srch_inf.ntwrk_buf_start = NULL;\n\t\t}\n\t\trc = initiate_cifs_search(xid, file);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"error %d reinitiating a search on rewind\\n\",\n\t\t\t\t rc);\n\t\t\treturn rc;\n\t\t}\n\t\t/* FindFirst/Next set last_entry to NULL on malformed reply */\n\t\tif (cfile->srch_inf.last_entry)\n\t\t\tcifs_save_resume_key(cfile->srch_inf.last_entry, cfile);\n\t}\n\n\tsearch_flags = CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME;\n\tif (backup_cred(cifs_sb))\n\t\tsearch_flags |= CIFS_SEARCH_BACKUP_SEARCH;\n\n\twhile ((index_to_find >= cfile->srch_inf.index_of_last_entry) &&\n\t       (rc == 0) && !cfile->srch_inf.endOfSearch) {\n\t\tcifs_dbg(FYI, \"calling findnext2\\n\");\n\t\trc = server->ops->query_dir_next(xid, tcon, &cfile->fid,\n\t\t\t\t\t\t search_flags,\n\t\t\t\t\t\t &cfile->srch_inf);\n\t\t/* FindFirst/Next set last_entry to NULL on malformed reply */\n\t\tif (cfile->srch_inf.last_entry)\n\t\t\tcifs_save_resume_key(cfile->srch_inf.last_entry, cfile);\n\t\tif (rc)\n\t\t\treturn -ENOENT;\n\t}\n\tif (index_to_find < cfile->srch_inf.index_of_last_entry) {\n\t\t/* we found the buffer that contains the entry */\n\t\t/* scan and find it */\n\t\tint i;\n\t\tchar *cur_ent;\n\t\tchar *end_of_smb = cfile->srch_inf.ntwrk_buf_start +\n\t\t\tserver->ops->calc_smb_size(\n\t\t\t\t\tcfile->srch_inf.ntwrk_buf_start);\n\n\t\tcur_ent = cfile->srch_inf.srch_entries_start;\n\t\tfirst_entry_in_buffer = cfile->srch_inf.index_of_last_entry\n\t\t\t\t\t- cfile->srch_inf.entries_in_buffer;\n\t\tpos_in_buf = index_to_find - first_entry_in_buffer;\n\t\tcifs_dbg(FYI, \"found entry - pos_in_buf %d\\n\", pos_in_buf);\n\n\t\tfor (i = 0; (i < (pos_in_buf)) && (cur_ent != NULL); i++) {\n\t\t\t/* go entry by entry figuring out which is first */\n\t\t\tcur_ent = nxt_dir_entry(cur_ent, end_of_smb,\n\t\t\t\t\t\tcfile->srch_inf.info_level);\n\t\t}\n\t\tif ((cur_ent == NULL) && (i < pos_in_buf)) {\n\t\t\t/* BB fixme - check if we should flag this error */\n\t\t\tcifs_dbg(VFS, \"reached end of buf searching for pos in buf %d index to find %lld rc %d\\n\",\n\t\t\t\t pos_in_buf, index_to_find, rc);\n\t\t}\n\t\trc = 0;\n\t\t*current_entry = cur_ent;\n\t} else {\n\t\tcifs_dbg(FYI, \"index not in buffer - could not findnext into it\\n\");\n\t\treturn 0;\n\t}\n\n\tif (pos_in_buf >= cfile->srch_inf.entries_in_buffer) {\n\t\tcifs_dbg(FYI, \"can not return entries pos_in_buf beyond last\\n\");\n\t\t*num_to_ret = 0;\n\t} else\n\t\t*num_to_ret = cfile->srch_inf.entries_in_buffer - pos_in_buf;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_save_resume_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "535-549",
    "snippet": "static int cifs_save_resume_key(const char *current_entry,\n\tstruct cifsFileInfo *file_info)\n{\n\tstruct cifs_dirent de;\n\tint rc;\n\n\trc = cifs_fill_dirent(&de, current_entry, file_info->srch_inf.info_level,\n\t\t\t      file_info->srch_inf.unicode);\n\tif (!rc) {\n\t\tfile_info->srch_inf.presume_name = de.name;\n\t\tfile_info->srch_inf.resume_name_len = de.namelen;\n\t\tfile_info->srch_inf.resume_key = de.resume_key;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_fill_dirent",
          "args": [
            "&de",
            "current_entry",
            "file_info->srch_inf.info_level",
            "file_info->srch_inf.unicode"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fill_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "454-484",
          "snippet": "static int cifs_fill_dirent(struct cifs_dirent *de, const void *info,\n\t\tu16 level, bool is_unicode)\n{\n\tmemset(de, 0, sizeof(*de));\n\n\tswitch (level) {\n\tcase SMB_FIND_FILE_UNIX:\n\t\tcifs_fill_dirent_unix(de, info, is_unicode);\n\t\tbreak;\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_dir(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_FULL_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_full(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\tcifs_fill_dirent_search(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_BOTH_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_both(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_INFO_STANDARD:\n\t\tcifs_fill_dirent_std(de, info);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(FYI, \"Unknown findfirst level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int cifs_fill_dirent(struct cifs_dirent *de, const void *info,\n\t\tu16 level, bool is_unicode)\n{\n\tmemset(de, 0, sizeof(*de));\n\n\tswitch (level) {\n\tcase SMB_FIND_FILE_UNIX:\n\t\tcifs_fill_dirent_unix(de, info, is_unicode);\n\t\tbreak;\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_dir(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_FULL_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_full(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\tcifs_fill_dirent_search(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_BOTH_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_both(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_INFO_STANDARD:\n\t\tcifs_fill_dirent_std(de, info);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(FYI, \"Unknown findfirst level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int cifs_save_resume_key(const char *current_entry,\n\tstruct cifsFileInfo *file_info)\n{\n\tstruct cifs_dirent de;\n\tint rc;\n\n\trc = cifs_fill_dirent(&de, current_entry, file_info->srch_inf.info_level,\n\t\t\t      file_info->srch_inf.unicode);\n\tif (!rc) {\n\t\tfile_info->srch_inf.presume_name = de.name;\n\t\tfile_info->srch_inf.resume_name_len = de.namelen;\n\t\tfile_info->srch_inf.resume_key = de.resume_key;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "is_dir_changed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "523-533",
    "snippet": "static int is_dir_changed(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct cifsInodeInfo *cifsInfo = CIFS_I(inode);\n\n\tif (cifsInfo->time == 0)\n\t\treturn 1; /* directory was changed, perhaps due to unlink */\n\telse\n\t\treturn 0;\n\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int is_dir_changed(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct cifsInodeInfo *cifsInfo = CIFS_I(inode);\n\n\tif (cifsInfo->time == 0)\n\t\treturn 1; /* directory was changed, perhaps due to unlink */\n\telse\n\t\treturn 0;\n\n}"
  },
  {
    "function_name": "cifs_entry_is_dot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "489-519",
    "snippet": "static int cifs_entry_is_dot(struct cifs_dirent *de, bool is_unicode)\n{\n\tint rc = 0;\n\n\tif (!de->name)\n\t\treturn 0;\n\n\tif (is_unicode) {\n\t\t__le16 *ufilename = (__le16 *)de->name;\n\t\tif (de->namelen == 2) {\n\t\t\t/* check for . */\n\t\t\tif (ufilename[0] == UNICODE_DOT)\n\t\t\t\trc = 1;\n\t\t} else if (de->namelen == 4) {\n\t\t\t/* check for .. */\n\t\t\tif (ufilename[0] == UNICODE_DOT &&\n\t\t\t    ufilename[1] == UNICODE_DOT)\n\t\t\t\trc = 2;\n\t\t}\n\t} else /* ASCII */ {\n\t\tif (de->namelen == 1) {\n\t\t\tif (de->name[0] == '.')\n\t\t\t\trc = 1;\n\t\t} else if (de->namelen == 2) {\n\t\t\tif (de->name[0] == '.' && de->name[1] == '.')\n\t\t\t\trc = 2;\n\t\t}\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define UNICODE_DOT cpu_to_le16(0x2e)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define UNICODE_DOT cpu_to_le16(0x2e)\n\nstatic int cifs_entry_is_dot(struct cifs_dirent *de, bool is_unicode)\n{\n\tint rc = 0;\n\n\tif (!de->name)\n\t\treturn 0;\n\n\tif (is_unicode) {\n\t\t__le16 *ufilename = (__le16 *)de->name;\n\t\tif (de->namelen == 2) {\n\t\t\t/* check for . */\n\t\t\tif (ufilename[0] == UNICODE_DOT)\n\t\t\t\trc = 1;\n\t\t} else if (de->namelen == 4) {\n\t\t\t/* check for .. */\n\t\t\tif (ufilename[0] == UNICODE_DOT &&\n\t\t\t    ufilename[1] == UNICODE_DOT)\n\t\t\t\trc = 2;\n\t\t}\n\t} else /* ASCII */ {\n\t\tif (de->namelen == 1) {\n\t\t\tif (de->name[0] == '.')\n\t\t\t\trc = 1;\n\t\t} else if (de->namelen == 2) {\n\t\t\tif (de->name[0] == '.' && de->name[1] == '.')\n\t\t\t\trc = 2;\n\t\t}\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_fill_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "454-484",
    "snippet": "static int cifs_fill_dirent(struct cifs_dirent *de, const void *info,\n\t\tu16 level, bool is_unicode)\n{\n\tmemset(de, 0, sizeof(*de));\n\n\tswitch (level) {\n\tcase SMB_FIND_FILE_UNIX:\n\t\tcifs_fill_dirent_unix(de, info, is_unicode);\n\t\tbreak;\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_dir(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_FULL_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_full(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\tcifs_fill_dirent_search(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_BOTH_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_both(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_INFO_STANDARD:\n\t\tcifs_fill_dirent_std(de, info);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(FYI, \"Unknown findfirst level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Unknown findfirst level %d\\n\"",
            "level"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_fill_dirent_std",
          "args": [
            "de",
            "info"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fill_dirent_std",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "445-452",
          "snippet": "static void cifs_fill_dirent_std(struct cifs_dirent *de,\n\t\tconst FIND_FILE_STANDARD_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\t/* one byte length, no endianess conversion */\n\tde->namelen = info->FileNameLength;\n\tde->resume_key = info->ResumeKey;\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void cifs_fill_dirent_std(struct cifs_dirent *de,\n\t\tconst FIND_FILE_STANDARD_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\t/* one byte length, no endianess conversion */\n\tde->namelen = info->FileNameLength;\n\tde->resume_key = info->ResumeKey;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_fill_dirent_both",
          "args": [
            "de",
            "info"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fill_dirent_both",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "437-443",
          "snippet": "static void cifs_fill_dirent_both(struct cifs_dirent *de,\n\t\tconst FILE_BOTH_DIRECTORY_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void cifs_fill_dirent_both(struct cifs_dirent *de,\n\t\tconst FILE_BOTH_DIRECTORY_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_fill_dirent_search",
          "args": [
            "de",
            "info"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fill_dirent_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "428-435",
          "snippet": "static void cifs_fill_dirent_search(struct cifs_dirent *de,\n\t\tconst SEARCH_ID_FULL_DIR_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n\tde->ino = le64_to_cpu(info->UniqueId);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void cifs_fill_dirent_search(struct cifs_dirent *de,\n\t\tconst SEARCH_ID_FULL_DIR_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n\tde->ino = le64_to_cpu(info->UniqueId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_fill_dirent_full",
          "args": [
            "de",
            "info"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fill_dirent_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "420-426",
          "snippet": "static void cifs_fill_dirent_full(struct cifs_dirent *de,\n\t\tconst FILE_FULL_DIRECTORY_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void cifs_fill_dirent_full(struct cifs_dirent *de,\n\t\tconst FILE_FULL_DIRECTORY_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_fill_dirent_dir",
          "args": [
            "de",
            "info"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fill_dirent_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "412-418",
          "snippet": "static void cifs_fill_dirent_dir(struct cifs_dirent *de,\n\t\tconst FILE_DIRECTORY_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void cifs_fill_dirent_dir(struct cifs_dirent *de,\n\t\tconst FILE_DIRECTORY_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_fill_dirent_unix",
          "args": [
            "de",
            "info",
            "is_unicode"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fill_dirent_unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "400-410",
          "snippet": "static void cifs_fill_dirent_unix(struct cifs_dirent *de,\n\t\tconst FILE_UNIX_INFO *info, bool is_unicode)\n{\n\tde->name = &info->FileName[0];\n\tif (is_unicode)\n\t\tde->namelen = cifs_unicode_bytelen(de->name);\n\telse\n\t\tde->namelen = strnlen(de->name, PATH_MAX);\n\tde->resume_key = info->ResumeKey;\n\tde->ino = le64_to_cpu(info->basic.UniqueId);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void cifs_fill_dirent_unix(struct cifs_dirent *de,\n\t\tconst FILE_UNIX_INFO *info, bool is_unicode)\n{\n\tde->name = &info->FileName[0];\n\tif (is_unicode)\n\t\tde->namelen = cifs_unicode_bytelen(de->name);\n\telse\n\t\tde->namelen = strnlen(de->name, PATH_MAX);\n\tde->resume_key = info->ResumeKey;\n\tde->ino = le64_to_cpu(info->basic.UniqueId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "de",
            "0",
            "sizeof(*de)"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int cifs_fill_dirent(struct cifs_dirent *de, const void *info,\n\t\tu16 level, bool is_unicode)\n{\n\tmemset(de, 0, sizeof(*de));\n\n\tswitch (level) {\n\tcase SMB_FIND_FILE_UNIX:\n\t\tcifs_fill_dirent_unix(de, info, is_unicode);\n\t\tbreak;\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_dir(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_FULL_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_full(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\tcifs_fill_dirent_search(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_BOTH_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_both(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_INFO_STANDARD:\n\t\tcifs_fill_dirent_std(de, info);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(FYI, \"Unknown findfirst level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_fill_dirent_std",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "445-452",
    "snippet": "static void cifs_fill_dirent_std(struct cifs_dirent *de,\n\t\tconst FIND_FILE_STANDARD_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\t/* one byte length, no endianess conversion */\n\tde->namelen = info->FileNameLength;\n\tde->resume_key = info->ResumeKey;\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void cifs_fill_dirent_std(struct cifs_dirent *de,\n\t\tconst FIND_FILE_STANDARD_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\t/* one byte length, no endianess conversion */\n\tde->namelen = info->FileNameLength;\n\tde->resume_key = info->ResumeKey;\n}"
  },
  {
    "function_name": "cifs_fill_dirent_both",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "437-443",
    "snippet": "static void cifs_fill_dirent_both(struct cifs_dirent *de,\n\t\tconst FILE_BOTH_DIRECTORY_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "info->FileNameLength"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void cifs_fill_dirent_both(struct cifs_dirent *de,\n\t\tconst FILE_BOTH_DIRECTORY_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n}"
  },
  {
    "function_name": "cifs_fill_dirent_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "428-435",
    "snippet": "static void cifs_fill_dirent_search(struct cifs_dirent *de,\n\t\tconst SEARCH_ID_FULL_DIR_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n\tde->ino = le64_to_cpu(info->UniqueId);\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "info->UniqueId"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "info->FileNameLength"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void cifs_fill_dirent_search(struct cifs_dirent *de,\n\t\tconst SEARCH_ID_FULL_DIR_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n\tde->ino = le64_to_cpu(info->UniqueId);\n}"
  },
  {
    "function_name": "cifs_fill_dirent_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "420-426",
    "snippet": "static void cifs_fill_dirent_full(struct cifs_dirent *de,\n\t\tconst FILE_FULL_DIRECTORY_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "info->FileNameLength"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void cifs_fill_dirent_full(struct cifs_dirent *de,\n\t\tconst FILE_FULL_DIRECTORY_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n}"
  },
  {
    "function_name": "cifs_fill_dirent_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "412-418",
    "snippet": "static void cifs_fill_dirent_dir(struct cifs_dirent *de,\n\t\tconst FILE_DIRECTORY_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "info->FileNameLength"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void cifs_fill_dirent_dir(struct cifs_dirent *de,\n\t\tconst FILE_DIRECTORY_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n}"
  },
  {
    "function_name": "cifs_fill_dirent_unix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "400-410",
    "snippet": "static void cifs_fill_dirent_unix(struct cifs_dirent *de,\n\t\tconst FILE_UNIX_INFO *info, bool is_unicode)\n{\n\tde->name = &info->FileName[0];\n\tif (is_unicode)\n\t\tde->namelen = cifs_unicode_bytelen(de->name);\n\telse\n\t\tde->namelen = strnlen(de->name, PATH_MAX);\n\tde->resume_key = info->ResumeKey;\n\tde->ino = le64_to_cpu(info->basic.UniqueId);\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "info->basic.UniqueId"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "de->name",
            "PATH_MAX"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_unicode_bytelen",
          "args": [
            "de->name"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_unicode_bytelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "349-360",
          "snippet": "static int cifs_unicode_bytelen(const char *str)\n{\n\tint len;\n\tconst __le16 *ustr = (const __le16 *)str;\n\n\tfor (len = 0; len <= PATH_MAX; len++) {\n\t\tif (ustr[len] == 0)\n\t\t\treturn len << 1;\n\t}\n\tcifs_dbg(FYI, \"Unicode string longer than PATH_MAX found\\n\");\n\treturn len << 1;\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int cifs_unicode_bytelen(const char *str)\n{\n\tint len;\n\tconst __le16 *ustr = (const __le16 *)str;\n\n\tfor (len = 0; len <= PATH_MAX; len++) {\n\t\tif (ustr[len] == 0)\n\t\t\treturn len << 1;\n\t}\n\tcifs_dbg(FYI, \"Unicode string longer than PATH_MAX found\\n\");\n\treturn len << 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void cifs_fill_dirent_unix(struct cifs_dirent *de,\n\t\tconst FILE_UNIX_INFO *info, bool is_unicode)\n{\n\tde->name = &info->FileName[0];\n\tif (is_unicode)\n\t\tde->namelen = cifs_unicode_bytelen(de->name);\n\telse\n\t\tde->namelen = strnlen(de->name, PATH_MAX);\n\tde->resume_key = info->ResumeKey;\n\tde->ino = le64_to_cpu(info->basic.UniqueId);\n}"
  },
  {
    "function_name": "nxt_dir_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "362-391",
    "snippet": "static char *nxt_dir_entry(char *old_entry, char *end_of_smb, int level)\n{\n\tchar *new_entry;\n\tFILE_DIRECTORY_INFO *pDirInfo = (FILE_DIRECTORY_INFO *)old_entry;\n\n\tif (level == SMB_FIND_FILE_INFO_STANDARD) {\n\t\tFIND_FILE_STANDARD_INFO *pfData;\n\t\tpfData = (FIND_FILE_STANDARD_INFO *)pDirInfo;\n\n\t\tnew_entry = old_entry + sizeof(FIND_FILE_STANDARD_INFO) +\n\t\t\t\tpfData->FileNameLength;\n\t} else\n\t\tnew_entry = old_entry + le32_to_cpu(pDirInfo->NextEntryOffset);\n\tcifs_dbg(FYI, \"new entry %p old entry %p\\n\", new_entry, old_entry);\n\t/* validate that new_entry is not past end of SMB */\n\tif (new_entry >= end_of_smb) {\n\t\tcifs_dbg(VFS, \"search entry %p began after end of SMB %p old entry %p\\n\",\n\t\t\t new_entry, end_of_smb, old_entry);\n\t\treturn NULL;\n\t} else if (((level == SMB_FIND_FILE_INFO_STANDARD) &&\n\t\t    (new_entry + sizeof(FIND_FILE_STANDARD_INFO) > end_of_smb))\n\t\t  || ((level != SMB_FIND_FILE_INFO_STANDARD) &&\n\t\t   (new_entry + sizeof(FILE_DIRECTORY_INFO) > end_of_smb)))  {\n\t\tcifs_dbg(VFS, \"search entry %p extends after end of SMB %p\\n\",\n\t\t\t new_entry, end_of_smb);\n\t\treturn NULL;\n\t} else\n\t\treturn new_entry;\n\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"search entry %p extends after end of SMB %p\\n\"",
            "new_entry",
            "end_of_smb"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"search entry %p began after end of SMB %p old entry %p\\n\"",
            "new_entry",
            "end_of_smb",
            "old_entry"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"new entry %p old entry %p\\n\"",
            "new_entry",
            "old_entry"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "pDirInfo->NextEntryOffset"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic char *nxt_dir_entry(char *old_entry, char *end_of_smb, int level)\n{\n\tchar *new_entry;\n\tFILE_DIRECTORY_INFO *pDirInfo = (FILE_DIRECTORY_INFO *)old_entry;\n\n\tif (level == SMB_FIND_FILE_INFO_STANDARD) {\n\t\tFIND_FILE_STANDARD_INFO *pfData;\n\t\tpfData = (FIND_FILE_STANDARD_INFO *)pDirInfo;\n\n\t\tnew_entry = old_entry + sizeof(FIND_FILE_STANDARD_INFO) +\n\t\t\t\tpfData->FileNameLength;\n\t} else\n\t\tnew_entry = old_entry + le32_to_cpu(pDirInfo->NextEntryOffset);\n\tcifs_dbg(FYI, \"new entry %p old entry %p\\n\", new_entry, old_entry);\n\t/* validate that new_entry is not past end of SMB */\n\tif (new_entry >= end_of_smb) {\n\t\tcifs_dbg(VFS, \"search entry %p began after end of SMB %p old entry %p\\n\",\n\t\t\t new_entry, end_of_smb, old_entry);\n\t\treturn NULL;\n\t} else if (((level == SMB_FIND_FILE_INFO_STANDARD) &&\n\t\t    (new_entry + sizeof(FIND_FILE_STANDARD_INFO) > end_of_smb))\n\t\t  || ((level != SMB_FIND_FILE_INFO_STANDARD) &&\n\t\t   (new_entry + sizeof(FILE_DIRECTORY_INFO) > end_of_smb)))  {\n\t\tcifs_dbg(VFS, \"search entry %p extends after end of SMB %p\\n\",\n\t\t\t new_entry, end_of_smb);\n\t\treturn NULL;\n\t} else\n\t\treturn new_entry;\n\n}"
  },
  {
    "function_name": "cifs_unicode_bytelen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "349-360",
    "snippet": "static int cifs_unicode_bytelen(const char *str)\n{\n\tint len;\n\tconst __le16 *ustr = (const __le16 *)str;\n\n\tfor (len = 0; len <= PATH_MAX; len++) {\n\t\tif (ustr[len] == 0)\n\t\t\treturn len << 1;\n\t}\n\tcifs_dbg(FYI, \"Unicode string longer than PATH_MAX found\\n\");\n\treturn len << 1;\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Unicode string longer than PATH_MAX found\\n\""
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int cifs_unicode_bytelen(const char *str)\n{\n\tint len;\n\tconst __le16 *ustr = (const __le16 *)str;\n\n\tfor (len = 0; len <= PATH_MAX; len++) {\n\t\tif (ustr[len] == 0)\n\t\t\treturn len << 1;\n\t}\n\tcifs_dbg(FYI, \"Unicode string longer than PATH_MAX found\\n\");\n\treturn len << 1;\n}"
  },
  {
    "function_name": "initiate_cifs_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "261-346",
    "snippet": "static int\ninitiate_cifs_search(const unsigned int xid, struct file *file)\n{\n\t__u16 search_flags;\n\tint rc = 0;\n\tchar *full_path = NULL;\n\tstruct cifsFileInfo *cifsFile;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct tcon_link *tlink = NULL;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\n\tif (file->private_data == NULL) {\n\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\tif (IS_ERR(tlink))\n\t\t\treturn PTR_ERR(tlink);\n\n\t\tcifsFile = kzalloc(sizeof(struct cifsFileInfo), GFP_KERNEL);\n\t\tif (cifsFile == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto error_exit;\n\t\t}\n\t\tfile->private_data = cifsFile;\n\t\tcifsFile->tlink = cifs_get_tlink(tlink);\n\t\ttcon = tlink_tcon(tlink);\n\t} else {\n\t\tcifsFile = file->private_data;\n\t\ttcon = tlink_tcon(cifsFile->tlink);\n\t}\n\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->query_dir_first) {\n\t\trc = -ENOSYS;\n\t\tgoto error_exit;\n\t}\n\n\tcifsFile->invalidHandle = true;\n\tcifsFile->srch_inf.endOfSearch = false;\n\n\tfull_path = build_path_from_dentry(file->f_path.dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto error_exit;\n\t}\n\n\tcifs_dbg(FYI, \"Full path: %s start at: %lld\\n\", full_path, file->f_pos);\n\nffirst_retry:\n\t/* test for Unix extensions */\n\t/* but now check for them on the share/mount not on the SMB session */\n\t/* if (cap_unix(tcon->ses) { */\n\tif (tcon->unix_ext)\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_UNIX;\n\telse if ((tcon->ses->capabilities &\n\t\t  tcon->ses->server->vals->cap_nt_find) == 0) {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_INFO_STANDARD;\n\t} else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_ID_FULL_DIR_INFO;\n\t} else /* not srvinos - BB fixme add check for backlevel? */ {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_DIRECTORY_INFO;\n\t}\n\n\tsearch_flags = CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME;\n\tif (backup_cred(cifs_sb))\n\t\tsearch_flags |= CIFS_SEARCH_BACKUP_SEARCH;\n\n\trc = server->ops->query_dir_first(xid, tcon, full_path, cifs_sb,\n\t\t\t\t\t  &cifsFile->fid, search_flags,\n\t\t\t\t\t  &cifsFile->srch_inf);\n\n\tif (rc == 0)\n\t\tcifsFile->invalidHandle = false;\n\t/* BB add following call to handle readdir on new NTFS symlink errors\n\telse if STATUS_STOPPED_ON_SYMLINK\n\t\tcall get_symlink_reparse_path and retry with new path */\n\telse if ((rc == -EOPNOTSUPP) &&\n\t\t(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)) {\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\n\t\tgoto ffirst_retry;\n\t}\nerror_exit:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->query_dir_first",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "cifs_sb",
            "&cifsFile->fid",
            "search_flags",
            "&cifsFile->srch_inf"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backup_cred",
          "args": [
            "cifs_sb"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "backup_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "598-611",
          "snippet": "bool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nbool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Full path: %s start at: %lld\\n\"",
            "full_path",
            "file->f_pos"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_path_from_dentry",
          "args": [
            "file->f_path.dentry"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "build_path_from_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "81-167",
          "snippet": "char *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nchar *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cifsFile->tlink"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_get_tlink",
          "args": [
            "tlink"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "939-945",
          "snippet": "static inline struct tcon_link *\ncifs_get_tlink(struct tcon_link *tlink)\n{\n\tif (tlink && !IS_ERR(tlink))\n\t\tatomic_inc(&tlink->tl_count);\n\treturn tlink;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct tcon_link *\ncifs_get_tlink(struct tcon_link *tlink)\n{\n\tif (tlink && !IS_ERR(tlink))\n\t\tatomic_inc(&tlink->tl_count);\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct cifsFileInfo)",
            "GFP_KERNEL"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_FILE_SB",
          "args": [
            "file"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_FILE_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1171-1175",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int\ninitiate_cifs_search(const unsigned int xid, struct file *file)\n{\n\t__u16 search_flags;\n\tint rc = 0;\n\tchar *full_path = NULL;\n\tstruct cifsFileInfo *cifsFile;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct tcon_link *tlink = NULL;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\n\tif (file->private_data == NULL) {\n\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\tif (IS_ERR(tlink))\n\t\t\treturn PTR_ERR(tlink);\n\n\t\tcifsFile = kzalloc(sizeof(struct cifsFileInfo), GFP_KERNEL);\n\t\tif (cifsFile == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto error_exit;\n\t\t}\n\t\tfile->private_data = cifsFile;\n\t\tcifsFile->tlink = cifs_get_tlink(tlink);\n\t\ttcon = tlink_tcon(tlink);\n\t} else {\n\t\tcifsFile = file->private_data;\n\t\ttcon = tlink_tcon(cifsFile->tlink);\n\t}\n\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->query_dir_first) {\n\t\trc = -ENOSYS;\n\t\tgoto error_exit;\n\t}\n\n\tcifsFile->invalidHandle = true;\n\tcifsFile->srch_inf.endOfSearch = false;\n\n\tfull_path = build_path_from_dentry(file->f_path.dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto error_exit;\n\t}\n\n\tcifs_dbg(FYI, \"Full path: %s start at: %lld\\n\", full_path, file->f_pos);\n\nffirst_retry:\n\t/* test for Unix extensions */\n\t/* but now check for them on the share/mount not on the SMB session */\n\t/* if (cap_unix(tcon->ses) { */\n\tif (tcon->unix_ext)\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_UNIX;\n\telse if ((tcon->ses->capabilities &\n\t\t  tcon->ses->server->vals->cap_nt_find) == 0) {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_INFO_STANDARD;\n\t} else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_ID_FULL_DIR_INFO;\n\t} else /* not srvinos - BB fixme add check for backlevel? */ {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_DIRECTORY_INFO;\n\t}\n\n\tsearch_flags = CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME;\n\tif (backup_cred(cifs_sb))\n\t\tsearch_flags |= CIFS_SEARCH_BACKUP_SEARCH;\n\n\trc = server->ops->query_dir_first(xid, tcon, full_path, cifs_sb,\n\t\t\t\t\t  &cifsFile->fid, search_flags,\n\t\t\t\t\t  &cifsFile->srch_inf);\n\n\tif (rc == 0)\n\t\tcifsFile->invalidHandle = false;\n\t/* BB add following call to handle readdir on new NTFS symlink errors\n\telse if STATUS_STOPPED_ON_SYMLINK\n\t\tcall get_symlink_reparse_path and retry with new path */\n\telse if ((rc == -EOPNOTSUPP) &&\n\t\t(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)) {\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\n\t\tgoto ffirst_retry;\n\t}\nerror_exit:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_std_info_to_fattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "208-227",
    "snippet": "static void\ncifs_std_info_to_fattr(struct cifs_fattr *fattr, FIND_FILE_STANDARD_INFO *info,\n\t\t       struct cifs_sb_info *cifs_sb)\n{\n\tint offset = cifs_sb_master_tcon(cifs_sb)->ses->server->timeAdj;\n\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_atime = cnvrtDosUnixTm(info->LastAccessDate,\n\t\t\t\t\t    info->LastAccessTime, offset);\n\tfattr->cf_ctime = cnvrtDosUnixTm(info->LastWriteDate,\n\t\t\t\t\t    info->LastWriteTime, offset);\n\tfattr->cf_mtime = cnvrtDosUnixTm(info->LastWriteDate,\n\t\t\t\t\t    info->LastWriteTime, offset);\n\n\tfattr->cf_cifsattrs = le16_to_cpu(info->Attributes);\n\tfattr->cf_bytes = le32_to_cpu(info->AllocationSize);\n\tfattr->cf_eof = le32_to_cpu(info->DataSize);\n\n\tcifs_fill_common_info(fattr, cifs_sb);\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_fill_common_info",
          "args": [
            "fattr",
            "cifs_sb"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fill_common_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "137-190",
          "snippet": "static void\ncifs_fill_common_info(struct cifs_fattr *fattr, struct cifs_sb_info *cifs_sb)\n{\n\tfattr->cf_uid = cifs_sb->mnt_uid;\n\tfattr->cf_gid = cifs_sb->mnt_gid;\n\n\tif (fattr->cf_cifsattrs & ATTR_DIRECTORY) {\n\t\tfattr->cf_mode = S_IFDIR | cifs_sb->mnt_dir_mode;\n\t\tfattr->cf_dtype = DT_DIR;\n\t} else {\n\t\tfattr->cf_mode = S_IFREG | cifs_sb->mnt_file_mode;\n\t\tfattr->cf_dtype = DT_REG;\n\t}\n\n\t/*\n\t * We need to revalidate it further to make a decision about whether it\n\t * is a symbolic link, DFS referral or a reparse point with a direct\n\t * access like junctions, deduplicated files, NFS symlinks.\n\t */\n\tif (fattr->cf_cifsattrs & ATTR_REPARSE)\n\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\t/* non-unix readdir doesn't provide nlink */\n\tfattr->cf_flags |= CIFS_FATTR_UNKNOWN_NLINK;\n\n\tif (fattr->cf_cifsattrs & ATTR_READONLY)\n\t\tfattr->cf_mode &= ~S_IWUGO;\n\n\t/*\n\t * We of course don't get ACL info in FIND_FIRST/NEXT results, so\n\t * mark it for revalidation so that \"ls -l\" will look right. It might\n\t * be super-slow, but if we don't do this then the ownership of files\n\t * may look wrong since the inodes may not have timed out by the time\n\t * \"ls\" does a stat() call on them.\n\t */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL)\n\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL &&\n\t    fattr->cf_cifsattrs & ATTR_SYSTEM) {\n\t\tif (fattr->cf_eof == 0)  {\n\t\t\tfattr->cf_mode &= ~S_IFMT;\n\t\t\tfattr->cf_mode |= S_IFIFO;\n\t\t\tfattr->cf_dtype = DT_FIFO;\n\t\t} else {\n\t\t\t/*\n\t\t\t * trying to get the type and mode via SFU can be slow,\n\t\t\t * so just call those regular files for now, and mark\n\t\t\t * for reval\n\t\t\t */\n\t\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_fill_common_info(struct cifs_fattr *fattr, struct cifs_sb_info *cifs_sb)\n{\n\tfattr->cf_uid = cifs_sb->mnt_uid;\n\tfattr->cf_gid = cifs_sb->mnt_gid;\n\n\tif (fattr->cf_cifsattrs & ATTR_DIRECTORY) {\n\t\tfattr->cf_mode = S_IFDIR | cifs_sb->mnt_dir_mode;\n\t\tfattr->cf_dtype = DT_DIR;\n\t} else {\n\t\tfattr->cf_mode = S_IFREG | cifs_sb->mnt_file_mode;\n\t\tfattr->cf_dtype = DT_REG;\n\t}\n\n\t/*\n\t * We need to revalidate it further to make a decision about whether it\n\t * is a symbolic link, DFS referral or a reparse point with a direct\n\t * access like junctions, deduplicated files, NFS symlinks.\n\t */\n\tif (fattr->cf_cifsattrs & ATTR_REPARSE)\n\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\t/* non-unix readdir doesn't provide nlink */\n\tfattr->cf_flags |= CIFS_FATTR_UNKNOWN_NLINK;\n\n\tif (fattr->cf_cifsattrs & ATTR_READONLY)\n\t\tfattr->cf_mode &= ~S_IWUGO;\n\n\t/*\n\t * We of course don't get ACL info in FIND_FIRST/NEXT results, so\n\t * mark it for revalidation so that \"ls -l\" will look right. It might\n\t * be super-slow, but if we don't do this then the ownership of files\n\t * may look wrong since the inodes may not have timed out by the time\n\t * \"ls\" does a stat() call on them.\n\t */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL)\n\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL &&\n\t    fattr->cf_cifsattrs & ATTR_SYSTEM) {\n\t\tif (fattr->cf_eof == 0)  {\n\t\t\tfattr->cf_mode &= ~S_IFMT;\n\t\t\tfattr->cf_mode |= S_IFIFO;\n\t\t\tfattr->cf_dtype = DT_FIFO;\n\t\t} else {\n\t\t\t/*\n\t\t\t * trying to get the type and mode via SFU can be slow,\n\t\t\t * so just call those regular files for now, and mark\n\t\t\t * for reval\n\t\t\t */\n\t\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "info->DataSize"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "info->Attributes"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cnvrtDosUnixTm",
          "args": [
            "info->LastWriteDate",
            "info->LastWriteTime",
            "offset"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "cnvrtDosUnixTm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/netmisc.c",
          "lines": "962-1014",
          "snippet": "struct timespec cnvrtDosUnixTm(__le16 le_date, __le16 le_time, int offset)\n{\n\tstruct timespec ts;\n\tint sec, min, days, month, year;\n\tu16 date = le16_to_cpu(le_date);\n\tu16 time = le16_to_cpu(le_time);\n\tSMB_TIME *st = (SMB_TIME *)&time;\n\tSMB_DATE *sd = (SMB_DATE *)&date;\n\n\tcifs_dbg(FYI, \"date %d time %d\\n\", date, time);\n\n\tsec = 2 * st->TwoSeconds;\n\tmin = st->Minutes;\n\tif ((sec > 59) || (min > 59))\n\t\tcifs_dbg(VFS, \"illegal time min %d sec %d\\n\", min, sec);\n\tsec += (min * 60);\n\tsec += 60 * 60 * st->Hours;\n\tif (st->Hours > 24)\n\t\tcifs_dbg(VFS, \"illegal hours %d\\n\", st->Hours);\n\tdays = sd->Day;\n\tmonth = sd->Month;\n\tif ((days > 31) || (month > 12)) {\n\t\tcifs_dbg(VFS, \"illegal date, month %d day: %d\\n\", month, days);\n\t\tif (month > 12)\n\t\t\tmonth = 12;\n\t}\n\tmonth -= 1;\n\tdays += total_days_of_prev_months[month];\n\tdays += 3652; /* account for difference in days between 1980 and 1970 */\n\tyear = sd->Year;\n\tdays += year * 365;\n\tdays += (year/4); /* leap year */\n\t/* generalized leap year calculation is more complex, ie no leap year\n\tfor years/100 except for years/400, but since the maximum number for DOS\n\t year is 2**7, the last year is 1980+127, which means we need only\n\t consider 2 special case years, ie the years 2000 and 2100, and only\n\t adjust for the lack of leap year for the year 2100, as 2000 was a\n\t leap year (divisable by 400) */\n\tif (year >= 120)  /* the year 2100 */\n\t\tdays = days - 1;  /* do not count leap year for the year 2100 */\n\n\t/* adjust for leap year where we are still before leap day */\n\tif (year != 120)\n\t\tdays -= ((year & 0x03) == 0) && (month < 2 ? 1 : 0);\n\tsec += 24 * 60 * 60 * days;\n\n\tts.tv_sec = sec + offset;\n\n\t/* cifs_dbg(FYI, \"sec after cnvrt dos to unix time %d\\n\",sec); */\n\n\tts.tv_nsec = 0;\n\treturn ts;\n}",
          "includes": [
            "#include \"nterr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smberr.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/inet.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/div64.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/in.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int total_days_of_prev_months[] = {\n\t0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nterr.h\"\n#include \"cifs_debug.h\"\n#include \"smberr.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/inet.h>\n#include <asm/byteorder.h>\n#include <asm/div64.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/net.h>\n\nstatic const int total_days_of_prev_months[] = {\n\t0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334\n};\n\nstruct timespec cnvrtDosUnixTm(__le16 le_date, __le16 le_time, int offset)\n{\n\tstruct timespec ts;\n\tint sec, min, days, month, year;\n\tu16 date = le16_to_cpu(le_date);\n\tu16 time = le16_to_cpu(le_time);\n\tSMB_TIME *st = (SMB_TIME *)&time;\n\tSMB_DATE *sd = (SMB_DATE *)&date;\n\n\tcifs_dbg(FYI, \"date %d time %d\\n\", date, time);\n\n\tsec = 2 * st->TwoSeconds;\n\tmin = st->Minutes;\n\tif ((sec > 59) || (min > 59))\n\t\tcifs_dbg(VFS, \"illegal time min %d sec %d\\n\", min, sec);\n\tsec += (min * 60);\n\tsec += 60 * 60 * st->Hours;\n\tif (st->Hours > 24)\n\t\tcifs_dbg(VFS, \"illegal hours %d\\n\", st->Hours);\n\tdays = sd->Day;\n\tmonth = sd->Month;\n\tif ((days > 31) || (month > 12)) {\n\t\tcifs_dbg(VFS, \"illegal date, month %d day: %d\\n\", month, days);\n\t\tif (month > 12)\n\t\t\tmonth = 12;\n\t}\n\tmonth -= 1;\n\tdays += total_days_of_prev_months[month];\n\tdays += 3652; /* account for difference in days between 1980 and 1970 */\n\tyear = sd->Year;\n\tdays += year * 365;\n\tdays += (year/4); /* leap year */\n\t/* generalized leap year calculation is more complex, ie no leap year\n\tfor years/100 except for years/400, but since the maximum number for DOS\n\t year is 2**7, the last year is 1980+127, which means we need only\n\t consider 2 special case years, ie the years 2000 and 2100, and only\n\t adjust for the lack of leap year for the year 2100, as 2000 was a\n\t leap year (divisable by 400) */\n\tif (year >= 120)  /* the year 2100 */\n\t\tdays = days - 1;  /* do not count leap year for the year 2100 */\n\n\t/* adjust for leap year where we are still before leap day */\n\tif (year != 120)\n\t\tdays -= ((year & 0x03) == 0) && (month < 2 ? 1 : 0);\n\tsec += 24 * 60 * 60 * days;\n\n\tts.tv_sec = sec + offset;\n\n\t/* cifs_dbg(FYI, \"sec after cnvrt dos to unix time %d\\n\",sec); */\n\n\tts.tv_nsec = 0;\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fattr",
            "0",
            "sizeof(*fattr)"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_master_tcon",
          "args": [
            "cifs_sb"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_master_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3948-3952",
          "snippet": "struct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_std_info_to_fattr(struct cifs_fattr *fattr, FIND_FILE_STANDARD_INFO *info,\n\t\t       struct cifs_sb_info *cifs_sb)\n{\n\tint offset = cifs_sb_master_tcon(cifs_sb)->ses->server->timeAdj;\n\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_atime = cnvrtDosUnixTm(info->LastAccessDate,\n\t\t\t\t\t    info->LastAccessTime, offset);\n\tfattr->cf_ctime = cnvrtDosUnixTm(info->LastWriteDate,\n\t\t\t\t\t    info->LastWriteTime, offset);\n\tfattr->cf_mtime = cnvrtDosUnixTm(info->LastWriteDate,\n\t\t\t\t\t    info->LastWriteTime, offset);\n\n\tfattr->cf_cifsattrs = le16_to_cpu(info->Attributes);\n\tfattr->cf_bytes = le32_to_cpu(info->AllocationSize);\n\tfattr->cf_eof = le32_to_cpu(info->DataSize);\n\n\tcifs_fill_common_info(fattr, cifs_sb);\n}"
  },
  {
    "function_name": "cifs_dir_info_to_fattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "192-206",
    "snippet": "void\ncifs_dir_info_to_fattr(struct cifs_fattr *fattr, FILE_DIRECTORY_INFO *info,\n\t\t       struct cifs_sb_info *cifs_sb)\n{\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_cifsattrs = le32_to_cpu(info->ExtFileAttributes);\n\tfattr->cf_eof = le64_to_cpu(info->EndOfFile);\n\tfattr->cf_bytes = le64_to_cpu(info->AllocationSize);\n\tfattr->cf_createtime = le64_to_cpu(info->CreationTime);\n\tfattr->cf_atime = cifs_NTtimeToUnix(info->LastAccessTime);\n\tfattr->cf_ctime = cifs_NTtimeToUnix(info->ChangeTime);\n\tfattr->cf_mtime = cifs_NTtimeToUnix(info->LastWriteTime);\n\n\tcifs_fill_common_info(fattr, cifs_sb);\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_fill_common_info",
          "args": [
            "fattr",
            "cifs_sb"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fill_common_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
          "lines": "137-190",
          "snippet": "static void\ncifs_fill_common_info(struct cifs_fattr *fattr, struct cifs_sb_info *cifs_sb)\n{\n\tfattr->cf_uid = cifs_sb->mnt_uid;\n\tfattr->cf_gid = cifs_sb->mnt_gid;\n\n\tif (fattr->cf_cifsattrs & ATTR_DIRECTORY) {\n\t\tfattr->cf_mode = S_IFDIR | cifs_sb->mnt_dir_mode;\n\t\tfattr->cf_dtype = DT_DIR;\n\t} else {\n\t\tfattr->cf_mode = S_IFREG | cifs_sb->mnt_file_mode;\n\t\tfattr->cf_dtype = DT_REG;\n\t}\n\n\t/*\n\t * We need to revalidate it further to make a decision about whether it\n\t * is a symbolic link, DFS referral or a reparse point with a direct\n\t * access like junctions, deduplicated files, NFS symlinks.\n\t */\n\tif (fattr->cf_cifsattrs & ATTR_REPARSE)\n\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\t/* non-unix readdir doesn't provide nlink */\n\tfattr->cf_flags |= CIFS_FATTR_UNKNOWN_NLINK;\n\n\tif (fattr->cf_cifsattrs & ATTR_READONLY)\n\t\tfattr->cf_mode &= ~S_IWUGO;\n\n\t/*\n\t * We of course don't get ACL info in FIND_FIRST/NEXT results, so\n\t * mark it for revalidation so that \"ls -l\" will look right. It might\n\t * be super-slow, but if we don't do this then the ownership of files\n\t * may look wrong since the inodes may not have timed out by the time\n\t * \"ls\" does a stat() call on them.\n\t */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL)\n\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL &&\n\t    fattr->cf_cifsattrs & ATTR_SYSTEM) {\n\t\tif (fattr->cf_eof == 0)  {\n\t\t\tfattr->cf_mode &= ~S_IFMT;\n\t\t\tfattr->cf_mode |= S_IFIFO;\n\t\t\tfattr->cf_dtype = DT_FIFO;\n\t\t} else {\n\t\t\t/*\n\t\t\t * trying to get the type and mode via SFU can be slow,\n\t\t\t * so just call those regular files for now, and mark\n\t\t\t * for reval\n\t\t\t */\n\t\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_fill_common_info(struct cifs_fattr *fattr, struct cifs_sb_info *cifs_sb)\n{\n\tfattr->cf_uid = cifs_sb->mnt_uid;\n\tfattr->cf_gid = cifs_sb->mnt_gid;\n\n\tif (fattr->cf_cifsattrs & ATTR_DIRECTORY) {\n\t\tfattr->cf_mode = S_IFDIR | cifs_sb->mnt_dir_mode;\n\t\tfattr->cf_dtype = DT_DIR;\n\t} else {\n\t\tfattr->cf_mode = S_IFREG | cifs_sb->mnt_file_mode;\n\t\tfattr->cf_dtype = DT_REG;\n\t}\n\n\t/*\n\t * We need to revalidate it further to make a decision about whether it\n\t * is a symbolic link, DFS referral or a reparse point with a direct\n\t * access like junctions, deduplicated files, NFS symlinks.\n\t */\n\tif (fattr->cf_cifsattrs & ATTR_REPARSE)\n\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\t/* non-unix readdir doesn't provide nlink */\n\tfattr->cf_flags |= CIFS_FATTR_UNKNOWN_NLINK;\n\n\tif (fattr->cf_cifsattrs & ATTR_READONLY)\n\t\tfattr->cf_mode &= ~S_IWUGO;\n\n\t/*\n\t * We of course don't get ACL info in FIND_FIRST/NEXT results, so\n\t * mark it for revalidation so that \"ls -l\" will look right. It might\n\t * be super-slow, but if we don't do this then the ownership of files\n\t * may look wrong since the inodes may not have timed out by the time\n\t * \"ls\" does a stat() call on them.\n\t */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL)\n\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL &&\n\t    fattr->cf_cifsattrs & ATTR_SYSTEM) {\n\t\tif (fattr->cf_eof == 0)  {\n\t\t\tfattr->cf_mode &= ~S_IFMT;\n\t\t\tfattr->cf_mode |= S_IFIFO;\n\t\t\tfattr->cf_dtype = DT_FIFO;\n\t\t} else {\n\t\t\t/*\n\t\t\t * trying to get the type and mode via SFU can be slow,\n\t\t\t * so just call those regular files for now, and mark\n\t\t\t * for reval\n\t\t\t */\n\t\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_NTtimeToUnix",
          "args": [
            "info->LastWriteTime"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_NTtimeToUnix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/netmisc.c",
          "lines": "921-948",
          "snippet": "struct timespec\ncifs_NTtimeToUnix(__le64 ntutc)\n{\n\tstruct timespec ts;\n\t/* BB what about the timezone? BB */\n\n\t/* Subtract the NTFS time offset, then convert to 1s intervals. */\n\ts64 t = le64_to_cpu(ntutc) - NTFS_TIME_OFFSET;\n\tu64 abs_t;\n\n\t/*\n\t * Unfortunately can not use normal 64 bit division on 32 bit arch, but\n\t * the alternative, do_div, does not work with negative numbers so have\n\t * to special case them\n\t */\n\tif (t < 0) {\n\t\tabs_t = -t;\n\t\tts.tv_nsec = (long)(do_div(abs_t, 10000000) * 100);\n\t\tts.tv_nsec = -ts.tv_nsec;\n\t\tts.tv_sec = -abs_t;\n\t} else {\n\t\tabs_t = t;\n\t\tts.tv_nsec = (long)do_div(abs_t, 10000000) * 100;\n\t\tts.tv_sec = abs_t;\n\t}\n\n\treturn ts;\n}",
          "includes": [
            "#include \"nterr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smberr.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/inet.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/div64.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/in.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>"
          ],
          "macros_used": [
            "#define NTFS_TIME_OFFSET ((u64)(369*365 + 89) * 24 * 3600 * 10000000)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nterr.h\"\n#include \"cifs_debug.h\"\n#include \"smberr.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/inet.h>\n#include <asm/byteorder.h>\n#include <asm/div64.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/net.h>\n\n#define NTFS_TIME_OFFSET ((u64)(369*365 + 89) * 24 * 3600 * 10000000)\n\nstruct timespec\ncifs_NTtimeToUnix(__le64 ntutc)\n{\n\tstruct timespec ts;\n\t/* BB what about the timezone? BB */\n\n\t/* Subtract the NTFS time offset, then convert to 1s intervals. */\n\ts64 t = le64_to_cpu(ntutc) - NTFS_TIME_OFFSET;\n\tu64 abs_t;\n\n\t/*\n\t * Unfortunately can not use normal 64 bit division on 32 bit arch, but\n\t * the alternative, do_div, does not work with negative numbers so have\n\t * to special case them\n\t */\n\tif (t < 0) {\n\t\tabs_t = -t;\n\t\tts.tv_nsec = (long)(do_div(abs_t, 10000000) * 100);\n\t\tts.tv_nsec = -ts.tv_nsec;\n\t\tts.tv_sec = -abs_t;\n\t} else {\n\t\tabs_t = t;\n\t\tts.tv_nsec = (long)do_div(abs_t, 10000000) * 100;\n\t\tts.tv_sec = abs_t;\n\t}\n\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "info->CreationTime"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "info->ExtFileAttributes"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fattr",
            "0",
            "sizeof(*fattr)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nvoid\ncifs_dir_info_to_fattr(struct cifs_fattr *fattr, FILE_DIRECTORY_INFO *info,\n\t\t       struct cifs_sb_info *cifs_sb)\n{\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_cifsattrs = le32_to_cpu(info->ExtFileAttributes);\n\tfattr->cf_eof = le64_to_cpu(info->EndOfFile);\n\tfattr->cf_bytes = le64_to_cpu(info->AllocationSize);\n\tfattr->cf_createtime = le64_to_cpu(info->CreationTime);\n\tfattr->cf_atime = cifs_NTtimeToUnix(info->LastAccessTime);\n\tfattr->cf_ctime = cifs_NTtimeToUnix(info->ChangeTime);\n\tfattr->cf_mtime = cifs_NTtimeToUnix(info->LastWriteTime);\n\n\tcifs_fill_common_info(fattr, cifs_sb);\n}"
  },
  {
    "function_name": "cifs_fill_common_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "137-190",
    "snippet": "static void\ncifs_fill_common_info(struct cifs_fattr *fattr, struct cifs_sb_info *cifs_sb)\n{\n\tfattr->cf_uid = cifs_sb->mnt_uid;\n\tfattr->cf_gid = cifs_sb->mnt_gid;\n\n\tif (fattr->cf_cifsattrs & ATTR_DIRECTORY) {\n\t\tfattr->cf_mode = S_IFDIR | cifs_sb->mnt_dir_mode;\n\t\tfattr->cf_dtype = DT_DIR;\n\t} else {\n\t\tfattr->cf_mode = S_IFREG | cifs_sb->mnt_file_mode;\n\t\tfattr->cf_dtype = DT_REG;\n\t}\n\n\t/*\n\t * We need to revalidate it further to make a decision about whether it\n\t * is a symbolic link, DFS referral or a reparse point with a direct\n\t * access like junctions, deduplicated files, NFS symlinks.\n\t */\n\tif (fattr->cf_cifsattrs & ATTR_REPARSE)\n\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\t/* non-unix readdir doesn't provide nlink */\n\tfattr->cf_flags |= CIFS_FATTR_UNKNOWN_NLINK;\n\n\tif (fattr->cf_cifsattrs & ATTR_READONLY)\n\t\tfattr->cf_mode &= ~S_IWUGO;\n\n\t/*\n\t * We of course don't get ACL info in FIND_FIRST/NEXT results, so\n\t * mark it for revalidation so that \"ls -l\" will look right. It might\n\t * be super-slow, but if we don't do this then the ownership of files\n\t * may look wrong since the inodes may not have timed out by the time\n\t * \"ls\" does a stat() call on them.\n\t */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL)\n\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL &&\n\t    fattr->cf_cifsattrs & ATTR_SYSTEM) {\n\t\tif (fattr->cf_eof == 0)  {\n\t\t\tfattr->cf_mode &= ~S_IFMT;\n\t\t\tfattr->cf_mode |= S_IFIFO;\n\t\t\tfattr->cf_dtype = DT_FIFO;\n\t\t} else {\n\t\t\t/*\n\t\t\t * trying to get the type and mode via SFU can be slow,\n\t\t\t * so just call those regular files for now, and mark\n\t\t\t * for reval\n\t\t\t */\n\t\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_fill_common_info(struct cifs_fattr *fattr, struct cifs_sb_info *cifs_sb)\n{\n\tfattr->cf_uid = cifs_sb->mnt_uid;\n\tfattr->cf_gid = cifs_sb->mnt_gid;\n\n\tif (fattr->cf_cifsattrs & ATTR_DIRECTORY) {\n\t\tfattr->cf_mode = S_IFDIR | cifs_sb->mnt_dir_mode;\n\t\tfattr->cf_dtype = DT_DIR;\n\t} else {\n\t\tfattr->cf_mode = S_IFREG | cifs_sb->mnt_file_mode;\n\t\tfattr->cf_dtype = DT_REG;\n\t}\n\n\t/*\n\t * We need to revalidate it further to make a decision about whether it\n\t * is a symbolic link, DFS referral or a reparse point with a direct\n\t * access like junctions, deduplicated files, NFS symlinks.\n\t */\n\tif (fattr->cf_cifsattrs & ATTR_REPARSE)\n\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\t/* non-unix readdir doesn't provide nlink */\n\tfattr->cf_flags |= CIFS_FATTR_UNKNOWN_NLINK;\n\n\tif (fattr->cf_cifsattrs & ATTR_READONLY)\n\t\tfattr->cf_mode &= ~S_IWUGO;\n\n\t/*\n\t * We of course don't get ACL info in FIND_FIRST/NEXT results, so\n\t * mark it for revalidation so that \"ls -l\" will look right. It might\n\t * be super-slow, but if we don't do this then the ownership of files\n\t * may look wrong since the inodes may not have timed out by the time\n\t * \"ls\" does a stat() call on them.\n\t */\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL)\n\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL &&\n\t    fattr->cf_cifsattrs & ATTR_SYSTEM) {\n\t\tif (fattr->cf_eof == 0)  {\n\t\t\tfattr->cf_mode &= ~S_IFMT;\n\t\t\tfattr->cf_mode |= S_IFIFO;\n\t\t\tfattr->cf_dtype = DT_FIFO;\n\t\t} else {\n\t\t\t/*\n\t\t\t * trying to get the type and mode via SFU can be slow,\n\t\t\t * so just call those regular files for now, and mark\n\t\t\t * for reval\n\t\t\t */\n\t\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "cifs_prime_dcache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "75-135",
    "snippet": "static void\ncifs_prime_dcache(struct dentry *parent, struct qstr *name,\n\t\t    struct cifs_fattr *fattr)\n{\n\tstruct dentry *dentry, *alias;\n\tstruct inode *inode;\n\tstruct super_block *sb = parent->d_inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\n\tcifs_dbg(FYI, \"%s: for %s\\n\", __func__, name->name);\n\n\tdentry = d_hash_and_lookup(parent, name);\n\tif (unlikely(IS_ERR(dentry)))\n\t\treturn;\n\n\tif (dentry) {\n\t\tinode = dentry->d_inode;\n\t\tif (inode) {\n\t\t\t/*\n\t\t\t * If we're generating inode numbers, then we don't\n\t\t\t * want to clobber the existing one with the one that\n\t\t\t * the readdir code created.\n\t\t\t */\n\t\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM))\n\t\t\t\tfattr->cf_uniqueid = CIFS_I(inode)->uniqueid;\n\n\t\t\t/* update inode in place\n\t\t\t * if both i_ino and i_mode didn't change */\n\t\t\tif (CIFS_I(inode)->uniqueid == fattr->cf_uniqueid &&\n\t\t\t    (inode->i_mode & S_IFMT) ==\n\t\t\t    (fattr->cf_mode & S_IFMT)) {\n\t\t\t\tcifs_fattr_to_inode(inode, fattr);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t}\n\n\t/*\n\t * If we know that the inode will need to be revalidated immediately,\n\t * then don't create a new dentry for it. We'll end up doing an on\n\t * the wire call either way and this spares us an invalidation.\n\t */\n\tif (fattr->cf_flags & CIFS_FATTR_NEED_REVAL)\n\t\treturn;\n\n\tdentry = d_alloc(parent, name);\n\tif (!dentry)\n\t\treturn;\n\n\tinode = cifs_iget(sb, fattr);\n\tif (!inode)\n\t\tgoto out;\n\n\talias = d_splice_alias(inode, dentry);\n\tif (alias && !IS_ERR(alias))\n\t\tdput(alias);\nout:\n\tdput(dentry);\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "alias"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_iget",
          "args": [
            "sb",
            "fattr"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_alloc",
          "args": [
            "parent",
            "name"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_read_allocate_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "2798-2821",
          "snippet": "static int\ncifs_read_allocate_pages(struct cifs_readdata *rdata, unsigned int nr_pages)\n{\n\tint rc = 0;\n\tstruct page *page;\n\tunsigned int i;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpage = alloc_page(GFP_KERNEL|__GFP_HIGHMEM);\n\t\tif (!page) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\trdata->pages[i] = page;\n\t}\n\n\tif (rc) {\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tput_page(rdata->pages[i]);\n\t\t\trdata->pages[i] = NULL;\n\t\t}\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_read_allocate_pages(struct cifs_readdata *rdata, unsigned int nr_pages)\n{\n\tint rc = 0;\n\tstruct page *page;\n\tunsigned int i;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpage = alloc_page(GFP_KERNEL|__GFP_HIGHMEM);\n\t\tif (!page) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\trdata->pages[i] = page;\n\t}\n\n\tif (rc) {\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tput_page(rdata->pages[i]);\n\t\t\trdata->pages[i] = NULL;\n\t\t}\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_invalidate",
          "args": [
            "dentry"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "d_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1465-1506",
          "snippet": "void d_invalidate(struct dentry *dentry)\n{\n\t/*\n\t * If it's already been dropped, return OK.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\t/* Negative dentries can be dropped without further checks */\n\tif (!dentry->d_inode) {\n\t\td_drop(dentry);\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct detach_data data;\n\n\t\tdata.mountpoint = NULL;\n\t\tINIT_LIST_HEAD(&data.select.dispose);\n\t\tdata.select.start = dentry;\n\t\tdata.select.found = 0;\n\n\t\td_walk(dentry, &data, detach_and_collect, check_and_drop);\n\n\t\tif (data.select.found)\n\t\t\tshrink_dentry_list(&data.select.dispose);\n\n\t\tif (data.mountpoint) {\n\t\t\tdetach_mounts(data.mountpoint);\n\t\t\tdput(data.mountpoint);\n\t\t}\n\n\t\tif (!data.mountpoint && !data.select.found)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_invalidate(struct dentry *dentry)\n{\n\t/*\n\t * If it's already been dropped, return OK.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\t/* Negative dentries can be dropped without further checks */\n\tif (!dentry->d_inode) {\n\t\td_drop(dentry);\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct detach_data data;\n\n\t\tdata.mountpoint = NULL;\n\t\tINIT_LIST_HEAD(&data.select.dispose);\n\t\tdata.select.start = dentry;\n\t\tdata.select.found = 0;\n\n\t\td_walk(dentry, &data, detach_and_collect, check_and_drop);\n\n\t\tif (data.select.found)\n\t\t\tshrink_dentry_list(&data.select.dispose);\n\n\t\tif (data.mountpoint) {\n\t\t\tdetach_mounts(data.mountpoint);\n\t\t\tdput(data.mountpoint);\n\t\t}\n\n\t\tif (!data.mountpoint && !data.select.found)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_fattr_to_inode",
          "args": [
            "inode",
            "fattr"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "IS_ERR(dentry)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_hash_and_lookup",
          "args": [
            "parent",
            "name"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash_and_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2312-2326",
          "snippet": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: for %s\\n\"",
            "__func__",
            "name->name"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "sb"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_prime_dcache(struct dentry *parent, struct qstr *name,\n\t\t    struct cifs_fattr *fattr)\n{\n\tstruct dentry *dentry, *alias;\n\tstruct inode *inode;\n\tstruct super_block *sb = parent->d_inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\n\tcifs_dbg(FYI, \"%s: for %s\\n\", __func__, name->name);\n\n\tdentry = d_hash_and_lookup(parent, name);\n\tif (unlikely(IS_ERR(dentry)))\n\t\treturn;\n\n\tif (dentry) {\n\t\tinode = dentry->d_inode;\n\t\tif (inode) {\n\t\t\t/*\n\t\t\t * If we're generating inode numbers, then we don't\n\t\t\t * want to clobber the existing one with the one that\n\t\t\t * the readdir code created.\n\t\t\t */\n\t\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM))\n\t\t\t\tfattr->cf_uniqueid = CIFS_I(inode)->uniqueid;\n\n\t\t\t/* update inode in place\n\t\t\t * if both i_ino and i_mode didn't change */\n\t\t\tif (CIFS_I(inode)->uniqueid == fattr->cf_uniqueid &&\n\t\t\t    (inode->i_mode & S_IFMT) ==\n\t\t\t    (fattr->cf_mode & S_IFMT)) {\n\t\t\t\tcifs_fattr_to_inode(inode, fattr);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t}\n\n\t/*\n\t * If we know that the inode will need to be revalidated immediately,\n\t * then don't create a new dentry for it. We'll end up doing an on\n\t * the wire call either way and this spares us an invalidation.\n\t */\n\tif (fattr->cf_flags & CIFS_FATTR_NEED_REVAL)\n\t\treturn;\n\n\tdentry = d_alloc(parent, name);\n\tif (!dentry)\n\t\treturn;\n\n\tinode = cifs_iget(sb, fattr);\n\tif (!inode)\n\t\tgoto out;\n\n\talias = d_splice_alias(inode, dentry);\n\tif (alias && !IS_ERR(alias))\n\t\tdput(alias);\nout:\n\tdput(dentry);\n}"
  },
  {
    "function_name": "dump_cifs_file_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "63-65",
    "snippet": "static inline void dump_cifs_file_struct(struct file *file, char *label)\n{\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline void dump_cifs_file_struct(struct file *file, char *label)\n{\n}"
  },
  {
    "function_name": "dump_cifs_file_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/readdir.c",
    "lines": "44-61",
    "snippet": "static void dump_cifs_file_struct(struct file *file, char *label)\n{\n\tstruct cifsFileInfo *cf;\n\n\tif (file) {\n\t\tcf = file->private_data;\n\t\tif (cf == NULL) {\n\t\t\tcifs_dbg(FYI, \"empty cifs private file data\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (cf->invalidHandle)\n\t\t\tcifs_dbg(FYI, \"invalid handle\\n\");\n\t\tif (cf->srch_inf.endOfSearch)\n\t\t\tcifs_dbg(FYI, \"end of search\\n\");\n\t\tif (cf->srch_inf.emptyDir)\n\t\t\tcifs_dbg(FYI, \"empty dir\\n\");\n\t}\n}",
    "includes": [
      "#include \"cifsfs.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"empty dir\\n\""
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"end of search\\n\""
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"invalid handle\\n\""
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"empty cifs private file data\\n\""
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void dump_cifs_file_struct(struct file *file, char *label)\n{\n\tstruct cifsFileInfo *cf;\n\n\tif (file) {\n\t\tcf = file->private_data;\n\t\tif (cf == NULL) {\n\t\t\tcifs_dbg(FYI, \"empty cifs private file data\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (cf->invalidHandle)\n\t\t\tcifs_dbg(FYI, \"invalid handle\\n\");\n\t\tif (cf->srch_inf.endOfSearch)\n\t\t\tcifs_dbg(FYI, \"end of search\\n\");\n\t\tif (cf->srch_inf.emptyDir)\n\t\t\tcifs_dbg(FYI, \"empty dir\\n\");\n\t}\n}"
  }
]